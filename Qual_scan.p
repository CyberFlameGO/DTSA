 {[j=30/55,:+,u+,r+,o=120,k+,n+,#+,v+,q+,b+]}{[f-]} {*********************************} UNIT Qual_scan;{*********************************}{**********************************} INTERFACE {**********************************} USES QuickDraw, Types, OSUtils, ToolUtils, Timer, Errors, Menus, Files, Lists, Memory,TextUtils,   Packages, Printing, StandardFile, fenv, fp, PasLibIntf, Retrace, SegLoad, Controls, Spectrum_Structures, Declarations, INITIALIZE, Global_Functions, Utilities, xray, Xray_Energies, physics, BG_Correct, CurveFit, MathWin;Procedure Main_Qual(Initial_File : integer);Procedure WriteQualResults(Final_File : integer);PROCEDURE write_qual_Header;      {******************************}IMPLEMENTATION{**********************************}{$S QUAL}   (* CONST      Max_Spec                      = 100;	  Max_Line_Peaks				= 130;*)		{put in declarations}	TYPE		AR200	= array [1..MaxLabels] of real;		(*Qual_record		=		RECORD								Spec_Nam	: string[32];								Peak_Max	: array [1..Max_Line_Peaks] of string[12];			END;		Qual_record_ptr =		^Qual_record;*)		{put in declarations}			VAR			LTQ 					: array[1..MaxLabels] of integer;			RTQ 					: array[1..MaxLabels] of integer;			num_rgns, Num_Chans		: integer;			max_val					: AR200;			max_chan				: array[1..MaxLabels] of integer;			Possible_Peaks			: array[1..12,1..MaxLabels] of integer;			Temp					: array [1..12,1..MaxLabels] of integer;			Temp_x					: array [1..12,1..MaxLabels] of string[6];			Assigned_Peaks			: array [1..MaxLabels] of integer;			Assigned_lines			: array [1..MaxLabels] of string[6];			En_chan					: AR200;			{Energy_Label			: array[0..Max_Line_Peaks] of real;	Declarations}			Qualrecptr				: array [1..Max_Spec] of Qual_record_ptr;			{Col_Label				: array[0..Max_Line_Peaks] of string[10];	Declarations}			{label_count				: integer;	Declarations}			Last_File				: integer;			First_File 				: integer;			Spec_Limit				: real;			spectrum_index			: integer;			Z_Labls					: array [1..129] of integer;			Labls					: array [1..129] of STRING[3];			index_used				: array [1..MaxLabels] of boolean;    PROCEDURE Stuff_Label( Chan_num, y        	  : Integer; 	                      symb                        : Str_2; 						  Family                      : Str_4; { K,L,M, M2N4 etc.}                          Greek                       : Str_4 { 'alpha'1,2 etc}         );       		VAR 		  jj,kk,j : integer;		  pt : point;      BEGIN        Label_Counter := Label_Counter + 1;        IF Label_Counter > MaxLabels THEN          BEGIN            Putmessage('You have exceeded the limit for the number of labels', '', '', '');			Label_Counter := MaxLabels;            exit(Stuff_Label);          END;        slopeX := (ChannelMax - ChannelMin) / (Full_Right_Screen - Full_Left_Screen );		Lab^^.S[Label_Counter].Channel := Chan_num;		Lab^^.S[Label_Counter].ShiftedChannel := Chan_num;		Lab^^.S[Label_Counter].V_Scale_Top      := V_Scale_Top;    { ¥REAL, at the time of creation }		Lab^^.S[Label_Counter].V_Scale_Bottom   := V_Scale_Bottom; { ¥REAL, at the time of creation }		if y > Full_Bottom_Screen - 5 then y := Full_Bottom_Screen - 5 ;        		j := rinttol(( Chan_num - ChannelMin + slopeX * 13) / slopeX) ;						for kk := 1 to Label_Counter-1 do { this logic arbitrates any turf war}		for jj := 1 to Label_Counter-1 do		  begin		     pt.v := y;		     pt.h := j;		    if PtInRect(pt, Lab^^.S[jj].Box) then y := y - 8;			if y < Full_Top_Screen + 35 then y := Full_Top_Screen + 35;		  end;		          Lab^^.S[Label_Counter].XCenter := j;		IF (Lab^^.s[Label_Counter].XCenter <= Full_Left_Screen + 20) then Lab^^.s[Label_Counter].XCenter := Full_Left_Screen + 20;		Lab^^.S[Label_Counter].YCenter := y;		Lab^^.S[Label_Counter].Box.Left  := Lab^^.S[Label_Counter].XCenter - 20;		Lab^^.S[Label_Counter].Box.Top   := Lab^^.S[Label_Counter].YCenter - 6;		SetRect(Lab^^.S[Label_Counter].Box, Lab^^.S[Label_Counter].Box.Left, 								 Lab^^.S[Label_Counter].Box.Top, 								 Lab^^.S[Label_Counter].Box.Left + 35, 								 Lab^^.S[Label_Counter].Box.Top + 12);        Lab^^.S[Label_Counter].Element := symb;        Lab^^.S[Label_Counter].Family := Family;        Lab^^.S[Label_Counter].Greek := Greek;        Lab^^.S[Label_Counter].Exists := True;      END;PROCEDURE write_qual_Header;	VAR		i, ii, j				: integer;		lab0					: STRING[8];		omit_elems				: Array [1..11] of integer;		omit_this				: boolean;			BEGIN	  omit_elems[1] := 10;	{Ne}	  omit_elems[2] := 36;	{Kr}	  omit_elems[3] := 43;	{Tc}	  omit_elems[4] := 54;	{Xe}	  omit_elems[5] := 61;	{Pm}	  omit_elems[6] := 84;	{Po}	  omit_elems[7] := 85;	{At}	  omit_elems[8] := 86;	{Rn}	  omit_elems[9] := 87;	{Fr}	  omit_elems[10] := 89;	{Ac}	  omit_elems[11] := 91;	{Pa}	  	  lab0 := 'Spectrum';	  ii := 0;	  for i := 6 to 94 do begin	  	omit_this := false;	  	For j := 1 to 11 do if (i = omit_elems[j]) then omit_this := true;	  	if NOT omit_this then begin		Get_Energies(i);		if i < 45 then begin			ii := ii + 1;			Labls[ii] := concat(A^.sym[i],'K');			Z_Labls[ii] := i;		end;		if i > 22 then begin			ii := ii + 1;			Labls[ii] := concat(A^.sym[i],'L');			Z_Labls[ii] := i;		end;		if i > 56 then begin			ii := ii + 1;			Labls[ii] := concat(A^.sym[i],'M');			Z_Labls[ii] := i;		end;	   end;	  end;	{for i := 6 to 94}	  write(Spread,lab0);	  for i := 1 to 129 do		write(Spread, chr(9), Labls[i]);	  write(Spread, chr(13));		END;		{PROCEDURE write_qual_Header}PROCEDURE semi_Quant;	VAR		i, ii					: integer;			T_lab, E_lab			: str255;		BEGIN	  Qualrecptr[1] := Qual_record_ptr(NewPtr(SizeOf(Qual_record)));	  for i := 1 to Max_Line_Peaks do Qualrecptr[1]^.Peak_Max[i] := '0';	  T_lab := Strip_Trailing_Blanks(Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.Spectrum_Comment_Field);	  if (length(T_lab) > 32) then		  Qualrecptr[1]^.Spec_Nam := copy(T_lab,1,32)		else		  Qualrecptr[1]^.Spec_Nam := T_lab;	  	  for i := 1 to num_rgns DO begin	  	if Assigned_lines[i] = 'KA1   ' then begin		  for ii := 1 to 129 do begin		  	if (Z_Labls[ii] = Assigned_Peaks[i]) AND (Labls[ii][3] = 'K') then begin				realtostring(max_val[i], 5, 1, E_lab);								Qualrecptr[1]^.Peak_Max[ii] := Strip_Trailing_Blanks(E_lab);				Leave;			  end;			end;	{for ii := 1 to 129}		  end	{if Assigned_lines[i] = 'KA1'}		else if Assigned_lines[i] = 'LA1   ' then begin		  for ii := 1 to 129 do begin		  	if (Z_Labls[ii] = Assigned_Peaks[i]) AND (Labls[ii][3] = 'L') then begin				realtostring(max_val[i], 5, 1, E_lab);								Qualrecptr[1]^.Peak_Max[ii] := Strip_Trailing_Blanks(E_lab);				Leave;			  end;			end;	{for ii := 1 to 129}		  end	{if Assigned_lines[i] = 'LA1'}		else if Assigned_lines[i] = 'MA1   ' then begin		  for ii := 1 to 129 do begin		  	if (Z_Labls[ii] = Assigned_Peaks[i]) AND (Labls[ii][3] = 'M') then begin				realtostring(max_val[i], 5, 1, E_lab);								Qualrecptr[1]^.Peak_Max[ii] := Strip_Trailing_Blanks(E_lab);				Leave;			  end;			end;	{for ii := 1 to 129}		  end;	{if Assigned_lines[i] = 'MA1'}		end;	{for i := 1 to num_rgns}			  write(Spread,Qualrecptr[1]^.Spec_Nam);	  for i := 1 to 129 do		write(Spread, chr(9), Qualrecptr[1]^.Peak_Max[i]);	  write(Spread, chr(13));	  DisposePtr(Ptr(Qualrecptr[1]));	  Qualrecptr[1] := NIL;	  	END;		{semi_Quant}{$S QUAL A}	  	Procedure Display_labels;		VAR		Index, Y_val              	  : Integer;		fam, grk					  : Str_4;		el							  : Str_2;        InterceptY, slopeY, local_peak, sc_max           : real;	BEGIN		   FOR index := 1 TO num_rgns DO            BEGIN					grk := '    ';					fam := '    ';					el  := '  ';				if (Assigned_Peaks[index] > 3 ) then				 begin					el := A^.sym[Assigned_Peaks[index]];					if (Assigned_lines[index] = Nm_Line[57]) then fam := 'M2N4'					else if (Assigned_lines[index] = Nm_Line[61]) then fam := 'M3N1'					else if (Assigned_lines[index] = Nm_Line[53]) then fam := 'M1N2';					if (fam = '    ') then				  BEGIN					if 		(Assigned_lines[index][1] = 'K') then fam := 'K'					else if (Assigned_lines[index][1] = 'L') then fam := 'L'					else if (Assigned_lines[index][1] = 'M') then fam := 'M';										if (Assigned_lines[index][2] = 'l') then grk := 'i' {Bob, l(little L) comes out lambda, so eye used i}										else if (Assigned_lines[index][2] = 'A') then begin						if 		(Assigned_lines[index][3] = '1') then grk := 'a1'						else if (Assigned_lines[index][3] = '2') then grk := 'a2'					end										else if (Assigned_lines[index][2] = 'B') then begin						if		(Assigned_lines[index][3] = '1') then grk := 'b1'						else if	(Assigned_lines[index][3] = '2') then grk := 'b2'						else if	(Assigned_lines[index][3] = '3') then grk := 'b3'						else if	(Assigned_lines[index][3] = '4') then grk := 'b4'						else if	(Assigned_lines[index][3] = '5') then grk := 'b5'					end					else if (Assigned_lines[index][2] = 'G') then begin						if		(Assigned_lines[index][3] = '1') then grk := 'g1'						else if	(Assigned_lines[index][3] = '3') then grk := 'g3'					end					else if (Assigned_lines[index][2] = 'n') then grk := 'h'										else if (Assigned_lines[index][2] = 'Z') then grk := 'z1';										if (Assigned_lines[index][1] = 'M') then begin						if 		(Assigned_lines[index][2] = 'B') then grk := 'b'						else if (Assigned_lines[index][2] = 'G') then grk := 'g'					end;				  END;		{ if (fam = '    ') }				 end			else 			   begin			    if (OptionKeyDown OR Fit_Invisibly) then			     fam := ' ?'				else				 fam := '    ';			   end;			   			  (* IF (Fit_Invisibly = false) then  *)			     begin				   slopeY := (Full_top_Screen - Full_Bottom_Screen) / 							 (Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.Maximum_Counts - 							  Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.Minimum_Counts);				  InterceptY := Full_Bottom_Screen - slopeY * Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.Minimum_Counts;		 {¥¥¥ Bob I had to do a range check here to prevent crashing, look into why we get a zero here, from time to time}					if (max_chan[index] > 0) AND (max_chan[index] < 8193) then 					begin					local_peak := Plt_spec[10]^^.s[max_chan[index]];					sc_max := 0.05 * Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.Maximum_Counts;					if (Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.Maximum_Counts - local_peak < sc_max) then					  local_peak := 0.95 * local_peak;					Y_val := rinttol(slopeY * local_peak + InterceptY) - 12;											if (Assigned_Peaks[index] <> 3 ) then					  Stuff_Label(  {Label_Counter, }								  max_chan[index], 								  Y_val, 								  el, 								  fam, 								  grk);				end;			END;			end; { if (max_chan[index] > 0) AND (max_chan[index] < 8193) then...}				END;		{ Procedure Display_labels }{$S QUAL B}	Procedure FormatQualResults(Initial_File : integer);		  VAR		T_lab, str					: str255;		E_lab, str1, str2			: str255;		temp_label					: string[10];	  	i, indx, Sp_Cnt				: integer;		col_found					: boolean;		  (*    Lab^^.S[Label_Counter].Element := symb;        Lab^^.S[Label_Counter].Family := Family;        Lab^^.S[Label_Counter].Greek := Greek;        Lab^^.S[Label_Counter].Exists := True;	*)			BEGIN					  Sp_Cnt := Spectrum_Counter - Initial_File +1;		  if Sp_Cnt > Max_Spec then begin		  	putmessage('The number of spectra exceeds 100.',' This run will stop and print the results. ',						'You may restart with spectrum 101. ','Be sure to give the Excel file a different name.');			  Sp_Cnt := Sp_Cnt -1;			  Last_File := Sp_Cnt;			  Qual_Incomplete := True;			  exit(FormatQualResults);					  end;		  Qualrecptr[Sp_Cnt] := Qual_record_ptr(NewPtr(SizeOf(Qual_record)));		  if ( Qualrecptr[Sp_Cnt] = NIL ) then 		    begin			  Last_File := Sp_Cnt -1;			  Qual_Incomplete := True;			  exit(FormatQualResults);			end;		  for i := 1 to Max_Line_Peaks do Qualrecptr[Sp_Cnt]^.Peak_Max[i] := '0';		  T_lab := Strip_Trailing_Blanks(Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.Spectrum_Comment_Field);		  if (length(T_lab) > 32) then			  Qualrecptr[Sp_Cnt]^.Spec_Nam := copy(T_lab,1,32)			else			  Qualrecptr[Sp_Cnt]^.Spec_Nam := T_lab;	  		  IF (Sp_Cnt = 1) then		    begin			  label_count := 0;			  First_File := 1;			 (* numtostring(Sp_Cnt,str);			  numtostring(Spectrum_Counter,str1);			  numtostring(Initial_File,str2);			  str1 := concat('Spectrum_Counter : ',str1);			  str2 := concat('Initial_File : ',str2);			  putmessage('Sp_Cnt = ',str, str1, str2);*)			  Col_Label[0] := 'Spectrum';			  for i := 1 to Label_Counter do			    if ((Lab^^.S[i].Exists = True) AND (Lab^^.S[i].Family <> ' ?')) then				  begin			        Col_Label[i] := concat(Lab^^.S[i].Element,Lab^^.S[i].Family,								    Lab^^.S[i].Greek);					realtostring(max_val[i], 5, 1, E_lab);									Qualrecptr[Sp_Cnt]^.Peak_Max[i] := Strip_Trailing_Blanks(E_lab);					label_count := label_count +1;					if (label_count > Max_Line_Peaks) then					 begin					   putmessage('The number of peaks found exceeds 130',' This file of spectra must be divided as it is too large',					   				' The results obtained to this point will be saved.','');					   label_count := Max_Line_Peaks;					   Sp_Cnt := Sp_Cnt -1;					   Last_File := Sp_Cnt;					   Halt_Qual := true;					   exit(FormatQualResults);					 end;				  end				else				  begin				    Energy_Label[i] := En_chan[i];			        realtostring(En_chan[i], 5, 1, T_lab);					Col_Label[i] := Strip_Trailing_Blanks(T_lab);					realtostring(max_val[i], 5, 1, E_lab);									Qualrecptr[Sp_Cnt]^.Peak_Max[i] := Strip_Trailing_Blanks(E_lab);					label_count := label_count +1;					if (label_count > Max_Line_Peaks) then					 begin					   putmessage('The number of peaks found exceeds 130',' This file of spectra must be divided as it is too large',					   				' The results obtained to this point will be saved.','');					   label_count := Max_Line_Peaks;					   Sp_Cnt := Sp_Cnt -1;					   Last_File := Sp_Cnt;					   Halt_Qual := true;					   exit(FormatQualResults);					 end;				  end;			end		  ELSE		    begin			  for i := 1 to Label_Counter do			    if ((Lab^^.S[i].Exists = True) AND (Lab^^.S[i].Family <> ' ?')) then				  begin			        temp_label := concat(Lab^^.S[i].Element,Lab^^.S[i].Family,								    Lab^^.S[i].Greek);					col_found := false;					for indx := 1 to label_count do					  begin					    if (temp_label = Col_Label[indx]) then						  begin							realtostring(max_val[i], 5, 1, E_lab);											Qualrecptr[Sp_Cnt]^.Peak_Max[indx] := Strip_Trailing_Blanks(E_lab);							col_found := true;						  end;					  end;					if (col_found = false) then					  begin						label_count := label_count +1;						if (label_count > Max_Line_Peaks) then						 begin						   putmessage('The number of peaks found exceeds 130',' This file of spectra must be divided as it is too large',										' The results obtained to this point will be saved.','');						   label_count := Max_Line_Peaks;						   Sp_Cnt := Sp_Cnt -1;						   Last_File := Sp_Cnt;						   Halt_Qual := true;						   exit(FormatQualResults);						 end;						Col_Label[label_count] := temp_label;						realtostring(max_val[i], 5, 1, E_lab);										Qualrecptr[Sp_Cnt]^.Peak_Max[label_count] := Strip_Trailing_Blanks(E_lab);											  end;			  	  end				else				  begin				    for indx := 1 to label_count do					  begin					    if ((En_chan[i] <= Energy_Label[indx]+20) AND (En_chan[i] >= Energy_Label[indx]-20)) then						  begin							realtostring(max_val[i], 5, 1, E_lab);											Qualrecptr[Sp_Cnt]^.Peak_Max[indx] := Strip_Trailing_Blanks(E_lab);							col_found := true;						  end;					  end;						if (col_found = false) then						  begin							label_count := label_count +1;							if (label_count > Max_Line_Peaks) then							 begin							   putmessage('The number of peaks found exceeds 130',' This file of spectra must be divided as it is too large',											' The results obtained to this point will be saved.','');							   label_count := Max_Line_Peaks;							   Sp_Cnt := Sp_Cnt -1;							   Last_File := Sp_Cnt;							   Halt_Qual := true;							   exit(FormatQualResults);							 end;							Energy_Label[label_count] := En_chan[i];							realtostring(En_chan[i], 5, 1, T_lab);							Col_Label[label_count] := Strip_Trailing_Blanks(T_lab);							realtostring(max_val[i], 5, 1, E_lab);											Qualrecptr[Sp_Cnt]^.Peak_Max[label_count] := Strip_Trailing_Blanks(E_lab);						  end;				  end;			end;		  		END;		{FormatQualResults}			{$S QUAL1}    PROCEDURE Deriv2;		{*** the filter second derivative ***}        { on exit, the first npoints-filtersize chs of arrayout will have filtered data }          VAR            nn, i, ntofil, nl_peak, nr_peak 				: integer;            xlobe, xcenter, shift_chan, n_tofil, xfil_siz 	: array [1..3] of integer;            lobe, center, fil_siz							: integer;			n_start, j										: integer;			corr 											: array [1..27,1..3] of integer;            epsil, sigma  									: real;			CM, CMS		 									: real;			Ltemp, Rtemp  									: integer;			left_switch, right_switch						: boolean;          BEGIN	{procedure Deriv2}		 	nl_peak := 0;			nr_peak := 0;			num_rgns := 0;			for i := 1 to MaxLabels do			  begin			    max_val[i] := 0.0;				en_chan[i] := 0.0;				max_chan[i] := 0;				spinCursor;			  end;			xfil_siz[1] := 21;	{low energy peaks}			xfil_siz[2] := 27;	{mid-range peaks}			xfil_siz[3] := 27;	{high energy peaks}		{	sensi := 2.5;	}		{*** this is the sensitivity ***}						FOR j := 1 to 3 DO BEGIN				xlobe[j] := (xfil_siz[j]) DIV 3;				xcenter[j] := (xfil_siz[j] DIV 2) + 1;				FOR i := 1 to xlobe[j] DO BEGIN					corr[i,j] := -1;					corr[i+2*xlobe[j],j] := -1;				END;				for i := xlobe[j] + 1 to 2*xlobe[j] do corr[i,j] := 2;				n_tofil[j] := Num_Chans - xfil_siz[j] - 1;			END;	{FOR j := 1 to 3}			IF Spec_Limit > 40000.0 then ntofil := n_tofil[3]			ELSE IF Spec_Limit < 6000.0 then ntofil := n_tofil[1]			ELSE  ntofil := n_tofil[2];			shift_chan[1] := 0;			shift_chan[2] := rinttol(6000.0/Plt_spec[10]^^.Expt_Info.dE);			shift_chan[3] := rinttol(40000.0/Plt_spec[10]^^.Expt_Info.dE);					CM := 0.0;			max_val[1] := 0.0;				left_switch := false;				right_switch := false;				Rtemp := 0;				Ltemp := 0;			n_start := {truncl}rinttol((50.0 * Plt_Spec[10]^^.Expt_Info.Energy_Slope + Plt_Spec[10]^^.Expt_Info.Energy_Intercept)/						Plt_spec[10]^^.Expt_Info.dE);            FOR nn := n_start TO ntofil DO              BEGIN			    spinCursor;				CMS := CM;								IF ( nn < shift_chan[2] ) then begin					center := xcenter[1];					lobe := xlobe[1];					fil_siz := xfil_siz[1];				end				else IF ( nn > shift_chan[3] ) then begin					center := xcenter[3];					lobe := xlobe[3];					fil_siz := xfil_siz[3];				end				else begin					center := xcenter[2];					lobe := xlobe[2];					fil_siz := xfil_siz[2];								end;								for i := 1 to fil_siz do				  IF ( nn < shift_chan[2] ) then				    Col_3^[center+nn] := Col_3^[center+nn] + Col_2^[i+nn] * corr[i,1]				  else IF ( nn > shift_chan[3] ) then				    Col_3^[center+nn] := Col_3^[center+nn] + Col_2^[i+nn] * corr[i,3]				  else				    Col_3^[center+nn] := Col_3^[center+nn] + Col_2^[i+nn] * corr[i,2];				CM := Col_3^[center+nn];				sigma := SQRT(Col_1^[center+nn]);	{Col_1^ should be the background}				if (sigma < 3.0) then sigma := 3.0;		{*** lower limit of square root of background ***}				EPSIL := 1.2 * sensi * lobe * sigma;				if ((CMS < epsil) and (CM > epsil)) then				  begin				    if NOT left_switch then				      nl_peak := nl_peak + 1;					  if nl_peak >= MaxLabels then begin					  	putmessage('Found too many peaks.','nl_peak','','');						Halt_Qual := true;						Qual_Incomplete := True;						exit(Deriv2);					  end;					left_switch := true;					Ltemp := center + nn;				  end;				if ((CMS > epsil) and (CM < epsil) and (left_switch)) then				  begin				    nr_peak := nr_peak + 1;					  if nr_peak >= MaxLabels then begin					  	putmessage('Found too many peaks.','nr_peak','','');						Halt_Qual := true;						Qual_Incomplete := True;						exit(Deriv2);					  end;					right_switch := true;					Rtemp := center + nn;				  end;				  if ((left_switch and right_switch) and (nl_peak = nr_peak)) then				  begin				    if ((Rtemp - Ltemp) > 1) AND (Ltemp > 0) then					 begin					  LTQ[nl_peak] := Ltemp;					  RTQ[nr_peak] := Rtemp;					  					  max_chan[nl_peak] := Ltemp + (Rtemp - Ltemp) DIV 2;					  					  max_val[nl_peak+1] := 0.0;					  left_switch := false;					  right_switch := false;					  Rtemp := 0;					  Ltemp := 0;					 end					else					 begin					  max_val[nl_peak] := 0.0;					  nl_peak := nl_peak -1;					  nr_peak := nr_peak -1;					  left_switch := false;					  right_switch := false;					  Rtemp := 0;					  Ltemp := 0;					 end;				  end				  else				  begin				  	if (nr_peak > nl_peak) then nr_peak := nr_peak - 1;					IF (nl_peak > (nr_peak+1)) THEN nl_peak := nl_peak - 1;				  end;				  if ((left_switch) and not (right_switch)) then				   begin				    (*if (CM > max_val[nl_peak]) then*)				    if (CM > 0) then					 begin					  max_val[nl_peak] := max_val[nl_peak] + CM;					  (*max_chan[nl_peak] := center + nn;*)					 end;				   end;              END;                                    {for nn}			  num_rgns := nl_peak;			  {if (nr_peak > nl_peak) then num_rgns := nr_peak;}          END;                                        {procedure Deriv2}{$S QUAL1A}	Procedure Find_element;		{*** find all possible K, L, and M alpha lines for a given peak ***}	VAR		index1, index, indx	: integer;		diff				: real;		wted_M, temp_M		: real;		omit_elems			: Array [1..11] of integer;		omit_this			: boolean;		BEGIN	  omit_elems[1] := 10;	{Ne}	  omit_elems[2] := 36;	{Kr}	  omit_elems[3] := 43;	{Tc}	  omit_elems[4] := 54;	{Xe}	  omit_elems[5] := 61;	{Pm}	  omit_elems[6] := 84;	{Po}	  omit_elems[7] := 85;	{At}	  omit_elems[8] := 86;	{Rn}	  omit_elems[9] := 87;	{Fr}	  omit_elems[10] := 89;	{Ac}	  omit_elems[11] := 91;	{Pa}	  	  FOR index := 1 to MaxLabels do	  	for index1 := 1 to 12 do Possible_Peaks[index1,index] := 1;	  FOR index := 1 to num_rgns do	  begin	  if En_chan[index] > 50000.0 then	    diff := search_Range + 40.0	  else if En_chan[index] > 40000.0 then	    diff := search_Range + 30.0	  else if En_chan[index] > 20000.0 then	    diff := search_Range + 20.0	  else 	  if En_chan[index] > 5000.0 then	    diff := search_Range + 10.0	  else	    diff := search_Range;      FOR index1 := 6 TO 94 DO 	{Start with carbon, end with plutonium}        BEGIN			spinCursor;			omit_this := false;			For indx := 1 to 11 do if (index1 = omit_elems[indx]) then omit_this := true;			if NOT omit_this then begin			Get_Energies(index1);			  IF ((A^.edge[1] / 1000.0) < Plt_spec[10]^^.Expt_Info.kV) AND             	 (eV_Line[1] >= (En_chan[index] - diff)) AND 			     (eV_Line[1] <= (En_chan[index] + diff)) THEN                BEGIN				 if (Possible_Peaks[1,index] = 1) then				  Possible_Peaks[1,index] := index1				 else if (Possible_Peaks[2,index] = 1) then				  Possible_Peaks[2,index] := index1				 else if (Possible_Peaks[3,index] = 1) then				  Possible_Peaks[3,index] := index1				 else				  Possible_Peaks[4,index] := index1;				END;			  if (index1 > 24) then begin              IF ((A^.edge[4] / 1000.0) < Plt_spec[10]^^.Expt_Info.kV) AND			  	 (eV_Line[42] >= (En_chan[index] - diff)) AND 			     (eV_Line[42] <= (En_chan[index] + diff)) THEN                BEGIN				 if (Possible_Peaks[5,index] = 1) then				  Possible_Peaks[5,index] := index1				 else if (Possible_Peaks[6,index] = 1) then				  Possible_Peaks[6,index] := index1				 else if (Possible_Peaks[7,index] = 1) then				  Possible_Peaks[7,index] := index1				 else				  Possible_Peaks[8,index] := index1;				END;			  end;	{if (index1 > 24)}			  if (index1 > 56) THEN				   begin				if (index1 < 82) then begin					temp_M := (Wt_Line[72] + Wt_Line[73])/2;					wted_M := (temp_M*(eV_Line[72] + eV_Line[73])/2 + Wt_Line[69]*eV_Line[69])/(temp_M + Wt_Line[69]);					end				else					wted_M := (eV_Line[72] + eV_Line[73])/2;              IF ((A^.edge[9] / 1000.0) < Plt_spec[10]^^.Expt_Info.kV) AND			  	 (wted_M >= (En_chan[index] - diff)) AND 			     (wted_M <= (En_chan[index] + diff)) THEN                BEGIN				 if (Possible_Peaks[9,index] = 1) then				  Possible_Peaks[9,index] := index1				 else if (Possible_Peaks[10,index] = 1) then				  Possible_Peaks[10,index] := index1				 else if (Possible_Peaks[11,index] = 1) then				  Possible_Peaks[11,index] := index1				 else				  Possible_Peaks[12,index] := index1;				END;			end;	{if (index1 > 56)}		 end;		END;	{ FOR index1 := 6 TO 94 DO }      end;    { FOR index := 1 to num_rgns do }        	END;	{ Procedure Find_element }{$S QUAL1B}	Function mx_pk(a : AR200; num : integer)	: integer;		{*** find the largest peak (derivative) ***}	VAR		maxc, i		: integer;		maxp		: real;			BEGIN	  maxp := 0.0;	  for i := 1 to num do	    begin		  if (Assigned_Peaks[i] = 0) then		    begin			  if (a[i] > maxp) then				begin				  maxp := a[i];				  maxc := i;				end;		    end;		end;	  mx_pk := maxc;	END;{$S QUAL1C}	Procedure Select_K(maxc : integer;  VAR selected_elem, num_of_pks : longint {integer});			{*** if the main peak is a K-alpha check for other peaks from same element ***}			{ this will return one element from the possible K-alpha peaks }	VAR		index, index1, indx		: integer;		line_count				: array [1..4] of integer;		K_found					: array [1..8] of boolean;		L_found					: array [1..8] of boolean;		M_found					: array [1..8] of boolean;		{index_used				: array [1..MaxLabels] of boolean;}	    dff, wted_M             : real;		L1_index, M1_index		: integer;			BEGIN	    dff := search_Range;		{for index := 1 to MaxLabels do			index_used[index] := false;}		line_count[1] := 0;		line_count[2] := 0;		line_count[3] := 0;		line_count[4] := 0;		num_of_pks := 0;		selected_elem := 0;		L1_index := 0;		M1_index := 0;		for index1 := 1 to 4 do		{ Start checking K lines }			begin			  spinCursor;			  if (Possible_Peaks[index1,maxc] > 1) then		{ found a K line }			    begin					for indx := 1 to 8 do					 begin						L_found[indx] := false;						M_found[indx] := false;						K_found[indx] := false;					 end;				  Get_Energies(Possible_Peaks[index1,maxc]);				  K_found[1] := true;				  line_count[index1] := line_count[index1] +1;				  Temp[index1,maxc] := Possible_Peaks[index1,maxc];				  Temp_x[index1,maxc] := Nm_Line[1];				  index_used[maxc] := true; 				 for indx := maxc + 1 to num_rgns do				   begin				     spinCursor;					 IF (En_chan[indx] > 40000.0) then dff := search_Range + 80 else					 IF (En_chan[indx] > 10000.0) then dff := search_Range + 60 else				   	 IF (En_chan[indx] > 5000.0) then dff := search_Range + 40 else					                                  dff := search_Range;					 IF ((Possible_Peaks[index1,maxc] > 15) AND (Possible_Peaks[index1,maxc] < 19)) then					 	 dff := search_Range + 40;    					 IF (NOT K_found[2]) AND					 	(NOT index_used[indx]) AND					 	(eV_Line[3] >= (En_chan[indx] - dff)) AND 						(eV_Line[3] <= (En_chan[indx] + dff)) AND						(max_val[maxc] > max_val[indx]) AND						(Possible_Peaks[index1,maxc] > 15) THEN	{ K_beta separated from K_alpha }				  		begin						  K_found[2] := true;						  line_count[index1] := line_count[index1] +1;						  Temp[index1,indx] := Possible_Peaks[index1,maxc];						  Temp_x[index1,indx] := Nm_Line[3];						  index_used[indx] := true;						end;					if (Possible_Peaks[index1,maxc] > 55) then begin					 IF (NOT K_found[3]) AND					 	(NOT index_used[indx]) AND					 	(eV_Line[2] >= (En_chan[indx] - dff)) AND 						(eV_Line[2] <= (En_chan[indx] + dff)) (*AND						(max_val[maxc] > max_val[indx])*)  THEN	{ K_alpha2 separated from K_alpha1 }				  		begin						  K_found[3] := true;						  line_count[index1] := line_count[index1] +1;						  Temp[index1,indx] := Possible_Peaks[index1,maxc];						  Temp_x[index1,indx] := Nm_Line[2];						  index_used[indx] := true;						end;					(* else IF (NOT K_found[4]) AND					 	(NOT index_used[indx]) AND					 	(eV_Line[4] >= (En_chan[indx] - dff)) AND 						(eV_Line[4] <= (En_chan[indx] + dff)) AND						(max_val[maxc] > max_val[indx])  THEN	{ K_beta2 separated from K_beta1 }				  		begin						  K_found[4] := true;						  line_count[index1] := line_count[index1] +1;						  Temp[index1,indx] := Possible_Peaks[index1,maxc];						  Temp_x[index1,indx] := 'KB2';						  index_used[indx] := true;						end					 else IF (NOT K_found[5]) AND					 	(NOT index_used[indx]) AND					 	(eV_Line[5] >= (En_chan[indx] - dff)) AND 						(eV_Line[5] <= (En_chan[indx] + dff)) AND						(max_val[maxc] > max_val[indx])  THEN	{ K_beta3 separated from K_beta1 }				  		begin						  K_found[5] := true;						  line_count[index1] := line_count[index1] +1;						  Temp[index1,indx] := Possible_Peaks[index1,maxc];						  Temp_x[index1,indx] := 'KB3';						  index_used[indx] := true;						end					 else IF (NOT K_found[6]) AND					 	(NOT index_used[indx]) AND					 	(eV_Line[6] >= (En_chan[indx] - dff)) AND 						(eV_Line[6] <= (En_chan[indx] + dff)) AND						(max_val[maxc] > max_val[indx])  THEN	{ K_beta4 separated from K_beta1 }				  		begin						  K_found[6] := true;						  line_count[index1] := line_count[index1] +1;						  Temp[index1,indx] := Possible_Peaks[index1,maxc];						  Temp_x[index1,indx] := 'KB4';						  index_used[indx] := true;						end					 else IF (NOT K_found[7]) AND					 	(NOT index_used[indx]) AND					 	(eV_Line[7] >= (En_chan[indx] - dff)) AND 						(eV_Line[7] <= (En_chan[indx] + dff)) AND						(max_val[maxc] > max_val[indx])  THEN	{ K_beta5 separated from K_beta1 }				  		begin						  K_found[7] := true;						  line_count[index1] := line_count[index1] +1;						  Temp[index1,indx] := Possible_Peaks[index1,maxc];						  Temp_x[index1,indx] := 'KB5';						  index_used[indx] := true;						end;*)					end;				   end;				 for indx := 1 to maxc-1 do				   begin					 spinCursor;					 IF (NOT L_found[1]) AND						(NOT index_used[indx]) AND					 	(eV_Line[42] >= (En_chan[indx] - dff)) AND 						(eV_Line[42] <= (En_chan[indx] + dff)) AND						(Possible_Peaks[index1,maxc] > 24) THEN	{ L_alpha }				  		begin						  L_found[1] := true;						  line_count[index1] := line_count[index1] +1;						  Temp[index1,indx] := Possible_Peaks[index1,maxc];						  Temp_x[index1,indx] := Nm_Line[42];						  index_used[indx] := true;						  L1_index := indx;						end;				   end;				 if ((L_found[1]) AND (Possible_Peaks[index1,maxc] > 40)) THEN	{ L_beta test }				 for indx := 1 to maxc-1 do					   begin					     spinCursor;						 IF (NOT L_found[2]) AND						 	(NOT index_used[indx]) AND						 	(eV_Line[29] >= (En_chan[indx] - dff)) AND							(max_val[L1_index] > max_val[indx]) AND 							(eV_Line[29] <= (En_chan[indx] + dff)) THEN	{ L_beta }							begin							  L_found[2] := true;							  line_count[index1] := line_count[index1] +1;							  Temp[index1,indx] := Possible_Peaks[index1,maxc];							  Temp_x[index1,indx] := Nm_Line[29];							  index_used[indx] := true;							end						 ELSE IF (NOT L_found[3]) AND						 	(NOT index_used[indx]) AND							(max_val[L1_index] > max_val[indx]) AND						 	(eV_Line[31] >= (En_chan[indx] - dff)) AND 							(eV_Line[31] <= (En_chan[indx] + dff)) THEN	{ L_gamma }							begin							  L_found[3] := true;							  line_count[index1] := line_count[index1] +1;							  Temp[index1,indx] := Possible_Peaks[index1,maxc];							  Temp_x[index1,indx] := Nm_Line[31];							  index_used[indx] := true;							end						 ELSE IF (NOT L_found[4]) AND						 	(NOT index_used[indx]) AND							(max_val[L1_index] > max_val[indx]) AND						 	(eV_Line[49] >= (En_chan[indx] - dff)) AND 							(eV_Line[49] <= (En_chan[indx] + dff)) THEN	{ L_L }							begin							  L_found[4] := true;							  line_count[index1] := line_count[index1] +1;							  Temp[index1,indx] := Possible_Peaks[index1,maxc];							  Temp_x[index1,indx] := Nm_Line[49];							  index_used[indx] := true;							end						 ELSE IF (NOT L_found[5]) AND						 	(NOT index_used[indx]) AND							(max_val[L1_index] > max_val[indx]) AND						 	(eV_Line[35] >= (En_chan[indx] - dff)) AND 							(eV_Line[35] <= (En_chan[indx] + dff)) THEN	{ L_eta }							begin							  L_found[5] := true;							  line_count[index1] := line_count[index1] +1;							  Temp[index1,indx] := Possible_Peaks[index1,maxc];							  Temp_x[index1,indx] := Nm_Line[35];							  index_used[indx] := true;							end						 ELSE IF (NOT L_found[6]) AND						 	(NOT index_used[indx]) AND							(max_val[L1_index] > max_val[indx]) AND						 	(eV_Line[45] >= (En_chan[indx] - dff)) AND 							(eV_Line[45] <= (En_chan[indx] + dff)) THEN	{ L_B2 }							begin							  L_found[6] := true;							  line_count[index1] := line_count[index1] +1;							  Temp[index1,indx] := Possible_Peaks[index1,maxc];							  Temp_x[index1,indx] := Nm_Line[45];							  index_used[indx] := true;							end						 ELSE IF (NOT L_found[7]) AND						 	(NOT index_used[indx]) AND							(max_val[L1_index] > max_val[indx]) AND						 	(eV_Line[18] >= (En_chan[indx] - dff)) AND 							(eV_Line[18] <= (En_chan[indx] + dff)) THEN	{ L_G3 }							begin							  L_found[7] := true;							  line_count[index1] := line_count[index1] +1;							  Temp[index1,indx] := Possible_Peaks[index1,maxc];							  Temp_x[index1,indx] := Nm_Line[18];							  index_used[indx] := true;							end						 ELSE IF (NOT L_found[8]) AND						 	(NOT index_used[indx]) AND						 	(eV_Line[46] >= (En_chan[indx] - dff)) AND 							(eV_Line[46] <= (En_chan[indx] + dff)) AND							(max_val[L1_index] > max_val[indx]) AND				 			(Plt_spec[10]^^.Expt_Info.kV > (A^.edge[4] / 1000.0)) THEN	{ L_B5 }							begin							  L_found[8] := true;							  line_count[index] := line_count[index] +1;							  Temp[index1,indx] := Possible_Peaks[index1,maxc];							  Temp_x[index1,indx] := Nm_Line[46];							  index_used[indx] := true;							end;					   end;				 if (Possible_Peaks[index1,maxc] > 56) THEN				   begin					 for indx := 1 to maxc-1 do					   begin						 spinCursor;					if (index1 < 90) then						wted_M := (Wt_Line[72]*eV_Line[72] + Wt_Line[69]*eV_Line[69])/(Wt_Line[72] + Wt_Line[69])					else						wted_M := (eV_Line[72] + eV_Line[73])/2;					 IF (NOT M_found[1]) AND						(NOT index_used[indx]) AND					 	(wted_M >= (En_chan[indx] - dff)) AND 						(wted_M <= (En_chan[indx] + dff)) THEN	{ M_alpha }				  		begin						  M_found[1] := true;						  line_count[index1] := line_count[index1] +1;						  Temp[index1,indx] := Possible_Peaks[index1,maxc];						  Temp_x[index1,indx] := Nm_Line[72];						  index_used[indx] := true;						  M1_index := indx;						end;					  end;		{for indx := 1 to maxc-1}					  				  for indx := 1 to maxc-1 do				   begin					 IF (M_found[1]) then					 begin						 spinCursor;					 IF (NOT M_found[2]) AND						(NOT index_used[indx]) AND						(max_val[M1_index] > max_val[indx]) AND					 	(eV_Line[66] >= (En_chan[indx] - dff)) AND 						(eV_Line[66] <= (En_chan[indx] + dff)) THEN	{ M_gamma }						begin						  M_found[2] := true;						  line_count[index1] := line_count[index1] +1;						  Temp[index1,indx] := Possible_Peaks[index1,maxc];						  Temp_x[index1,indx] := Nm_Line[66];						  index_used[indx] := true;						end					 ELSE IF (NOT M_found[3]) AND						(NOT index_used[indx]) AND						(max_val[M1_index] > max_val[indx]) AND					 	(eV_Line[74] >= (En_chan[indx] - dff)) AND 						(eV_Line[74] <= (En_chan[indx] + dff)) THEN	{ M_zeta }						begin						  M_found[3] := true;						  line_count[index1] := line_count[index1] +1;						  Temp[index1,indx] := Possible_Peaks[index1,maxc];						  Temp_x[index1,indx] := Nm_Line[74];						  index_used[indx] := true;						end				 	ELSE IF (NOT M_found[4]) AND						(NOT index_used[indx]) AND						(max_val[M1_index] > max_val[indx]) AND						(eV_Line[57] >= (En_chan[indx] - dff)) AND 						(eV_Line[57] <= (En_chan[indx] + dff)) THEN	{ M_2N4 }						begin						  M_found[4] := true;						  line_count[index1] := line_count[index1] +1;						  Temp[index1,indx] := Possible_Peaks[index1,maxc];						  Temp_x[index1,indx] := Nm_Line[57];						  index_used[indx] := true;						end					 ELSE IF (NOT M_found[5]) AND						(NOT index_used[indx]) AND						(max_val[M1_index] > max_val[indx]) AND					 	(Possible_Peaks[index1,maxc] > 80) AND					 	(eV_Line[69] >= (En_chan[indx] - dff)) AND 						(eV_Line[69] <= (En_chan[indx] + dff)) THEN	{ M_beta }						begin						  M_found[5] := true;						  line_count[index1] := line_count[index1] +1;						  Temp[index1,indx] := Possible_Peaks[index1,maxc];						  Temp_x[index1,indx] := Nm_Line[69];						  index_used[indx] := true;						end				 	ELSE IF (NOT M_found[6]) AND						(NOT index_used[indx]) AND						(max_val[M1_index] > max_val[indx]) AND						(eV_Line[61] >= (En_chan[indx] - dff)) AND 						(eV_Line[61] <= (En_chan[indx] + dff)) THEN	{ M_3N1 }						begin						  M_found[6] := true;						  line_count[index1] := line_count[index1] +1;						  Temp[index1,indx] := Possible_Peaks[index1,maxc];						  Temp_x[index1,indx] := Nm_Line[61];						  index_used[indx] := true;						end				 	ELSE IF (NOT M_found[7]) AND						(NOT index_used[indx]) AND						(max_val[M1_index] > max_val[indx]) AND						(Possible_Peaks[index1,maxc] > 82) AND						(eV_Line[56] >= (En_chan[indx] - dff)) AND 						(eV_Line[56] <= (En_chan[indx] + dff)) THEN	{ M2N1 }						begin						  M_found[7] := true;						  line_count[index1] := line_count[index1] +1;						  Temp[index1,indx] := Possible_Peaks[index1,maxc];						  Temp_x[index1,indx] := Nm_Line[56];						  index_used[indx] := true;						end;					  end;				    end;				 end;	{ if (Possible_Peaks[index1,maxc] > 56) }					end;	{ if (Possible_Peaks[index1,maxc] > 1) }			  if (Possible_Peaks[index1,maxc] > 27) AND			     (NOT L_found[1]) then				  begin				 	line_count[index1] := 0;					for indx := 1 to num_rgns do					  begin					    Temp[index1,indx] := 0;						Temp_x[index1,indx] := '     ';					  end;				  end;			  if (line_count[index1] > num_of_pks) then			    begin				  num_of_pks := line_count[index1];				  selected_elem := Possible_Peaks[index1,maxc];				end;			 end;	{ for index1 := 1 to 4 do }	END;	{ Procedure Select_K }{$S QUAL2}			Procedure Select_L(maxc : integer; VAR selected_elem, num_of_pks : longint {integer});		{*** if the main peak is a L-alpha check for other peaks from same element ***}		{ this will return one element from the possible L-alpha peaks }	VAR		index, index1, indx		: integer;		line_count				: array [1..4] of integer;		K_found					: array [1..8] of boolean;		L_found					: array [1..8] of boolean;		M_found					: array [1..8] of boolean;			{index_used				: array [1..MaxLabels] of boolean;}		dff, wted_M             : real; 		K1_index, M1_index		: integer;		r_count					: integer;	BEGIN	    dff := search_Range;		{for index := 1 to MaxLabels do			index_used[index] := false;}		line_count[1] := 0;		line_count[2] := 0;		line_count[3] := 0;		line_count[4] := 0;		num_of_pks := 0;		selected_elem := 0;		K1_index := 0;		M1_index := 0;		for index1 := 5 to 8 do		{ Start checking L lines }			begin				r_count := 0;			REPEAT				r_count := r_count + 1;			  spinCursor;			  index := index1 - 4;			  if (Possible_Peaks[index1,maxc] > 1) then			    begin					for indx := 1 to 8 do					 begin					    K_found[indx] := false;						L_found[indx] := false;						M_found[indx] := false;					 end;				  Get_Energies(Possible_Peaks[index1,maxc]);				  L_found[1] := true;				  line_count[index] := line_count[index] +1;				  Temp[index1,maxc] := Possible_Peaks[index1,maxc];				  Temp_x[index1,maxc] := Nm_Line[42];				  index_used[maxc] := true; 				 for indx := 1 to num_rgns do				   begin				     spinCursor;					 IF (En_chan[indx] > 40000.0) then dff := search_Range + 80 else					 if (En_chan[indx] > 10000.0) then dff := search_Range + 60 else 				     IF (En_chan[indx] > 5000.0) then dff := search_Range + 40 else					                      dff := search_Range;    					 IF (NOT L_found[2]) AND						(NOT index_used[indx]) AND					 	(eV_Line[29] >= (En_chan[indx] - dff)) AND 						(eV_Line[29] <= (En_chan[indx] + dff)) AND						(Possible_Peaks[index1,maxc] > 40) AND						(max_val[maxc] > max_val[indx]) AND						(Plt_spec[10]^^.Expt_Info.kV > (A^.edge[3] / 1000.0)) THEN	{ L_beta test }				  		begin						  L_found[2] := true;						  line_count[index] := line_count[index] +1;						  Temp[index1,indx] := Possible_Peaks[index1,maxc];						  Temp_x[index1,indx] := Nm_Line[29];						  index_used[indx] := true;						end					 ELSE IF (NOT L_found[3]) AND						(NOT index_used[indx]) AND					 	(eV_Line[31] >= (En_chan[indx] - dff)) AND 						(eV_Line[31] <= (En_chan[indx] + dff)) AND						(max_val[maxc] > max_val[indx]) AND						(Plt_spec[10]^^.Expt_Info.kV > (A^.edge[3] / 1000.0)) THEN	{ L_gamma }						begin						  L_found[3] := true;						  line_count[index] := line_count[index] +1;						  Temp[index1,indx] := Possible_Peaks[index1,maxc];						  Temp_x[index1,indx] := Nm_Line[31];						  index_used[indx] := true;						end					 ELSE IF (NOT L_found[4]) AND						(NOT index_used[indx]) AND					 	(eV_Line[49] >= (En_chan[indx] - dff)) AND 						(eV_Line[49] <= (En_chan[indx] + dff)) AND						(max_val[maxc] > max_val[indx]) AND						(Plt_spec[10]^^.Expt_Info.kV > (A^.edge[4] / 1000.0)) THEN	{ L_L }						begin						  L_found[4] := true;						  line_count[index] := line_count[index] +1;						  Temp[index1,indx] := Possible_Peaks[index1,maxc];						  Temp_x[index1,indx] := Nm_Line[49];						  index_used[indx] := true;						end					 ELSE IF (NOT L_found[5]) AND						(NOT index_used[indx]) AND					 	(eV_Line[35] >= (En_chan[indx] - dff)) AND 						(eV_Line[35] <= (En_chan[indx] + dff)) AND						(max_val[maxc] > max_val[indx]) AND						(Plt_spec[10]^^.Expt_Info.kV > (A^.edge[3] / 1000.0)) THEN	{ L_eta }						begin						  L_found[5] := true;						  line_count[index] := line_count[index] +1;						  Temp[index1,indx] := Possible_Peaks[index1,maxc];						  Temp_x[index1,indx] := Nm_Line[35];						  index_used[indx] := true;						end					 ELSE IF (NOT L_found[6]) AND						(NOT index_used[indx]) AND						(eV_Line[45] >= (En_chan[indx] - dff)) AND 						(eV_Line[45] <= (En_chan[indx] + dff)) AND						(max_val[maxc] > max_val[indx]) AND						(Plt_spec[10]^^.Expt_Info.kV > (A^.edge[4] / 1000.0)) THEN	{ L_B2 }						begin						  L_found[6] := true;						  line_count[index] := line_count[index] +1;						  Temp[index1,indx] := Possible_Peaks[index1,maxc];						  Temp_x[index1,indx] := Nm_Line[45];						  index_used[indx] := true;						end					 ELSE IF (NOT L_found[7]) AND						(NOT index_used[indx]) AND						(eV_Line[18] >= (En_chan[indx] - dff)) AND 						(eV_Line[18] <= (En_chan[indx] + dff)) AND						(max_val[maxc] > max_val[indx]) AND						(Plt_spec[10]^^.Expt_Info.kV > (A^.edge[2] / 1000.0)) THEN	{ L_G3 }						begin						  L_found[7] := true;						  line_count[index] := line_count[index] +1;						  Temp[index1,indx] := Possible_Peaks[index1,maxc];						  Temp_x[index1,indx] := Nm_Line[18];						  index_used[indx] := true;							end					 ELSE IF (NOT L_found[8]) AND						(NOT index_used[indx]) AND						(eV_Line[46] >= (En_chan[indx] - dff)) AND 						(eV_Line[46] <= (En_chan[indx] + dff)) AND						(max_val[maxc] > max_val[indx]) AND						(Plt_spec[10]^^.Expt_Info.kV > (A^.edge[4] / 1000.0)) THEN	{ L_B5 }						begin						  L_found[8] := true;						  line_count[index] := line_count[index] +1;						  Temp[index1,indx] := Possible_Peaks[index1,maxc];						  Temp_x[index1,indx] := Nm_Line[46];						  index_used[indx] := true;						end;				   end;				  if (Plt_spec[10]^^.Expt_Info.kV > (A^.edge[1] / 1000.0)) then				   begin					 for indx := maxc+1 to num_rgns do						   begin						   	 spinCursor;							 IF (NOT K_found[1]) AND								(NOT index_used[indx]) AND							 	(eV_Line[1] >= (En_chan[indx] - dff)) AND 								(eV_Line[1] <= (En_chan[indx] + dff)) THEN	{ K_alpha }								begin								  K_found[1] := true;								  line_count[index] := line_count[index] +1;								  Temp[index1,indx] := Possible_Peaks[index1,maxc];								  Temp_x[index1,indx] := Nm_Line[1];								  index_used[indx] := true;								  K1_index := indx;								end;							end;							IF (K_found[1]) THEN							for indx := maxc + 1 to num_rgns do							BEGIN						   	 spinCursor;							 IF (NOT K_found[2]) AND								(NOT index_used[indx]) AND							 	(eV_Line[3] >= (En_chan[indx] - dff)) AND 								(eV_Line[3] <= (En_chan[indx] + dff)) AND								(Possible_Peaks[index1,maxc] > 15) AND								(max_val[K1_index] > max_val[indx]) THEN	{ K_beta1 }								begin								  K_found[2] := true;								  line_count[index] := line_count[index] +1;								  Temp[index1,indx] := Possible_Peaks[index1,maxc];								  Temp_x[index1,indx] := Nm_Line[3];								  index_used[indx] := true;								end;							  if (Possible_Peaks[index1,maxc] > 55) then begin								 IF (NOT K_found[3]) AND									(NOT index_used[indx]) AND									(eV_Line[2] >= (En_chan[indx] - dff)) AND 									(eV_Line[2] <= (En_chan[indx] + dff)) (*AND									(max_val[K1_index] > max_val[indx])*)  THEN	{ K_alpha2 separated from K_alpha1 }									begin									  K_found[3] := true;									  line_count[index] := line_count[index] +1;									  Temp[index1,indx] := Possible_Peaks[index1,maxc];									  Temp_x[index1,indx] := Nm_Line[2];									  index_used[indx] := true;									end;								(* else IF (NOT K_found[4]) AND									(NOT index_used[indx]) AND									(eV_KB2 >= (En_chan[indx] - dff)) AND 									(eV_KB2 <= (En_chan[indx] + dff)) AND									(max_val[K1_index] > max_val[indx])  THEN	{ K_beta2 separated from K_beta1 }									begin									  K_found[4] := true;									  line_count[index] := line_count[index] +1;									  Temp[index1,indx] := Possible_Peaks[index1,maxc];									  Temp_x[index1,indx] := 'KB2';									  index_used[indx] := true;									end								 else IF (NOT K_found[5]) AND									(NOT index_used[indx]) AND									(eV_KB3 >= (En_chan[indx] - dff)) AND 									(eV_KB3 <= (En_chan[indx] + dff)) AND									(max_val[K1_index] > max_val[indx])  THEN	{ K_beta3 separated from K_beta1 }									begin									  K_found[5] := true;									  line_count[index] := line_count[index] +1;									  Temp[index1,indx] := Possible_Peaks[index1,maxc];									  Temp_x[index1,indx] := 'KB3';									  index_used[indx] := true;									end								 else IF (NOT K_found[6]) AND									(NOT index_used[indx]) AND									(eV_KB4 >= (En_chan[indx] - dff)) AND 									(eV_KB4 <= (En_chan[indx] + dff)) AND									(max_val[K1_index] > max_val[indx])  THEN	{ K_beta4 separated from K_beta1 }									begin									  K_found[6] := true;									  line_count[index] := line_count[index] +1;									  Temp[index1,indx] := Possible_Peaks[index1,maxc];									  Temp_x[index1,indx] := 'KB4';									  index_used[indx] := true;									end								 else IF (NOT K_found[7]) AND									(NOT index_used[indx]) AND									(eV_KB5 >= (En_chan[indx] - dff)) AND 									(eV_KB5 <= (En_chan[indx] + dff)) AND									(max_val[K1_index] > max_val[indx])  THEN	{ K_beta5 separated from K_beta1 }									begin									  K_found[7] := true;									  line_count[index] := line_count[index] +1;									  Temp[index1,indx] := Possible_Peaks[index1,maxc];									  Temp_x[index1,indx] := 'KB5';									  index_used[indx] := true;									end;*)								end;							 END;				   end;	 { if (Plt_spec[10]^^.Expt_Info.kV > (A^.edge[1] / 1000.0)) }				 if (Possible_Peaks[index1,maxc] > 56) THEN				   begin					 for indx := 1 to maxc-1 do					   begin						 spinCursor;					if (index1 < 90) then						wted_M := (Wt_Line[72]*eV_Line[72] + Wt_Line[69]*eV_Line[69])/(Wt_Line[72] + Wt_Line[69])					else						wted_M := (eV_Line[72] + eV_Line[73])/2;;					 IF (NOT M_found[1]) AND						(NOT index_used[indx]) AND					 	(wted_M >= (En_chan[indx] - dff)) AND 						(wted_M <= (En_chan[indx] + dff)) THEN	{ M_alpha }				  		begin						  M_found[1] := true;						  line_count[index] := line_count[index] +1;						  Temp[index1,indx] := Possible_Peaks[index1,maxc];						  Temp_x[index1,indx] := Nm_Line[72];						  index_used[indx] := true;						  M1_index := indx;						end;					  end;					 IF (M_found[1]) then					 begin					 for indx := 1 to maxc-1 do					   begin						 spinCursor;					 IF (NOT M_found[2]) AND						(NOT index_used[indx]) AND						(max_val[M1_index] > max_val[indx]) AND					 	(eV_Line[66] >= (En_chan[indx] - dff)) AND 						(eV_Line[66] <= (En_chan[indx] + dff)) THEN	{ M_gamma }						begin						  M_found[2] := true;						  line_count[index] := line_count[index] +1;						  Temp[index1,indx] := Possible_Peaks[index1,maxc];						  Temp_x[index1,indx] := Nm_Line[66];						  index_used[indx] := true;						end					 ELSE IF (NOT M_found[3]) AND						(NOT index_used[indx]) AND						(max_val[M1_index] > max_val[indx]) AND					 	(eV_Line[74] >= (En_chan[indx] - dff)) AND 						(eV_Line[74] <= (En_chan[indx] + dff)) THEN	{ M_zeta }						begin						  M_found[3] := true;						  line_count[index] := line_count[index] +1;						  Temp[index1,indx] := Possible_Peaks[index1,maxc];						  Temp_x[index1,indx] := Nm_Line[74];						  index_used[indx] := true;						end				 	ELSE IF (NOT M_found[4]) AND						(NOT index_used[indx]) AND						(max_val[M1_index] > max_val[indx]) AND						(eV_Line[57] >= (En_chan[indx] - dff)) AND 						(eV_Line[57] <= (En_chan[indx] + dff)) THEN	{ M_2N4 }						begin						  M_found[4] := true;						  line_count[index] := line_count[index] +1;						  Temp[index1,indx] := Possible_Peaks[index1,maxc];						  Temp_x[index1,indx] := Nm_Line[57];						  index_used[indx] := true;						end					 ELSE IF (NOT M_found[5]) AND						(NOT index_used[indx]) AND						(max_val[M1_index] > max_val[indx]) AND					 	(Possible_Peaks[index1,maxc] > 80) AND					 	(eV_Line[69] >= (En_chan[indx] - dff)) AND 						(eV_Line[69] <= (En_chan[indx] + dff)) THEN	{ M_beta }						begin						  M_found[5] := true;						  line_count[index] := line_count[index] +1;						  Temp[index1,indx] := Possible_Peaks[index1,maxc];						  Temp_x[index1,indx] := Nm_Line[69];						  index_used[indx] := true;						end				 	ELSE IF (NOT M_found[6]) AND						(NOT index_used[indx]) AND						(max_val[M1_index] > max_val[indx]) AND						(eV_Line[61] >= (En_chan[indx] - dff)) AND 						(eV_Line[61] <= (En_chan[indx] + dff)) THEN	{ M_3N1 }						begin						  M_found[6] := true;						  line_count[index] := line_count[index] +1;						  Temp[index1,indx] := Possible_Peaks[index1,maxc];						  Temp_x[index1,indx] := Nm_Line[61];						  index_used[indx] := true;						end				 	ELSE IF (NOT M_found[7]) AND						(NOT index_used[indx]) AND						(Possible_Peaks[index1,maxc] > 82) AND						(max_val[M1_index] > max_val[indx]) AND						(eV_Line[56] >= (En_chan[indx] - dff)) AND 						(eV_Line[56] <= (En_chan[indx] + dff)) THEN	{ M2N1 }						begin						  M_found[7] := true;						  line_count[index] := line_count[index] +1;						  Temp[index1,indx] := Possible_Peaks[index1,maxc];						  Temp_x[index1,indx] := Nm_Line[56];						  index_used[indx] := true;						end;					   end;					  end;					 end;	{ if (Possible_Peaks[index1,maxc] > 56) }				 end;	{ if (Possible_Peaks[index1,maxc] > 1) }				 				 if ((Plt_spec[10]^^.Expt_Info.kV > (1.2 * A^.edge[1] / 1000.0)) AND				 	(eV_Line[1] < Spec_Limit) AND (not K_found[1])) then					  begin					    line_count[index] := 0;						for indx := 1 to num_rgns do						  begin							Temp[index1,indx] := 0;							Temp_x[index1,indx] := '     ';						  end;					  end				 else if (Possible_Peaks[index1,maxc] > 56) AND				 	(NOT M_found[1]) THEN				   begin	  				    line_count[index] := 0;					for indx := 1 to num_rgns do					  begin						Temp[index1,indx] := 0;						Temp_x[index1,indx] := '     ';					  end;				   end;			  if (line_count[index] > num_of_pks) then			    begin				  num_of_pks := line_count[index];				  selected_elem := Possible_Peaks[index1,maxc];				  r_count := 4;				end;					 IF ((r_count = 1) AND (selected_elem = 0) AND (index1 = 5)) then					 	Possible_Peaks[index1,maxc] := Possible_Peaks[index1,maxc] + 1;					 IF ((r_count = 2) AND (selected_elem = 0) AND (index1 = 5)) then					 	Possible_Peaks[index1,maxc] := Possible_Peaks[index1,maxc] - 2;				UNTIL (r_count >= 3);			 end;	{ for index1 := 5 to 8 do }	END;	{ Procedure Select_L }	Procedure Select_M(maxc : integer; VAR selected_elem, num_of_pks : longint {integer});		{*** if the main peak is a M-alpha check for other peaks from same element ***}		{ this will return one element from the possible M-alpha peaks }	VAR		index, index1, indx		: integer;		line_count				: array [1..4] of integer;		K_found					: array [1..8] of boolean;		L_found					: array [1..8] of boolean;		M_found					: array [1..8] of boolean;		{index_used				: array [1..MaxLabels] of boolean;}	    dff                     : real; 		K1_index				: integer;		L1_index				: integer;		r_count					: integer;			BEGIN	    dff := search_Range;		{for index := 1 to MaxLabels do			index_used[index] := false;}		line_count[1] := 0;		line_count[2] := 0;		line_count[3] := 0;		line_count[4] := 0;		num_of_pks := 0;		selected_elem := 0;		K1_index := 0;		L1_index := 0;		for index1 := 9 to 12 do		{ Start checking M lines }			begin				r_count := 0;			REPEAT				r_count := r_count + 1;			  index := index1 - 8;			  if (Possible_Peaks[index1,maxc] > 1) then		{ found a M line }			    begin					for indx := 1 to 8 do					 begin					    K_found[indx] := false;						L_found[indx] := false;						M_found[indx] := false;					 end;				  spinCursor;				  Get_Energies(Possible_Peaks[index1,maxc]);				  M_found[1] := true;				  line_count[index] := line_count[index] +1;				  Temp[index1,maxc] := Possible_Peaks[index1,maxc];				  Temp_x[index1,maxc] := Nm_Line[72];				  index_used[maxc] := true; 				 for indx := 1 to num_rgns do				   begin				     spinCursor;					 IF (En_chan[indx] > 40000.0) then dff := search_Range + 80 else					 if (En_chan[indx] > 10000.0) then dff := search_Range + 60 else				     IF (En_chan[indx] > 5000.0) then dff := search_Range + 40 else					                      dff := search_Range;					 IF (NOT M_found[2]) AND						(NOT index_used[indx]) AND						(max_val[maxc] > max_val[indx]) AND					 	(eV_Line[66] >= (En_chan[indx] - dff)) AND 						(eV_Line[66] <= (En_chan[indx] + dff)) THEN	{ M_gamma }						begin						  M_found[2] := true;						  line_count[index] := line_count[index] +1;						  Temp[index1,indx] := Possible_Peaks[index1,maxc];						  Temp_x[index1,indx] := Nm_Line[66];						  index_used[indx] := true;						end					 ELSE IF (NOT M_found[3]) AND						(NOT index_used[indx]) AND						(max_val[maxc] > max_val[indx]) AND					 	(eV_Line[74] >= (En_chan[indx] - dff)) AND 						(eV_Line[74] <= (En_chan[indx] + dff)) THEN	{ M_zeta }						begin						  M_found[3] := true;						  line_count[index] := line_count[index] +1;						  Temp[index1,indx] := Possible_Peaks[index1,maxc];						  Temp_x[index1,indx] := Nm_Line[74];						  index_used[indx] := true;						end				 	ELSE IF (NOT M_found[4]) AND						(NOT index_used[indx]) AND						(max_val[maxc] > max_val[indx]) AND						(eV_Line[57] >= (En_chan[indx] - dff)) AND 						(eV_Line[57] <= (En_chan[indx] + dff)) THEN	{ M_2N4 }						begin						  M_found[4] := true;						  line_count[index] := line_count[index] +1;						  Temp[index1,indx] := Possible_Peaks[index1,maxc];						  Temp_x[index1,indx] := Nm_Line[57];						  index_used[indx] := true;						end					 ELSE IF (NOT M_found[5]) AND						(NOT index_used[indx]) AND						(max_val[maxc] > max_val[indx]) AND					 	(Possible_Peaks[index1,maxc] > 81) AND					 	(eV_Line[69] >= (En_chan[indx] - dff)) AND 						(eV_Line[69] <= (En_chan[indx] + dff)) THEN	{ M_beta }						begin						  M_found[5] := true;						  line_count[index] := line_count[index] +1;						  Temp[index1,indx] := Possible_Peaks[index1,maxc];						  Temp_x[index1,indx] := Nm_Line[69];						  index_used[indx] := true;						end				 	ELSE IF (NOT M_found[6]) AND						(NOT index_used[indx]) AND						(max_val[maxc] > max_val[indx]) AND						(eV_Line[61] >= (En_chan[indx] - dff)) AND 						(eV_Line[61] <= (En_chan[indx] + dff)) THEN	{ M_3N1 }						begin						  M_found[6] := true;						  line_count[index] := line_count[index] +1;						  Temp[index1,indx] := Possible_Peaks[index1,maxc];						  Temp_x[index1,indx] := Nm_Line[61];						  index_used[indx] := true;						end				 	ELSE IF (NOT M_found[7]) AND						(NOT index_used[indx]) AND						(Possible_Peaks[index1,maxc] > 82) AND						(max_val[maxc] > max_val[indx]) AND						(eV_Line[56] >= (En_chan[indx] - dff)) AND 						(eV_Line[56] <= (En_chan[indx] + dff)) THEN	{ M2N1 }						begin						  M_found[7] := true;						  line_count[index] := line_count[index] +1;						  Temp[index1,indx] := Possible_Peaks[index1,maxc];						  Temp_x[index1,indx] := Nm_Line[56];						  index_used[indx] := true;						end;				   end;				 if (Possible_Peaks[index1,maxc] > 24) then begin				 if (Plt_spec[10]^^.Expt_Info.kV > (A^.edge[4] / 1000.0)) then				 for indx := maxc + 1 to num_rgns do				   begin				     spinCursor;					 IF (NOT L_found[1]) AND						(NOT index_used[indx]) AND						(eV_Line[42] >= (En_chan[indx] - dff)) AND 						(eV_Line[42] <= (En_chan[indx] + dff)) THEN	{ L_alpha }				  		begin						  L_found[1] := true;						  line_count[index] := line_count[index] +1;						  Temp[index1,indx] := Possible_Peaks[index1,maxc];						  Temp_x[index1,indx] := Nm_Line[42];						  index_used[indx] := true;						  L1_index := indx;						end;				   end;				 if (L_found[1]) THEN	{ L_beta test }				 for indx := maxc + 1 to num_rgns do					   begin					   spinCursor;						 IF (NOT L_found[2]) AND						 	(NOT index_used[indx]) AND							(Possible_Peaks[index1,maxc] > 40) AND						 	(eV_Line[29] >= (En_chan[indx] - dff)) AND 							(eV_Line[29] <= (En_chan[indx] + dff)) AND							(max_val[L1_index] > max_val[indx]) AND				 			(Plt_spec[10]^^.Expt_Info.kV > (A^.edge[3] / 1000.0)) THEN	{ L_beta }							begin							  L_found[2] := true;							  line_count[index] := line_count[index] +1;							  Temp[index1,indx] := Possible_Peaks[index1,maxc];							  Temp_x[index1,indx] := Nm_Line[29];							  index_used[indx] := true;							end						 ELSE IF (NOT L_found[3]) AND						 	(NOT index_used[indx]) AND						 	(eV_Line[31] >= (En_chan[indx] - dff)) AND 							(eV_Line[31] <= (En_chan[indx] + dff)) AND							(max_val[L1_index] > max_val[indx]) AND				 			(Plt_spec[10]^^.Expt_Info.kV > (A^.edge[3] / 1000.0)) THEN	{ L_gamma }							begin							  L_found[3] := true;							  line_count[index] := line_count[index] +1;							  Temp[index1,indx] := Possible_Peaks[index1,maxc];							  Temp_x[index1,indx] := Nm_Line[31];							  index_used[indx] := true;							end						 ELSE IF (NOT L_found[4]) AND						 	(NOT index_used[indx]) AND						 	(eV_Line[49] >= (En_chan[indx] - dff)) AND 							(eV_Line[49] <= (En_chan[indx] + dff)) AND							(max_val[L1_index] > max_val[indx]) AND				 			(Plt_spec[10]^^.Expt_Info.kV > (A^.edge[4] / 1000.0)) THEN	{ L_L }							begin							  L_found[4] := true;							  line_count[index] := line_count[index] +1;							  Temp[index1,indx] := Possible_Peaks[index1,maxc];							  Temp_x[index1,indx] := Nm_Line[49];							  index_used[indx] := true;							end						 ELSE IF (NOT L_found[5]) AND						 	(NOT index_used[indx]) AND						 	(eV_Line[35] >= (En_chan[indx] - dff)) AND 							(eV_Line[35] <= (En_chan[indx] + dff)) AND							(max_val[L1_index] > max_val[indx]) AND				 			(Plt_spec[10]^^.Expt_Info.kV > (A^.edge[3] / 1000.0)) THEN	{ L_eta }							begin							  L_found[5] := true;							  line_count[index] := line_count[index] +1;							  Temp[index1,indx] := Possible_Peaks[index1,maxc];							  Temp_x[index1,indx] := Nm_Line[35];							  index_used[indx] := true;							end						 ELSE IF (NOT L_found[6]) AND						 	(NOT index_used[indx]) AND						 	(eV_Line[45] >= (En_chan[indx] - dff)) AND 							(eV_Line[45] <= (En_chan[indx] + dff)) AND							(max_val[L1_index] > max_val[indx]) AND				 			(Plt_spec[10]^^.Expt_Info.kV > (A^.edge[4] / 1000.0)) THEN	{ L_B2 }							begin							  L_found[6] := true;							  line_count[index] := line_count[index] +1;							  Temp[index1,indx] := Possible_Peaks[index1,maxc];							  Temp_x[index1,indx] := Nm_Line[45];							  index_used[indx] := true;							end						 ELSE IF (NOT L_found[7]) AND						 	(NOT index_used[indx]) AND						 	(eV_Line[18] >= (En_chan[indx] - dff)) AND 							(eV_Line[18] <= (En_chan[indx] + dff)) AND							(max_val[L1_index] > max_val[indx]) AND				 			(Plt_spec[10]^^.Expt_Info.kV > (A^.edge[2] / 1000.0)) THEN	{ L_G3 }							begin							  L_found[7] := true;							  line_count[index] := line_count[index] +1;							  Temp[index1,indx] := Possible_Peaks[index1,maxc];							  Temp_x[index1,indx] := Nm_Line[18];							  index_used[indx] := true;							end						 ELSE IF (NOT L_found[8]) AND						 	(NOT index_used[indx]) AND						 	(eV_Line[46] >= (En_chan[indx] - dff)) AND 							(eV_Line[46] <= (En_chan[indx] + dff)) AND							(max_val[L1_index] > max_val[indx]) AND				 			(Plt_spec[10]^^.Expt_Info.kV > (A^.edge[4] / 1000.0)) THEN	{ L_B5 }							begin							  L_found[8] := true;							  line_count[index] := line_count[index] +1;							  Temp[index1,indx] := Possible_Peaks[index1,maxc];							  Temp_x[index1,indx] := Nm_Line[46];							  index_used[indx] := true;							end;						 end;					   end;				  if (Plt_spec[10]^^.Expt_Info.kV > (A^.edge[1] / 1000.0)) then				   begin					 for indx := maxc+1 to num_rgns do						   begin							 (*IF (En_chan[indx] > 40000.0) then dff := search_Range + 80 else							 if (En_chan[indx] > 10000.0) then dff := search_Range + 60 else							 IF (En_chan[indx] > 5000.0) then dff := search_Range + 40 else												  dff := search_Range;	*)						   	 spinCursor;							 IF (NOT index_used[indx]) AND							 	(eV_Line[1] >= (En_chan[indx] - dff)) AND 								(eV_Line[1] <= (En_chan[indx] + dff)) THEN	{ K_alpha }								begin								  K_found[1] := true;								  line_count[index] := line_count[index] +1;								  Temp[index1,indx] := Possible_Peaks[index1,maxc];								  Temp_x[index1,indx] := Nm_Line[1];								  index_used[indx] := true;								  K1_index := indx;								end;							end;							IF (K_found[1]) THEN 							for indx := maxc + 1 to num_rgns do							BEGIN						   	 spinCursor;							 IF (NOT K_found[2]) AND						 		(NOT index_used[indx]) AND							 	(eV_Line[3] >= (En_chan[indx] - dff)) AND 								(eV_Line[3] <= (En_chan[indx] + dff)) AND								(Possible_Peaks[index1,maxc] > 15) AND								(max_val[K1_index] > max_val[indx]) THEN	{ K_beta1 }								begin								  K_found[2] := true;								  line_count[index] := line_count[index] +1;								  Temp[index1,indx] := Possible_Peaks[index1,maxc];								  Temp_x[index1,indx] := Nm_Line[3];								  index_used[indx] := true;								end;							  if (Possible_Peaks[index1,maxc] > 55) then begin								 IF (NOT K_found[3]) AND						 			(NOT index_used[indx]) AND									(eV_Line[2] >= (En_chan[indx] - dff)) AND 									(eV_Line[2] <= (En_chan[indx] + dff)) (*AND									(max_val[K1_index] > max_val[indx])*)  THEN	{ K_alpha2 separated from K_alpha1 }									begin									  K_found[3] := true;									  line_count[index] := line_count[index] +1;									  Temp[index1,indx] := Possible_Peaks[index1,maxc];									  Temp_x[index1,indx] := Nm_Line[2];									  index_used[indx] := true;									end;								(* else IF (NOT K_found[4]) AND						 			(NOT index_used[indx]) AND									(eV_KB2 >= (En_chan[indx] - dff)) AND 									(eV_KB2 <= (En_chan[indx] + dff)) AND									(max_val[K1_index] > max_val[indx])  THEN	{ K_beta2 separated from K_beta1 }									begin									  K_found[4] := true;									  line_count[index] := line_count[index] +1;									  Temp[index1,indx] := Possible_Peaks[index1,maxc];									  Temp_x[index1,indx] := 'KB2';									  index_used[indx] := true;									end								 else IF (NOT K_found[5]) AND						 			(NOT index_used[indx]) AND									(eV_KB3 >= (En_chan[indx] - dff)) AND 									(eV_KB3 <= (En_chan[indx] + dff)) AND									(max_val[K1_index] > max_val[indx])  THEN	{ K_beta3 separated from K_beta1 }									begin									  K_found[5] := true;									  line_count[index] := line_count[index] +1;									  Temp[index1,indx] := Possible_Peaks[index1,maxc];									  Temp_x[index1,indx] := 'KB3';									  index_used[indx] := true;									end								 else IF (NOT K_found[6]) AND						 			(NOT index_used[indx]) AND									(eV_KB4 >= (En_chan[indx] - dff)) AND 									(eV_KB4 <= (En_chan[indx] + dff)) AND									(max_val[K1_index] > max_val[indx])  THEN	{ K_beta4 separated from K_beta1 }									begin									  K_found[6] := true;									  line_count[index] := line_count[index] +1;									  Temp[index1,indx] := Possible_Peaks[index1,maxc];									  Temp_x[index1,indx] := 'KB4';									  index_used[indx] := true;									end								 else IF (NOT K_found[7]) AND						 			(NOT index_used[indx]) AND									(eV_KB5 >= (En_chan[indx] - dff)) AND 									(eV_KB5 <= (En_chan[indx] + dff)) AND									(max_val[K1_index] > max_val[indx])  THEN	{ K_beta5 separated from K_beta1 }									begin									  K_found[7] := true;									  line_count[index] := line_count[index] +1;									  Temp[index1,indx] := Possible_Peaks[index1,maxc];									  Temp_x[index1,indx] := 'KB5';									  index_used[indx] := true;									end;*)								end;							 END;				   end;	 { if (Plt_spec[10]^^.Expt_Info.kV > (A^.edge[1] / 1000.0)) }				end;	{ if (Possible_Peaks[index1,maxc] > 1) }			  if (Plt_spec[10]^^.Expt_Info.kV > (1.2 * A^.edge[4] / 1000.0)) AND			  	 (eV_Line[42] < Spec_Limit) AND			  	 (NOT L_found[1]) then				  begin				    line_count[index] := 0;					for indx := 1 to num_rgns do					  begin						Temp[index1,indx] := 0;						Temp_x[index1,indx] := '     ';					  end;				  end;			  if (line_count[index] > num_of_pks) then			    begin				  num_of_pks := line_count[index];				  selected_elem := Possible_Peaks[index1,maxc];				  r_count := 4;				end;					 IF ((r_count = 1) AND (selected_elem = 0) AND (index1 = 9)) then					 	Possible_Peaks[index1,maxc] := Possible_Peaks[index1,maxc] + 1;					 IF ((r_count = 2) AND (selected_elem = 0) AND (index1 = 9)) then					 	Possible_Peaks[index1,maxc] := Possible_Peaks[index1,maxc] - 2;				UNTIL (r_count >= 3);			 end;	{ for index1 := 9 to 12 do }	END;	{ Procedure Select_M }{$S QUAL3}	Procedure Sort_Elements;		{*** select an element for each peak ***}	VAR		index, index1, indx, maxc		: integer;		selected_element, num_of_pks	: array [1..3] of integer;		the_element_pk, the_element, free_pks		: integer;		old_free_pks			: integer;		diff				: real;		sel_el, nu_pk		: longint {integer};	BEGIN	    		for index := 1 to MaxLabels do		  begin			Assigned_Peaks[index] := 0;			Assigned_lines[index] := '     ';			for indx := 1 to 12 do			 begin			  Temp[indx,index] := 0;			  Temp_x[indx,index] := '     ';			 end;		  end;				free_pks := num_rgns;		old_free_pks := num_rgns;		for index := 1 to 3 do		  begin			selected_element[index] := 0;			num_of_pks[index] := 0;		  end;				REPEAT		maxc := mx_pk(max_val,num_rgns);		IF maxc > 0 then begin		Select_K(maxc, sel_el, nu_pk);		selected_element[1] := sel_el;		num_of_pks[1] := nu_pk;		Select_L(maxc, sel_el, nu_pk);		selected_element[2] := sel_el;		num_of_pks[2] := nu_pk;		Select_M(maxc, sel_el, nu_pk);		selected_element[3] := sel_el;		num_of_pks[3] := nu_pk;		the_element_pk := 0;		for index := 1 to 3 do		  begin		    if (num_of_pks[index] > the_element_pk) then			  begin			    the_element_pk := num_of_pks[index];				the_element := selected_element[index];			  end;		  end;		free_pks := free_pks - the_element_pk;		if (free_pks = old_free_pks) then		  begin			  if En_chan[maxc] > 50000.0 then				diff := search_Range + 40.0			  else if En_chan[maxc] > 40000.0 then				diff := search_Range + 30.0			  else if En_chan[maxc] > 20000.0 then				diff := search_Range + 20.0			  else if En_chan[maxc] > 5000.0 then				diff := search_Range + 10.0			  else				diff := search_Range;			{the_element := 0;}			index1 := 3;			REPEAT				spinCursor;				Get_Energies(index1);			  	IF ((A^.edge[1] / 1000.0) < Plt_spec[10]^^.Expt_Info.kV) AND             	 (eV_Line[1] >= (En_chan[maxc] - diff)) AND 			     (eV_Line[1] <= (En_chan[maxc] + diff)) THEN                BEGIN					the_element := index1;					Temp[1,maxc] := the_element;					Temp_x[1,maxc] := Nm_Line[1];					free_pks := free_pks -1;				END;				index1 := index1 + 1;			UNTIL ((index1 > 95) OR (old_free_pks > free_pks));		  end;			if (free_pks = old_free_pks) then			  begin				Assigned_Peaks[maxc] := 1;				free_pks := free_pks -1;			  end;		for index := 1 to num_rgns do		  begin		    for indx := 1 to 12 do			  begin			    spinCursor;		        if (Temp[indx,index] = the_element) then				  begin				   if (Assigned_Peaks[index] <= 1) then				    begin					 Assigned_Peaks[index] := the_element;					 Assigned_lines[index] := Temp_x[indx,index];					end;				  end;			  end;		  end;		old_free_pks := free_pks;		end;	{IF maxc > 0}	  UNTIL free_pks <= 0;	 	END;		{ Procedure Sort_Elements; }		Procedure WriteQualResults(Final_File : integer);		  VAR	  	i, indx	: integer;				BEGIN		 		 if (First_File = 1) then		  begin		  	  write(Spread,Col_Label[0]);			  for i := 1 to label_count do				write(Spread, chr(9), Col_Label[i]);			  write(Spread, chr(13));		  end;		  for indx := First_File to Final_File {Spectrum_Counter} do		    begin			  write(Spread,Qualrecptr[indx]^.Spec_Nam);			  for i := 1 to label_count do				write(Spread, chr(9), Qualrecptr[indx]^.Peak_Max[i]);			  write(Spread, chr(13));			  DisposePtr(Ptr(Qualrecptr[indx]));			  Qualrecptr[indx] := NIL;			end;		END;		{WriteQualResults}		   Procedure Main_Qual(Initial_File : integer);   	VAR		i, Sp_Cnt		: integer;      BEGIN   	  spinCursor;	  	if Qual_DTSA_True = false then begin		  Sp_Cnt := Spectrum_Counter - Initial_File +1;		  if Sp_Cnt > Max_Spec then begin		  	putmessage('The number of spectra exceeds 100.',' This run will stop and print the results. ',						'You may restart with spectrum 101. ','Be sure to give the Excel file a different name.');			  Sp_Cnt := Sp_Cnt -1;			  Qual_Incomplete := True;			  exit(Main_Qual);					  end;	    end;		      Do_it_in_the_Dark := true;	  D_BG_Correct;					{ do the background to get the statistics }	  Do_it_in_the_Dark := false;	{Col_1^ now has the BG }	  Num_Chans := Plt_Spec[10]^^.Expt_Info.number_of_channels;	  Spec_Limit := Num_Chans * Plt_spec[10]^^.Expt_Info.dE;      FOR i := 1 TO Maximum_Channels DO          BEGIN            Col_2^[i] := 0.0;            Col_3^[i] := 0.0;			spinCursor;			Plt_spec[7]^^.s[i] := 0.0;    	  END;	  Smooth_Spectrum(Plt_Spec[10]^^.S, Plt_Spec[7]^^.S, 5 );	  BlockMove(@Plt_Spec[7]^^.S,@Col_2^,SizeOf(Plt_Spec[7]^^.S)); {Put the smoothed spectrum into the routine. double_t }	  UpDate_Max_Min(7);	  Deriv2;		{Col_3^ contains the filtered spectrum}	  if num_rgns > MaxLabels then begin		putmessage('Found too many regions.','','','');		Halt_Qual := true;		Qual_Incomplete := True;		exit(Main_Qual);	  		  end;	  Label_Counter := 0;	  BlockMove(@Col_3^,@Plt_spec[8]^^.S,SizeOf(Plt_spec[8]^^.S));	 {FOR i := 1 TO Num_Chans DO Plt_spec[8]^^.s[i] := Col_3^[i];}	{ filtered spectrum into 8 }	  UpDate_Max_Min(8);	  if (num_rgns > 0) then begin	   for i := 1 to num_rgns do	     En_chan[i] := Max_chan[i] * Plt_spec[10]^^.Expt_Info.dE;		for i := 1 to MaxLabels do			index_used[i] := false;	     	     Find_element;	     Sort_Elements;	  end;	  ChangeCursor(ArrowC);	  (*Qual_display;*)	{ puts up the white window }	  	  if Qual_DTSA_True = true then	  		semi_Quant		else begin	   		Display_labels;		  (* Auto_Scale_Display := TRUE;		   SetControlValue(AutoScale_CtrlHandle, 1);*) {Set AutoScale checkbox to on value}		  		   Update_Full;						IF (Fit_Invisibly = true) then			 FormatQualResults(Initial_File);		 end;   END;		{ Procedure Main_Qual }END.		{ unit Qual_scan }