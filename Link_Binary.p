UNIT Link_binary_Plug;INTERFACEUSES	Types, QuickDraw, Memory, fp, StandardFile, GestaltEqu, Errors, Files,	ToolUtils, {PascalA4,} FilePlugIns;const		__procinfo : longint = $3F80;{$Main}PROCEDURE	ENTRYPOINT(message:Integer; VAR InPtr:IOPlugPtr; VAR theResult:OSerr);IMPLEMENTATION{$IFC NOT POWERPC}uses PascalA4;{$ENDC}TYPE	Ch_arr = array [1..4] of byte {char};	Ch_arrPtr = ^Ch_arr;PROCEDURE Link_binary(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);FORWARD;PROCEDURE DoAbout(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);FORWARD;PROCEDURE DoOpen(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);FORWARD;PROCEDURE DoWrite(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);FORWARD;(*PROCEDURE TCnvtMacReal(SPtrAry,DPtrAry:Ptr; NumSamples,BitsPSample:LONGINT);EXTERNAL;	PROCEDURE VAX_TCnvtMacReal(SPtrAry,DPtrAry:Ptr; NumSamples,BitsPSample:LONGINT);EXTERNAL;PROCEDURE VAX_TCnvtMacInt(SPtrAry,DPtrAry:Ptr; NumSamples,BitsPSample:LONGINT);EXTERNAL;*)PROCEDURE 	ENTRYPOINT{(message:Integer; VAR InPtr:IOPlugPtr; VAR theResult:OSErr)};		{ Main dispatching routine.  Initializes and sets up the global variables,	}		{		and performs the operation specified by the message. 				}		VAR	firstTime	: BOOLEAN;	OldA4		: Longint;BEGIN{$IFC NOT POWERPC}	oldA4 := SetCurrentA4();	RememberA4();{$ENDC}	theResult:=noErr;	firstTime:=(InPtr=NIL);					{ See if this is the first time called }	IF firstTime THEN BEGIN						{ If so, allocate and initialize a data area }		InPtr:= IOPlugPtr(NewPtrClear(sizeof(IOPlug)));		IF (InPtr=NIL) THEN BEGIN			debugstr('memFullErr');			theResult:=memFullErr;{$IFC NOT POWERPC}	oldA4 := SetA4(oldA4);{$ENDC}			EXIT(ENTRYPOINT);		END;				END;		CASE message OF					{ Perform the requested operation }		fileAbout		:DoAbout(InPtr, theResult);		ImpFile			:Link_binary(InPtr, theResult);		ExpFile			:DoWrite(InPtr, theResult);		OpenInPlug		:DoOpen(InPtr, theResult);		OpenExPlug		:DoOpen(InPtr, theResult);		END; {CASE message}		{$IFC NOT POWERPC}	oldA4 := SetA4(oldA4);{$ENDC}END;PROCEDURE DoAbout(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);	Begin	End;	PROCEDURE DoOpen(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);	Begin		InPtr^.PlugInName:='Link binary';		{Debugstr('Inside of Link_binary - Do Open');}		theResult := noErr;	End;	PROCEDURE DoWrite(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);	Begin	End;	PROCEDURE SWBYTE(VAR value	: integer);   VAR	temp1, temp2	: integer;		BEGIN		temp1 := LoWrd(BSL{BitShift}(value, 8));		temp2 := LoWrd(BSR{BitShift}(value, {-}8));		value := BOR{BitOR}(temp1, temp2);		{value := BitAND(value, $0000FFFF);}	END;	PROCEDURE SWWORD(VAR wvalue	: longint);   VAR   	temp1, temp2			: integer;   	l_temp, temp1x			: longint;   	   BEGIN   	temp1 := HiWrd(wvalue);   	temp2 := LoWrd(wvalue);   	SWBYTE(temp1);   	SWBYTE(temp2);   	l_temp := BSL{BitShift}(temp2, 16);   	temp1x := temp1;   	temp1x := BAND{BitAND}(temp1x, $0000FFFF);   	wvalue := BOR{BitOR}(l_temp, temp1x);   END;{PROCEDURE SWREAL(val_addr : ptr; VAR rvalue	: real);}Function bytes_to_realNumber(by_in : Ch_arrPtr) : real;type	by_arr	=	Ch_arr;VAR	by_ptr	: ^by_arr;	rl_out	: real;	begin	by_ptr := @rl_out;	by_ptr^[4] := by_in^[1];	by_ptr^[3] := by_in^[2];	by_ptr^[2] := by_in^[3];	by_ptr^[1] := by_in^[4] - 1;		bytes_to_realNumber := rl_out;end;   Function bytes_to_realNumber_NS(by_in : Ch_arrPtr) : real;{type	by_arr	=	Ch_arr;}VAR	{by_ptr	: ^by_arr;}	by_ptr	: Ch_arrPtr;	rl_out	: real;	begin	by_ptr := @rl_out;	by_ptr^[4] := by_in^[4];	by_ptr^[3] := by_in^[3];	by_ptr^[2] := by_in^[2];	by_ptr^[1] := by_in^[1] {- 1};		bytes_to_realNumber_NS := rl_out;end;PROCEDURE Link_binary(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);          CONST      UnSignedID                    = 0;      SignedID                      = 1;      UNDEid                        = 0;      EDSid                         = 1;      EELSid                        = 2;      AUGEid                        = 3;      CLSid                         = 4;      NUCLid                        = 5;      ESCAid                        = 6;    TYPE	  Data_Array                    = ARRAY [1..4096] OF longint;	  Data_TypePtr                  = ^Data_Array;	  TByte                         = PACKED ARRAY [1..1] OF byte;      LinkRecPtr                    = ^LinkRec;      LinkRec                       =        RECORD          MTYPE                         : integer;    { $D540 + spectrum type; 0=undefined, 1=xray, 2=EELS, 3=Auger, 4=CLS,                                                       5=Nuclear, 6=ESCA }          {Some spectra from csiro were $D680 + spectrum type }          MHDSIZE                       : integer;    { Number of words in header, normally 256 }          MHORDER                       : PACKED ARRAY [1..2] OF byte;{ Definition of channel contents: MSByte: 0 = unsigned, 1 = signed LSByte: bits used for value of one channel. Following are examples of full word value in decimal: 272=+-32K counts 16= +64K counts 288= +- 2 G counts, 32 bits big big  }          MCMIN                         : integer;    { The first channel of stored histogram data in this file corresponds to the                                                       data in this channel number as it appeared on the screen before packing and                                                       saving}          MCMAX                         : integer;    { The last channel of histogram data in this file}          MUNITS                        : PACKED ARRAY [1..4] OF char;          { 3 chars of the units for horiz axis and one byte of null terminator. eg "keV" }          GF                            : real;       { gain factor (channels per unit energy interval) such that the value Y of the                                                       }          { number of units corresponding to channel I is Y = (I-X0)/GF}          { ie еее eV/Channel ее typically GF= 57, 44.5, etc.}          X0                            : real;       { Exact channel number corresponding to zero units, ie real number being the                                                       еее exact channel number corresponding to zero units еее typically XO =                                                       19.4,19.7, etc }          MHISTLAB                      : PACKED ARRAY [1..34] OF char;          { Up to 32 chars of label + 2 bytes null terminator.If 1st byte is zero then a null label }          MEMSTATE                      : integer;    { State of memory from which data was recorded: 0=undefined, 1=ready, 2=busy,                                                       3=done, 4=overwritten}          ISCALE                        : integer;    { Scaling coefficient, normally zero for current spectra }          NSCALE                        : integer;    { Scaling coefficient. If ISCALE is zero then no scaling of data. Otherwise                                                       actual value of a channel is ISCALE*channel value stored/NSCALE }          QF                            : real;       { Quadratic term in calibration formula Y = [I(1+QF*I)-X0]/GF }          MDUMMY1                       : integer;    { Unused }          MDUMMY2                       : integer;    { Unused }          MDUMMY3                       : integer;    { Unused }          { ееее From here on type specific; for x-ray spectra  use: }          JLIVE                         : integer;    { LiveTime }          JREAL                         : integer;    { RealTime }          JLLIM                         : integer;    { Value of JLIVE at which analysis would stop }          JCPSH                         : integer;    { High order word of counts per second value }          JCPSL                         : integer;    { Low orderwword of counts per second value }          JLIVEP                        : integer;    { Preset Livetime }          JSTRBADD                      : integer;    { Flag to indicate if strobe events are with rest of spectrum: 0=store in                                                       header(only found in early format spectra). 1=store with histogram data.                                                       16=stobe in header as 16 bit unsigned integers. 32=strobe in header as 32                                                       bit integer }          JRTBAR                        : integer;    { length of ratemeter bar }          JDUMMY                        : ARRAY [1..84] OF integer; { Unused }          JSTROBE                       : ARRAY [1..128] OF integer; { 64 channels of strobe data if JSTRBADD=0.}          { Order is same as spectrum at time of acquisition.}        END;    VAR      indx, nn, jj, kk              : integer;      errCode                       : integer;      refnum                        : integer;      bytecount                     : longint;      indexL                        : longint;	  DataBits                      : longint;      strLength                     : TByte;      str, str1, str2, str3         : str255;      theWhere                      : Point;      theReply                      : SFReply;      finished                      : Boolean;	  IValue						: longint;	  RValue                        : real;	  LoByte                        : integer;      HiByte                        : integer;	  counter                       : integer;	  LinkPtr						: LinkRecPtr;	  ByteOrder                     : Boolean;	  MHORDER_temp                  : PACKED ARRAY [1..2] OF byte;	  sp_type						: integer;	  spectrm						: Data_Array;	  spectrw						: ARRAY [1..4096] OF integer;      BEGIN { еееее Link binary files via MSDOSCONVERT utility еееее}		refnum := InPtr^.Rd_Refnum;		{Debugstr('Inside of Link_binary');}		FOR nn := 1 TO 8192 DO		  InPtr^.Spec_cts[nn] := 0.0;			InPtr^.Specimen_Comment_Field := '';			InPtr^.dE := 10.0;			InPtr^.kV := 0.0;			InPtr^.Begin_Faraday := 1.0;			InPtr^.End_Faraday := 1.0;			InPtr^.FirstValue := 0.0;			InPtr^.EndValue := 0.0;			InPtr^.Real_Time := 0.0;			InPtr^.Live_Time := 0.0;			InPtr^.FirstChannel := 1;			InPtr^.Energy_Slope := 1.0;			InPtr^.Energy_Intercept := 0.0;			InPtr^.NDoffset := 0;			InPtr^.Spectrum_Type := 'EDS ';			InPtr^.Title_Comment_Field := '';			InPtr^.Owner := '';			InPtr^.D_Azimuth := 90.0;			InPtr^.D_Elevation := 40.0;			InPtr^.Mn_FWHM := 140.0;			InPtr^.X_Tilt := 0.0;			InPtr^.S_Thickness := 0.0;			         LinkPtr := LinkRecPtr(NewPtr(sizeof(LinkRec)));        bytecount := sizeof(LinkRec);			(*str := stringof('bytecount = ',bytecount);			Debugstr(str);*)        WITH LinkPtr^ DO          BEGIN            errCode := FSRead(refnum, bytecount, @MTYPE);			theResult := errCode;			sp_type := MTYPE;            LoByte := BAND{BitAND}(MTYPE, $00FF); { Mask off the MSByte and pick up the LSByte }            HiByte := BSR{BitShift}(MTYPE, {-}8); { Shift right 8 bits, pick up the MSByte and test for $D5}            IF HiByte = $D5 THEN              BEGIN                ByteOrder := true; {Motorola standard byte order}                sp_type := sp_type - $D540;                { Debugstr('Motorola standard byte order');}              END            ELSE              IF LoByte = $D5 THEN                BEGIN                  ByteOrder := false; {Intel/Vax byte order}                 { Debugstr('Intel/Vax byte order');}                END              ELSE                BEGIN                  IF HiByte = $D6 THEN begin { because of the csiro spectra carol brought back }                  sp_type := sp_type - $D680;				    {Debugstr('Motorola standard byte order - csiro');}                    ByteOrder := true;					end                  ELSE                    BEGIN                     (* PutMessage('Not an acceptable LINK format', '', '', '');*)					  theResult := badFileFormat;					  DisposePtr(Ptr(LinkPtr));                      exit(Link_binary);                    END;                END;            IF NOT ByteOrder THEN             	BEGIN            		SWBYTE(MTYPE);	{Vax_TcnvtMacInt(@MTYPE, @MTYPE, 5, 16);} {Byte swap on 1st 5 integers}            		SWBYTE(MHDSIZE);            		{SWBYTE(MHORDER);}            		MHORDER_temp[1] := MHORDER[1];            		MHORDER_temp[2] := MHORDER[2];            		MHORDER[1] := MHORDER_temp[2];            		MHORDER[2] := MHORDER_temp[1];            		SWBYTE(MCMIN);            		SWBYTE(MCMAX);            	            {IF NOT ByteOrder THEN Vax_TcnvtMacReal(@GF, @GF, 2, 32);} {FP convert on REALs}            		GF := bytes_to_realNumber(@GF);            		X0 := bytes_to_realNumber(@X0);            {IF NOT ByteOrder THEN Vax_TcnvtMacInt(@MEMSTATE, @MEMSTATE, 2, 16);} {Byte swap on next 2 integers}            		SWBYTE(MEMSTATE);            		SWBYTE(ISCALE);            {IF NOT ByteOrder THEN Vax_TcnvtMacReal(@QF, @QF, 1, 32);} {FP convert on REAL}            		QF := bytes_to_realNumber(@QF);            {IF NOT ByteOrder THEN Vax_TcnvtMacInt(@MDUMMY1, @MDUMMY1, (11 + 84 + 128), 16);} {Byte swap on 1st 5 integers}            		SWBYTE(JLIVE);            		SWBYTE(JREAL);            		sp_type := sp_type - $D540;				END;            CASE sp_type OF              UNDEid:                BEGIN                  {InPtr^.Spec  := 'UNDE';}                END;              EDSid:                BEGIN                  {Plt_spec[10]^^.Expt_Info.Detector.Spec := EDS;}				  InPtr^.Spectrum_Type := 'EDS ';				  {Debugstr('Spectrum type is x-ray $D681');}                END;              EELSid:                BEGIN                  {Plt_spec[10]^^.Expt_Info.Detector.Spec := EELS;}                END;              AUGEid:                BEGIN                  {Plt_Spec[10]^^.SpectrumStuff.Spectrum_Info.Spectrum_Type  := 'AUGE';}                END;              CLSid:                BEGIN                  {Plt_Spec[10]^^.SpectrumStuff.Spectrum_Info.Spectrum_Type  := 'CLS ';}                END;              NUCLid:                BEGIN                  {Plt_Spec[10]^^.SpectrumStuff.Spectrum_Info.Spectrum_Type  := 'NUCL';}                END;              ESCAid:                BEGIN                  {Plt_Spec[10]^^.SpectrumStuff.Spectrum_Info.Spectrum_Type  := 'ESCA';}                END;              END;            DataBits := MHORDER[2];            FOR counter := 1 TO 32 DO              IF MHISTLAB[counter] = '*' THEN MHISTLAB[counter] := ' ';            InPtr^.Specimen_Comment_Field := ' ';            FOR counter := 1 TO 32 DO              InPtr^.Specimen_Comment_Field[counter] := MHISTLAB[counter];            (*InPtr^.Specimen_Comment_Field := Strip_Trailing_Blanks(InPtr^.Specimen_Comment_Field);*)            InPtr^.Live_Time := JLIVE;            InPtr^.Real_Time := JREAL;			(*str := stringof('JLIVE = ',JLIVE);			Debugstr(str);			str := stringof('JREAL = ',JREAL);			Debugstr(str);			str := stringof('GF = ',GF);			Debugstr(str);			str := stringof('X0 = ',X0);			Debugstr(str);*)            RValue := 1000.0/GF;            InPtr^.NDoffset := rinttol((X0 * 10)/RValue);			            IF (GF > 1000) OR (GF < 0) THEN InPtr^.dE := 10.0            else InPtr^.dE := 20.0;            IF (X0 > 1000) OR (X0 < 0) THEN X0 := 10.0;                        			{Debugstr('At start of Spectrum');}            { еееее Now, pick up the spectrum }            MCMAX := MCMAX + 1;            MCMIN := MCMIN + 1;			(*str := stringof('MCMAX = ',MCMAX);			Debugstr(str);			str := stringof('MCMIN = ',MCMIN);			Debugstr(str);			str := stringof('MHDSIZE = ',MHDSIZE);			Debugstr(str);*)            errCode := SetFPos(refnum, fsFromstart, MHDSIZE * 2);            bytecount := (DataBits DIV 8) * (MCMAX - MCMIN + 1);			{str := stringof('bytecount = ',bytecount);			Debugstr(str);}			if (DataBits DIV 8) = 4 then            	errCode := FSRead(refnum, bytecount, @spectrm[MCMIN])            else if (DataBits DIV 8) = 2 then begin           		errCode := FSRead(refnum, bytecount, @spectrw[MCMIN]);           		FOR Indx := MCMIN TO MCMAX DO           			spectrm[Indx] := spectrw[Indx];           	END;                        FOR Indx := 1 TO (MCMAX - MCMIN + 1) DO begin            IF NOT ByteOrder THEN              BEGIN                {Vax_TcnvtMacReal(@InPtr^.Spec_cts[MCMIN], @InPtr^.Spec_cts[MCMIN], bytecount, DataBits);}                InPtr^.Spec_cts[Indx] := bytes_to_realNumber(@spectrm[Indx]);              END            ELSE              BEGIN                {TcnvtMacReal(@InPtr^.Spec_cts[MCMIN], @InPtr^.Spec_cts[MCMIN], bytecount, DataBits);}				{str := stringof('spectrm[Indx] = ',spectrm[Indx]);				Debugstr(str);}                InPtr^.Spec_cts[Indx] := spectrm[Indx] * 1.0;                {InPtr^.Spec_cts[Indx] := bytes_to_realNumber_NS(@spectrm[Indx]);}              END;            end;	{FOR Indx := 1 TO (MCMAX - MCMIN + 1)}            IF MHORDER[1] = UnSignedID THEN              BEGIN                FOR Indx := MCMIN TO MCMAX DO                  BEGIN                    IF Indx > 0 THEN                      IF spectrm[Indx] < 0 THEN InPtr^.Spec_cts[Indx] := spectrm[Indx] + (2 * 32767.0);                  END;              END;			FOR Indx := MCMIN TO MCMAX DO                  BEGIN                  	spectrm[Indx] := rinttol(InPtr^.Spec_cts[Indx]);                  END;                  			(*FOR Indx := 1 TO MCMAX DO begin				jj := indx - (rinttol(X0/2) + 1);				if jj > 0 then			  InPtr^.Spec_cts[jj {Indx}] := spectrm[Indx {+ rinttol(X0 / 2) + 1}];			 end;*)			{FOR Indx := MCMAX - (rinttol(X0) + 1) TO MCMAX DO			  InPtr^.Spec_cts[Indx] := 0.0;}			  counter := 512;		FOR Indx := 1 TO 5 DO BEGIN			IF MCMAX > counter then counter := counter * 2			ELSE			begin				InPtr^.Number_of_Channels := counter;				LEAVE;			end;		END;		InPtr^.LastChannel := InPtr^.Number_of_Channels;        DisposePtr(Ptr(LinkPtr));     END; { Link binary files via MSDOSCONVERT utility }  END;END.