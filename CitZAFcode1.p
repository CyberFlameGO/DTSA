unit CITZAFCode1;interface	uses  QuickDraw, Types, OSUtils, ToolUtils, Timer, Errors, Menus, Files, Finder, Lists, Memory,   Packages, Printing, StandardFile, PasLibIntf, fenv, fp {SANE}, SegLoad, Retrace,TextUtils,   CitInitialize, CITZAFCode,Spectrum_Structures, Declarations, INITIALIZE, Utilities,  Global_Functions; 	procedure MAIN_Handler;	procedure MAIN_Handler1;	implementation{$S CITZAFCode1}VAR    ZAF_vol                       : integer;    fndrInfo                      : FInfo;  	procedure MAIN_Handler;		var			i, IDummy                   : integer;            str1,str2,str3	     		: str255;			TempName                    : fnamestr;	begin     { ----------------------------------------------------------------------}{         -----          PRINTOUT OF HEADING & INITIAL DATA INPUT          -----}{         ----------------------------------------------------------------------}        If I_N < 1 then		begin		  PutMessage('There are no elements chosen to perform an analysis on','','','');		  Exit(MAIN_Handler);		end;		if Setup_File_Input then			begin			{	File_Name := 'datain';				Reset(TxtFile, File_Name); }			end		else			begin                TempName := 'DataFile';        { the user's choice replaces this }              if (CreateFile(TempName, 'Will Create -.DIN, -.ZAF') = true) OR (File_Cancel_Button = false) then;              IF (File_Cancel_Button = false) THEN exit(MAIN_Handler);                ZAF_vol := Out_VolRefNum;                errcode := getvol(Save_Volume_Name, save_vol);                IF errcode = NoErr THEN errcode := SetVol(NIL, ZAF_vol);                IF errcode = NoErr THEN                  BEGIN 			    				 					{str2 := CONCAT(TempName,'.RAW');}					str1 := CONCAT(TempName,'.DIN');					str3 := CONCAT(TempName,'.ZAF');												if not demo_DTSA then				begin				   Rewrite(Out_TxtFile1, str1);         { DIN }                    fndrInfo.fdcreator := 'MSWD';                    fndrInfo.fdtype := 'TEXT';                    fndrInfo.fdFlags := 0;                    errcode := setfinfo(str1, ZAF_vol, fndrInfo);				  { Rewrite(TxtFile1,     str2);}         { RAW }      				   Rewrite(Out_TxtFile,  str3);  		 { Main CITZAF Output }                    fndrInfo.fdcreator := 'MSWD';                    fndrInfo.fdtype := 'TEXT';                    fndrInfo.fdFlags := 0;                    errcode := setfinfo(str3, ZAF_vol, fndrInfo);				end;				END;	{IF errcode = NoErr}			end; 		writeln(Out_TxtFile, ' ------------------------------------------------------------------------------');		writeln(Out_TxtFile, ' -----  CITZAF1 V3.02 -- 15 Dec 88 -- J. Armstrong, Caltech, Geol. Dept.  -----');		writeln(Out_TxtFile, ' -----         Copyright, California Institute of Technology, 1988        -----');		writeln(Out_TxtFile, ' ------------------------------------------------------------------------------');		if Setup_File_Input then			Readln(TxtFile, IA, IB, IMAC)		else			begin			 if not demo_DTSA then writeln(Out_TxtFile1, IA : 4, IB : 4, IMAC : 4);			end;		if Setup_File_Input then			begin				if IRepro = 2 then					for I := 1 to 5 do						read(TxtFile, IDummy)				else					Readln(TxtFile, IBSC, IMIP, IPHI, IICS, IERE, IABS, ISTP, IBKS);			end;                  { if Setup_File_Input then... }		if not Setup_File_Input then if not demo_DTSA then writeln(Out_TxtFile1, IBSC : 4, IMIP : 4, IPHI : 4, IICS :4, IERE :4, IABS : 4, ISTP : 4, IBKS :4);		Heading;                  { PRINTOUT OF CORRECTIONS USED }		Type_of_Stored_Output;    { CHOICE OF OUTPUT FORMAT }		if Setup_File_Input then			Readln(TxtFile, Title)		else			if not demo_DTSA then writeln(Out_TxtFile1, 'CITZAF Output Title');		if IFirstRun = 1 then			begin				writeln(Out_TxtFile, Title);				writeln(Out_TxtFile);			end;		if Setup_File_Input then			begin				read(TxtFile, E0, T0);				read(TxtFile, I_N)			end		else			begin				if not demo_DTSA then writeln(Out_TxtFile1, E0 : 6 : 2, T0 : 6 : 2);				if not demo_DTSA then writeln(Out_TxtFile1, I_N : 4);			end;		if IFirstRun = 1 then			begin				writeln(Out_TxtFile, '   E0 = ', E0 : 6 : 1, ' KEV,    PSI = ', T0 : 6 : 1, ' DEGREES.');				writeln(Out_TxtFile);			end;		T := T0 * pi / 180.0;		T1 := 1 / SIN(T);        { -----  Elem. Z's, lines & grav. factors }		ICCAT := 0;		G^^.IPD[1] := IKEL;		G^^.IPD[2] := ICEL;		G^^.IPD[3] := ICOX;		G^^.IPD[4] := ICAT;		for I := 1 to I_N do      { 본본본본본 }			begin				if Setup_File_Input then					Readln(TxtFile, A^.IZ[I], G4^^.IL[I], A^.GR[I])				else					if not demo_DTSA then writeln(Out_TxtFile1, A^.IZ[I] : 4, G4^^.IL[I] : 4, A^.GR[I] : 6 : 2);				if G4^^.IL[I] < 0 then                { Determine if element is only in standard }					begin						G^^.IT[I] := 1;						G4^^.IL[I] := ABS(G4^^.IL[I]);					end;				if A^.GR[I] <> 0 then					ICCAT := 1;    { Determine whether to calculate atom proportions }				G^^.IVL[I] := rinttol(2 * A^.GR[I] + 0.01); { Valence of element }				G^^.ZZZ[I] := A^.IZ[I]			end;                    { of read in I_N elements loop }		writeln(Out_TxtFile);		if G4^^.IL[I_N] = 0 then			IN1 := I_N - 1		else			IN1 := I_N;        { Is last element to be calculated by gravimetry }		n := I_N;		N1 := IN1;		Load_Energies;		GetMACs;        { -----  CALC GRAVIMETRIC FACTORS }		for I := 1 to IN1 do			begin				G4^^.GR1[I] := A^.GR[I] * G4^^.B[I_N] / G4^^.B[I];			end;		STD_ZAF;		SETUP_Fluorescence;       { INITIALIZATION OF FLUORESCENCE CORRECTION FACTORS }		Which_Elements_Done;      { PRINTOUT OF ANALYZED ELEMENTS, VALENCES & LINES }		List_Element_Corrections; { PRINTOUT OF MAC's & ELEMENT CORRECTION FACTORS }        {-----            INITIALIZATION FOR SAMPLE DATA INPUT            -----}		if Setup_File_Input then			Readln(TxtFile, IM2, M3, ISTAGE)		else			if not demo_DTSA then writeln(Out_TxtFile1, IM2 : 4, M3 : 4 : 1, ISTAGE : 4);        { IM2 Code # for printout in % or ppm }        { M3 if greater than zero it is the deadtime in microseconds }        { ISTAGE Code number for reading and writing the stage coordinates }{if not demo_DTSA then begin PLFlush(Out_TxtFile1);  PLFlush(Out_TxtFile); end;}	end;                        { Procedure MAIN_Handler }	procedure MAIN_Handler1;		label			2300, 3300;		var			i: integer;			AnError: OSErr;            str : str255;			OrigK : Array[1..20] of real {double_t};			OrigTot  : real {double_t};			I7,I8    : Integer;	begin		if TimesThrough = 0 then			begin				AnError := FSOpen('datain', 0, i);				if anError = 0 then					begin					 {if not demo_DTSA then PLFlush(Out_TxtFile1);} 					if not demo_DTSA then Close(Out_TxtFile1);						TimesThrough := TimesThrough + 1;						numtostring(TimesThrough, str);						Current_File := CONCAT('Datain', str);					if not demo_DTSA then rewrite(Out_TxtFile1, Current_File);					end;			end		else			begin				AnError := FSOpen(Current_File, 0, i);				if anError = 0 then					begin                     {if not demo_DTSA then PLFlush(Out_TxtFile1);} 										if not demo_DTSA then Close(Out_TxtFile1);						TimesThrough := TimesThrough + 1;						numtostring(TimesThrough, str);						Current_File := CONCAT('Datain', str);					if not demo_DTSA then rewrite(Out_TxtFile1, Current_File);					end;			end;								INIT := 1;                { code # that element initialization is done }		ICPH := 1;                { initialization code for ? }		ICPH1 := 0;               { initialization code for ? }		ICPH2 := 0;               { initialization code for ? }        {[f-]}         {----------------------------------------------------------------------}         {-----             MAIN ROUTINE FOR SAMPLE DATA INPUT             -----}         {----------------------------------------------------------------------}{[f+]}2300:		N7 := 0;                  { This is a starting point of the loop that reads all input data }		if Setup_File_Input then			read(TxtFile, IN9)		else			if not demo_DTSA then Write(Out_TxtFile1, IN9 : 4); { code # for type of data to be input }		if (IN9 = 1) or (IN9 = 3) or (IN9 = 6) then			ICPH2 := 1;		case IN9 of               { This CASE IN9 OF portion gets the data }			1: 				begin                 { CODE 1: std conc. for calc. k-values }					N7 := 1;					if Setup_File_Input then						read(TxtFile, ID_Name)					else              { read the sample number }						if not demo_DTSA then Write(Out_TxtFile1, '    ', ID_Name);					for I := 1 to IN1 do						begin							if G^^.IT[I] <> 0 then								G4^^.K[I] := 0;							if G^^.IT[I] = 0 then								begin									if Setup_File_Input then										read(TxtFile, G4^^.K[I])									else										if not demo_DTSA then Write(Out_TxtFile1, G4^^.K[I] : 8 : 5);								end;							G4^^.KSMP[I] := G4^^.K[I];						end;              { FOR I := 1 TO IN1 }					if not Setup_File_Input then						if not demo_DTSA then Writeln(Out_TxtFile1, '');				end;                  { CASE 1 }			2: 				begin                 { CODE 2: k-values for stds or drift factors }					for I := 1 to IN1 do						if G^^.IT[I] = 0 then							begin								if Setup_File_Input then									read(TxtFile, G^^.U[I])								else									if not demo_DTSA then Write(Out_TxtFile1, G^^.U[I] : 8 : 5);							end;					if not Setup_File_Input then						if not demo_DTSA then Writeln(Out_TxtFile1, '');					exit(MAIN_Handler1);				end;                  { CASE 2 }			3: 				begin                 { CODE 3: k-values for smps }					if Setup_File_Input then						read(TxtFile, ID_Name)					else              { read the sample number }						if not demo_DTSA then Write(Out_TxtFile1, '    ', ID_Name);					for I := 1 to IN1 do						begin							if G^^.IT[I] = 0 then								begin									if Setup_File_Input then										read(TxtFile, G4^^.K[I])									else										if not demo_DTSA then Write(Out_TxtFile1, G4^^.K[I] : 8 : 5)								end							else								G4^^.K[I] := 0;							G4^^.K[I] := G4^^.K[I] * G^^.U[I];							G4^^.KSMP[I] := G4^^.K[I];							G4^^.K[I] := G4^^.KSMP[I] * G4^^.KSTD[I];						end;              { FOR I := 1 TO IN1 }          {IF (ISTAGE = 1)}{            THEN begin}{              if Setup_File_Input THEN read(TxtFile, XCoord, YCoord) else}{             write(Out_TxtFile1, XCoord:8:3, YCoord:8:3);}{			 end;}					if not Setup_File_Input then						if not demo_DTSA then writeln(Out_TxtFile1, '');				end;                  { CASE 3 }			4: 				begin                 { CODE 4: bkd's for stds & smps }					for I := 1 to IN1 do { bkd's for stds }						begin							if G^^.IT[I] = 0 then								begin									if Setup_File_Input then										read(TxtFile, G2^^.F[1, I])									else										if not demo_DTSA then Write(Out_TxtFile1, G2^^.F[1, I] : 15 : 5);									G2^^.F[1, I] := G2^^.F[1, I] / (1 - M3 * G2^^.F[1, I] * 0.000001); { dead time correction }								end;						end;              { FOR I := 1 TO IN1 }					if not Setup_File_Input then						if not demo_DTSA then Writeln(Out_TxtFile1, '');					exit(MAIN_Handler1);				end;                    { CASE 4 }			41: 				begin					for I := 1 to IN1 do { bkd's for smps }						begin							if G^^.IT[I] = 0 then								begin									if Setup_File_Input then										read(TxtFile, G2^^.F[2, I])									else										if not demo_DTSA then Write(Out_TxtFile1, G2^^.F[2, I] : 15 : 5);									G2^^.F[2, I] := G2^^.F[2, I] / (1 - M3 * G2^^.F[2, I] * 0.000001); { dead time correction }								end;						end;					if not Setup_File_Input then						if not demo_DTSA then Writeln(Out_TxtFile1, '');					exit(MAIN_Handler1);				end;                  { CASE 41 }			5: 				begin                 { CODE 5: peak intens. for stds }					for I := 1 to IN1 do						begin							if G^^.IT[I] = 0 then								begin									if Setup_File_Input then										read(TxtFile, G2^^.F[3, I])									else										if not demo_DTSA then Write(Out_TxtFile1, G2^^.F[3, I] : 15 : 5);									G2^^.F[3, I] := G2^^.F[3, I] / (1 - M3 * G2^^.F[3, I] * 0.000001) - G2^^.F[1, I];								end;						end;					if not Setup_File_Input then						if not demo_DTSA then Writeln(Out_TxtFile1, '');					exit(MAIN_Handler1);				end;                  { CASE 5 }			6: 				begin                 {CODE 6: peak intens. for smps}					if Setup_File_Input then						read(TxtFile, ID_Name)					else              { read the sample number }						if not demo_DTSA then Write(Out_TxtFile1, '    ', ID_Name);					for I := 1 to IN1 do						begin							if G^^.IT[I] = 1 then								G4^^.K[I] := 0							else								begin									if Setup_File_Input then										read(TxtFile, G2^^.F[4, I])									else										if not demo_DTSA then Write(Out_TxtFile1, G2^^.F[4, I] : 15 : 5);									G2^^.F[4, I] := G2^^.F[4, I] / (1 - M3 * G2^^.F[4, I] * 0.000001) - G2^^.F[2, I];									G4^^.K[I] := G2^^.F[4, I] / G2^^.F[3, I] * G^^.U[I];								end;							G4^^.KSMP[I] := G4^^.K[I];							G4^^.K[I] := G4^^.KSMP[I] * G4^^.KSTD[I];						end;              { FOR I := 1 TO IN1 }          {IF (ISTAGE = 1)}{            THEN begin}{              if Setup_File_Input THEN read(TxtFile, XCoord, YCoord) else}{             write(Out_TxtFile1, XCoord:8:3, YCoord:8:3);}{			 end;}					if not Setup_File_Input then						if not demo_DTSA then writeln(Out_TxtFile1, '');				end;                  { CASE 6 }			7: 				begin                 { CODE 7: # atoms for atom prop. calc'n. }					if Setup_File_Input then						read(TxtFile, Num_Oxs)					else						if not demo_DTSA then Write(Out_TxtFile1, Num_Oxs : 6 : 2);					if Num_Oxs = 0 then						begin							if Setup_File_Input then								read(TxtFile, NCAT)							else								if not demo_DTSA then Write(Out_TxtFile1, NCAT : 6 : 2);						end;					if not Setup_File_Input then						if not demo_DTSA then Writeln(Out_TxtFile1, '');					exit(MAIN_Handler1);				end;                  { CASE 7 }			8: 				begin                 { CODE 8: atom prop. for stds }					if Setup_File_Input then						read(TxtFile, IN8, ELEMSTD)					else						if not demo_DTSA then Write(Out_TxtFile1, IN8 : 6, '    ', chr(39), ELEMSTD, chr(39));					N7 := 1;					M4 := 0;					N8 := G^^.ZZZ[IN8];					ICPH := 1;					for I := 1 to I_N do						begin							if Setup_File_Input then								read(TxtFile, G4^^.K[I])							else								if not demo_DTSA then Write(Out_TxtFile1, G4^^.K[I] : 8 : 5);							G4^^.K[I] := G4^^.K[I] * G4^^.B[I];							M4 := M4 + G4^^.K[I];						end;              { FOR I := 1 TO I_N }					for I := 1 to I_N do						G4^^.K[I] := G4^^.K[I] / M4;					M4 := 1;					if not Setup_File_Input then						if not demo_DTSA then Writeln(Out_TxtFile1, '');				end;                  { CASE 8 }			9: 				begin                 { CODE 9: el. wt. frac. for stds }					if Setup_File_Input then						read(TxtFile, IN8, ELEMSTD)					else						if not demo_DTSA then Write(Out_TxtFile1, IN8 : 6, '    ', chr(39), ELEMSTD, chr(39));					N7 := 1;					M4 := 0;					N8 := G^^.ZZZ[IN8];					ICPH := 1;					for I := 1 to I_N do						begin							if Setup_File_Input then								read(TxtFile, G4^^.K[I])							else								if not demo_DTSA then Write(Out_TxtFile1, G4^^.K[I] : 8 : 5);							M4 := M4 + G4^^.K[I];						end;					if not Setup_File_Input then						if not demo_DTSA then Writeln(Out_TxtFile1, '');				end;                  { CASE 9 }			10: 				begin                 { CODE 10: ox. wt. frac. for stds }					if Setup_File_Input then						read(TxtFile, IN8, ELEMSTD)					else						if not demo_DTSA then Write(Out_TxtFile1, IN8 : 6, '    ', chr(39), ELEMSTD, chr(39));					N7 := 1;					M4 := 0;					G4^^.K[I_N] := 0;					N8 := G^^.ZZZ[IN8];					ICPH := 1;					for I := 1 to I_N do						begin							if Setup_File_Input then								read(TxtFile, G4^^.K[I])							else								if not demo_DTSA then Write(Out_TxtFile1, G4^^.K[I] : 8 : 5);							G4^^.K[I] := G4^^.K[I] / (1 + G4^^.GR1[I]);							G4^^.K[I_N] := G4^^.K[I_N] + G4^^.K[I] * G4^^.GR1[I];							M4 := M4 + G4^^.K[I];						end;					if not Setup_File_Input then						if not demo_DTSA then Writeln(Out_TxtFile1, '');					M4 := M4 + G4^^.K[I_N]				end;                  { CASE 10 }			11: 				begin                 { CODE 11: SWITCH DATA INPUT FILE }					if Setup_File_Input then						begin{Close(TxtFile);}							  { Reset(TxtFile, File_Name); }						end					else						begin							if not Setup_File_Input then								if not demo_DTSA then Writeln(Out_TxtFile1, '');							if not demo_DTSA then 							begin							{PLFlush(Out_TxtFile1);} 							 Close(Out_TxtFile1); 							end;						 	(*File_Name1 := 'RawData';					if not demo_DTSA then Rewrite(Out_TxtFile1, File_Name1);   *)						end;					All_Done_in_File := True;					exit(MAIN_Handler1);				end;                  { CASE 11 }			12: 				begin                 { End of Data, Close the Program }					if not Setup_File_Input then						if not demo_DTSA then Writeln(Out_TxtFile1, '');						All_Done_in_File := true;						sysbeep(10);						sysbeep(10);						sysbeep(10);						{if not demo_DTSA then PLFlush(Out_TxtFile1); 						if not demo_DTSA then PLFlush ( Out_TxtFile ); }					   						if not demo_DTSA then Close(Out_TxtFile); 						 						if not demo_DTSA then Close(Out_TxtFile1);						errcode := SetVol(Save_Volume_Name, save_vol); 					    All_Done_Folks := True;					exit(MAIN_Handler1);				end;                  { CASE 12 }							13:					begin                 { CODE 13: particle/thin film models }					if Setup_File_Input then						read(TxtFile, IMOD)					else						if not demo_DTSA then Write(Out_TxtFile1, IMOD : 5);					for I := 1 to IMOD do						begin									if Setup_File_Input then										read(TxtFile, IMD[I])									else										if not demo_DTSA then Write(Out_TxtFile1, IMD[I] : 5);						end;					if not Setup_File_Input then						if not demo_DTSA then Writeln(Out_TxtFile1, '');					exit(MAIN_Handler1);				end;                  { CASE 13 }															14:				begin                 { CODE 14: particle diameters or thin film thicknesses }					if Setup_File_Input then						read(TxtFile, IDIAM)					else						if not demo_DTSA then Write(Out_TxtFile1, IDIAM : 5);					for I := 1 to IDIAM do						begin									if Setup_File_Input then										read(TxtFile, DIA[I])									else										if not demo_DTSA then Write(Out_TxtFile1, DIA[I] : 10 : 2);						end;					if not Setup_File_Input then						if not demo_DTSA then Writeln(Out_TxtFile1, '');					exit(MAIN_Handler1);				end;                  { CASE 14 }											15:				begin                 { CODE 15: sample density in gm/cm^3 }					if Setup_File_Input then						read(TxtFile, pRHO)					else						if not demo_DTSA then Write(Out_TxtFile1, pRHO : 7 : 2);				end;                  { CASE 15 }							16:				begin                 { CODE 16: thickness to diameter ratio }					if Setup_File_Input then						read(TxtFile, J9)					else						if not demo_DTSA then Write(Out_TxtFile1, J9 : 7 : 2);				end;                  { CASE 16 }							17:				begin                 { CODE 17: numerical integration step size in g/cm^2 }					if Setup_File_Input then						read(TxtFile, X1)					else						if not demo_DTSA then Write(Out_TxtFile1, X1 : 10 : 6);				end;                  { CASE 17 }		end;                      { CASE IN9 OF }		if (IN9 < 1) or (IN9 > 17) then			begin				PutMessage(' The code number is not recognizable,', 'check your data file, type CR to exit', '', '');{Close(TxtFile);}				errcode := SetVol(Save_Volume_Name, save_vol);				exit(MAIN_Handler1);			end;                  { CASE ELSE }		case IN9 of               { This CASE IN9 OF portion makes 1st estimate of composition & normalizes.}			1, 3, 6: 				begin					M4 := 0;              {  IF IPRN > 0 AND ICPH := 1 THEN GOSUB 5700:     --- print compressed hdg }					ICPH := 0;					for I := 1 to IN1 do						begin							if G4^^.K[I] < 0 then								G4^^.K[I] := 0;							M4 := M4 + G4^^.K[I];						end;					if G4^^.IL[I_N] = 0 then						begin							G4^^.K[I_N] := 0;							for I := 1 to IN1 do								G4^^.K[I_N] := G4^^.K[I_N] + G4^^.K[I] * G4^^.GR1[I];							M4 := M4 + G4^^.K[I_N];							for I := 1 to IN1 do								begin									if G4^^.IL[I] = 6 then										begin											G4^^.K[I] := G4^^.K[I_N] / G4^^.GR1[I];											M4 := M4 + G4^^.K[I];										end;								end;						end;            { IF G4^^.IL[I_N] = 0 }					for I := 1 to I_N do						begin							if G4^^.IL[I] = 4 then								begin									G4^^.K[I] := 1 - M4;									M4 := 1;								end;						end;				end;                  { CASE 1,3,6 }			otherwise				NoOp := 0;		end;                      { CASE IN9 OF }        {[f-]}    {  ---------------------------------------------------------------------- }    {    -----              BEGIN ZAF CALCULATION FOR SAMPLE             -----}    {   ----------------------------------------------------------------------}{[f+]}            for I := 1 to I_N do                  begin                    OrigK[I] := G4^^.K[I];         { remember orig. data }                  end;            OrigTot := M4;       for I7 := 1 to IDIAM do         begin          IPtcD := I7;           for I8 := 1 to IMOD do            begin             IPtcM := I8;            for I := 1 to I_N do                  begin                        G4^^.K[I] := OrigK[I];                  end;                  M4 := OrigTot;		for I := 1 to I_N do			begin				G^^.C[I] := G4^^.K[I];         { concentration equals the K value }				if N7 = 0 then					G^^.C[I] := G^^.C[I] / M4;			end;		I5 := 1;                  { set iteration to one }3300:		SMP_ZAF;        {----- CALCULATION OF SMP ZAFCOR  }		if N7 < 0.9 then			begin				M4 := 0;				RCD := 0;			end;		for I := 1 to IN1 do			begin				if (G4^^.K[I] <= 0) or (G4^^.IL[I] > 3) then					ICHOICE := 0				else					ICHOICE := 1;				case ICHOICE of					1: 						begin							KNEW := G^^.C[I] / G3^^.A[I] * (1 + G^^.Fluor[I]) * G^^.W[I] / G^^.E[I];							if (KNEW = 1) or (G^^.C[I] = 1) then								ALPHA := 1							else								ALPHA := ((1 - KNEW) / KNEW) * G^^.C[I] / (1 - G^^.C[I]);							if N7 < 0.9 then								begin									G4^^.CNEW[I] := ALPHA * G4^^.K[I] / (1 + G4^^.K[I] * (ALPHA - 1));									M4 := M4 + G4^^.CNEW[I];								end;							if N7 = 1 then								begin									G4^^.K[I] := KNEW;									G4^^.KSMP[I] := G4^^.K[I] / G4^^.KSTD[I];								end;						end;              { CASE 1 }					0: 						begin							if G4^^.IL[I] = 5 then								G4^^.CNEW[I] := G4^^.K[I]							else								G4^^.CNEW[I] := 0;							if N7 < 0.9 then								M4 := M4 + G4^^.CNEW[I];						end;              { CASE 0 }				end;                  { CASE }			end;                    { FOR I := 1 TO IN1 }		if (N7 = 1) and (IN9 > 7) then			begin				I := IN8;				G4^^.KSTD[I] := G4^^.K[I];    { ----- assign std k-el value}				G4^^.STDZAF[I] := G^^.E[I] / G^^.W[I] * G3^^.A[I] / (1 + G^^.Fluor[I]);			end;        { -----  NORMALIZ. & CONVERGENCE TEST}		if N7 < 0.9 then			begin				if G4^^.IL[I_N] <> 0 then					ICHOICE := 1				else					ICHOICE := 0;				case ICHOICE of     { is there oxygen in the sample }					0: 						begin							G4^^.CNEW[I_N] := 0;							for I := 1 to IN1 do								G4^^.CNEW[I_N] := G4^^.CNEW[I_N] + G4^^.CNEW[I] * G4^^.GR1[I];							M4 := M4 + G4^^.CNEW[I_N];							for I := 1 to IN1 do								begin									if G4^^.IL[I] = 6 then										begin											G4^^.CNEW[I] := G4^^.CNEW[I_N] / G4^^.GR1[I];											M4 := M4 + G4^^.CNEW[I];											G4^^.K[I] := G4^^.CNEW[I];										end;								end;        { i loop }						end;            { case 0 }					otherwise						noOp := 0;				end;                { case }				for I := 1 to I_N do					begin						if G4^^.IL[I] = 4 then							begin								G4^^.CNEW[I] := 1 - M4;								M4 := 1;								G4^^.K[I] := G4^^.CNEW[I];							end;					end;              { FOR I := 1 TO I_N }				for I := 1 to I_N do					begin						G4^^.CNEW[I] := G4^^.CNEW[I] / M4;						if (G^^.C[I] > G4^^.CNEW[I] + 0.00005) or (G4^^.CNEW[I] > G^^.C[I] + 0.00005) then							RCD := 1;						G^^.C[I] := G4^^.CNEW[I];					end;              { i loop }				if (RCD > 0.5) and (I5 < 9.5) then					begin						I5 := I5 + 1;						goto 3300;    { next iteration }					end;				for I := 1 to I_N do					G^^.C[I] := G^^.C[I] * M4;			end;                  { IF N7 < 0.9 } { Analysis completed }		if IN9 < 8 then			Show_Smp_Result		else			Show_Std_Result;   { Display analysis results on screen}{ IF IN9 < 8 THEN Save_Smp_Result else Save_Std_Result; { Save analysis results to disk }             end;  { loop I8 }           end;    { loop I7 } {if not demo_DTSA then PLFlush(Out_TxtFile1);  if not demo_DTSA then PLFlush(Out_TxtFile);} 	end;                        { Main_Handler1 Procedure }end.                              { of UNIT }(* These are basic subroutines for various output procedures for screen, printer and disc}{         ----------------------------------------------------------------------}{         -----             DISPLAY ANALYSIS RESULTS ON SCREEN             -----}{         ----------------------------------------------------------------------}{3730 CLS}{     I1 := 0}{     FOR I := 1 TO I_N}{     IF C[I] > 0 THEN I1 := I1 + 1}{     NEXT I}{     IF I1 < 11 THEN I1 := INT((12 - I1) / 2): FOR I := 1 TO I1: writeln( : NEXT I}{     writeln(}{     writeln( ' ------------------------------------------------------------';}{     writeln( '-----------------'}{     writeln(}{     writeln( '              SAMPLE '; N8; '   ***************   '; I5; ' ITERATIONS.'}{     writeln(}{     writeln( '       ELEMENT   K-VALUE   K-(STD)     EL. WT %      OX WT %    AT. PROP.'}{     writeln(}{     SUMOX1 := 0}{     FOR I := 1 TO IN1: SUMOX1 := SUMOX1 + C[I] * GR1[I]: NEXT I}{     IF Num_Oxs <> 0 THEN GOTO 3734 ELSE SCAT := 0}{     FOR I := 1 TO IN1}{     IF ICCAT := 0 THEN SCAT := SCAT + C[I] / B[I]: GOTO 3732}{     IF IL[I] <> 6 AND GR1[I] > 0 THEN SCAT := SCAT + C[I] / B[I]}{3732 NEXT I}{3734 FOR I := 1 TO I_N}{     IF C[I] := 0 THEN GOTO 3760}{     IF Num_Oxs := 0 THEN C := (C[I] / B[I]) * (NCAT / SCAT) ELSE C := C[I] / B[I] / (C[I_N] / B[I_N]) * Num_Oxs}{     IF IL[I_N] := 0 THEN IF I := I_N THEN GOTO 3750}{     writeln( USING '          \\'; Z$[I];}{     IF IM2 > 0 AND C[I] < .01 THEN GOTO 3740}{     writeln( USING '     #.#####'; K[I];}{     writeln( USING '   #.#####'; KSMP[I];}{     IF I := I_N THEN writeln( USING '     ###.##  '; 100 * C[I]; 100 * (C[I] - SUMOX1); : GOTO 3736}{     writeln( USING '     ###.##  '; 100 * C[I]; 100 * C[I] * (1 + GR1[I]);}{3736 writeln( USING '     ###.###'; C}{     GOTO 3760}{3740 writeln( USING '     #.######'; K[I];}{     writeln( USING '  #.######'; KSMP[I];}{     writeln( USING '    ###.####'; 100 * C[I];}{     IF I := I_N THEN writeln( USING '     ###.####'; 100 * (C[I] - SUMOX1); : GOTO 3742}{     writeln( USING '     ###.####'; 100 * C[I] * (1 + GR1[I]);}{3742 writeln( USING '     ###.###'; C}{     GOTO 3760}{3750 writeln( USING '          \\'; Z$[I];}{     writeln( '      -----     -----      ';}{     writeln( USING '###.##'; 100 * C[I];}{     writeln( USING '                    ###.###'; C}{3760 NEXT I}{     writeln(}{     writeln( '        TOTAL:                         ';}{     writeln( USING '###.##'; 100 * M4}{     writeln(}{     writeln( ' ------------------------------------------------------------';}{     writeln( '-----------------'}{         ----------------------------------------------------------------------}{         -----                PRINT OUT ANALYSIS RESULTS                  -----}{         ----------------------------------------------------------------------}{3770 IF ILPRN := 0 THEN GOTO 3810}{     I1 := 0}{     FOR I := 1 TO I_N}{     IF C[I] > 0 THEN I1 := I1 + 1}{     NEXT I}{     IF I1 < 21 THEN I1 := INT((22 - I1) / 2): FOR I := 1 TO I1: LPRINT : NEXT I}{     LPRINT}{     LPRINT ' ------------------------------------------------------------';}{     LPRINT '-----------------'}{     LPRINT}{     HowLong := LEN(Title): Ilong := INT((80 - HowLong) / 2)}{     LPRINT TAB(Ilong); Title}{     LPRINT}{     LPRINT '              SAMPLE '; N8; '   ***************   '; I5; ' ITERATIONS.'}{     LPRINT}{     LPRINT '       ELEMENT   K-VALUE   K-(STD)     EL. WT %      OX WT %    AT. PROP.'}{     LPRINT}{     SUMOX1 := 0}{     FOR I := 1 TO IN1: SUMOX1 := SUMOX1 + C[I] * GR1[I]: NEXT I}{     IF Num_Oxs <> 0 THEN GOTO 3774 ELSE SCAT := 0}{     FOR I := 1 TO IN1}{     IF ICCAT := 0 THEN SCAT := SCAT + C[I] / B[I]: GOTO 3772}{     IF IL[I] <> 6 AND GR1[I] > 0 THEN SCAT := SCAT + C[I] / B[I]}{3772 NEXT I}{3774 FOR I := 1 TO I_N}{     IF C[I] := 0 THEN GOTO 3800}{     IF Num_Oxs := 0 THEN C := (C[I] / B[I]) * (NCAT / SCAT) ELSE C := C[I] / B[I] / (C[I_N] / B[I_N]) * Num_Oxs}{     IF IL[I_N] := 0 THEN IF I := I_N THEN GOTO 3790}{     LPRINT USING '          \\'; Z$[I];}{     IF IM2 > 0 AND C[I] < .01 THEN GOTO 3780}{     LPRINT USING '     #.#####'; K[I];}{     LPRINT USING '   #.#####'; KSMP[I];}{     IF I := I_N THEN LPRINT USING '     ###.##  '; 100 * C[I]; 100 * (C[I] - SUMOX1); : GOTO 3776}{     LPRINT USING '     ###.##  '; 100 * C[I]; 100 * C[I] * (1 + GR1[I]);}{3776 LPRINT USING '     ###.###'; C}{     GOTO 3760}{3780 LPRINT USING '     #.######'; K[I];}{     LPRINT USING '  #.######'; KSMP[I];}{     LPRINT USING '    ###.####'; 100 * C[I];}{     IF I := I_N THEN LPRINT USING '     ###.####'; 100 * (C[I] - SUMOX1); : GOTO 3782}{     LPRINT USING '     ###.####'; 100 * C[I] * (1 + GR1[I]);}{3782 LPRINT USING '     ###.###'; C}{     GOTO 3800}{3790 LPRINT USING '          \\'; Z$[I];}{     LPRINT '      -----     -----      ';}{     LPRINT USING '###.##'; 100 * C[I];}{     LPRINT USING '                    ###.###'; C}{3800 NEXT I}{     LPRINT}{     LPRINT '        TOTAL:                         ';}{     LPRINT USING '###.##'; 100 * M4}{     LPRINT}{     LPRINT ' ------------------------------------------------------------';}{     LPRINT '-----------------'}{     LPRINT CHR$(12)}{}{}{         ----------------------------------------------------------------------}{         -----           SUBROUTINE: COMPRESSED PRINTOUT MODE             -----}{         ----------------------------------------------------------------------}{5200 IF IKEL := 1 THEN GOTO 5260}{     IF IPRN > 4 THEN CLOSE #1: OPEN 'DATAKRAT.OUT' FOR APPEND AS #1}{     writeln( USING '####.##'; N8;}{     FOR I := 1 TO IN1}{     IF IT[I] := 0 THEN writeln( USING ' #.#####'; KSMP[I];}{     NEXT I}{     IF ISTAGE := 1 THEN writeln( '        ';}{     IF ISTAGE := 1 AND IN1 < I_N THEN writeln( '        ';}{     IF ISTAGE := 1 THEN writeln( USING ' ###.###'; XCOORD, YCOORD;}{     writeln(}{5260 IF ICEL := 1 THEN GOTO 5340}{     IF IPRN > 4 THEN CLOSE #1: OPEN 'DATAELWT.OUT' FOR APPEND AS #1}{     writeln( USING '####.##'; N8;}{     NORMF := 1: IF INORM := 1 THEN NORMF := M4}{     FOR I := 1 TO I_N}{     IF IT[I] := 1 THEN GOTO 5320}{     IF IM2 > 0 THEN IF C[I] > .0000005 AND C[I] < .01 THEN GOTO 5310}{     writeln( USING '  ###.##'; 100 * C[I] / NORMF;}{     GOTO 5320}{5310 writeln( USING '  #.####'; 100 * C[I] / NORMF;}{5320 NEXT I}{     writeln( USING '  ###.##'; 100 * M4;}{     IF ISTAGE := 1 THEN writeln( USING ' ###.###'; XCOORD, YCOORD ELSE writeln(}{5340 IF ICOX := 1 THEN GOTO 5420}{     IF IPRN > 4 THEN CLOSE #1: OPEN 'DATAOXWT.OUT' FOR APPEND AS #1}{     writeln( USING '####.##'; N8;}{     SUMOX1 := 0: NORMF := 1: IF INORM := 1 THEN NORMF := M4}{     FOR I := 1 TO IN1}{     SUMOX1 := SUMOX1 + C[I] * GR1[I]}{     NEXT I}{     FOR I := 1 TO IN1}{     IF IT[I] := 1 THEN GOTO 5400}{     IF I := IN1 AND I_N := IN1 THEN GOTO 5400}{     IF IM2 > 0 THEN IF C[I] > .0000005 AND C[I] < .01 THEN GOTO 5390}{     writeln( USING '  ###.##'; 100 * C[I] * (1 + GR1[I]) / NORMF;}{     GOTO 5400}{5390 writeln( USING '  #.####'; 100 * C[I] * (1 + GR1[I]) / NORMF;}{5400 NEXT I}{     IF I_N := IN1 THEN GOTO 5414}{     writeln( '        '; : writeln( USING '  ###.##'; 100 * M4;}{     GOTO 5418}{5414 writeln( USING '  ###.##'; 100 * (C[I_N] - SUMOX1) / NORMF;}{     writeln( USING '  ###.##'; 100 * M4;}{5418 IF ISTAGE := 1 THEN writeln( USING ' ###.###'; XCOORD, YCOORD ELSE writeln(}{5420 IF ICAT := 1 THEN GOTO 5500}{     IF IPRN > 4 THEN CLOSE #1: OPEN 'DATAATOM.OUT' FOR APPEND AS #1}{     writeln( USING '####.##'; N8;}{     IF Num_Oxs <> 0 THEN GOTO 5450 ELSE SCAT := 0}{     FOR I := 1 TO IN1}{     IF ICCAT := 0 THEN SCAT := SCAT + C[I] / B[I]: GOTO 5448}{     IF IL[I] <> 6 AND GR1[I] > 0 THEN SCAT := SCAT + C[I] / B[I]}{5448 NEXT I}{5450 FOR I := 1 TO I_N}{     IF IT[I] := 1 THEN GOTO 5480}{     IF Num_Oxs := 0 THEN C := (C[I] / B[I]) * (NCAT / SCAT) ELSE C := C[I] / B[I] / (C[I_N] / B[I_N]) * Num_Oxs}{     IF IM2 > 0 THEN IF C[I] > .0000005 AND C < .1 THEN GOTO 5470}{     writeln( USING ' ###.###'; C;}{     GOTO 5480}{5470 writeln( USING ' #.#####'; C;}{5480 NEXT I}{     IF ISTAGE := 1 THEN writeln( '        ';}{     IF ISTAGE := 1 THEN writeln( USING ' ###.###'; XCOORD, YCOORD;}{     writeln(}{5500 IF IZAF := 0 THEN RETURN}{     IF IPRN > 4 THEN CLOSE #1: OPEN 'DATAKRAT.OUT' FOR APPEND AS #1}{     IF IKEL := 1 THEN writeln( 'Sample # '; N8}{     FOR I := 1 TO IN1}{     IF IL[I] > 3 THEN W[I] := 1: E[I] := 0: Fluor[I] := 0:  A[I] := 0}{     NEXT I}{     writeln( ' ABSCOR';}{     FOR I := 1 TO IN1}{     IF IT[I] := 0 THEN writeln( USING ' ##.####'; E[I] / W[I];}{     NEXT I}{     writeln( : writeln( ' FLUCOR';}{     FOR I := 1 TO IN1}{     IF IT[I] := 0 THEN writeln( USING ' ##.####'; 1 / (1 + Fluor[I]);}{     NEXT I}{     writeln( : writeln( ' ZEDCOR';}{     FOR I := 1 TO IN1}{     IF IT[I] := 0 THEN writeln( USING ' ##.####'; A[I];}{     NEXT I}{     writeln( : writeln( ' ZAFCOR';}{     FOR I := 1 TO IN1}{     IF IT[I] := 0 THEN writeln( USING ' ##.####'; E[I] / W[I] * A[I] / (1 + Fluor[I]);}{     NEXT I}{     writeln( : writeln( ' ZAFSTD';}{     FOR I := 1 TO IN1}{     IF IT[I] := 0 THEN writeln( USING ' ##.####'; (E[I] / W[I] * A[I] / (1 + Fluor[I])) / STDZAF[I];}{     NEXT I}{     writeln( : writeln(}{     RETURN}{         ----------------------------------------------------------------------}{         -----          SUBROUTINE: COMPRESSED PRINTOUT HEADING           -----}{         ----------------------------------------------------------------------}{5700 IF IFirstRun := 0 THEN RETURN}{     IF IPRN < 5 THEN}{        GOSUB 5720}{        RETURN}{     END IF}{     FOR IPROUT := 1 TO 4}{     IF IPD(IPROUT) := 0 THEN}{        CLOSE #1}{        OPEN DFILE$(IPROUT) FOR APPEND AS #1}{        IPRT := IPROUT}{        GOSUB 5720}{     END IF}{     NEXT IPROUT}{     IF IPD(1) := 1 AND IZAF := 1 THEN}{        CLOSE #1}{        OPEN DFILE$(1) FOR APPEND AS #1}{        IPRT := 5}{        GOSUB 5720}{     END IF}{     ICPH1 := 1}{     RETURN}{}{                  ----- Beginning of printing sub-subroutine -----}{}{5720 IF ICPH1 := 1 THEN GOTO 5760}{     IF IB := 0 THEN writeln(}{     HowLong := LEN(Title)}{     Ilong := INT((80 - HowLong) / 2)}{     writeln( TAB(Ilong); Title: writeln(}{     IF INORM := 1 THEN writeln( TAB(22); '*** RESULTS NORMALIZED TO 100 % ***': writeln(}{     IF IPRT := 1 THEN writeln( TAB(20); '***  k-factors relative to standards  ***';}{     IF IPRT := 2 THEN writeln( TAB(27); '***  Element Weight %  ***';}{     IF IPRT := 3 THEN writeln( TAB(28); '***  Oxide Weight %  ***';}{     IF IPRT := 4 THEN writeln( TAB(27); '***  Atom Proportions  ***';}{     IF IPRT := 5 THEN writeln( TAB(26); '***  Correction factors  ***';}{     IF IL[I_N] := 0 OR IPRT <> 3 THEN GOTO 5760}{     writeln( : writeln(}{     writeln( '    (Data under '; Z$[I_N]; ' are the differences between the measured concentrations'}{     writeln( '    of '; Z$[I_N]; ' and those calculated by stoichiometry from cation concentrations.)';}{5760 writeln( : writeln(}{     writeln( '  SMP # ';}{     IF IPRT := 3 THEN GOTO 5770}{     FOR I := 1 TO I_N}{     IF IT[I] := 0 THEN writeln( USING '    \\  '; Z$[I];}{     NEXT I}{     GOTO 5780}{5770 FOR I := 1 TO I_N}{     IF IT[I] := 0 THEN writeln( USING '  \   \ '; OX$[I];}{     NEXT I}{5780 writeln( '  TOTAL';}{     IF ISTAGE := 1 THEN writeln( '  X (mm)  Y (mm)' ELSE writeln(}{     writeln(}{     RETURN}{*)