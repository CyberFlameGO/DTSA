UNIT FilePlugIns;INTERFACEUSES	Types,QuickDraw,Memory,OSUtils,ToolUtils,Windows, Menus, TextEdit, TextUtils, Timer, StandardFile, Controls, Errors, Files, Retrace, SegLoad,		Resources, Dialogs, Lists, Printing, Packages, fenv,fp, Spectrum_Structures, Declarations, INITIALIZE, Global_Functions;(**************************************************************************)CONST	{ Operation messages }	fileAbout		= 0;		{Plugin should display about dialog								}	ImpFile			= 1;		{Read the imported file.										}	ExpFile			= 2;		{Write the exported file.										}	OpenInPlug		= 3;	OpenExPlug		= 4;	fileBadParameters=-1;		MaxFilePlugins		= 20;	ImpPlugFileType		= 'DTim';	ExpPlugFileType		= 'DTem';	PlugFileCreator		= 'DTSA';	FilePlugRezType		= 'DTpl';TYPE	FilePlugRezHdl		= ^FilePlugRezPtr;	{ Plugin resource information, compatablity check during load	}	FilePlugRezPtr		= ^FilePlugRez;	FilePlugRez			= PACKED RECORD		version			: Integer;			{ The version number of the interface supported.		}		subVersion		: Integer;			{ The sub-version number.						  		}		priority		: Integer;			{ The plug-in's priority.                       		}		Spare1			: Integer;		SpecificHost	: OSType;			{ PlugIn functions only with Host of OSType Type		}		CanAcqSpectra	: Boolean;			{ Can Acquire X-ray Spectra								}		CanAcqXRImage	: Boolean;			{ Can Acquire X-ray images								}		CanAcqImage		: Boolean;			{ Can Acquire SEM/STEM images							}		SpareBoolean	: Boolean;		reserved		: LongInt;	END;											{ ¥ This is used by all File plugins to pass information}	IOPlugPtr		= ^IOPlug;	IOPlug			= RECORD		serialNumber	: LongInt;			{ Host serial number (future copy protection for plugin	}		hostVersion		: Integer;			{ Host version number									}		hostsubVersion	: Integer;			{ Host subversion number								}		hostModes		: LongInt;			{ Host modes that are supported (spectra,images, etc.).	}		hostMaxChan		: LongInt;			{ Maximum of channels that can be passed back to host 	}		PlugInName		: Str255;			{ Menu Name for PlugIn, Fill in for 'open' or leave ''	}		Specimen_Comment_Field       : Str255;		Title_Comment_Field		     : Str255;		Owner						 : STRING[50];		dE						 	 : real;		kV                       	 : real;		Begin_Faraday                : real;    { nA }		End_Faraday                  : real;    { nA }		FirstValue                   : Real;    { eg if WDS spectrum the begin lamda}		EndValue                     : Real;		Real_Time                    : real;         { The time on the wall }		Live_Time                    : real;		Energy_Slope                 : real;		Energy_Intercept             : real;		D_Azimuth					 : real;		D_Elevation					 : real;		D_Solid_Angle				 : real;		Mn_FWHM						 : real;		X_Tilt						 : real;		Y_Tilt						 : real;		T_Be_Wind					 : real;		T_Au_Wind					 : real;		T_Al_Wind					 : real;		T_Py_Wind					 : real;		T_BN_Wind					 : real;		T_Di_Wind					 : real;		T_HC_Wind					 : real;		T_Dead_Layr					 : real;		T_Act_Layr					 : real;		S_Thickness                  : real;		X_Pos						 : real;		Y_Pos						 : real;		NDoffset		             : Longint;		Begin_Time                   : Longint;		Number_of_Channels       	 : integer;		Spectrum_Type 				 : string[4];		FirstChannel                 : integer;		LastChannel                  : integer;				rd_refNum					 : integer;		Spare2                       : Boolean;		Spare4						 : Boolean;		Spec_cts					 : ARRAY [1..8192] OF Real;	END;											{ ¥ This is used by FilePlugins to remember each plugin	}	FilePlugHdl			= ^FilePlugPtr;	FilePlugPtr			= ^FilePlug;	FilePlug			= RECORD		fRefNum			: Integer;			{ fRefnum of plugin file								}		vRefNum			: Integer;			{ vRefnum of plugin file								}		DirID			: LongInt;			{ directory ID of plugin file							}		PlugID			: Integer;					PlugName		: Str255;			{ Name of the DTSA plugin name							}		ReqDestBuff		: Integer;		FixupMenus		: Boolean;		theProc			: ProcPtr;			{ Plugin code location (filled when plugin is loaded)	}		IOPtr			: IOPlugPtr;		{ Ptr to file plugin's record 							}		PrivData		: Ptr;				{ Used for plug-in private data (global), NIL 1st time	}	END;	PROCEDURE	OpenFilePlugIns;	FUNCTION	CFilePlugIns(message:Integer;whichPlug:Integer):Boolean;VAR		gInFilePlugIns			: ARRAY [1..MaxFilePlugins] of FilePlugPtr;	gExFilePlugIns			: ARRAY [1..MaxFilePlugins] of FilePlugPtr;	gFileCurrentPlugIn		: Integer;	gImpCurrentPlugIn		: Integer;	gExpCurrentPlugIn		: Integer;	gCurrentType			: Integer;IMPLEMENTATION{$ifc GENERATINGPOWERPC}PROCEDURE	CallFilePlug(message:Integer; VAR theFilePtr:IOPlugPtr;{VAR thePrivData:Ptr;}VAR theResult:OSerr; UniversalProcPtr:Ptr);EXTERNAL;			{Otherwise use C glue routine ("DTSAGlue.c") that calls CallUniversalProc. We can't			 call it directly because CallUniversalProc uses a variable number of arguments.}{$elsec}PROCEDURE	CallFilePlug(message:Integer; VAR theFilePtr:IOPlugPtr;{VAR thePrivData:Ptr;}VAR theResult:OSerr; UniversalProcPtr:Ptr);	INLINE	$205F,		{MOVE.L	(A7)+,A0	;pop ptr off stack					}			$4E90;		{JSR	(A0)		;call proc leaving params on stack	}{$endc}FUNCTION	PGetAnotherFileName(VAR Name: Str63; VAR VolumeRef: integer): Boolean; FORWARD;PROCEDURE	eV_Options; FORWARD;PROCEDURE	Do_ASCII_Files(counter: Integer; The_File_name: Str63; IOPtr: IOPlugPtr); FORWARD;PROCEDURE	Load_New_Spectra(counter: Integer); FORWARD;PROCEDURE	Write_ASCII_File(IOPtr: IOPlugPtr); FORWARD;PROCEDURE	Load_the_Current_Data(IOPtr: IOPlugPtr); FORWARD;VAR	In_File_Spec			: FSSpec;	Out_File_Spec			: FSSpec;	temp_File_Spec			: FSSpec;	temp_eV 				: Real;	temp_Shift, sav_volref	: integer;	Do_a_Shift, mult_file	: Boolean;	Overide_the_eV 			: Boolean;	FName, fil_nam			: Str63;	Prompt, defName			: str255;	Outreply				: StandardFileReply;	Inreply					: StandardFileReply;	gFirstTime, nextime 	: boolean;	sav_dirID				: Longint;	(**************************************************************************)FUNCTION	MyHGetVol(volName: StringPtr; VAR vRefNum: INTEGER; VAR dirID: LONGINT): OSErr;	{BUG NOTE: The high level call, HGetVol, should do this dirty work for us.			}	{Unfortunately it is returning the ioVRefNum which Inside Mac warns may be			}	{a working directory.  The field ioWDVRefNum will always be the real vRefNum.		}(*CONST	kFSAsynch 			= TRUE;*)							{asynchronous File Manager call}VAR	myWDBRec			: WDPBRec;BEGIN	myWDBRec.ioCompletion:= NIL;	myWDBRec.ioNamePtr:= NIL;	MyHGetVol:= PBHGetVolAsync(@myWDBRec);	vRefNum:= myWDBRec.ioWDVRefNum;						{the real vRefNum}	dirID:= myWDBRec.ioWDDirID;END;(**************************************************************************)FUNCTION	CFilePlugIns(message:Integer;whichPlug:Integer):Boolean;VAR	thePlug					: FilePlugPtr;	theResult, errcode		: OSErr;	theCurResFile			: Integer;	(*SIdx					: Integer;	EIdx					: Integer;*)	theReturnValue			: Boolean;	counter					: Integer;	in_refNum, xVolumeRef	: integer;	out_refnum				: integer;		The_File_name			: Str63;	savename                : fnamestr;	savevol         		: integer;	save_dirID				: longint;	BEGIN	theCurResFile:=CurResFile;									{Save the current resource file			}	theReturnValue:=FALSE;	theResult:=NoErr;	IF (whichplug=0) THEN EXIT(CFilePlugIns);	(*IF (whichplug=-1) THEN BEGIN		SIdx:=1;		EIdx:=10;	END ELSE BEGIN		SIdx:=whichplug;		EIdx:=whichplug;	END;*)	CASE message OF	fileAbout:	 BEGIN		thePlug:=gInFilePlugIns[whichplug];		IF (thePlug<>NIL) THEN BEGIN			WITH thePlug^ DO BEGIN				UseResFile(fRefNum);							{Change to the Plugs's resource file }				CallFilePlug(fileAbout,IOPtr,{PrivData,}theResult,theProc);				UseResFile(theCurResFile);						{Restore the current resource file		}				theReturnValue:=(theResult=NoErr);			END;		END;	 END;	ImpFile:	 BEGIN	 			thePlug:=gInFilePlugIns[whichplug];		IF (thePlug<>NIL) THEN BEGIN			WITH thePlug^ DO BEGIN			  {Initialize the DTSA file & the input file}			  {putmessage('The plug-in name is: ',IOPtr^.PlugInName,'','');}				defName := 'DTSAfile.Dat';				Prompt := 'Make the OUTPUT File';				StandardPutFile(Prompt, defName, Outreply);				if NOT Outreply.sfGood Then exit(CFilePlugIns);				WITH Outreply DO begin					Write_DTSA_Spec := sfFile;					  OutVol_volnum := Write_DTSA_Spec.vRefNum;					  OutVol_DirID := Write_DTSA_Spec.parID;					  					  {The volume names in the folowing calls are all StringPtr}					  errcode := HGetVol(@savename, savevol, save_dirID);{keep track of default vol}					  errcode := HSetVol(@OutVol_volname, OutVol_volnum, OutVol_DirID);{get name of current vol}					  errcode := HGetVol(@OutVol_volname, OutVol_volnum, OutVol_DirID);{get name of current vol}					  errcode := HSetVol(@savename, savevol, save_dirID);{restore default vol}										err := FSpCreate(sfFile, 'DTSA', 'MCAf', sfScript);					if NOT sfGood Then exit(CFilePlugIns);				end;				  BeginUpdate(BackPlane);				  DrawAxesFull;				  Update_Full;				  EndUpdate(BackPlane);								eV_Options;			{Replaces Ascii_Format_Choices}								{Select an input file}				counter := 0;				Plt_spec[10]^^.Expt_Info.FirstSpec := 1;				Plt_spec[10]^^.Expt_Info.Specimen_ID := '';			  IF NOT PGetAnotherFileName(The_File_name, xVolumeRef) THEN exit(CFilePlugIns);	{This will make an In_File_Spec}			  			  REPEAT		{Until all files are read}			  {Open input file & get ready}								counter := counter + 1;				err := FSpOpenDF(In_File_Spec, fsRdPerm, in_refNum);				IOPtr^.rd_refNum := in_refNum;			  IF (err <> NoErr) THEN exit(CFilePlugIns);				Load_the_Current_Data(IOPtr);				UseResFile(fRefNum);		{Change to the Plugs's resource file }				CallFilePlug(ImpFile,IOPtr,{PrivData,}theResult,theProc);				UseResFile(theCurResFile);						{Restore the current resource file		}				IF (theResult=NoErr) THEN BEGIN					(*UpdateDTSABuffers(message,Plt_Spec[ReqDestBuff]^,IOPtr);*)					theReturnValue:=TRUE;				END				ELSE					putmessage('Read terminated due to ','a bad file format.','','');			  			  {Close input file, load up any additional data, put it all into PltSpec[10] and save it to the DTSA file}			   err := FSClose(in_refNum);			   err := FlushVol(NIL, In_File_Spec.vRefNum);			   Do_ASCII_Files(counter, The_File_name, IOPtr);			  UNTIL NOT PGetAnotherFileName(The_File_name, xVolumeRef);			END;		  {Open the DTSA file for reading and put spectrum 1 into WORK}		  Load_New_Spectra(counter);		  putmessage('Check the data in the Experiment Header, ','in the Spectrum Header.',		  		'Check the Detector Parameters to be ','sure that they are correct.');		  Mouse_Active_Window;		END;	 END;	ExpFile:	{code for writing an MSA/MAS format file (or other)}		BEGIN		thePlug:=gExFilePlugIns[whichplug];		IF (thePlug<>NIL) THEN BEGIN			WITH thePlug^ DO BEGIN						  {Initialize the output file}				defName := 'TEXTfile.mas';				Prompt := 'Make the OUTPUT File';				StandardPutFile(Prompt, defName, Outreply);				if NOT Outreply.sfGood Then exit(CFilePlugIns);				WITH Outreply DO begin					  Out_File_Spec := sfFile;					  OutVol_volnum := Out_File_Spec.vRefNum;					  OutVol_DirID := Out_File_Spec.parID;					  					  {The volume names in the folowing calls are all StringPtr}					  errcode := HGetVol(@savename, savevol, save_dirID);{keep track of default vol}					  errcode := HSetVol(@OutVol_volname, OutVol_volnum, OutVol_DirID);{get name of current vol}					  errcode := HGetVol(@OutVol_volname, OutVol_volnum, OutVol_DirID);{get name of current vol}					  errcode := HSetVol(@savename, savevol, save_dirID);{restore default vol}										err := FSpCreate(sfFile, 'MSWD', 'TEXT', sfScript);					if NOT sfGood Then exit(CFilePlugIns);				end;				  BeginUpdate(BackPlane);				  DrawAxesFull;				  Update_Full;				  EndUpdate(BackPlane);								{Select an input file}			  								err := FSpOpenDF(Out_File_Spec, fsWrPerm, out_refnum);				IOPtr^.rd_refNum := out_refnum;			  IF (err <> NoErr) THEN exit(CFilePlugIns);			    Write_ASCII_File(IOPtr);				UseResFile(fRefNum);							{Change to the Plugs's resource file }				CallFilePlug(ExpFile,IOPtr,{PrivData,}theResult,theProc);				UseResFile(theCurResFile);						{Restore the current resource file		}				IF (theResult=NoErr) THEN BEGIN					(*UpdateDTSABuffers(message,Plt_Spec[ReqDestBuff]^,IOPtr);*)					theReturnValue:=TRUE;				END				ELSE					putmessage('Write terminated due to ','a bad file format.','','');			  			  {Close output file, load up any additional data, put it all into PltSpec[10] and save it to the DTSA file}			   err := FSClose(out_refnum);			END;		  Mouse_Active_Window;		END;	END;	OpenInPlug:		BEGIN		thePlug:=gInFilePlugIns[whichplug];		IF (thePlug<>NIL) THEN BEGIN			WITH thePlug^ DO BEGIN				UseResFile(fRefNum);							{Change to the Plugs's resource file }				CallFilePlug(OpenInPlug,IOPtr,{PrivData,}theResult,theProc);				UseResFile(theCurResFile);						{Restore the current resource file		}				theReturnValue:=(theResult=NoErr);			END;		  END;		END;	OpenExPlug:		BEGIN		thePlug:=gExFilePlugIns[whichplug];		IF (thePlug<>NIL) THEN BEGIN			WITH thePlug^ DO BEGIN				UseResFile(fRefNum);							{Change to the Plugs's resource file }				CallFilePlug(OpenExPlug,IOPtr,{PrivData,}theResult,theProc);				UseResFile(theCurResFile);						{Restore the current resource file		}				theReturnValue:=(theResult=NoErr);			END;		  END;		END;			OTHERWISE	 BEGIN	 	Debugstr('should never get here');	 END;	END;	CFilePlugIns:=theReturnValue;	Mouse_Active_Window;END;PROCEDURE	OpenFilePlugIns;	{Find and load external Plugs, to do this you need to find		}	{ the Plugs directory in the directory of the application,		}	{ then search the Plugs directory for Plug type files, then		}	{ search each plug for the correct Plug info resources.			}	{ If good, then load each all Plug resources for each Plug-in	}(*CONST	kFSAsynch 			= TRUE;*)							{asynchronous File Manager call}TYPE	ProcHandle			=^ProcPtr;VAR	err					: OSErr;	tfolderName			: Str255;	tfileName			: Str31;	tID					: INTEGER;	tType				: ResType;	tName				: Str255;	PlugInIndx			: Integer;						{ Index into array of DTSA compatable plug-ins				}	PlugExIndx			: Integer;						{ Index into array of DTSA compatable plug-ins				}	RezIndx				: Integer;	BadPlugNoFind		: Boolean;	tCInfo				: CInfoPBRec;	tDirID				: LongInt;	tPlug				: FilePlugPtr;	tPlugRez			: FilePlugRezHdl;	tProcHandle			: ProcHandle;		PlugRezFile			: Integer;	AppRezFile			: Integer;	AppVRefNum			: Integer;	AppDirID			: LongInt;BEGIN	FOR PlugInIndx:=1 TO MaxFilePlugins DO gInFilePlugIns[PlugInIndx]:=NIL;	PlugInIndx:=1;													{Start filling from the start of the Plug array	}	FOR PlugExIndx:=1 TO MaxFilePlugins DO gExFilePlugIns[PlugExIndx]:=NIL;	PlugExIndx:=1;													{Start filling from the start of the Plug array	}	AppRezFile:=CurResFile;											{Remember the applications resource file number	}	err:= MyHGetVol(NIL, AppVRefNum, AppDirID);					{¥1¥ Get the volume and directory of the application}	tDirID:=0;	mult_file := false;		{set for one file} 						{ and walk the directory down to the plugins	}													WITH tCInfo DO BEGIN											{Setup the catalog info record					}			ioCompletion:= NIL;											{no completion}			ioNamePtr:= NIL;											{no name}					ioFDirIndex:= -1;											{-1 means use ioDrDirID}		ioVRefNum:= AppVRefNum; 									{use this volume}		ioDrDirID:= AppDirID;										{in the application directory}		err:= PBGetCatInfoSync(@tCInfo);						{¥2¥ Get the number of files in this directory}		IF err=NoErr THEN BEGIN									ioFDirIndex:=ioDRNmFls;									{This is number of files in application dir		}			REPEAT													{Now find the Plugin folder						}				tfolderName:= '';									{initialize string}				ioCompletion:= NIL;									{no completion}				ioNamePtr:= @tfolderName;							{Ptr to string}				ioVRefNum:= AppVRefNum; 							{this is the volume}				ioDrDirID:= AppDirID;								{this is the directory}				err:= PBGetCatInfoSync(@tCInfo);					{Checking through all files}				ioFDirIndex:=ioFDirIndex-1;							{until we find the 'Plug-ins' directory (folder)}			UNTIL ( (ioFDirIndex<=0) or ( (BitTst(@ioFLAttrib,3)) and (ioNamePtr^='Plug-ins') ) );			IF ioFDirIndex>0 THEN tDirID:=tCInfo.ioDirID;			{If ioFDirIndex>0, we got a name/folder match	}		END;		IF tDirID<>0 THEN BEGIN									{¥3¥ IF we got a good Plugs folder, get num of plugins}					ioCompletion:= NIL;										{no completion}					ioNamePtr:= NIL;										{no name}				ioFDirIndex:= -1;										{-1 means use ioDrDirID}			ioVRefNum:= AppVRefNum; 								{this is the volume}			ioDrDirID:= tDirID;										{this is the directory}			err:= PBGetCatInfoSync(@tCInfo);						{Get the number of plugins in this directory	}			IF err=NoErr THEN BEGIN												ioFDirIndex:=ioDRNmFls;								{This is the number of files in this dir		}							REPEAT					tfileName:= '';									{initialize string}					ioCompletion:=NIL;								{no completion}						ioNamePtr:=@tfileName;							{Ptr to string}						ioVRefNum:=AppVRefNum; 							{this is the volume}					ioDrDirID:=tDirID;								{this is the directory}					err:= PBGetCatInfoSync(@tCInfo);				{Search the Plugs directory}					ioFDirIndex:=ioFDirIndex-1;						{until we find a file with correct type/creator	}					IF (((ioFlFndrInfo.fdType=ImpPlugFileType) and							 (ioFlFndrInfo.fdCreator=PlugFileCreator)) or							  ((ioFlFndrInfo.fdType=ExpPlugFileType) and							 (ioFlFndrInfo.fdCreator=PlugFileCreator))) THEN BEGIN						PlugRezFile:=HOpenResFile(AppVRefNum,tDirID,tfileName,fsCurPerm);																											{¥4¥ Setup for multiple plug resources in plugin	}						IF (PlugRezFile<>-1) THEN BEGIN							RezIndx:=1;							tPlugRez:=NIL;							REPEAT									{If good open,Index through all plug resources	}								BadPlugNoFind:=false;				{Setup for getting a good plug resources		}								tPlug:=FilePlugPtr(NewPtrClear(Sizeof(FilePlug)));								tPlug^.vRefNum	:=AppVRefNum;		{Fill in Plug file data record					}								tPlug^.fRefNum	:=PlugRezFile;								tPlug^.DirID	:=tDirID;								tPlug^.PlugID	:=0;				{fill in later}								tPlug^.PlugName	:=tfileName;								tPlug^.FixupMenus:=FALSE;								tPlug^.ReqDestBuff:=10;				{ Point to the "Work" buffer	}								tPlug^.theProc	:=NIL;				{fill in later}								tPlug^.IOPtr	:=NIL;				{fill in later}								tPlug^.PrivData	:=NIL;																{¥5¥ Get plugin's resource info record				}								UseResFile(tPlug^.fRefNum);			{Point to the Plug's res file					}								tPlugRez:=FilePlugRezHdl(Get1IndResource(FilePlugRezType,RezIndx));								RezIndx:=RezIndx+1;								IF (tPlugRez<>NIL) THEN BEGIN									IF (tPlugRez^^.version<>2) THEN BadPlugNoFind:=TRUE;									(*IF (not tPlugRez^^.CanAcqSpectra) THEN BadPlugNoFind:=TRUE;*)									IF (tPlugRez^^.SpecificHost<>PlugFileCreator) THEN BadPlugNoFind:=TRUE;																								{¥6¥ If still good, fill in some more plug record}									IF (not BadPlugNoFind) THEN BEGIN										GetResInfo(Handle(tPlugRez),tID,tType,tName);										tPlug^.PlugID:=tID;										tPlug^.PlugName:=tName;									END;									ReleaseResource(Handle(tPlugRez));	{ Done with plug resource so release it		}									tPlugRez:=NIL;								END ELSE BEGIN									BadPlugNoFind:=TRUE;								END;																{¥7¥ Now load, detach and lock the code	segment		}																{ and filling last of plug record and the acq record}								IF (not BadPlugNoFind) THEN BEGIN										tProcHandle:=ProcHandle(GetResource('proc',tPlug^.PlugID));									IF (tProcHandle<>NIL) THEN BEGIN										DetachResource(Handle(tProcHandle));										MoveHHI(Handle(tProcHandle));										HLock(Handle(tProcHandle));										tPlug^.theProc:=tProcHandle^;										tPlug^.IOPtr:=IOPlugPtr(NewPtrClear(Sizeof(IOPlug)));	{This is PltSpec}										WITH IOPlugPtr(tPlug^.IOPtr)^ DO BEGIN											serialNumber:=4*314159;		{ let's see in anyone notices				}											hostVersion	:=2;			{ Version 2.0 of DTSA						}											hostsubVersion:=0;			{ Who knows what subversion					}											hostModes	:=1;			{ Only Spectra mode for now					}											hostMaxChan	:=8192;																		{ImpFile takes care of rest of record	}										END;																			(*																					gFilePlugIns[PlugIndx]:=tPlug;	{Must do this BEFORE CFilePlugIns			}																{¥8¥ The final check, call the plugin code to open	}						{¥¥¥}				IF (CFilePlugIns(OpenPlug,PlugIndx)) THEN BEGIN																		{Add plugin to the Acquire plugins menu		}											UseResFile(AppRezFile);	 	{Point back to the AppRezFile for fail		}											IF (tPlug^.IOPtr^.PlugInName<>'') THEN BEGIN	{Plug might want name change}												tPlug^.PlugName:=tPlug^.IOPtr^.PlugInName;											END;												IF (ioFlFndrInfo.fdType=ImpPlugFileType) then												AppendMenu(GetMenu(228),tPlug^.PlugName);	{One for the import menu	}											IF (ioFlFndrInfo.fdType=ExpPlugFileType) then												AppendMenu(GetMenu(229),tPlug^.PlugName);	{One for the exportmenu     }											PlugIndx:=PlugIndx+1;	{Plugin had good open, go to next array index	}										END ELSE BEGIN				{Open failed, scratch this one					}											UseResFile(AppRezFile);	 	{Point back to the AppRezFile for fail		}											gFilePlugIns[PlugIndx]:=NIL;											DisposePtr(Ptr(tPlug^.IOPtr));											DisposePtr(Ptr(tPlug));										END;					*)																		IF (ioFlFndrInfo.fdType=ImpPlugFileType) then begin										gInFilePlugIns[PlugInIndx]:=tPlug;	{Must do this BEFORE CFilePlugIns			}																{¥8¥ The final check, call the plugin code to open	}						{¥¥¥}				IF (CFilePlugIns(OpenInPlug,PlugInIndx)) THEN BEGIN																		{Add plugin to the Acquire plugins menu		}											UseResFile(AppRezFile);	 	{Point back to the AppRezFile for fail		}											IF (tPlug^.IOPtr^.PlugInName<>'') THEN BEGIN	{Plug might want name change}												tPlug^.PlugName:=tPlug^.IOPtr^.PlugInName;											END;											AppendMenu(GetMenu(228),tPlug^.PlugName);	{One for the import menu	}										PlugInIndx:=PlugInIndx+1;	{Plugin had good open, go to next array index	}										END ELSE BEGIN				{Open failed, scratch this one					}											UseResFile(AppRezFile);	 	{Point back to the AppRezFile for fail		}											gInFilePlugIns[PlugInIndx]:=NIL;											DisposePtr(Ptr(tPlug^.IOPtr));											DisposePtr(Ptr(tPlug));										END;								end;								IF (ioFlFndrInfo.fdType=ExpPlugFileType) then begin										gExFilePlugIns[PlugExIndx]:=tPlug;	{Must do this BEFORE CFilePlugIns			}																{¥8¥ The final check, call the plugin code to open	}						{¥¥¥}				IF (CFilePlugIns(OpenExPlug,PlugExIndx)) THEN BEGIN																		{Add plugin to the Acquire plugins menu		}											UseResFile(AppRezFile);	 	{Point back to the AppRezFile for fail		}											IF (tPlug^.IOPtr^.PlugInName<>'') THEN BEGIN	{Plug might want name change}												tPlug^.PlugName:=tPlug^.IOPtr^.PlugInName;											END;											AppendMenu(GetMenu(229),tPlug^.PlugName);	{One for the exportmenu     }										PlugExIndx:=PlugExIndx+1;	{Plugin had good open, go to next array index	}										END ELSE BEGIN				{Open failed, scratch this one					}											UseResFile(AppRezFile);	 	{Point back to the AppRezFile for fail		}											gExFilePlugIns[PlugExIndx]:=NIL;											DisposePtr(Ptr(tPlug^.IOPtr));											DisposePtr(Ptr(tPlug));										END;								end;																			END ELSE BEGIN										UseResFile(AppRezFile);	 		{Point back to the AppRezFile for fail		}										DisposePtr(Ptr(tPlug));									END;								END ELSE BEGIN																						UseResFile(AppRezFile);	 			{Point back to the AppRezFile for fail		}									DisposePtr(Ptr(tPlug));								END;								IF (PlugInIndx>MaxFilePlugins) THEN leave;	{if we run out of slots, don't process anymore	}							UNTIL (BadPlugNoFind);						END;					END;					IF (PlugInIndx>MaxFilePlugins) THEN leave;			{if we run out of slots, don't process anymore	}				UNTIL (ioFDirIndex<=0);								{¥9¥ Done											}			END;		END;	END;	IF ((gInFilePlugIns[1]<>NIL) OR (gExFilePlugIns[1]<>NIL)) THEN BEGIN		gFileCurrentPlugIn:=1;	END ELSE BEGIN		gFileCurrentPlugIn:=0;	END;END;(*FUNCTION MyDlgHook(item: integer; GetSelection: DialogPtr; myDataPtr: Ptr): Integer;VAR	MyType		: Integer;	MyHandle	: Handle;	MyRect		: Rect;	MyIgnore	: Integer;	{mult_f		: boolean;}CONST	MyItem = 12;BEGIN	myDataPtr := @mult_file;	MyDlgHook := item;	IF GetWRefCon(WindowPtr(GetSelection)) <> LongInt(sfMainDialogRefCon) THEN Exit(MyDlgHook);	CASE item OF		sfHookFirstCall:			BEGIN			  GetDialogItem(GetSelection, MyItem, MyType, MyHandle, MyRect);			  SetControlValue(ControlHandle(MyHandle), gCurrentType);			  MyDlgHook := sfHookNullEvent;			END;		MyItem:			BEGIN			  {GetDialogItem(GetSelection, item, MyIgnore, MyHandle, MyRect);			  MyType := GetControlValue(ControlHandle(MyHandle));			  IF MyType <> gCurrentType THEN			    BEGIN			      gCurrentType := MyType;			      MyDlgHook := sfHookRebuildList;			    END;}			  mult_file := true;			  MyDlgHook := sfHookNullEvent;			END;		OTHERWISE			;	END;END;*)	    FUNCTION PGetAnotherFileName(VAR Name: Str63; VAR VolumeRef: integer): Boolean;    VAR      GetFileDialogID				: integer;      where                         : Point;      mytype                     	: OSType {SFTypeList};	{¥¥¥¥this must be a typelist¥¥¥¥}      sfPtr                         : ConstSFTypeListPtr;      GotType                       : OSType;	  reply                         : SFReply {StandardFileReply};	  errCode                       : OSErr;	  GetSelection                  : DialogPtr;    {Pointer to this dialog}	  {MyDlgHook						: DlgHookProcPtr;}	  ignorstring					: Str255;	  My_Spec						: FSSpec;    BEGIN      IF (gFirstTime) then begin		  GetSelection := GetNewDialog(2511, NIL, Pointer( - 1));	      GetFileDialogID := 2511;		  CenterDialog(GetSelection, FALSE, where);	      ignorstring := '';	      mytype := 'TEXT';		{THIS MUST BE A TYPE LIST}	      sfPtr := @mytype;	      SFPGetFile(where, ignorstring, NIL, 1, sfPtr, NIL {MyDlgHook}, reply, GetFileDialogID, NIL {@DefaultFilter});	      nextime := false;	      IF (mult_file) then begin		      sav_volref := reply.vRefNum;		      fil_nam := reply.fName;		      {GotType := reply.ftype;}		      gFirstTime := false;		      nextime := true;	      end;	  end;		if mult_file then begin			{putmessage('mult_file is true.','','','');}			if nextime then begin				nextime := false;		        errCode := FSMakeFSSpec(sav_volref,0,fil_nam,My_Spec);		        paramBlock.ioVRefNum := My_Spec.vRefNum; {needs vol ref num}		        paramBlock.ioNamePtr := @fil_nam; {file name found}				paramBlock.ioFDirIndex := 0; {start of index to first file}				sav_dirID := My_Spec.parID;				paramBlock.ioDirID := sav_dirID; 		        errCode := PBHGetFInfoSync(@paramBlock); {finds the file}			end;	        	  {This should get a good file but must check to see if it is the correct type}	        	        IF ({(paramBlock.ioFlFndrInfo.fdtype = GotType) AND} NOT (paramBlock.ioFlFndrInfo.fdcreator = 'DTSA')) THEN	         BEGIN	          {err := PBHGetFInfoSync(@paramBlock);}		      paramBlock.ioFDirIndex := paramBlock.ioFDirIndex + 1;		      paramBlock.ioDirID := sav_dirID;	          err := PBHGetFInfoSync(@paramBlock);	          if err = 0 then begin	          	{errCode := PBMakeFSSpecSync(@paramBlock);}	          	{BlockMove(@paramBlock.ioMisc, @In_File_Spec, Sizeof(In_File_Spec));}	          	{In_File_Spec := paramBlock.ioMisc;}	          	Name := paramBlock.ioNamePtr^;	          	VolumeRef := sav_volref;	          	In_VolRefNum := sav_volref;	          	errCode := FSMakeFSSpec(VolumeRef,0,Name,In_File_Spec);	          	PGetAnotherFileName := true;	          end	          else begin	          	PGetAnotherFileName := false;	          	exit(PGetAnotherFileName);	          end;			 END;		{return the good data here until there are no more files}			end		else begin			{putmessage('mult_file is false.','','','');}	      IF reply.good THEN	        BEGIN	          Name := reply.fname;	          GotType := reply.ftype;	          VolumeRef := reply.vRefNum;			  In_VolRefNum := reply.VRefNum;			  errCode := FSMakeFSSpec(VolumeRef,0,Name,In_File_Spec);		{Set up the file spec (FSSpec}	        END;	      PGetAnotherFileName := reply.good;	    end;    END;	  PROCEDURE POutlineButton (theDialog: DialogPtr; itemNo, CornerRad: Integer);   { Draws a border around a button. 16 is the normal cornerRad for small buttons }    VAR      itemType                      : integer;      itemBox                       : rect;      itemHdl                       : Handle;      tempPort                      : GrafPtr;    BEGIN      GetPort(tempPort);      SetPort(theDialog);      GetDialogItem(theDialog, itemNo, itemType, itemHdl, itemBox);      PenSize(3, 3);      InSetRect(itemBox, - 4, - 4);      FrameRoundRect(itemBox, CornerRad, CornerRad);      PenSize(1, 1);      SetPort(tempPort);    END;    PROCEDURE eV_Options;      CONST                                           {Dialog item numbers from resource fork}        B_OK                      = 1;        B_Cancel                  = 2;        B_eV_Channel		      = 5;        B_Shift_Channels          = 6;        B_eV_Use_it               = 9;        B_Shift_Use_it            = 10;        B_mult_file				  = 11;		      VAR        ExitDialog			          : Boolean;        GetSelection                  : DialogPtr;    {Pointer to this dialog}        tempRect                      : Rect;        DType                         : integer;        DItem                         : Handle;        CItem			              : controlhandle;        sTemp,str                     : str255;        itemHit                       : integer;        temp	                      : integer;		where						  : point;      BEGIN        GetSelection := GetNewDialog(525, NIL, Pointer( - 1));		CenterDialog(GetSelection, TRUE, where);        ShowWindow(GetSelection);        SelectWindow(GetSelection);        GetDialogItem(GetSelection, B_eV_Channel, DType, DItem, tempRect);        RealToString(10.0, 8, 2, str);        SetDialogItemText(DItem, str);        GetDialogItem(GetSelection, B_Shift_Channels, DType, DItem, tempRect);        numToString(0, str);        SetDialogItemText(DItem, str);        GetDialogItem(GetSelection, B_eV_Use_it, DType, DItem, tempRect);        SetControlValue(controlhandle(DItem), 0); { turn off the "use this value" check box }        GetDialogItem(GetSelection, B_Shift_Use_it, DType, DItem, tempRect);        SetControlValue(controlhandle(DItem), 0); { turn off the "use this value" check box }        GetDialogItem(GetSelection, B_mult_file, DType, DItem, tempRect);        SetControlValue(controlhandle(DItem), 0); { turn off the "multiple file" check box }		POutlineButton(GetSelection, 1, 16); { outline the accept button }        Overide_the_eV := false;        temp_eV := 10.0 {InPtr^.Expt_Info.dE};        ExitDialog := false;		WDS_Convert_only_X_axis := TRUE;		Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.WDS_in_eV := TRUE;		gFirstTime := true;		mult_file := false;		        REPEAT          ModalDialog(NIL, itemHit);          GetDialogItem(GetSelection, itemHit, DType, DItem, tempRect);          CItem := controlhandle(DItem);          IF (itemHit = B_Cancel) THEN            BEGIN              ExitDialog := true;			  Overide_the_eV := false;			  Do_a_Shift := false;            END;			          IF (itemHit = B_OK) THEN            BEGIN              ExitDialog := true;            END;			          IF (itemHit = B_eV_Channel) THEN            BEGIN              GetDialogItem(GetSelection, B_eV_Channel, DType, DItem, tempRect);              GetDialogItemText(DItem, sTemp);              IF (MYstr2num(sTemp) <= 0.0) OR (Mystr2num(sTemp) >= 200.0) THEN                BEGIN                  RealToString(10.0, 8, 2, str);                  SetDialogItemText(DItem, str);                END;            END;          IF (itemHit = B_eV_Use_it) THEN            BEGIN              temp := GetControlValue(CItem);              SetControlValue(CItem, (temp + 1) MOD 2);              IF (temp = 1) THEN                BEGIN                  Overide_the_eV := false;                  temp_eV := Plt_spec[10]^^.Expt_Info.dE;                END              ELSE                BEGIN                  Overide_the_eV := true;                  GetDialogItem(GetSelection, B_eV_Channel, DType, DItem, tempRect);                  GetDialogItemText(DItem, sTemp);                  temp_eV := Mystr2num(sTemp);                  Plt_spec[10]^^.Expt_Info.dE := temp_eV;                END;            END;          IF (itemHit = B_Shift_Use_it) THEN            BEGIN              temp := GetControlValue(CItem);              SetControlValue(CItem, (temp + 1) MOD 2);              IF (temp = 1) THEN                BEGIN                  Do_a_Shift := false;                  temp_Shift := 0;                END              ELSE                BEGIN                  Do_a_Shift := true;                  GetDialogItem(GetSelection, B_Shift_Channels, DType, DItem, tempRect);                  GetDialogItemText(DItem, sTemp);                  temp_Shift := rinttol(Mystr2num(sTemp));                END;            END;                    IF (itemHit = B_mult_file) THEN          	BEGIN          		temp := GetControlValue(CItem);          		SetControlValue(CItem, (temp + 1) MOD 2);          		IF (temp = 0) THEN mult_file := true          		else mult_file := false;          	END;        UNTIL ExitDialog;		          IF Overide_the_eV THEN { in case more than one choice typed in }            BEGIN              GetDialogItem(GetSelection, B_eV_Channel, DType, DItem, tempRect);              GetDialogItemText(DItem, sTemp);              temp_eV := Mystr2num(sTemp);            END;          IF Do_a_Shift THEN { in case more than one choice typed in }            BEGIN              GetDialogItem(GetSelection, B_Shift_Channels, DType, DItem, tempRect);              GetDialogItemText(DItem, sTemp);              temp_Shift := rinttol(Mystr2num(sTemp));            END;		  GetDateTime(Plt_spec[10]^^.SpectrumStuff.Acq_Info.Begin_Time);				tempRect := GetSelection^.portRect;        DisposeDialog(GetSelection);		      	FillWhiteSpace(tempRect);        Mouse_Active_Window;      END; { End of procedure }  PROCEDURE FSetNumChan_Button(n: integer);    BEGIN      IF (n > 0) AND (n <= 256) THEN Range_Keeper := 5      ELSE        IF (n > 256) AND (n <= 512) THEN Range_Keeper := 6        ELSE          IF (n > 512) AND (n <= 1024) THEN Range_Keeper := 7          ELSE            IF (n > 1024) AND (n <= 2048) THEN Range_Keeper := 8            ELSE              IF (n > 2048) AND (n <= 4096) THEN Range_Keeper := 9              ELSE IF (n > 4096) AND (n <= Maximum_Channels) THEN Range_Keeper := 10;      n := 2 ** (Range_Keeper - 5);      Spectrum_Size := 256 * n;      New_Range := Spectrum_Size;      ChannelMax := Spectrum_Size;      ChannelMin := 1;      Plt_spec[10]^^.Expt_Info.Number_of_Channels := Spectrum_Size;    END;(*Lay out of the new file handling procedure. When this procedure is called, it will:	1. Get a DTSA file name.	2. Create the DTSA file.	2a. Select shift & eV.	3. Select a file to read.	4. Open the file.	5. The plug-in will read the file and:		a. Check for line-feeds.		b. Eliminate them if necessary.		c. Put the data into the common data structure.	6. Close the file.	7. Transfer the common data to Plt_Spec[10].	8. Open the DTSA file.	9. Write Plt_Spec[10] to the DTSA file.	10. Close the DTSA file.	11. Loop back to 3 if the plug-in message requires it.	12. End.We will try to do this in one routine instead of the multiple routines used by Tools2.p. *)PROCEDURE Calc_TOA_Angle;    VAR      a, B, c, X, y, az, E, Z, beam_ang       : real {double_t};    BEGIN		WITH Plt_spec[10]^^.Expt_Info DO begin	      az := Azimuth / (360 / Pi2);	      X := Plt_Spec[10]^^.SpectrumStuff.Spectrum_Info.X_Tilt / (360 / Pi2);	      y := Plt_Spec[10]^^.SpectrumStuff.Spectrum_Info.Y_Tilt / (360 / Pi2);	      E := Elevation / (360 / Pi2);	      a := Cos(X) * Cos(y) * Cos(az) * Cos(E);	      B := Cos(X) * Cos(y) * Sin(az) * Cos(E);	      c := Sin(y) * Cos(az) * Cos(E) + Sin(X) * Cos(y) * Cos(E) * Sin(az);	      Z := (Sin(y) * Cos(az) * Cos(E) + Sin(X) * Cos(y) * Cos(E) * Sin(az)) / sqrt(a * a + B * B + c * c);	      { Geom.Beam_Entry_Angle is in the plane of the beam and detector }	      beam_ang := 2 * ArcTan(sqrt((1 - Z) / (1 + Z))) * (360 / Pi2);	      Plt_Spec[10]^^.SpectrumStuff.Spectrum_Info.Take_Off_Angle := Elevation + 90.0 - beam_ang;		end;	END;PROCEDURE	Load_the_Current_Data(IOPtr: IOPlugPtr);  VAR  	nn			: integer;BEGIN	WITH Plt_spec[10]^^.Expt_Info DO begin		IOPtr^.dE := dE;		IOPtr^.kV := kV;		IOPtr^.Number_of_Channels := Number_of_Channels;		IOPtr^.Energy_Slope := Energy_Slope;		IOPtr^.Energy_Intercept := Energy_Intercept;		IOPtr^.D_Azimuth := Azimuth;		IOPtr^.D_Elevation := Elevation;		IOPtr^.Title_Comment_Field := Specimen_Comment_Field;		IOPtr^.T_Be_Wind := Be_Thickness;		IOPtr^.T_Au_Wind := Au_Thickness;		IOPtr^.T_Al_Wind := Al_Thickness;		IOPtr^.T_Py_Wind := 0.0;		IOPtr^.T_BN_Wind := BN_Thickness;		IOPtr^.T_Di_Wind := Diamond;		IOPtr^.T_HC_Wind := Mylar;		IOPtr^.T_Dead_Layr := Si_Thickness;		IOPtr^.T_Act_Layr := Detector_Thickness;		IOPtr^.Mn_FWHM := Si_Resolution;		IOPtr^.Owner := Analyst;		IOPtr^.D_Solid_Angle := 0.0;			END;	{WITH}		WITH Plt_Spec[10]^^.SpectrumStuff.Acq_Info DO begin		IOPtr^.Begin_Faraday := Begin_Faraday;		IOPtr^.End_Faraday := End_Faraday;		IOPtr^.FirstValue := FirstValue;		IOPtr^.EndValue := EndValue;		IOPtr^.Real_Time := Real_Time;		IOPtr^.Live_Time := Live_Time;		IOPtr^.FirstChannel := FirstChannel;		IOPtr^.LastChannel := LastChannel;	END;		WITH Plt_Spec[10]^^.SpectrumStuff.Spectrum_Info DO begin		IOPtr^.Spectrum_Type := Spectrum_Type;		IOPtr^.S_Thickness := Specimen_Thickness;		FOR nn := 1 TO Maximum_Channels DO			 IOPtr^.Spec_cts[nn] := 0.0;		IOPtr^.X_Tilt := X_Tilt;		IOPtr^.Y_Tilt := Y_Tilt;		IOPtr^.Specimen_Comment_Field := Spectrum_Comment_Field;	END;END;	{Load_the_Current_Data}PROCEDURE	Write_ASCII_File(IOPtr: IOPlugPtr);  VAR  	nn			: integer;BEGIN	Load_the_Current_Data(IOPtr);		WITH Plt_Spec[10]^^.SpectrumStuff.Spectrum_Info DO begin		FOR nn := 1 TO IOPtr^.Number_of_Channels DO			 IOPtr^.Spec_cts[nn] := Plt_spec[10]^^.S[nn];	END;END;	{Write_ASCII_File}PROCEDURE Do_ASCII_Files(counter: Integer; The_File_name: Str63; IOPtr: IOPlugPtr);	VAR		nn, kk			: integer;		bytecount		: longint;		IValue			: longint;		err				: OSErr;		out_refNum		: integer;BEGIN				{Load the data into the WORK spectrum (Plt_Spec[10]}		WITH Plt_spec[10]^^.Expt_Info DO begin			dE := IOPtr^.dE;			  {RealToString(IOPtr^.dE, 8, 2, str);			  PutMessage('dE is the slope ', str, '', '');}			kV := IOPtr^.kV;			Number_of_Channels := IOPtr^.Number_of_Channels;			Energy_Slope := IOPtr^.Energy_Slope;			Energy_Intercept := IOPtr^.Energy_Intercept;			{IF IOPtr^.PlugInName = 'Read MSA 1.0 Format' then begin}				Azimuth := IOPtr^.D_Azimuth;				Elevation := IOPtr^.D_Elevation;				Specimen_Comment_Field := IOPtr^.Title_Comment_Field;				Si_Resolution := IOPtr^.Mn_FWHM;				Analyst := IOPtr^.Owner;			Be_Thickness := IOPtr^.T_Be_Wind;			Au_Thickness := IOPtr^.T_Au_Wind;			Al_Thickness := IOPtr^.T_Al_Wind;			BN_Thickness := IOPtr^.T_BN_Wind;			Diamond := IOPtr^.T_Di_Wind;			Mylar := IOPtr^.T_HC_Wind;			Si_Thickness := IOPtr^.T_Dead_Layr;			Detector_Thickness := IOPtr^.T_Act_Layr;			Si_Resolution := IOPtr^.Mn_FWHM;			{end;}		END;	{WITH}		WITH Plt_Spec[10]^^.SpectrumStuff.Acq_Info DO begin			Begin_Faraday := IOPtr^.Begin_Faraday;			End_Faraday := IOPtr^.End_Faraday;			FirstValue := IOPtr^.FirstValue;			EndValue := IOPtr^.EndValue;			Real_Time := IOPtr^.Real_Time;			Live_Time := IOPtr^.Live_Time;			FirstChannel := IOPtr^.FirstChannel;			LastChannel := IOPtr^.LastChannel;			X_Position := IOPtr^.X_Pos;			Y_Position := IOPtr^.Y_Pos;		END;	WITH Plt_Spec[10]^^.SpectrumStuff.Spectrum_Info DO begin	  	Number_of_Elements := 0;		Spectrum_Type := IOPtr^.Spectrum_Type;		  FOR nn := 1 TO 15 DO			BEGIN { stuff in what's in the record }			  Element_Info[nn].Atomic_Number := 0;			  Element_Info[nn].Valence := 0;			  Element_Info[nn].Weight_Fraction := 0.0;							 			END;		Specimen_Thickness := IOPtr^.S_Thickness;		FOR nn := 1 TO IOPtr^.Number_of_Channels DO			Plt_spec[10]^^.S[nn] := IOPtr^.Spec_cts[nn];		nn := IOPtr^.Number_of_Channels;		FSetNumChan_Button(nn);		{¥¥n is number of channels¥¥}		UpDate_Max_Min(10);		X_Tilt := IOPtr^.X_Tilt;		Y_Tilt := IOPtr^.Y_Tilt;		Spectrum_Number := counter;		Spectrum_Comment_Field := CONCAT(The_File_name,': ');		Spectrum_Comment_Field := CONCAT(Spectrum_Comment_Field,IOPtr^.Specimen_Comment_Field);		BkgSubtracted := false;		this_is_a_standard := false;		Average_Z := 0.0;		WDS_Convert_only_X_axis := FALSE;		WDS_in_eV := FALSE;		Theoretically_Generated := FALSE;	end;	{WITH}		Calc_TOA_Angle;		{Shift spectrum and set the eV/channel}		IF Overide_the_eV THEN Plt_spec[10]^^.Expt_Info.dE := temp_eV;		IF Do_a_Shift THEN		  BEGIN			FOR nn := 1 TO Maximum_Channels DO			  col_1^[nn] := 0.0;			FOR nn := 1 TO Maximum_Channels DO			  BEGIN				kk := nn;				IF (kk + temp_Shift > 0) AND (kk + temp_Shift <= 8192) THEN col_1^[kk] := Plt_spec[10]^^.S[kk + temp_Shift];			  END;			BlockMove(@col_1^, @Plt_spec[10]^^.S, sizeof(Plt_spec[10]^^.S));		  END;		IValue := IOPtr^.NDoffset;		{ This is for ND offsets }		if IValue <> 0 then begin          FOR nn := 1 TO Maximum_Channels DO            BEGIN              kk := nn;              IF kk <= 1 THEN kk := 1;              IF kk >= 8192 THEN kk := 8192;              IF (kk + IValue > 0) AND (kk + IValue <= 8192) { IValue is the ND "offset"}                 THEN                col_1^[kk] := Plt_spec[10]^^.S[kk + IValue];            END;          BlockMove(@col_1^, @Plt_spec[10]^^.S, sizeof(Plt_spec[10]^^.S));		END;				WITH Outreply DO begin			err := FSpOpenDF(sfFile, fsRdWrPerm, out_refNum);			if sfReplacing then				if counter = 1 then				  err := SetFPos(out_refNum, fsFromstart, 0);			GetDateTime(Plt_spec[10]^^.SpectrumStuff.Acq_Info.Begin_Time);			IF (counter > 1) THEN { write only new spectrum info and counts }			BEGIN			  Restore_Expt_Header(out_refNum);			  err := SetFPos(out_refNum, fsfromLEOF, 0);			  bytecount := sizeof(Spectrum_Structure);			  err := FSWrite(out_refNum, bytecount, @Plt_spec[10]^^.SpectrumStuff);			  bytecount := longint(Plt_spec[10]^^.Expt_Info.Number_of_Channels) * 4;			  err := FSWrite(out_refNum, bytecount, @Plt_spec[10]^^.S);			END			ELSE			IF (counter = 1) THEN { write a complete Work_spectrum }			  BEGIN				err := SetFPos(out_refNum, fsFromstart, 0);				bytecount := sizeof(Work_spectrum) - sizeof(Spectrum_Counts) + longint(Plt_spec[10]^^.Expt_Info.																					   Number_of_Channels) * 4;				err := FSWrite(out_refNum, bytecount, @Plt_spec[10]^^);			  END;			err := FSClose(out_refNum);			err := FlushVol(NIL, vRefNum);	END;	{WITH}END;      {Do_ASCII_Files}   						PROCEDURE Load_New_Spectra(counter: Integer);  VAR  	bytecount			: longint;	out_refNum			: integer;	err					: OSErr;	in_refNum			: integer;			BEGIN		WITH Outreply DO begin          {¥¥¥ next 6 lines update Expt_Info.LastSpect in Expt_Info header ¥¥¥}          err := FSpOpenDF(sfFile, fsRdWrPerm, out_refNum);          Plt_spec[10]^^.Expt_Info.LastSpect := counter;          err := SetFPos(out_refNum, fsFromstart, 0);          bytecount := sizeof(Expt_InfoRec);          err := FSWrite(out_refNum, bytecount, @Plt_spec[10]^^.Expt_Info);          err := FSClose(out_refNum);          err := FlushVol(NIL, vRefNum);          MCA_Spectrum_Active := true;          (*save_bool := MCA_Spectrum_Active;*)          { Read A spectrum back from the newly written file }          (*err := FSOpen_err(RdBinaryName, Binary_VolNum_Read, refnum, '');*)		  		  Read_DTSA_Spec := Write_DTSA_Spec;		  err := FSpOpenDF(Read_DTSA_Spec, fsRdWrPerm, in_refNum);          IF err = NoErr THEN             BEGIN			                bytecount := sizeof(Expt_InfoRec);              err := SetFPos(in_refNum, fsFromstart, 0);              err := FSRead(in_refNum, bytecount, @Plt_spec[10]^^.Expt_Info);              Displayed_Fst := Plt_spec[10]^^.Expt_Info.FirstSpec;              Displayed_Lst := Plt_spec[10]^^.Expt_Info.LastSpect;              err := SetFPos(in_refNum, fsFromstart, 0);              bytecount := sizeof(Work_spectrum) - sizeof(Spectrum_Counts) + 			  longint(Plt_spec[10]^^.Expt_Info.Number_of_Channels) * 4;              err := FSRead(in_refNum, bytecount, @Plt_spec[10]^^);              Spectrum_Counter := Plt_spec[10]^^.Expt_Info.FirstSpec;              Spec_Displayed := Spectrum_Counter;              { always end with this set to the # of spectrum displayed }              saved_displayed := true;            END;          err := FSClose(in_refNum);          err := FlushVol(NIL, Read_DTSA_Spec.vRefNum);          Spectrum_Full[10] := true;          CheckItem(FullMenu, A^.C_Full[10], Spectrum_Full[10]);          Refresh_ROIs;		  BeginUpdate(BackPlane);		  DrawAxesFull;		  Update_Full;		  EndUpdate(BackPlane);		  Reset_Range_Buttons;          SpecWork_has_been_Changed := true;		END;	{WITH}	END;		{Load_New_Spectra}END.