 {[j=30/55,:+,u+,r+,o=100,d-,k+,n+,#+,v+,q+,b+]}{[f-]}{*********************************} UNIT CurveFit ;{*********************************}{**********************************} INTERFACE {**********************************} USES QuickDraw, QuickdrawText, Types, OSUtils, ToolUtils, Timer, Errors, Menus, Files, Lists, Memory, TextUtils, TextEdit, Finder,  Dialogs, Packages, Printing, StandardFile, Retrace, SegLoad, Spectrum_Structures, Controls, Events, Windows,   Declarations, XRay, INITIALIZE, Xray_Energies, Global_Functions, Utilities, SANDIA, fenv, fp ,Script;     PROCEDURE WriteBinaryResults;    PROCEDURE MakeBinaryResults;	PROCEDURE CFirst_Derivative(VAR ntodo:integer; VAR Din, Dout: realWindowArray);     PROCEDURE CSecond_Derivative(VAR ntodo:integer; VAR Din, Dout: realWindowArray);    PROCEDURE Open_Text_Window;    PROCEDURE Update_Text_Window(whichWindow: WindowPtr);    PROCEDURE Close_Text_Window(whichWindow: WindowPtr; VAR theInput: TEHandle);    PROCEDURE Simplex_Output_Handler(Which_Output: integer);		    PROCEDURE Init_Text_Window;    PROCEDURE Do_Text_Window(myEvent: EventRecord);    PROCEDURE GLfit(VAR Y_in_Data,					   sig            : WindowArrayHdl;	{handles to double_t}	                   X_In_Data	  : WindowHdlArray; {array of handles to extendeds}				       ndata          : integer;    { Num_fit_chans }                   VAR Answer         : LinFitExtArray; 				       nfit           : integer;   {Pass in the poly order or number of 					                                          reference spectra; LinFitExtArray = 															  array [1..Max_Num_Terms] of double_t}                       do_me          : LinFitIntArray; 					   mfit           : integer;     {Pass in the poly order or number of reference                                                                spectra}                   VAR covar          : LinFitCovArray;   { sqrt(covar[i,i]) is the Std 				                                                      dev of each fitted term i }                       ncvm           : integer; 				   VAR chisq          : real {double_t});    {¥¥note that the eqn for chisq was changed 3/11/94}    PROCEDURE Lfit( Y_in_Data,					sig            : WindowArrayHdl;	{handles to double_t}	                X_In_Data	   : WindowHdlArray; {array of handles to double_ts}				    ndata          : longint {integer};    { Num_fit_chans }				    nfit           : longint {integer};   {Pass in the poly order or number of 					                                          reference spectra; LinFitExtArray = 															  array [1..Max_Num_Terms] of double_t}                    {do_me          : LinFitIntArray;}                    VAR covar          : LinFitCovArray;   { sqrt(covar[i,i]) is the Std 				                                                      dev of each fitted term i }                   VAR Answer         : LinFitExtArray; 				   VAR chisq          :  real {double_t});		(*PROCEDURE gaussj(VAR Answer: LinFitCovArray; 	                     n, np: integer; 					 VAR B: LinFitVarArray; 					     M, mp: integer);*)	PROCEDURE gaussj( n	: longint {integer}; 					 VAR Answer: LinFitCovArray; 					 VAR B:  LinFitVarArray);					 	PROCEDURE lubksb(VAR a: LinFitCovArray{RealArrayNPbyNP};                     n: integer;              VAR indx: LinFitIntArray{IntegerArrayNP};                 VAR b: LinFitExtArray{RealArrayNP});	PROCEDURE ludcmp(VAR a: LinFitCovArray{RealArrayNPbyNP};                     n: integer;              VAR indx: LinFitIntArray{IntegerArrayNP};                 VAR d: real);                 					     PROCEDURE Read_Spectrum; 	PROCEDURE D_Results_Options;	PROCEDURE DO_Correction_String;	PROCEDURE AutoROI_Data( Atomic_Number, Family : Integer);	PROCEDURE AutoROI_Chooser;     {******************************} IMPLEMENTATION {**********************************}{ UNIT Globals }{$S CurveFit1}	const		Smplx_Return                  = 19659;		Smplx_Els_Proceed             = 1;		Smplx_Els_Major_Peaks_Only    = 2;		Smplx_Els_Medium_Peaks_too    = 3;		Smplx_Els_Smallest_Peaks_too  = 4;		Smplx_Els_Clear_all_entries   = 5;		{[f+]}  VAR    ExitDialog                    : boolean;    errcode                       : OSErr;    refnum                        : integer;    f                             : text;	ROI_Line_Energy               : ARRAY [1..155] OF real; 	MaxEng, MinEng                : ARRAY [1..Max_ROIs] OF real;    {===========================================================}{$S CurveFit2}  PROCEDURE AutoROI_Data( Atomic_Number, Family : Integer);    VAR        mm, nn, JJ, kk, ii       : integer;		HiHold, LoHold, HighestEnergy       : Real;		sigma3, MN      : Real;		 str		  :str255;    begin        FOR nn := 1 TO 155 DO ROI_Line_Energy[nn] := 0.0;        FOR nn := 1 TO Max_ROIs DO		begin			MaxEng[nn] := 0.0;			MinEng[nn] := 0.0;		end;        Get_Energies(Atomic_Number);		With Plt_spec[10]^^.Expt_Info do 			HighestEnergy := ( Number_of_channels * dE - energy_intercept)/energy_slope;        		nn := 1;		    if Family = 1 then			begin			 FOR ii := 1 to 3 do             if eV_Line[ii] > 100 then begin ROI_Line_Energy[nn] := eV_Line[ii]; nn := nn + 1; end;             IF WDS_active THEN 			 BEGIN			 FOR ii := 4 to 7 do             if eV_Line[ii] > 100 then begin ROI_Line_Energy[nn] := eV_Line[ii]; nn := nn + 1; end;			 FOR ii := 77 to 100 do             if eV_Line[ii] > 100 then begin ROI_Line_Energy[nn] := eV_Line[ii]; nn := nn + 1; end;			 END; 			end;					    if Family = 2 then			begin						 FOR ii := 11 to 15 do              if eV_Line[ii] > 100 then begin ROI_Line_Energy[nn] := eV_Line[ii]; nn := nn + 1; end;			  ii := 24;             if eV_Line[ii] > 100 then begin ROI_Line_Energy[nn] := eV_Line[ii]; nn := nn + 1; end;			 FOR ii := 28 to 29 do              if eV_Line[ii] > 100 then begin ROI_Line_Energy[nn] := eV_Line[ii]; nn := nn + 1; end;			 FOR ii := 31 to 33 do              if eV_Line[ii] > 100 then begin ROI_Line_Energy[nn] := eV_Line[ii]; nn := nn + 1; end;			  ii := 35;             if eV_Line[ii] > 100 then begin ROI_Line_Energy[nn] := eV_Line[ii]; nn := nn + 1; end;			 FOR ii := 37 to 43 do              if eV_Line[ii] > 100 then begin ROI_Line_Energy[nn] := eV_Line[ii]; nn := nn + 1; end;			 FOR ii := 45 to 47 do              if eV_Line[ii] > 100 then begin ROI_Line_Energy[nn] := eV_Line[ii]; nn := nn + 1; end;			  ii := 49;             if eV_Line[ii] > 100 then begin ROI_Line_Energy[nn] := eV_Line[ii]; nn := nn + 1; end;			               IF WDS_active THEN 			 BEGIN			 FOR ii := 8 to 10 do              if eV_Line[ii] > 100 then begin ROI_Line_Energy[nn] := eV_Line[ii]; nn := nn + 1; end;			 FOR ii := 16 to 17 do              if eV_Line[ii] > 100 then begin ROI_Line_Energy[nn] := eV_Line[ii]; nn := nn + 1; end;			 FOR ii := 20 to 23 do              if eV_Line[ii] > 100 then begin ROI_Line_Energy[nn] := eV_Line[ii]; nn := nn + 1; end;			 FOR ii := 25 to 27 do              if eV_Line[ii] > 100 then begin ROI_Line_Energy[nn] := eV_Line[ii]; nn := nn + 1; end;			  ii := 30;             if eV_Line[ii] > 100 then begin ROI_Line_Energy[nn] := eV_Line[ii]; nn := nn + 1; end;			  ii := 34;             if eV_Line[ii] > 100 then begin ROI_Line_Energy[nn] := eV_Line[ii]; nn := nn + 1; end;			  ii := 36;             if eV_Line[ii] > 100 then begin ROI_Line_Energy[nn] := eV_Line[ii]; nn := nn + 1; end;			  ii := 44;             if eV_Line[ii] > 100 then begin ROI_Line_Energy[nn] := eV_Line[ii]; nn := nn + 1; end;			  ii := 48;             if eV_Line[ii] > 100 then begin ROI_Line_Energy[nn] := eV_Line[ii]; nn := nn + 1; end;			 FOR ii := 50 to 52 do              if eV_Line[ii] > 100 then begin ROI_Line_Energy[nn] := eV_Line[ii]; nn := nn + 1; end;			 FOR ii := 101 to 135 do              if eV_Line[ii] > 100 then begin ROI_Line_Energy[nn] := eV_Line[ii]; nn := nn + 1; end;			 			 END;			end; 			 		    if Family = 3 then			begin			 			 FOR ii := 53 to 66 do              if eV_Line[ii] > 100 then begin ROI_Line_Energy[nn] := eV_Line[ii]; nn := nn + 1; end;			 FOR ii := 68 to 74 do              if eV_Line[ii] > 100 then begin ROI_Line_Energy[nn] := eV_Line[ii]; nn := nn + 1; end;              IF WDS_active THEN 			 BEGIN			  ii := 67;             if eV_Line[ii] > 100 then begin ROI_Line_Energy[nn] := eV_Line[ii]; nn := nn + 1; end;			 FOR ii := 136 to 143 do              if eV_Line[ii] > 100 then begin ROI_Line_Energy[nn] := eV_Line[ii]; nn := nn + 1; end;			 END;            end;        nn := nn - 1;	{...because it increments at ends of tests}  				MN := Plt_spec[10]^^.Expt_Info.Si_Resolution * Plt_spec[10]^^.Expt_Info.Si_Resolution; 	   if ((Family = 3) AND (eV_Line[72] > 100)) OR 	      ((Family = 2) AND (eV_Line[42] > 100))   OR 		  ((Family = 1) AND (eV_Line[1] > 100))   then	   begin		For JJ := 1 to nn do	{ nn is the number of lines in the family }		Begin		 (* IF Si_Active THEN sigma3  := 3.7*SQRT((2.5 * (ROI_Line_Energy[JJ] - 5895.0) + MN) * aSigConst);		  IF Ge_Active THEN sigma3  := 3.7*SQRT((2.5 * (ROI_Line_Energy[JJ] - 5895.0) + MN) * aSigConst);		  IF WDS_active THEN sigma3 := 3.7*SQRT(Plt_spec[10]^^.Expt_Info.WDS_Resolution * 										   Plt_spec[10]^^.Expt_Info.WDS_Resolution * aSigConst); *)										   		 IF (Plt_spec[10]^^.Expt_Info.Detector.Spec = EDS) THEN 		 		sigma3  := 3.7*SQRT((2.5 * (ROI_Line_Energy[JJ] - 5895.0) + MN) * aSigConst)		 ELSE IF (Plt_spec[10]^^.Expt_Info.Detector.Spec = WDS) THEN		 		sigma3 := 3.7*SQRT(Plt_spec[10]^^.Expt_Info.WDS_Resolution * 						Plt_spec[10]^^.Expt_Info.WDS_Resolution * aSigConst)		 ELSE begin		 		PutMessage('There is no spectrum information available.',' Regions cannot be set. Please cancel.','','');				Exit(AutoROI_Data);		 END;		  MaxEng[JJ] := ROI_Line_Energy[JJ] + sigma3;		  if MaxEng[JJ] > HighestEnergy then MaxEng[JJ] := HighestEnergy;		  MinEng[JJ] := ROI_Line_Energy[JJ] - sigma3*1.1;		  if MinEng[JJ] > HighestEnergy then MinEng[JJ] := HighestEnergy;				{MaxEng may equal MinEng and then the window is deleted below} 		End;	{for JJ := 1 to nn...}				{now have the end points of a window for each line in the family;		         for all elements below Fl they are identical CRT 9/18/95}		{CRT 9/20/95 if all the lines for the element have the same energies then nothing happens here...}		FOR kk := 1 TO nn DO { reorder the windows according to the energy of 							   the lower end point }		FOR JJ := kk+1 to nn do		begin		  if MinEng[kk] > MinEng[JJ] then		  begin			 LoHold := MinEng[kk];			 HiHold := MaxEng[kk];			 MinEng[kk] := MinEng[JJ];			 MaxEng[kk] := MaxEng[JJ];			 MinEng[JJ] := LoHold;			 MaxEng[JJ] := HiHold;			 if MaxEng[JJ] < MinEng[JJ] then putmessage('Trouble in the energy sorter, in AutoROI_Data, in SiLiWin.p','','','');		  end;		end;	{FOR kk := 1 TO nn...}		{ Now combine any that overlap, for this SINGLE element		and delete any that is outside the spectrum chs...}				kk := 1;    	mm := nn;	{nn is still the number of windows for the element}		Repeat		   if MaxEng[kk] <= MinEng[kk] then		   begin{eliminate this window}				FOR JJ := kk to mm-1 do				begin				   MaxEng[jj] := MaxEng[jj + 1];				   MinEng[jj] := MinEng[jj + 1];				end; {then do this test again: check the new kk roi, kk doesn't change}				nn := nn-1;	{one less window}		        mm := nn;	{ we deleted a window}		   end	       else kk := kk+1;	    Until kk >= nn;		if MaxEng[nn] <= MinEng[nn] then nn := nn-1; {delete this window}				{these two repeats have different end points...}            	mm := nn;	{nn is still the number of windows}		kk := 1;		if nn > 2 then 		Repeat		   if MaxEng[kk] > MinEng[kk + 1] then	{this will be true for Z<Fl}		   begin	{ combine kk + 1 and kk into kk }                MaxEng[kk] := MaxEng[kk + 1]; {eliminate roi[kk + 1]}				FOR ii := kk+1 TO mm-1 DO {renumber everybody > kk down one}				begin				  MaxEng[ii] := MaxEng[ii + 1];				  MinEng[ii] := MinEng[ii + 1];				end;	 				nn := nn-1;	{there is one less window}		        mm := nn;	{in case we deleted a window}		   end	{then compare the new MaxEng for the same kk to the MinEng of the new kk+1} 		   else kk := kk+1;	    Until kk >= nn - 1;	{if kk was 1 and nn was 2 and we eliminated one window then kk=nn}				{CRT 9/20/95...if nn was 2 and we eliminated one window, we can't do this...}     (* if MaxEng[nn-1] > MinEng[nn] then		begin		   MaxEng[nn-1] := MaxEng[nn];		   nn := nn-1;	{there is one less window}		end;	 *)	if (nn >1) then if (MaxEng[nn-1] > MinEng[nn]) then		begin		   MaxEng[nn-1] := MaxEng[nn];		   nn := nn-1;	{there is one less window}		end;		{auto_roi_chooser zeros all ROI info but sets Number_of_PeakRois to 1 so		 don't initialize the value here!!!}		kk:=0;		if nn > 0 then 		REPEAT		   kk := kk+1;		   if (rinttol(MinEng[kk]/Plt_spec[10]^^.Expt_Info.dE) >= 1) and 		      (rinttol(MaxEng[kk]/Plt_spec[10]^^.Expt_Info.dE) <=Maximum_Channels) then		   begin { Number_of_PeakRois is always the number that already exists + 1		   		   so start loading values at that counter}			 ROI^^.Peak[Number_of_PeakRois].Lo := rinttol(MinEng[kk]/Plt_spec[10]^^.Expt_Info.dE);			 ROI^^.Peak[Number_of_PeakRois].Hi := rinttol(MaxEng[kk]/Plt_spec[10]^^.Expt_Info.dE);			 ROI^^.Peak[Number_of_PeakRois].Value := zero;			 ROI^^.Peak[Number_of_PeakRois].Exists := TRUE;			 ROI^^.Peak[Number_of_PeakRois].ROI := Number_of_PeakRois;		   end;		   Number_of_PeakRois := Number_of_PeakRois + 1; {counter for next roi}		UNTIL (Number_of_PeakRois > Max_ROIs) or (kk = nn);				{Number_of_PeakRois is now 1 greater than actually defined but Simplex		 decrements the value. Does all the other code that uses this???}		if Number_of_PeakRois > Max_ROIs then 		begin		 NumtoString( Max_ROIs,str);		 Putmessage('Uh-Oh! I had to truncate the number of ROIs at',str,					'This is the maximum allowed.','Please check your fitting setup.');		end;       End; { if ((Family = 3) AND (eV_MA1_2 > 0)) OR...etc.....  }			      END; { PROCEDURE AutoROI_Data; }   PROCEDURE AutoROI_Chooser;	const   							{These are the item numbers for controls in the Dialog}		I_Accept = 1;	{Finished}		I_H = 3; { the rest of the element button numbers are in between H & Am }		I_Am = 97;		I_Clear_All = 104;		I_Help = 98;		I_Auto = 99;		{Check box}		I_Instruction = 100;		I_K_Family = 101;		I_L_Family = 102;		I_M_Family = 103;		I_Cancel = 2;		I_ClearFamily = 105;		I_SkipSome = 106;	{button for lines to pick}    TYPE	T_ROI       = ROI_Data_Structure;	    	var	        HoldFam	  : FamilyHdl;			Family : string[1];						Family_on : array[1..3,1..95] of boolean;			Manual_Z : array[1..95] of boolean; 		    ExitDialog, auto_chkd, change_made,change_skip : boolean;   			GetSelection: DialogPtr; 			tempRect: Rect;    		 			DType, itemHit, temp: Integer;    		 			DItem: Handle; 			 			CItem, CItem1	: controlhandle; 			sTemp		: Str255; 			  			I,kk,nn,JJ,ii,mm,nfams,fam      : Integer;			Temp_Roi : T_ROI;			line_selected	: Array [1..3] of boolean;			theHdlSize : Longint;    	PROCEDURE Refresh_Dialog;            BEGIN        SetPort(GetSelection);        GetDialogItem(GetSelection, I_Accept, DType, DItem, tempRect);        PenSize(3, 3);        InsetRect(tempRect, - 4, - 4);        FrameRoundRect(tempRect, 16, 16);        PenSize(1, 1);      END;	  	 	  Procedure Do_SkipWindow;	  	Var 			i			: integer;					Begin						for i := I_K_Family to I_M_Family do			begin				 GetDialogItem(GetSelection, i, DType, DItem, tempRect);				 CItem1 := controlhandle(DItem);				 ShowControl(CItem1);				 if i = fam+100 then SetControlValue(CItem1, 1)				 else SetControlValue(CItem1, 0); 			end;						 						for i := I_H to I_Am do {for Manual, turn on any eles NOT picked for the family;									 for Auto_roi, turn on eles picked for the family}				if manual_z[i-2] then				begin					GetDialogItem(GetSelection, i, DType, DItem, tempRect);					CItem1 := controlhandle(DItem);					HiliteControl(CItem1, 0);					If ((auto_chkd or (not Use_Manual_ROIs)) and Family_on[fam,i-2])					   or					   (Use_Manual_ROIs and (not auto_chkd) and (not Family_on[fam,i-2]))					   then HiliteControl(CItem1, 1);				end;		End;		{ procedure Do_SkipWindow;}			  Procedure WhichRoi_Dial;	  		const   									  I_OK = 1;	{Finished}		  I_Cancel = 2; { tells user what to do }		  I_FamilyTxt = 4;		  I_ListRois = 5;		  I_Inst = 6; { tells user what to do }	  	Var 			fam, n,JJ, i	: integer;			sTemp,ROIstr,str: Str255;			FamilyDone, cancel : boolean;			nROI	: real {double_t};   			theSelection: DialogPtr; 			DType, itemHit: Integer;    		 			DItem: Handle; 			 			CItem	: controlhandle; 				Begin	{Procedure WhichRoi_Dial}		  theSelection := GetNewDialog(136, nil, Pointer(-1)); 		  ShowWindow(theSelection); 		  SelectWindow(theSelection); 		  SetPort(theSelection);  	 						        SetPort(theSelection);        GetDialogItem(theSelection, I_OK, DType, DItem, tempRect);        PenSize(3, 3);        InsetRect(tempRect, - 4, - 4);        FrameRoundRect(tempRect, 16, 16);        PenSize(1, 1);		cancel := false;		 JJ := 0;		 REPEAT		  JJ := JJ + 1; 		  i := Periodic_picks[jj];		  fam := 0;		  Repeat		   fam := fam + 1;		   IF (NOT family_on[fam,i]) THEN	{this code deals with only lines skipped}		   BEGIN			if fam = 1 then sTemp := ' K' else if fam = 2 then sTemp :=  ' L' else sTemp :=  ' M';  			str := concat(a^.sym[i], sTemp);			sTemp := concat('Skip ',str,' lines in ROI(s)');			GetDialogItem(theSelection, I_FamilyTxt, DType, DItem, tempRect);			SetDialogItemText(DItem, sTemp);				GetDialogItem(theSelection, I_ListRois, DType, DItem, tempRect);			sTemp := 'All ROIs';			SetDialogItemText(DItem, sTemp);						FamilyDone := FALSE;			REPEAT				 ModalDialog(NewModalFilterProc(@DefaultFilter), itemHit);				 GetDialogItem(theSelection, itemHit, DType, DItem, tempRect);				 CItem := controlhandle(DItem);							 				 if (ItemHit = I_OK) then FamilyDone := TRUE;				 if (ItemHit = I_Cancel) then cancel := true;			UNTIL FamilyDone or cancel;			If FamilyDone then	{user hit OK} 			Begin		        skip_some := true;				GetDialogItem(theSelection, I_ListRois, DType, DItem, tempRect);				GetDialogItemText(DItem, sTemp);				n:=1;				If (Pos('All ROIs',sTemp) <> 0) or (Length(sTemp) = 0) then				Begin					   nfams := nfams + 1;					   theHdlSize := theHdlSize + sizeof(aFamily);					   SetHandleSize(Handle(SkipFam),theHdlSize);					   SkipFam^^[nfams].Z := i;					   SkipFam^^[nfams].Roi := 1000;	{skip the fam in all ROIS}					 (* for kk := 1 to 3 do SkipFam^^[nfams].skip_fam[kk] := false;					   SkipFam^^[nfams].skip_fam[fam] := true;  *)					   SkipFam^^[nfams].skip_fam := fam;				End				Else Repeat {make a skipFam for each ROI for each family}					ROIstr:='';					repeat					  if (ord(sTemp[n]) >47) and (ord(sTemp[n]) < 58) then					  ROIstr := concat(ROIstr,sTemp[n]);					  n := n+1;					until (ord(sTemp[n]) < 48) or (ord(sTemp[n]) > 57) or (n > Length(sTemp));					if Length(ROIstr) > 0 then	{...only numbers go into ROIstr}					begin					   nfams := nfams + 1;					   theHdlSize := theHdlSize + sizeof(aFamily);					   SetHandleSize(Handle(SkipFam),theHdlSize);					   SkipFam^^[nfams].Z := i;					   nROI:= MyStr2Num(ROIstr);					   SkipFam^^[nfams].Roi := rinttol(nROI);					 (*for kk := 1 to 3 do SkipFam^^[nfams].skip_fam[kk] := false;					   SkipFam^^[nfams].skip_fam[fam] := true;*)					   SkipFam^^[nfams].skip_fam := fam;					end;	{if nROI <> NAN...}				Until n > Length(sTemp);			End;	{If FamilyDone...}		   END;	{FOR fam := 1 to 3...IF family_on[fam,i]...}		  Until (fam = 3) or cancel;		 UNTIL (JJ = Number_of_Elements_Simplexed) or cancel;		 If Cancel then		 begin		   Skip_some := false;		 end;		  		  tempRect := theSelection^.portRect;		  DisposeDialog(theSelection);		  FillWhiteSpace(tempRect);		End;		{ procedure WhichRoi_Dial;}    PROCEDURE Deselect_Lines;		var			kk,numfams,mm,item,hititem      : Integer;	BEGIN   							 	{¥¥¥Note: the main part of this code defines manual_Z [i]. Family_on[l,Z] for	    l = 1 to 3 becomes true when a manual_Z [Z] is set true so that all families		are fit unless picked in DESELECT_LINES. In DESELECT_LINES if not Family_on[i,Z]		the element is hilighted when the family button = i. Button on => skip the		family.}				{¥¥¥¥¥¥¥¥¥¥¥¥¥Setup initial conditions...Deselect_Lines;¥¥¥¥¥¥¥¥¥¥¥¥¥}						sTemp := 'PLEASE skip only VERY low intensity lines. Pick family then elements. "OK" accepts choices; "CANCEL" restores old choices.';			GetDialogItem(GetSelection, I_Instruction, DType, DItem, tempRect);			SetDialogItemText(DItem, sTemp);			GetDialogItem(GetSelection, I_SkipSome, DType, DItem, tempRect);			HideControl(controlhandle(DItem));			GetDialogItem(GetSelection, I_Auto, DType, DItem, tempRect);			HideControl(controlhandle(DItem));						GetDialogItem(GetSelection, I_ClearFamily, DType, DItem, tempRect);			ShowControl(controlhandle(DItem));						GetDialogItem(GetSelection, I_Clear_All, DType, DItem, tempRect);			ShowControl(controlhandle(DItem));						Do_SkipWindow; 				ExitDialog := FALSE;		REPEAT	{...in Deselect_Lines;}			ModalDialog(NewModalFilterProc(@DefaultFilter), hititem);			GetDialogItem(GetSelection, hititem, DType, DItem, tempRect);			CItem := controlhandle(DItem);						{initial fam is set in calling routine...}				if (hititem >= I_H) and (hititem <= I_Am) {3 to 97, Z = 1 to 95} then			begin	{Remember in this dialog the elements ON are those to skip, family_on = F.}			   If (manual_z[hititem-2]) then begin				  GetDialogItem(GetSelection, hititem, DType, DItem, tempRect);				  CItem1 := controlhandle(DItem);				  if (Family_on[fam,hititem-2]) then {...don't skip so element is off  }				  begin					   HiliteControl(CItem1, 1); { turn on = skip in this dial}					   Family_on[fam,hititem-2] := false; {we compare SkipFam to this later}				  end				  else begin	{element is on = skip}					   HiliteControl(CItem1, 0); {is on, turn off = don't skip}					   Family_on[fam,hititem-2] := true;	{don't skip the family}				 end;	{if (Family_on[...}				 change_skip := true;			   End;	{If (manual_z[hititem-2])...}			end;	{if (hititem >= I_H) and...}						if (hititem >= I_K_Family) and (hititem <= I_M_Family) and			   (fam <> hititem-100) then	{if fam = hititem-100, nothing changes}			begin				  fam := hititem - 100;				  if hititem = I_K_Family then Family := 'K'				  else if hititem = I_L_Family then Family := 'L'				  else Family := 'M';			      Do_SkipWindow; {change selected family button, turn skip eles on}						end;	{if (hititem >= I_K_Family) and...}							if (hititem = I_ClearFamily) then {we're in Deselect_Lines}			begin	{ K,L, or M button on defines fam}			    for item := I_H to I_Am do if manual_z[item-2] then{turn off all els}				begin					GetDialogItem(GetSelection, item, DType, DItem, tempRect);					HiliteControl(controlhandle(DItem), 0);					Family_on[fam,item-2] := true; {none of this family fam will be skipped}				    change_skip := true;				end;			end;	{if (hititem = I_ClearFamily)...}							if (hititem = I_Clear_All) then {we're in Deselect_Lines}			begin			    for item := I_H to I_Am do if manual_z[item-2] then {turn off all els}				begin					GetDialogItem(GetSelection, item, DType, DItem, tempRect);					HiliteControl(controlhandle(DItem), 0);					for kk := 1 to 3 do Family_on[kk,item-2] := true; {all families fit}				    change_skip := true;				end;			end;	{ if (hititem = I_Clear_All)...}			if (hititem = I_Help) then				begin					Putmessage('Coming...', 'Yeah? So`s Christmas.', '', '');				end;			if (hititem = I_Cancel) then {go back to previous skip data}				begin				  If (skip_some) then				  Begin				    theHdlSize := GetHandleSize(Handle(HoldFam));				    numfams := theHdlSize div sizeof(aFamily);					For kk := 1 to 95 do if manual_z[kk] then					  for mm := 1 to 3 do family_on[mm,kk] := true;				    For mm := 1 to numfams do	{there is a HoldFam^^[mm].z...}					  with HoldFam^^[mm] do if manual_z[z] then	{HoldFam^^[mm].z}						 family_on[skip_fam,z] := false;						 {...DO NOT MAKE an else...:= True}				  End;	{If (skip_some)...}				  change_skip := false;				  ExitDialog := TRUE;				end;	{if (hititem = I_Cancel)...}						if (hititem = I_Accept) then ExitDialog := TRUE;				UNTIL ExitDialog;				ExitDialog := False; {so we don't EXIT the next dialog too} 	 		  if (change_skip) then		  begin	{so that if we return to this dialog without exiting the element dialog		         we'll have the new skip selections for highlighting}		     numfams := 0;		     if skip_some then DisposeHandle(Handle(HoldFam)); {...otherwise there was no HoldFam}		     HoldFam := FamilyHdl(NewHandle(0));			 theHdlSize := 0;			 for kk := 1 to 95 do			 if manual_z[kk] then		     for mm := 1 to 3 do if (not Family_on[mm,kk]) then			 begin			   numfams := numfams + 1;			   theHdlSize := theHdlSize + sizeof(aFamily);			   setHandleSize(Handle(HoldFam),theHdlSize);			   with HoldFam^^[numfams] do			   begin				z := kk;				skip_fam := mm;				Roi := 0;{...more code to get this later, don't know this here}			   end;	{with...}			 end;	{if manual_z...then... begin...}		  end;	{if (hititem = I_Accept) and change...}	END;     { procedure Deselect_Lines }	  	 	  procedure Do_window;	  	Var 			i,item	: integer;			sTemp: Str255; 			 					Begin		  		  for item := I_H to I_Am do {3 to 97...turn on current els}			  begin				  GetDialogItem(GetSelection, item, DType, DItem, tempRect);				  CItem1 := controlhandle(DItem);				  if manual_z[item-2] then HiliteControl(CItem1, 1)				  else HiliteControl(CItem1, 0);			  end;		  {the family buttons show for auto rois or skip_some...}		   If (Use_Manual_ROIs and (Not auto_chkd)) then 		   for i := I_K_Family to I_M_Family do		   begin				GetDialogItem(GetSelection, i, DType, DItem, tempRect);			    HideControl(controlhandle(DItem))				{...show when dialog changed to skip families or auto_roi form}   		   end		   else Do_SkipWindow;	{to show family butts and what's to do}					GetDialogItem(GetSelection, I_Auto, DType, DItem, tempRect);			CItem1 := controlhandle(DItem);			If (Use_Manual_ROIs) then			begin	{true if ROIS have been selected, ie, by sweeping or by AutoRois in SiliWindow}			    ShowControl(CItem1);	{show the auto check box}				if auto_chkd then SetControlValue(CItem1, 1) 				else SetControlValue(CItem1, 0);	{make AutoRois when chkd}			end			else HideControl(CItem1); {...if this is CALLED from Silwindow AutoRois or									   OK to "I`ll  make windows"}			GetDialogItem(GetSelection, I_Instruction, DType, DItem, tempRect);			if (Use_Manual_ROIs) and (not auto_chkd) then			begin				if skip_some then sTemp := 'Click element(s). Click "Skip Some" to SEE/CHANGE families to skip. Check "Do Auto ROIS" for DTSA Rois.'				else sTemp := 'Click element(s). Click "Skip Some" to pick families to skip. Check "Do Auto ROIS" for DTSA Rois.';			end			else sTemp := 'Select family FIRST then select element(s); next family, etc. ONLY lines for selected families will be fit.';			SetDialogItemText(DItem, sTemp);					GetDialogItem(GetSelection, I_ClearFamily, DType, DItem, tempRect);			CItem1 := controlhandle(DItem);			If Use_Manual_ROIs then HideControl(CItem1)	{show when dialog changed to deselect_lines form}			else ShowControl(CItem1);						GetDialogItem(GetSelection, I_SkipSome, DType, DItem, tempRect);			CItem1 := controlhandle(DItem);			if (Use_Manual_ROIs) and (not auto_chkd) then ShowControl(CItem1)			else HideControl(CItem1);									GetDialogItem(GetSelection, I_Clear_All, DType, DItem, tempRect);			CItem1 := controlhandle(DItem);			ShowControl(CItem1);	End;		{ procedure Do_window;}	BEGIN  	{PROCEDURE AutoROI_Chooser} 							 	(*¥¥¥Note: the main part of this code defines manual_Z [i]. Family_on[l,Z] for	    l = 1 to 3 becomes true when a manual_Z [Z] is set true. In DESELECT_LINES		the element, for the family button i = on, is ON only if Family_on[i,Z] is		FALSE since the periodic table in this proc shows the element families to skip.*)				GetSelection := GetNewDialog(9200, nil, Pointer(-1)); 		ShowWindow(GetSelection); 		SelectWindow(GetSelection); 		SetPort(GetSelection);  	         GetDialogItem(GetSelection, I_Accept, DType, DItem, tempRect);        PenSize(3, 3);        InsetRect(tempRect, - 4, - 4);        FrameRoundRect(tempRect, 16, 16);        PenSize(1, 1);		        GetDialogItem(GetSelection, I_Help, DType, DItem, tempRect);	    HideControl(controlhandle(DItem));							{¥¥¥¥¥¥¥¥¥¥¥¥¥Setup initial conditions¥¥¥¥¥¥¥¥¥¥¥¥¥}        	   { we get to this routine from the roi window via 'auto pk roi' or from 'select	     elements' in simplex or llsq; auto may be set true in simplex or llsq if user has not		 made rois and directs the routine to do so}		 			{ for auto, if a family is NOT chosen NO lines will be fit for it in any ROI;	  this is new as of 4/19/95}			 if Skip_some then {copy the SkipFam data}			 Begin				theHdlSize := GetHandleSize(Handle(SkipFam));		        HoldFam := FamilyHdl(NewHandle(theHdlSize));		        nfams := theHdlSize div sizeof(aFamily);				blockmove(@SkipFam^^,@HoldFam^^,theHdlSize);			 End			 Else begin			 	HoldFam := NIL;				SkipFam := NIL;			 End;					{when we accept from the deselect dialog HoldFam changes to the values there;	 SkipFam gets final change when we accept from the element selection dialog}		for i := 1 to 95 do	{to turn everything off}		begin			manual_z[i] := false;	{no elements selected}			for jj := 1 to 3 do family_on[jj,i] := false;		end;				for i := 1 to Number_of_elements_Simplexed do		begin		  manual_z[periodic_picks[i]] := true; {start with current set of Zs}		  for jj := 1 to 3 do family_on[jj,periodic_picks[i]] := true;		                      {...family_on = do the family }			  	      if (Skip_some) then	{look thru SkipFam for ones not to fit}		  Begin			kk := 0;			Repeat			  kk := kk + 1;			  if SkipFam^^[kk].Z = periodic_picks[i] then			  begin			    jj := SkipFam^^[kk].skip_fam;				family_on[jj,periodic_picks[i]] := false;			  end;			Until (kk = nfams); {check all SkipFams...may be more than one for each z}					  End;	{if Skip_some...a Global}		end;	{for i := 1 to Number_of_elements_Simplexed...}				auto_chkd := false;		change_made := false;		change_skip := false;				fam := 1;	{...when they do show}		family := 'K';				Do_window;	{...if  Use_Manual_ROIs this will NOT call Do_SkipWindow		             because auto_chkd = false}				ExitDialog := FALSE;				REPEAT						ModalDialog(NewModalFilterProc(@DefaultFilter), itemHit);			GetDialogItem(GetSelection, itemHit, DType, DItem, tempRect);			CItem := controlhandle(DItem);						{this box is visible so came from a fit setup with ROIS			  chosen; clear them and do auto rois when user exits with OK			  and this button on.			  This box is invisible if came from SILI window Auto ROIS or fit			  setup without ROIS choosen. Then Use_Manual_ROIs is false and must			  make auto rois.}						if (itemhit = I_Auto) then	{this shows only for Use_Manual_rois}			begin			  temp := GetControlValue(CItem); {get what it is}			  SetControlValue(CItem, (temp + 1) MOD 2); {now change it}			  if temp = 1 then auto_chkd := false  {was on, turned it off}			  else auto_chkd := true;			  Do_window;	{gets the right controls and calls Skip_window for line stuff}			end;  						   			if (itemhit = I_SkipSome) then 	{this shows only for Use_Manual_rois}			begin			  Deselect_Lines;	{does not set skip_some to anything}			  if Change_skip then change_made := true;		      ExitDialog := FALSE;			  Do_window;			end;  						   		   {we always sort the elements into existing windows before fitting or for refs}		   {itemhit = 3 to 97, Z = 1 to 95}			if (itemhit >= I_H) and (itemhit <= I_Am)  then			begin			  if (Use_Manual_rois and (not Auto_chkd)) then	{no Family buttons showing}			  begin				if (manual_z[itemhit-2]) then	{the Z is already selected...now deselect}				begin					HiliteControl(CItem,0);					manual_z[itemhit-2] := false;					for kk := 1 to 3 do Family_on[kk,itemhit-2] := false;{deselect sets T}				end				else begin	{select Z to fit all lines }					HiliteControl(CItem,1);					manual_z[itemhit-2] := true;					for kk := 1 to 3 do Family_on[kk,itemhit-2] := true;{do all families}				end;			  end	{if (Use_Manual_rois and (not Auto_chkd))...}			  else begin	{do auto rois from SiLi or Fit Setup, or auto_chkd...			  				 a family button is on}			    if Family_on[fam,itemhit-2] then	{whatever fam is...}				begin				   HiliteControl(CItem,0);				   Family_on[fam,itemhit-2] := false;				   {DO NOT make manual_z[itemhit-2] false cause				    some other fam may be T for this Z}				end				else begin				   HiliteControl(CItem,1);				   Family_on[fam,itemhit-2] := true;{only the fams selected will be T}				   manual_z[itemhit-2] := true; {may already be T but that's ok}				end;			  end;			  change_made := true;			end;	{if (itemhit >= I_H) and...}			if (ItemHit >= I_K_Family) and (ItemHit <= I_M_Family) and			   (fam <> ItemHit-100) then	{if fam = hititem-100, nothing changes}			begin				{change selected family button}				  fam := ItemHit-100;				  if ItemHit = I_K_Family then Family := 'K'				  else if ItemHit = I_L_Family then Family := 'L'				  else Family := 'M';				  				  do_skipWindow;	{passes fam to turn on ItemHit-100 and elements}			end;	{if (hititem >= I_K_Family) and...}							if (ItemHit = I_ClearFamily) then {this only shows for auto rois or auto_chkd}			begin	{ K,L, or M button on defines fam}			    for kk := I_H to I_Am do if manual_z[kk-2] then {turn off all els for this family}				begin					GetDialogItem(GetSelection, kk, DType, DItem, tempRect);					HiliteControl(controlhandle(DItem), 0); {none of family done}					Family_on[fam,kk-2] := false;			        change_made := true;				end;			end;	{if (ItemHit = I_ClearFamily)...in Main proc}									if (ItemHit = I_Help) then				begin					Putmessage('Coming ', '', '', '');				end;			if (ItemHit = I_Clear_All) then 			begin {change the booleans only, not periodic_picks or number...}					for kk := 1 to 95 do					begin						GetDialogItem(GetSelection, kk+2, DType, DItem, tempRect);						HiliteControl(controlhandle(DItem), 0);												manual_z[kk] := false; 					    for nn := 1 to 3 do Family_on[nn,kk] := false;{so not on in Deselect}					 end;	{ for kk := 1 to 95...}						 			  change_made := true;;			end;	{ if (ItemHit = I_Clear_All...in Main proc}			if (ItemHit = I_Cancel) then				begin					ExitDialog := TRUE;				end;						if (ItemHit = I_Accept) then ExitDialog := TRUE;				UNTIL ExitDialog;			{¥¥¥¥¥¥¥¥¥¥Get results after dialog¥¥¥¥¥¥¥¥¥}		    if ((change_made) or (not Use_Manual_ROIs)) and (ItemHit <> I_Cancel) then	begin			{get new values from booleans}			FOR I := 1 TO MaxNumPks DO periodic_picks[I] := 0;						Elements_Chosen := FALSE;			Number_of_Elements_Simplexed := 0;	 	{Throw away the Hold family ptrs...}		  if (skip_some) Then			  {...if skip_some was true coming into the routine, nothing to here has reset it} 		  Begin  		    disposeHandle(Handle(HoldFam));	{if we turned off all skips, theHdlSize is 0...}  		    HoldFam := NIL;			beepbeep;		  	DisposeHandle(Handle(SkipFam));	{we'll make new ones if needed}		  	SkipFam := NIL;			beepbeep;            skip_some := false;	{reset below if...}		 End;		          (* We keep track of  auto_chkd value now (4/19/95)...*)  		   If Use_Manual_ROIs then {otherwise this box is not visible}			begin	{auto_chkd is opposite to Use_Manual_ROIs}			  GetDialogItem(GetSelection, I_Auto, DType, DItem, tempRect);			  temp := GetControlValue(controlhandle(DItem)); {get what it is}			  if temp = 1 then Use_Manual_ROIs := false			  else Use_Manual_ROIs := true;			end;							{family_on means do this family from any option}					  SkipFam := FamilyHdl(NewHandle(0));		  theHdlSize := 0;		  nfams := 0;		  		  If (not Use_Manual_ROIs) then begin				For nn := 1 TO Max_Rois DO				Begin				  ROI^^.Peak[nn].Lo := 1;				  ROI^^.Peak[nn].Hi := 1;				  ROI^^.Peak[nn].Value := zero;				  ROI^^.Peak[nn].Exists := False;				  ROI^^.Peak[nn].ROI := nn;				End;				Number_of_PeakRois := 1;		  end;          		  FOR i := 1 to 95 do		  BEGIN			if manual_Z [i] then	{element is selected}				begin			{if the user accidentally selects to skip all the lines for a selected element			 in ALL ROIS the routine will crash! So...}			  			  If (Use_Manual_ROIs) or			     (family_on[1,i] or family_on[2,i] or family_on[3,i])			  then begin	{Number_of_Elements_Simplexed zeroed above}			   Number_of_Elements_Simplexed := Number_of_Elements_Simplexed + 1;			   periodic_picks[Number_of_Elements_Simplexed] := i;			  end;			   			  for fam := 1 to 3 do			  Begin(*numtostring(fam,str);if family_on[fam,i] then str1 := 'family on, call AutoROI_Data'else str1 := 'family off, don`t call AutoROI_Data';putmessage(a^.sym[i],str,str1,'');*)			  	If ((not Use_Manual_ROIs) and family_on[fam,i]) then				AutoROI_Data(i,fam) {...makes the windows for whole ele family			                             but only those that fall within the number_of_channels}				else if (not family_on[fam,i]) then skip_some := true;			  End;	{for fam := 1 to 3...}					end;{if manual_Z [i]...}		  END;	{ for i...}			   			  		  If Calibrate_Window_Active OR QC_Enabled then {setting up to fit for calibration}		  Begin		  {family_on means do this family from any option}		   if Number_of_Elements_Simplexed = 1 then			{need two elements...or two lines...???}			 periodic_picks[2] := periodic_picks[1];			 Number_of_Elements_Simplexed := 2;			  			  {family_on here means it was selected to be fit} 			  for JJ := 1 to 2 do			  begin {if there is only one element, ist line => periodic_picks[1]			         and 2nd line => periodic_picks[2] : hence the 'elses' below}				 if (JJ = 1) or					    ((JJ = 2) and (periodic_picks[1] <> periodic_picks[2])) then				   {two els, 2nd ele different from first...}				   for kk := 1 to 3 do line_selected[kk] := false;				  				  {now get the line to use...if JJ=2 and there's only one element				   some line_selected is already true so a different line must be				   selected for JJ=2}				 i := periodic_picks[JJ];				 if (family_on[1,i]) and (not line_selected[1]) then				 begin				   line_selected[1] := true;				   x_label[JJ] := 'KA1  ';				 end				 else if (family_on[2,i]) and (not line_selected[2]) then				 begin				   line_selected[2] := true;				   x_label[JJ] := 'LA1  ';				 end				 else if (family_on[3,i]) and (not line_selected[3]) then				 begin				   line_selected[3] := true;				   x_label[JJ] := 'MA1  ';				 end;			  end;	{for JJ := 1 to Number_of_Elements_Simplexed do}		  End;	{If Calibrate_Window_Active...}			   {¥¥¥¥¥¥}        		IF Number_of_Elements_Simplexed = 0 THEN Elements_Chosen := FALSE        ELSE BEGIN		 Elements_Chosen := True;	   IF NOT Use_Manual_ROIs then	   BEGIN		 {¥¥¥¥ do sorting stuff among elements...for each element done in auto_roi_data ¥¥¥¥}		   {Number_of_PeakRois is one larger than actually defined; Simplex knows this}		 {...this is sooooo stupid and probably where the phantom roi arises!}  		 {any way...20/19 as the code reads, if we do a clear_all elements in		  auto_roi mode, Number_of_PeakRois is 1 but exists is false...}	       mm := Number_of_PeakRois -1;	{because Number_of_PeakRois is one larger		   								 than actually defined}		IF mm >1 then		BEGIN		   FOR kk := 1 TO mm-1 DO { First do an Energy Sort based on the Lower Limit } 		   FOR JJ := kk+1 to mm do		   Begin			  if ROI^^.Peak[kk].Lo > ROI^^.Peak[JJ].Lo then			  begin			    Temp_Roi := ROI^^.Peak[kk];                ROI^^.Peak[kk] := ROI^^.Peak[JJ];                ROI^^.Peak[JJ] := Temp_Roi;				ROI^^.Peak[kk].Roi := kk;				ROI^^.Peak[JJ].Roi := JJ; 			  end;		   End;	{FOR kk...FOR JJ...}        		   kk := 1;   		   Repeat{ Now combine any that overlap, for ALL elements chosen }		   {SiLi Win keeps you from making a Roi with too many chs but we must		    prevent the merging to one with too many chs...			Let's see what happens without the +8...Fe Ka and Kb fit in diff. ROIs!}			   if ROI^^.Peak[kk].Hi + 8 >= ROI^^.Peak[kk+1].Lo then		{¥¥¥¥overlap¥¥¥¥}			   begin			     {roi kk and kk+1 will combine into roi kk, but does Hi for kk				  change to the Hi for kk+1?...}				 if ROI^^.Peak[kk].Hi < ROI^^.Peak[kk+1].Hi then				 if ((ROI^^.Peak[kk+1].Hi - ROI^^.Peak[kk].Lo + 1) < Max_Fitting_Chans)				 then ROI^^.Peak[kk].Hi := ROI^^.Peak[kk+1].Hi;				 if ((ROI^^.Peak[kk].Hi - ROI^^.Peak[kk].Lo + 1) < Max_Fitting_Chans)				 then begin	{if the window is not too big then...}					 if mm >= (kk+2) then					 FOR ii := kk+1 TO mm - 1 DO 			 					 begin {kk + 1 gets data from kk+1+1, etc.}						ROI^^.Peak[ii] := ROI^^.Peak[ii + 1]; {...to mm-1 because of ii+1}						ROI^^.Peak[ii].ROI := ii;					 end;					 ROI^^.Peak[mm].Exists := false;					 mm := mm-1;	{a window has been eliminated}			   	 end;	{if ((ROI^^.Peak[kk+1].Hi -...}			   end	{if ((ROI^^.Peak[kk+1].Hi <...}			   else kk := kk+1;		   UNTIL kk = mm;		   Number_of_PeakRois := mm + 1;	{always 1 > set number of ROIS}		END; 	{IF mm > 1...}		  { skip_some := false; we may have just set it true!!!}		   FOR JJ := 1 to Number_of_Elements_Simplexed do		   BEGIN {...so that lines from a family that was NOT selected will NOT				  be fit in some window they happen to fall into}			i := Periodic_picks[jj];			for kk := 1 to 3 do		    If (not family_on[kk,i]) then			begin		{remember, family_on = fit this family for NOT Use_Manual_ROIs}			  skip_some := true;			  nfams := nfams + 1;			  theHdlSize := theHdlSize + sizeof(aFamily);			  SetHandleSize(Handle(SkipFam),theHdlSize);			  SkipFam^^[nfams].Z := i;			  SkipFam^^[nfams].Roi := 1000;	{for auto_roi, skip the fam in all ROIS}			  SkipFam^^[nfams].skip_fam := kk;			end;	{If	family_on[1,i] or...}		   END;	{FOR JJ := 1...}		 END	{IF (NOT Use_Manual_Rois)...}		 ELSE IF (change_skip and skip_some) THEN WhichRoi_Dial;				END;	{ IF Number_of_Elements_Simplexed <> 0...}	  	 end	{ if (change_made)...}	 else if (ItemHit = I_Cancel) then Elements_Chosen := false;     	 If (not skip_some) and (SkipFam <> NIL) then begin	 	DisposeHandle(Handle(SkipFam));	 	SkipFam := NIL;	 end;	 If HoldFam <> NIL then begin	 	DisposeHandle(Handle(HoldFam));      	HoldFam := NIL;      end;	  tempRect := GetSelection^.portRect;      DisposeDialog(GetSelection);      FillWhiteSpace(tempRect);  	end;     { procedure AutoROI_Chooser }      PROCEDURE gaussj{( n	: longint ; 					 VAR Answer: LinFitCovArray; 					 VAR B: LinFitVarArray)};      VAR        big, dum, pivinv              : double_t;        i, icol, irow, j, k, l, ll    : integer;        indxc, indxr, ipiv            : LinFitBigIArray;        M, mp						  : integer;      BEGIN {PROCEDURE gaussj}      	M := 1;      	mp := 1;        FOR j := 1 TO n DO          ipiv[j] := 0;        FOR i := 1 TO n DO          BEGIN            big := 0.0;            FOR j := 1 TO n DO              BEGIN                IF (ipiv[j] <> 1) THEN                  BEGIN                    FOR k := 1 TO n DO                      BEGIN                        IF (ipiv[k] = 0) THEN                          BEGIN                            IF (abs(Answer[j, k]) >= big) THEN                              BEGIN                                big := abs(Answer[j, k]);                                irow := j;                                icol := k                              END                          END                        ELSE                          IF (ipiv[k] > 1) THEN                            putmessage('A singular matrix happened in Linear Least Squares','(ipiv[k] > 1)', '','');                      END                  END              END;            ipiv[icol] := ipiv[icol] + 1;            IF (irow <> icol) THEN              BEGIN                FOR l := 1 TO n DO                  BEGIN                    dum := Answer[irow, l];                    Answer[irow, l] := Answer[icol, l];                    Answer[icol, l] := dum                  END;                FOR l := 1 TO M DO                  BEGIN                    dum := B[irow, l];                    B[irow, l] := B[icol, l];                    B[icol, l] := dum                  END              END;            indxr[i] := irow;            indxc[i] := icol;            IF (Answer[icol, icol] = 0.0) THEN              putmessage('A singular matrix happened in Linear Least Squares', 'Answer[icol, icol] = 0.0', '', '');            pivinv := 1.0 / Answer[icol, icol];            Answer[icol, icol] := 1.0;            FOR l := 1 TO n DO              Answer[icol, l] := Answer[icol, l] * pivinv;            FOR l := 1 TO M DO              B[icol, l] := B[icol, l] * pivinv;            FOR ll := 1 TO n DO              BEGIN                IF (ll <> icol) THEN                  BEGIN                    dum := Answer[ll, icol];                    Answer[ll, icol] := 0.0;                    FOR l := 1 TO n DO                      Answer[ll, l] := Answer[ll, l] - Answer[icol, l] * dum;                    FOR l := 1 TO M DO                      B[ll, l] := B[ll, l] - B[icol, l] * dum;                  END              END          END;        FOR l := n DOWNTO 1 DO          BEGIN            IF (indxr[l] <> indxc[l]) THEN              BEGIN                FOR k := 1 TO n DO                  BEGIN                    dum := Answer[k, indxr[l]];                    Answer[k, indxr[l]] := Answer[k, indxc[l]];                    Answer[k, indxc[l]] := dum                  END              END          END      END; {PROCEDURE gaussj}(* BEGINENVIRONCONST   np =TYPE   RealArrayNPbyNP = ARRAY [1..np,1..np] OF real;   RealArrayNP = ARRAY [1..np] OF real;   IntegerArrayNP = ARRAY [1..np] OF integer;ENDENVIRON *)PROCEDURE ludcmp{(VAR a: RealArrayNPbyNP;                     n: integer;              VAR indx: IntegerArrayNP;                 VAR d: real)};CONST   tiny = 1.0e-20;VAR   k,j,imax,i: integer;   sum,dum,big: real;   vv: ^LinFitExtArray	{^RealArrayNP};BEGIN   new(vv);   d := 1.0;   FOR i := 1 TO n DO BEGIN      big := 0.0;      FOR j := 1 TO n DO         IF abs(a[i,j]) > big THEN big := abs(a[i,j]);      IF big = 0.0 THEN BEGIN         writeln('pause in LUDCMP - singular matrix');         readln      END;      vv^[i] := 1.0/big   END;   FOR j := 1 TO n DO BEGIN      FOR i := 1 TO j-1 DO BEGIN         sum := a[i,j];         FOR k := 1 TO i-1 DO            sum := sum-a[i,k]*a[k,j];         a[i,j] := sum      END;      big := 0.0;      FOR i := j TO n DO BEGIN         sum := a[i,j];         FOR k := 1 TO j-1 DO            sum := sum-a[i,k]*a[k,j];         a[i,j] := sum;         dum := vv^[i]*abs(sum);         IF dum >= big THEN BEGIN            big := dum;            imax := i         END      END;      IF j <> imax THEN BEGIN         FOR k := 1 TO n DO BEGIN            dum := a[imax,k];            a[imax,k] := a[j,k];            a[j,k] := dum         END;         d := -d;         vv^[imax] := vv^[j]      END;      indx[j] := imax;      IF a[j,j] = 0.0 THEN a[j,j] := tiny;      IF j <> n THEN BEGIN         dum := 1.0/a[j,j];         FOR i := j+1 TO n DO            a[i,j] := a[i,j]*dum      END   END;   dispose(vv)END;(* BEGINENVIRONCONST   np =TYPE   RealArrayNP = ARRAY [1..np] OF real;   IntegerArrayNP = ARRAY [1..np] OF integer;   RealArrayNPbyNP = ARRAY [1..np,1..np] OF real;ENDENVIRON *)PROCEDURE lubksb{(VAR a: RealArrayNPbyNP;                     n: integer;              VAR indx: IntegerArrayNP;                 VAR b: RealArrayNP)};VAR   j,ip,ii,i: integer;   sum: real;BEGIN   ii := 0;   FOR i := 1 TO n DO BEGIN      ip := indx[i];      sum := b[ip];      b[ip] := b[i];      IF ii <> 0 THEN         FOR j := ii TO i-1 DO            sum := sum-a[i,j]*b[j]      ELSE IF sum <> 0.0 THEN         ii := i;      b[i] := sum   END;   FOR i := n DOWNTO 1 DO BEGIN      sum := b[i];      FOR j := i+1 TO n DO         sum := sum-a[i,j]*b[j];      b[i] := sum/a[i,i]   ENDEND;PROCEDURE Lfit (*(VAR Y_In_Data, sig : WindowArrayHdl; 				X_In_Data : WindowHdlArrayHdl;   {array of handles} 				ndata 	: integer;                 { Num_fit_chans } 			VAR Answer 	: LinFitExtArray; { = array [1..Max_Num_Terms] of double_t} 				nfit 	: integer; { poly order or number of reference spectra } 				do_me 	: LinFitIntArray;				mfit 	: integer; {Pass in the poly order or number of reference spectra} 			VAR covar 	: LinFitCovArray; { sqrt(covar[i,i]) is the Std dev of each fitted term i } 				ncvm 	: integer; VAR chisq : double_t) *) ;{¥¥note that the eqn for chisq was changed 3/11/94}          VAR      k                             : integer;      j                             : integer;      i                             : integer;      ddd							: real;      ydat                          : double_t;      wt                            : double_t;      sum                           : double_t;      sig2                          : double_t;      beta                          : LinFitExtArray {LinFitVarArray};      indext						: LinFitIntArray;      xdat                          : LinFitExtArray; {LinFitExtArray = array [1..Max_Num_Terms] of                                                       double_t}    BEGIN {PROCEDURE Lfit}	  {SpinCursor;}	  FOR j := 1 TO nfit {mfit} DO	  BEGIN		FOR k := 1 TO nfit {mfit} DO		covar[j, k] := 0.0;		beta[j {, 1}] := 0.0	  END;      FOR i := 1 TO ndata DO      BEGIN          ydat := Y_in_Data^^[i];          FOR j := 1 TO nfit DO xdat[j] := X_In_Data[j]^^[i];         (* IF (nfit {mfit} < nfit) THEN          FOR j := (nfit {mfit} + 1) TO nfit DO ydat := ydat - Answer[j] * xdat[j];*)          sig2 := 1.0 / sqr(sig^^[i]);          FOR j := 1 TO nfit {mfit} DO          BEGIN			wt := xdat[j] * sig2;			FOR k := 1 TO j DO covar[j, k] := covar[j, k] + wt * xdat[k];			beta[j {, 1}] := beta[j {, 1}] + ydat * wt          END      END;	{ FOR i := 1 TO ndata...}      IF (nfit {mfit} > 1) THEN      FOR j := 2 TO nfit {mfit} DO          FOR k := 1 TO j - 1 DO covar[k, j] := covar[j, k];      (*gaussj(nfit {mfit}, {ncvm,}covar,  beta {, 1, 1});*)	{the returned covar has been inverted}            ludcmp(covar,nfit,indext,ddd);      						  (*(VAR a: RealArrayNPbyNP;                     				 n: integer;             				  VAR indx: IntegerArrayNP;                				 VAR d: real);*)	  lubksb(covar,nfit,indext,beta);	  						  (*(VAR a: RealArrayNPbyNP;                     				 n: integer;             				  VAR indx: IntegerArrayNP;                 				 VAR b: RealArrayNP);*)                       FOR j := 1 TO nfit {mfit} DO Answer[j] := beta[j {, 1}];      chisq := 0.0;      FOR i := 1 TO ndata DO      BEGIN          FOR j := 1 TO nfit DO xdat[j] := X_In_Data[j]^^[i];          sum := 0.0;          FOR j := 1 TO nfit DO sum := sum + Answer[j] * xdat[j];          chisq := chisq + sqr((Y_in_Data^^[i] - sum)/sig^^[i]);	{3/11/94}         {chisq := chisq + sqr(Y_in_Data^^[i] - sum);}      END;      chisq := chisq / (ndata - nfit {mfit});    END; { Procedure LFIT }PROCEDURE GLfit (*(VAR Y_In_Data, sig : WindowArrayHdl; 				X_In_Data : WindowHdlArrayHdl;   {array of handles} 				ndata 	: integer;                 { Num_fit_chans } 			VAR Answer 	: LinFitExtArray; { = array [1..Max_Num_Terms] of double_t} 				nfit 	: integer; { poly order or number of reference spectra } 				do_me 	: LinFitIntArray;				mfit 	: integer; {Pass in the poly order or number of reference spectra} 			VAR covar 	: LinFitCovArray; { sqrt(covar[i,i]) is the Std dev of each fitted term i } 				ncvm 	: integer; VAR chisq : double_t) *) ;{¥¥note that the eqn for chisq was changed 3/11/94}          VAR      k                             : integer;      j                             : integer;      i                             : integer;      ddd							: real;      ydat                          : double_t;      wt                            : double_t;      sum                           : double_t;      sig2                          : double_t;      beta                          : LinFitVarArray;      indext						: LinFitIntArray;      xdat                          : LinFitExtArray; {LinFitExtArray = array [1..Max_Num_Terms] of                                                       double_t}    BEGIN {PROCEDURE GLfit}	  {SpinCursor;}	  FOR j := 1 TO  mfit DO	  BEGIN		FOR k := 1 TO  mfit DO		covar[j, k] := 0.0;		beta[j , 1] := 0.0	  END;      FOR i := 1 TO ndata DO      BEGIN          ydat := Y_in_Data^^[i];          FOR j := 1 TO nfit DO xdat[j] := X_In_Data[j]^^[i];          IF ( mfit < nfit) THEN          FOR j := ( mfit + 1) TO nfit DO ydat := ydat - Answer[j] * xdat[j];          sig2 := 1.0 / sqr(sig^^[i]);          FOR j := 1 TO  mfit DO          BEGIN			wt := xdat[j] * sig2;			FOR k := 1 TO j DO covar[j, k] := covar[j, k] + wt * xdat[k];			beta[j , 1] := beta[j , 1] + ydat * wt          END      END;	{ FOR i := 1 TO ndata...}      IF ( mfit > 1) THEN      FOR j := 2 TO  mfit DO          FOR k := 1 TO j - 1 DO covar[k, j] := covar[j, k];      gaussj( mfit, {ncvm,} covar,  beta );	{the returned covar has been inverted}            {ludcmp(covar,nfit,indext,ddd);}      						  (*(VAR a: RealArrayNPbyNP;                     				 n: integer;             				  VAR indx: IntegerArrayNP;                				 VAR d: real);*)	  {lubksb(covar,nfit,indext,beta);}	  						  (*(VAR a: RealArrayNPbyNP;                     				 n: integer;             				  VAR indx: IntegerArrayNP;                 				 VAR b: RealArrayNP);*)                       FOR j := 1 TO mfit DO Answer[j] := beta[j , 1];      chisq := 0.0;      FOR i := 1 TO ndata DO      BEGIN          FOR j := 1 TO nfit DO xdat[j] := X_In_Data[j]^^[i];          sum := 0.0;          FOR j := 1 TO nfit DO sum := sum + Answer[j] * xdat[j];          chisq := chisq + sqr((Y_in_Data^^[i] - sum)/sig^^[i]);	{3/11/94}         {chisq := chisq + sqr(Y_in_Data^^[i] - sum);}      END;      chisq := chisq / (ndata - mfit);    END; { Procedure GLFIT }{$S CurveFit3}  PROCEDURE DO_Correction_String;    VAR      index                         : integer;      class_str                     : STRING[4];    BEGIN      WITH Analysis_Result^^.SpectrumStuff.Spectrum_info DO        BEGIN          FOR index := 1 TO 4 DO            BEGIN              class_str[index] := Spectrum_class[index];              IF (Ord(class_str[index]) > 96) AND (Ord(class_str[index]) < 123) THEN                class_str[index] := char(Ord(class_str[index]) - 32)            END;          IF (class_str = 'GRID') OR (class_str = 'BULK') OR (class_str = 'CUGR') OR (class_str =             'CU G') THEN            Spectrum_class := 'bulk'          ELSE            IF (class_str = 'FILM') OR (class_str = 'CFIL') OR (class_str = 'C FI') THEN              Spectrum_class := 'film';        END; { WITH...}    END; { PROCEDURE DO_Correction_String }  PROCEDURE WriteBinaryResults; { write the WHOLE of Analysis_Result including ExptStuff }    VAR    	b_count		: Longint;    BEGIN      errcode := FSOpen_err(MCA_ResultsName, MCA_Results_VolNum, refnum,'');      errcode := SetFPos_err(refnum, fsFromLEOF, 0,'');      b_count := SizeOf(Simplex_Fit);      errcode := FSWrite_err(refnum, b_count, @Analysis_Result^^,'');      errcode := FSClose(refnum);      errcode := FlushVol(NIL, MCA_Results_VolNum);    END;  PROCEDURE MakeBinaryResults;  {for Batch fit or Add_fit without D_Results_Options...a default file is created if user   does not name the file. He is prompted to open an OLD FIT FILE to append, but he may   forget.}    var   	str1,str2,str3,str4 : str255;	errcode			 	: integer;	b_count				: Longint;    BEGIN		str1 := 'You did not specify a new binary filename via OUTPUT OPTIONS';		str2 := 'in the Fit setup, nor have you opened an OLD FIT to APPEND.';		str3 := 'If IT`S OK, name the file now.';		str4 := 'If IT`s NOT OK, I`ll exit so you can open an Old Fit File to Append.'; 		IF LLSQ_Active THEN		BEGIN		  IF (is_batch) THEN OutName := 'ML_Batch_Fit'		  ELSE OutName := 'ML_AddFit';		END		ELSE		BEGIN		  IF (is_batch) THEN OutName := 'Simplex_Batch_Fit'		  ELSE OutName := 'Simplex_AddFit';		END;	 REPEAT 	  IF (not MCA_OptionsBoolean) THEN		{Did not call D_Results_Options to name a binary results file. MCA_File_Boolean		 could be true. }	  BEGIN	    MCA_File_Boolean := False;		IF not answermessage(str1,str2,str3,str4) THEN exit(MakeBinaryResults)		ELSE BEGIN	   {CreateFile is a function:boolean which on return is true if OK is clicked		or is false if Cancel is clicked...why do we complicate the code with		File_Cancel_Button? File_Cancel_Button is false if Cancel is clicked!		CreateFile calls Get_WDInfo to get the Out...stuff;		the next is for the default file...}		  errcode := getvol(Save_Volume_Name,Out_VolRefNum);	{...the current vol stuff}		  OutVol_volnum := Out_VolRefNum;		  IF (CreateFile(OutName, 'Name the binary results File:')) THEN 		  BEGIN		    MCA_File_Boolean := False;	{...until the file is actually created}		    MCA_ResultsName := OutName;			MCA_Results_VolNum := Out_VolRefNum; {WD, a global,from CreateFile or above}			MCA_ResultsDirID := OutVol_DirID;			MCA_ResultsVNum := OutVol_volnum;			MCA_OptionsBoolean := true; 	{...binary filename vars are set, file not used}      	  END	{IF (CreateFile...}		  ELSE exit(MakeBinaryResults);		END;	{IF answermessage...}	  END;	{ IF (not MCA_OptionsBoolean) ... }	 	 IF (Hall_Active) AND (Make_Hall) THEN			   Hall_Output^^.resultsname := MCA_ResultsName;	  	  {	Now create the file; not done in D_Results_Options...	    the text files ARE created there!!??}	 	  err := Create(MCA_ResultsName, MCA_Results_VolNum, 'DTSA', 'MCAb');	  IF (err = NoErr) or (err = dupFNErr) THEN	  BEGIN		MCA_File_Boolean := True; {file is created}		errcode := FSOpen_err(MCA_ResultsName, MCA_Results_VolNum, refnum,'');		errcode := SetEOF(refnum, 0); { erases everything, if default file or replace filem }		errCode := setfpos(refnum, fsFromstart, 0);		b_count := 1;		errCode := FSWrite(refnum, b_count, @Is_Batch);		errCode := FSClose(refnum);		errCode := FlushVol(NIL, MCA_Results_VolNum);			MCA_OptionsBoolean := false;	{used the filename...}	  END	  ELSE BEGIN		MCA_File_Boolean := false; 		MCA_OptionsBoolean := false;		str1 := concat('There was a problem creating the file ',MCA_ResultsName,'.');		str2 := '';		str3 := 'If IT`S OK, you can try a new filename;';	  END;	 	 UNTIL (err = noerr) or (err = dupFNErr);    END;	{PROCEDURE MakeBinaryResults}  PROCEDURE CFirst_Derivative {(VAR ntodo:integer; VAR Din,Dout:realWindowArray)} ;    VAR      nn                            : integer;    BEGIN	      FOR nn := 1 TO Max_Fitting_Chans DO  Dout[nn] := zero; 	 if (ntodo > Max_Fitting_Chans) or (ntodo < 1) then begin	 		putmessage('In CFirst_Derivative (in CurveFit), ntodo is wrong.','','','');			end;      { Leftmost points }      Dout[1] := ( - 25 * Din[1] + 	                 48 * Din[2] - 					 36 * Din[3] + 					 16 * Din[4] - 					 3 * Din[5]) / (12 * Plt_spec[10]^^.Expt_Info.dE);      Dout[2] := ( - 25 * Din[2] + 	                 48 * Din[3] - 					 36 * Din[4] + 					 16 * Din[5] - 					 3 * Din[6]) / (12 * Plt_spec[10]^^.Expt_Info.dE);      { Rightmost points }      Dout[ntodo] := ( - 25 * Din[ntodo] + 	                     48 * Din[ntodo - 1] - 						 36 * Din[ntodo - 2] + 						 16 * Din[ ntodo - 3] - 						 3 * Din[ntodo - 4]) / ( - 12 * Plt_spec[10]^^.Expt_Info.dE);      nn := ntodo - 1;      Dout[nn] := ( - 25 * Din[nn] + 	                  48 * Din[nn - 1] - 					  36 * Din[nn - 2] + 					  16 * Din[nn - 3] - 					  3 * Din[nn - 4]) / ( - 12 * Plt_spec[10]^^.Expt_Info.dE);      FOR nn := 3 TO ntodo - 2 DO        BEGIN          Dout[nn] := (Din[nn - 2] - 		             8 * Din[nn - 1] + 					 8 * Din[nn + 1] - 					  Din[nn + 2]) / (12 * Plt_spec[10]^^.Expt_Info.dE);        END;    END; { procedure CFirst_Derivative }  PROCEDURE CSecond_Derivative {(VAR ntodo:integer; VAR Din, Dout: realWindowArray)} ;  { This stupid procedure actually replaces the incoming data with a smoothed function.    You can't do that when the procedure uses var: because you loose your data. This	is happening in MLLSQ to the references.}    VAR      nn                            : integer;	  smoothed						: windowArray;    BEGIN      FOR nn := 1 TO Max_Fitting_Chans DO        Dout[nn] := zero;	 	 if (ntodo > Max_Fitting_Chans) or (ntodo < 1) then begin	 		putmessage('In CFirst_Derivative (in CurveFit), ntodo is wrong.','','','');			end;         { ¥¥Start a 9 point smooth }		 		   smoothed[1] := (Din[1]+Din[2]+Din[3])/3;  		   smoothed[2] := (Din[1]+Din[2]+Din[3])/3; 		   smoothed[3] := (Din[2]+Din[3]+Din[4])/3; 		   smoothed[4] := (Din[3]+Din[4]+Din[5])/3; 		   smoothed[ntodo - 3 ] := (Din[ntodo-4]+Din[ntodo-3]+Din[ntodo-2])/3;		   smoothed[ntodo - 2] := (Din[ntodo-3]+Din[ntodo-2]+Din[ntodo-1])/3;		   smoothed[ntodo - 1] := (Din[ntodo-2]+Din[ntodo-1]+Din[ntodo])/3;		   smoothed[ntodo ] := (Din[ntodo-2]+Din[ntodo-1]+Din[ntodo])/3;                         FOR nn := 5 TO ntodo-4 DO                          smoothed[nn] := ( - 21 * Din[nn - 4]                                                + 14 * Din[nn - 3]                                                + 39 * Din[nn -2]                                                + 54 * Din[nn -1]                                                + 59 * Din[nn]                                                + 54 * Din[nn +1]                                                + 39 * Din[nn + 2]                                                + 14 * Din[nn + 3]                                                - 21 * Din[nn + 4]) / 231;       {this is the mess:	   For nn := 1 to ntodo Do Din[nn]:= Dout[nn];} { ¥¥Finish a 9 point smooth }       { Leftmost points }      Dout[1] := (2 * smoothed[1] - 	              5 * smoothed[2] + 				  4 * smoothed[3] - 				  smoothed[4]) / (Plt_spec[10]^^.Expt_Info.dE * Plt_spec[10]^^.Expt_Info.dE);      Dout[2] := (2 * smoothed[2] - 	              5 * smoothed[3] + 				  4 * smoothed[4] - 				  smoothed[5]) / (Plt_spec[10]^^.Expt_Info.dE * Plt_spec[10]^^.Expt_Info.dE);      { Rightmost points }      nn := ntodo;      Dout[nn - 1] := (2 * smoothed[nn - 1] - 	                   5 * smoothed[nn - 2] + 					   4 * smoothed[nn - 3] - 					   smoothed[nn - 4]) / ( Plt_spec[10]^^.Expt_Info.dE * Plt_spec[10]^^.Expt_Info.dE);      Dout[nn] := (2 * smoothed[nn] - 	               5 * smoothed[nn - 1] + 				   4 * smoothed[nn - 2] - 				   smoothed[nn - 3]) / (Plt_spec[10]^^.Expt_Info.dE * Plt_spec[10]^^.Expt_Info.dE);      FOR nn := 3 TO ntodo - 2 DO        BEGIN          Dout[nn] := ( - smoothed[nn - 2] + 		                 16 * smoothed[nn - 1] - 						 30 * smoothed[nn] + 						 16 * smoothed[nn + 1] - 						 smoothed[nn + 2]) / 						 (12 * Plt_spec[10]^^.Expt_Info.dE * Plt_spec[10]^^.Expt_Info.dE);        END;    END; { procedure CSecond_Derivative }  PROCEDURE Read_Spectrum; { this is done for each spectrum;reads spectrum from work^^.S into the                            array Col_1^ }    VAR      i                             : integer;    BEGIN { procedure Read_Spectrum : read spectrum, sum counts, remove escape peaks and integrate           bkg window}      tocnts := 0.0;  	  BlockMove(@Plt_spec[10]^^.S, @Col_1^, Sizeof(Col_1^));{ to leave data untouched }       FOR i := 1 TO Spectrum_Size DO        BEGIN          tocnts := tocnts + Col_1^[i];        END; {for i}      Escape; { remove escape peaks from Col_1^: keV_per_Channel,npts,Col_1^ }      Refresh_ROIs; { To make the Background 1 ROI current for the new spectrum }    END; { procedure Read_Spectrum }  PROCEDURE D_Results_Options;  	Const  		I_Accept = 1;		I_Cancel = 2;		I_Excel_Spreadsheet = 3;	{radio}		I_Statview_Spreadsheet = 4; {radio}		I_KaleidaGraph_Spreadsh = 5;{radio}		I_MCA_Format = 6;	{checkbox, small, no text}		I_OldFile = 7;		{enabled changeable static text for checkbox}		I_Full_Text_Report = 8;		I_SpreadSheet = 9;	{checkbox}		I_New = 10;	{ not used }		I_Sufficient_Output   = 11;		I_Bulk_Target_Physics = 12;		I_Thin_Target_Physics = 13;		I_Instruction = 14;	{enabled static text, depends on calling procedure}		I_Normal_Output               = 19;		I_Reduced_Output              = 20;    VAR      GetSelection                  : DialogPtr;      tempRect                      : Rect;      DType                         : integer;      index                         : integer;      DItem                         : Handle;      CItem, CTempItem              : controlhandle;      itemHit                       : integer;      temp                          : integer;      myprompt                      : Str255;      mytype                        : OsType;      ExitDialog					: boolean;      errcode		               : integer;      fndrInfo                      : FInfo;	  str,str1,str2	   : str255;      {This is an update routine for non-controls in the dialog}      {This is executed after the dialog is uncovered by an alert}        PROCEDURE Refresh_Dialog;            VAR        rTempRect                     : Rect;      BEGIN        SetPort(GetSelection);        rTempRect := tempRect;        GetDialogItem(GetSelection, I_Accept, DType, DItem, tempRect);        PenSize(3, 3);        InsetRect(tempRect, - 4, - 4);        FrameRoundRect(tempRect, 16, 16);        PenSize(1, 1);        PenSize(4, 4);        MoveTo(4, 53);        LineTo(423, 53);        PenSize(1, 1);        tempRect := rTempRect;      END;    BEGIN      GetSelection := GetNewDialog(1942, NIL, Pointer( - 1));      ShowWindow(GetSelection);      SelectWindow(GetSelection);      SetPort(GetSelection);		 { the calling code needs these to be false if exit	  WRONG!! nothing should happen on EXIT!!!}	  Plain_Boolean := false;	  Plain_options := false;	  Spread_Boolean := false;	  normal_output := true;	      If (not binary_choice) then begin	  {binary_choice is false if we got here from OpenOldFitFile: OutPutOptions and ???}		 If Do_CLOutput then str1:='Please choose ASCII output options for CL results. '		 else If Do_HallOutput then str1:='Please choose ASCII output options for Hall results. '		 else str1:='Please choose ASCII output options for Fit results. ';		 str2:='';		 GetDialogItem(GetSelection, I_Instruction, DType, DItem, tempRect);		 SetDialogItemText(DItem, str1);		 GetDialogItem(GetSelection, I_OldFile, DType, DItem, tempRect);		 SetDialogItemText(DItem, str2);	     GetDialogItem(GetSelection, I_MCA_Format, DType, DItem, tempRect);		 HideControl(controlhandle(DItem));		  	  end;	  	  {¥¥This is not Macie, but all the buttons must be off so the user HAS to turn	     one on to bring up file naming dialog...they are invisible til spreadsheet		 is checked}	   For index := I_Excel_Spreadsheet to I_KaleidaGraph_Spreadsh DO	   BEGIN		 GetDialogItem(GetSelection, index, DType, DItem, tempRect);		 CTempItem := controlhandle(DItem);		 SetControlValue(CTempItem,0);		 HideControl(CTempItem);	   END;	  	  IF (Thin_Physics_Boolean) THEN	  		GetDialogItem(GetSelection, I_Thin_Target_Physics, DType, DItem, tempRect)      Else IF (Bulk_Physics_Boolean) THEN	  	    GetDialogItem(GetSelection, I_Bulk_Target_Physics, DType, DItem, tempRect)	  Else	  		GetDialogItem(GetSelection, I_Sufficient_Output, DType, DItem, tempRect);	  SetControlValue(controlhandle(DItem), 1);	  {Putmessage('I_Normal_Output','','','');}	   GetDialogItem(GetSelection, I_Normal_Output, DType, DItem, tempRect);	   CTempItem := controlhandle(DItem);	   HiliteControl(CTempItem, 255); { initially, grey out }       IF (Normal_Output) THEN SetControlValue(CTempItem, 1)	   else SetControlValue(CTempItem, 0); 	   GetDialogItem(GetSelection, I_Reduced_Output, DType, DItem, tempRect);	   CTempItem := controlhandle(DItem);	   HiliteControl(CTempItem, 255); { initially, grey out }       IF (Reduced_Output) THEN SetControlValue(CTempItem, 1)	   else SetControlValue(CTempItem, 0); 	  			For index := I_Sufficient_Output to I_Thin_Target_Physics DO			BEGIN			  GetDialogItem(GetSelection, index, DType, DItem, tempRect);			  HiliteControl(controlhandle(DItem), 255); 			END;      Refresh_Dialog;      ExitDialog := False;{putmessage('start repeat','','','');}      REPEAT	{ don't change any filenames or booleans unless ACCEPT }        ModalDialog(NewModalFilterProc(@DefaultFilter), itemHit);        GetDialogItem(GetSelection, itemHit, DType, DItem, tempRect);        CItem := controlhandle(DItem);        {Handle it real time}        IF (itemHit = I_Accept) THEN          BEGIN            ExitDialog := True;            Refresh_Dialog;          END;        IF (itemHit = I_Cancel) THEN	{nothing should change!!!}          BEGIN            ExitDialog := True;		(*  Do_HallOutput := false;			Do_CLOutput := false;	*)            Refresh_Dialog;          END;        	    IF (itemHit = I_SpreadSheet) THEN		BEGIN            temp := GetControlValue(CItem);            SetControlValue(CItem, (temp + 1) MOD 2);			if temp = 0 then Spread_Boolean := true else Spread_Boolean := false;			IF (not Spread_Boolean) THEN temp := 255;						For index := I_Sufficient_Output to I_Thin_Target_Physics DO			BEGIN			  GetDialogItem(GetSelection, index, DType, DItem, tempRect);			  HiliteControl(controlhandle(DItem), temp); 			END;				        For index := I_Excel_Spreadsheet to I_KaleidaGraph_Spreadsh DO			BEGIN			{¥¥¥ which ever one was on last should be on when visible...NO!NO!NO!}			  GetDialogItem(GetSelection, index, DType, DItem, tempRect);			  CTempItem := controlhandle(DItem);			  IF (Spread_Boolean) then ShowControl(CTempItem)		      Else HideControl(CTempItem);			END;			Refresh_Dialog;       END;   { IF (itemHit = I_SpreadSheet)...}  				{¥¥¥ If you can't see them you can't turn them on but...}		IF (Spread_Boolean) and		   ((itemHit = I_Excel_Spreadsheet) or		    (itemHit = I_KaleidaGraph_Spreadsh) or		    (itemHit = I_Statview_Spreadsheet)) THEN        BEGIN			for index := I_Excel_Spreadsheet to I_KaleidaGraph_Spreadsh do			begin			  GetDialogItem(GetSelection, index, DType, DItem, tempRect);			  CTempItem := controlhandle(DItem);			  SetControlValue(CTempItem, 0); { turn off the button }			end;	{for index...}  			SetControlValue(CItem,1); { turn on the selected button }		    			IF (itemHit = I_Excel_Spreadsheet) THEN OutName := '.Excel'			ELSE IF (itemHit = I_Statview_Spreadsheet) THEN OutName := '.Stat'			ELSE OutName := '.Kaleid';						if Do_CLOutput then OutName := concat('CL_Results',OutName)			else if Do_HallOutput then OutName := concat(Hall_Name,OutName)			else OutName := concat(MCA_ResultsName,OutName);					    if (CreateFile(OutName, 'Name Spreadsheet File:') = True) OR			   (File_Cancel_Button = False) then; {the file is named, not created}			   						IF File_Cancel_Button = True THEN			BEGIN			    SpreadSpec := Out_Spec;				SpreadName := OutName;				Spread_VolNum := Out_VolRefNum;	{WD}				Spread_Boolean := true;			END			ELSE	{canceled the filename dialog so no spreadsheet so clear all}			BEGIN	{File_Cancel_Button = False}			    Spread_Boolean := false;				GetDialogItem(GetSelection, I_SpreadSheet, DType, DItem, tempRect);				SetControlValue(controlhandle(DItem), 0); { turn off spreadsheet }					            For index := I_Excel_Spreadsheet to I_KaleidaGraph_Spreadsh DO				BEGIN				  GetDialogItem(GetSelection, index, DType, DItem, tempRect);				  CTempItem := controlhandle(DItem);			      SetControlValue(CTempItem, 0); { turn off the button }				  HideControl(CTempItem);				END;	{For index := I_Excel_Spreadsheet...}		    END;	{File_Cancel_Button = False}			Refresh_Dialog;	    END;	{IF (Spread_Boolean) and (itemHit = I_Excel_Spreadsheet) or...}         IF (itemHit = I_MCA_Format) THEN          BEGIN		{this choice appears for fit files only}            temp := GetControlValue(CItem);            SetControlValue(CItem, (temp + 1) MOD 2);            IF (temp = 0) THEN	{ itemHit = I_MCA_Format }             BEGIN				If (binary_choice) then Begin				  IF (MCA_File_Boolean) THEN OutName := MCA_ResultsName 				  ELSE OutName := 'DTSA_CurveFitFile'; 				  temp:=0;				  if (CreateFile(OutName, 'Name the binary results File:') = True) OR 				  (File_Cancel_Button = False) then;				  If (File_Cancel_Button) then begin				  		MCA_Results_VolNum := Out_VolRefNum;						MCA_ResultsName := Outname;					    MCA_ResultsDirID := OutVol_DirID;					    MCA_ResultsVNum := OutVol_volnum;						end;				End				Else Begin				  If (Hall_active or Cliff_Lorimer_Active) then begin				  {You can make ascii fit files with quant info added if you get here from				   the quant D'Log. }					If Hall_Active then mytype := 'MCAH'					else if Cliff_Lorimer_Active then  mytype := 'MCAo';					myprompt := 'Quant File to use?';{get binary Hall or CL file to read}					REPEAT					temp := 0;					UNTIL (GetFileName(Hall_Name, mytype, mytype, myprompt) = True) OR 								(File_Cancel_Button = False);					If (File_Cancel_Button) then Hall_Vol := In_VolRefNum; {correct}				  end	{ If Hall_active...}				  else begin	{ Get an old fit file to read for options }					mytype := 'MCAb';					myprompt := 'Options for Fit File:';					REPEAT					temp := 0;					UNTIL (GetFileName(MCA_ResultsName, mytype, mytype, myprompt) = True) OR 								(File_Cancel_Button = False);					If (File_Cancel_Button) then MCA_Results_VolNum := In_VolRefNum; 				  end;				End;	{ Else Begin...}				IF (File_Cancel_Button = False) THEN SetControlValue(CItem, 0);			   Refresh_Dialog;              END;	{ IF (temp = 0)...}          END;	{ IF (itemHit = I_MCA_Format...}			        IF (itemHit = I_Full_Text_Report) THEN          BEGIN            temp := GetControlValue(CItem);            SetControlValue(CItem, (temp + 1) MOD 2); {change value}            IF (temp = 1) THEN {was on, now off}              BEGIN				GetDialogItem(GetSelection, I_Normal_Output, DType, DItem, tempRect);				HiliteControl(controlhandle(DItem), 255); { grey out }		 				GetDialogItem(GetSelection, I_Reduced_Output, DType, DItem, tempRect);				HiliteControl(controlhandle(DItem), 255); { grey out }              END            ELSE            IF (temp = 0) THEN BEGIN				if (Do_CLOutput or Do_HallOutput) then OutName := concat(Hall_name,'_Text')				else IF (MCA_File_Boolean) THEN OutName := concat(MCA_ResultsName,'_TEXT')                 else OutName := 'FitResults_TEXT';				temp := 0;                if (CreateFile(OutName, 'Name a Full Output text File:') = True) OR 				      ( File_Cancel_Button = False) then;                IF File_Cancel_Button = True THEN                  BEGIN					  PlainName := OutName;					  Plain_VolNum := Out_VolRefNum;					 GetDialogItem(GetSelection, I_Normal_Output, DType, DItem, tempRect);					 HiliteControl(controlhandle(DItem), 0); 					 GetDialogItem(GetSelection, I_Reduced_Output, DType, DItem, tempRect);					 HiliteControl(controlhandle(DItem), 0);				 END				ELSE SetControlValue(CItem, 0);			   Refresh_Dialog;              END;          END;        IF (itemHit >= I_Sufficient_Output) AND (itemHit <= I_Thin_Target_Physics) THEN          BEGIN            FOR index := I_Sufficient_Output TO I_Thin_Target_Physics DO              BEGIN                GetDialogItem(GetSelection, index, DType, DItem, tempRect);                SetControlValue(controlhandle(DItem), 0);              END;            SetControlValue(CItem, 1); { Set the button that was hit }			IF (itemHit = I_Sufficient_Output) THEN			BEGIN			  Thin_Physics_Boolean := False;			  Bulk_Physics_Boolean := False;			END			ELSE IF (itemHit = I_Thin_Target_Physics) THEN			BEGIN			  Thin_Physics_Boolean := True;			  Bulk_Physics_Boolean := False;			  Putmessage('¥¥Double Warning¥¥ if you are going to do k factors using the provided',			             'columns, be certain you have chosen the correct kilovoltage and the',						 'desired characteristic x-ray cross-sections and that the stored detector',						 'response curve agrees closely with your actual detector response');			END			ELSE IF (itemHit = I_Bulk_Target_Physics) THEN			BEGIN			  Thin_Physics_Boolean := False;			  Bulk_Physics_Boolean := True;			  Putmessage('¥¥Double Warning¥¥ if you are going to use the extra columns, be certain ',			             'you have "generated" a bulk spectrum with the same composition as your',						 'specimen, and that the stored detector response curve agrees closely with',						 'your actual detector response. "Generate" into an unused spectrum number.');			  			END;		   Refresh_Dialog;          END;         IF (itemHit >= I_Normal_Output) AND (itemHit <= I_Reduced_Output) THEN        BEGIN            FOR index := I_Normal_Output TO I_Reduced_Output DO              BEGIN                GetDialogItem(GetSelection, index, DType, DItem, tempRect);                SetControlValue(controlhandle(DItem), 0);              END;            SetControlValue(CItem, 1); { Set the button that was hit }			IF (itemHit = I_Normal_Output) THEN			BEGIN			  Normal_Output := True;			  Reduced_Output := FALSE;			END			ELSE IF (itemHit = I_Reduced_Output) THEN			BEGIN			  Normal_Output := FALSE;			  Reduced_Output := True; 			END;		   Refresh_Dialog;        END;		        UNTIL ExitDialog; { Now get the results }		  IF (itemHit = I_ACCEPT) THEN begin						num_of_fits := 0;				GetDialogItem(GetSelection, I_MCA_Format, DType, DItem, tempRect);		temp := GetControlValue(controlhandle(DItem));		IF ((temp = 1) and (binary_choice)) then		begin	{MCA_Results_VolNum is a WD num}			  MCA_File_Boolean := false;{file will be made in MakeBinaryResults}			  MCA_OptionsBoolean := true;		End;	{ IF ((temp = 1) and (binary_choice))...}	        errcode := getvol(Save_Volume_Name,save_vol);		    		GetDialogItem(GetSelection, I_Full_Text_Report, DType, DItem, tempRect);		temp := GetControlValue(controlhandle(DItem));		if temp = 1 then 		begin		  Plain_Boolean := True;		  Plain_options := True;		  errcode := SetVol(NIL, Plain_VolNum);		  Open(Plain, PlainName);		  Rewrite(Plain);		  close(Plain);          fndrInfo.fdcreator := 'MSWD';          fndrInfo.fdtype := 'TEXT';          fndrInfo.fdFlags := 0;          errCode := setfinfo(PlainName, Plain_VolNum, fndrInfo);		  errcode := SetVol(NIL, Plain_VolNum);          numToString(errCode, str);          IF errCode <> noErr THEN            putmessage('setFinfo error just occured', 'in trying to set file info for "plain"', 'Error Number', str);          errcode := FlushVol(NIL, Plain_VolNum);		end		else begin			 Plain_Boolean := false;			 Plain_options := false;		end;        errcode := setvol(Save_Volume_Name,save_vol);	    		IF Spread_Boolean THEN 		BEGIN			{do this here rather than above to be safe...}			index := I_Excel_Spreadsheet - 1;			temp := 0;			Repeat			  index := index + 1;			  GetDialogItem(GetSelection, index, DType, DItem, tempRect);			  temp := GetControlValue(controlhandle(DItem));			Until (temp =1) or (index = I_KaleidaGraph_Spreadsh);						{if Spread_Boolean temp must be 1 but...}			If (temp =1) then 			IF (index = I_Excel_Spreadsheet) THEN  spreadcreator:= 'XCEL'			ELSE IF (index = I_Statview_Spreadsheet) THEN  spreadcreator:= 'STAT'			ELSE  spreadcreator := 'QKPT';					    {If Plain_Boolean then Spread_VolNum := Plain_VolNum;}	{WHY change this???}			errcode := SetVol(NIL, Spread_VolNum);			fndrInfo.fdcreator := spreadcreator;			fndrInfo.fdtype := 'TEXT';			fndrInfo.fdFlags := 0; { set bit 14 to 0 to make icon visible }	(*      errcode := Create(SpreadName,Spread_VolNum,spreadcreator,'TEXT');	*)		   		    errcode := FSpCreate(SpreadSpec,fndrInfo.fdcreator,'TEXT',smSystemScript); 			errcode := FSPSetfinfo(SpreadSpec, fndrInfo);			IF errcode <> NoErr THEN			  putmessage('setFinfo error just occured', 'in FSPSetfinfo(SpreadSpec, fndrInfo)', '', '');(*          Open( spread, SpreadName);		    Rewrite(spread,SpreadName);  {we have to use this, or change spread from type   			                              text to integer, and all writeln, etc, in Sandia;										  this sets the mark at file start but does										  NOT set an EOF, so if one seeks an eof, the										  contents are not written over}		    Close(spread);            errCode := setfinfo(SpreadName, Spread_VolNum, fndrInfo);*)			errcode := FSPOpenDF(SpreadSpec,0,refnum);			errcode := setEOF(refnum,0);	{we NEVER append text files}			errcode := FSClose(refnum);						errcode := FlushVol(NIL, Spread_VolNum);		 END;	{IF Spread_Boolean...} 	  End;	{ if item_hit = I_accept...}		 		 		 tempRect := GetSelection^.portRect;		 DisposeDialog(GetSelection);		 FillWhiteSpace(tempRect);		{ binary_choice := true;	let the calling procedure reset this }    END;	{ D_Results_Options }    PROCEDURE Update_Text_Window { (whichWindow: WindowPtr) } ;    BEGIN {Start of Window update routine}      IF (TextWindow <> NIL) AND (TextWindow = whichWindow) THEN {Handle an open when already                                                                  opened}        BEGIN		  GetPort(GrafPtr(SavePort));          SetPort(TextWindow);          SelectWindow(TextWindow);		  BeginUpdate(whichWindow);      {Set the clipping to the update area}          DrawControls(TextWindow);          Mouse_Active_Window;		  EndUpdate(whichWindow);        {Return to normal clipping area}		  SetPort(GrafPtr(SavePort));        END; {End for if (TextWindow<>nil)}    END; {End of procedure}  {===========================================================================================}  PROCEDURE Init_Text_Window;    BEGIN {Start of Window initialize routine}      TextWindow := NIL; {Make sure other routines know we are not valid yet}    END; {End of procedure}  {===========================================================================================}  PROCEDURE Close_Text_Window { (whichWindow: WindowPtr; VAR theInput: TEHandle) } ;    BEGIN {Start of Window close routine}      IF (TextWindow <> NIL) AND (TextWindow = whichWindow) THEN {Close if this is us}        BEGIN          DisposeWindow(TextWindow); {Clear window and controls}          TextWindow := NIL; {Make sure other routines know we are open}        END; {End for if (TextWindow<>nil)}    END; {End of procedure}  PROCEDURE Do_Text_Window { (myEvent: EventRecord) } ;    VAR      RefCon                        : integer;        {RefCon for controls}      code                          : integer;        {Location of event in window or controls}      whichWindow                   : WindowPtr;      {Window pointerwwhere event happened}      myPt                          : Point;          {Point where event happened}      SmplxCtrlHandle              : ControlHandle;	      PROCEDURE Do_A_Button; {Handle a button being pressed}      BEGIN        HiliteControl(SmplxCtrlHandle, 10); {Darken the button}        RefCon := GetControlReference(SmplxCtrlHandle); {get control refcon}        CASE RefCon OF {Select correct button}          Smplx_Return: {Bye, button}            BEGIN              Open_Sili_Window; { Return to the SiLi window }              Mouse_Active_Window;              stopButton := True;            END; { case of...}          OTHERWISE {allow other buttons, trap for debug}            BEGIN {start}            END; {end of otherwise}          END; {end of case}        HiliteControl(SmplxCtrlHandle, 0); {Lighten the button}      END; {Handle a button being pressed}    BEGIN {Start of Window handler}      IF (TextWindow <> NIL) THEN {Handle only when the window is valid}        BEGIN          ShowWindow(TextWindow);          code := FindWindow(myEvent.where, whichWindow); {Get where in window and which window}          IF (myEvent.what = MouseDown) AND (TextWindow = whichWindow) THEN {}            BEGIN {}              myPt := myEvent.where; {Get mouse position}              WITH TextWindow^.portBits.Bounds DO {Make it relative}                BEGIN                  myPt.h := myPt.h + Left;                  myPt.v := myPt.v + Top;                END;            END;          IF (TextWindow = whichWindow) AND (code = inContent) THEN {for our window}            BEGIN              code := FindControl(myPt, whichWindow, SmplxCtrlHandle); {Get type of control}              IF (code <> 0) THEN {Check type of control}                code := TrackControl(SmplxCtrlHandle, myPt, NIL); {Track the control}              IF code = kControlButtonPart THEN Do_A_Button; {Do buttons}            END; {End for if (TextWindow=whichWindow)}        END; {End for if (TextWindow<>nil)}    END; {End of Text procedure}  {===========================================================================================}   PROCEDURE Open_Text_Window;    BEGIN {Start of Window open routine}      IF (TextWindow = NIL) THEN {Handle an open when not opened}        BEGIN          TextWindow := GetNewWindow(339, NIL, Pointer( - 1));		  MoveWindow(TextWindow,MaxWindowRect.Left,MaxWindowRect.Bottom-123,TRUE );           CtrlHandle := GetNewControl(Smplx_Return, TextWindow); { button "BYE"}        END {End for if (TextWindow=nil)}      ELSE {Already open, so ..... }        BEGIN        END;    END;  PROCEDURE Simplex_Output_Handler {( Which_Output : Integer )} ;    VAR      Value                         : real;      index                         : integer;      j, jj, index2, kk     : integer;      X_OffSet                      : integer;      Y_OffSet                      : integer;      Print_Offset                  : integer;      TextRect                      : Rect;           {Temporary rectangle}      Simplex_Temp                  : Str255;         {Temporary string}	  str,str1,str2,str3,str4,str7   : str255;    BEGIN		  SetPort(TextWindow);		  SelectWindow(TextWindow);		  ShowWindow(TextWindow);		  {if test hall or cl here then can't see xisq window stuff in do_a_fit...		   try the test in 2:}		  if fit_invisibly or		    ((Hall_Active or Cliff_Lorimer_Active) and (Which_Output = 2))			 then HideWindow(TextWindow);		  SetRect(TextRect, 0, 0, 595, 116); {left top, right bottom relative to TextWindow rectangle											  (8,365),(633,471)...seems bigger}		  BackColor(WhiteColor);		  ForeColor(BlackColor);		  eraseRect(TextRect);		  DrawControls(TextWindow); {Draw the BYE box}		  Mouse_Active_Window;		Peak_12 := False; { the following set to false in case the user left up the ROI}		BackGround_12 := False; { window and went directly to the SIMPLEX procedure }		Peak_Wipe := False;		BackGround_Wipe := False;		Clear_ROI := False;		Scale_ROI := False;      CASE Which_Output OF	  	    0:          BEGIN		  END;        1:          BEGIN            SetFont('Geneva', 12, [bold]);            SetRect(Simplex_In_Rect, 23, 1, 174, 17); {left,top,right,bottom}            Simplex_Temp := 'Biggest Peak FWHM:';            TETextBox(Pointer(Ord(@Simplex_Temp) + 1), length(Simplex_Temp), Simplex_In_Rect,                    Tejustright);            SetRect(Simplex_In_Rect, 66, 19, 174, 35);            Simplex_Temp := 'Chi-Squared:';            TETextBox(Pointer(Ord(@Simplex_Temp) + 1), length(Simplex_Temp), Simplex_In_Rect,                    Tejustright);            SetRect(Simplex_In_Rect, 100, 37, 174, 53);            Simplex_Temp := 'Run Time:';            TETextBox(Pointer(Ord(@Simplex_Temp) + 1), length(Simplex_Temp), Simplex_In_Rect,                    Tejustright);            SetRect(Simplex_In_Rect, 23, 55, 174, 71);            Simplex_Temp := 'Vertex Spread:';            TETextBox(Pointer(Ord(@Simplex_Temp) + 1), length(Simplex_Temp), Simplex_In_Rect,                    Tejustright);            SetRect(Simplex_In_Rect, 75, 73, 174, 89);            Simplex_Temp := 'Iterations:';            TETextBox(Pointer(Ord(@Simplex_Temp) + 1), length(Simplex_Temp), Simplex_In_Rect,                    Tejustright);            SetRect(Simplex_In_Rect, 98, 91, 174, 106);            if WDS_active then Simplex_Temp := 'Pk FWHM:' else Simplex_Temp := 'Mn FWHM:';            TETextBox(Pointer(Ord(@Simplex_Temp) + 1), length(Simplex_Temp), Simplex_In_Rect,                    Tejustright);          END; { CASE OF 1:}        2:          BEGIN            SetFont('Geneva', 12, [bold]);            SetRect(Simplex_In_Rect, 5, 51, 630, 57); {left,top,right,bottom}            Simplex_Temp := 'To See Abreviated Results for a ROI, Click in the ROI. For a full'             ;            TETextBox(Pointer(Ord(@Simplex_Temp) + 1), length(Simplex_Temp), Simplex_In_Rect,                    TeJustLeft);            SetRect(Simplex_In_Rect, 5, 65, 630, 71); {left,top,right,bottom}            Simplex_Temp := 'report of this fit, Click OK to retire this message, then SEE FIT.';            TETextBox(Pointer(Ord(@Simplex_Temp) + 1), length(Simplex_Temp), Simplex_In_Rect,                    TeJustLeft);            Update_Full;          END; { CASE OF 2:}        3:          BEGIN            SetFont('Geneva', 9, []);            X_OffSet := 310;            Y_OffSet := 11;            Print_Offset := 80;            Value := Analysis_Result^^.Fit_Result.Response[Chosen_Region];            MoveTo(1, 7);            DrawString('Response = ');            RealToString(Value, 5, 2, Str);            DrawString(Str);            MoveTo(100, 7);            Value := Analysis_Result^^.Fit_Result.FWHM_Mn[Chosen_Region];            DrawString('Mn FWHM = ');            RealToString(Value, 5, 2, Str);            DrawString(Str);            MoveTo(200, 7);            Value := Analysis_Result^^.Fit_Result.Iterations[Chosen_Region];            DrawString('  Iterations = ');            RealToString(Value, 5, 1, Str);            DrawString(Str);            MoveTo(60, 18);            DrawString('Area');            MoveTo(60 + Print_Offset, 18);            IF LLSQ_Active THEN DrawString('Error') ELSE DrawString('Energy');            RealToString(Plt_spec[10]^^.Expt_Info.dE, 4, 2, str7);            str7 := CONCAT('P/', str7, 'eV Local');            MoveTo(60 + 2 * Print_Offset, 18);            DrawString(str7);            { MoveTo(60 + 3 * Print_Offset, 18); DrawString('P/Chosen');}            kk := Analysis_Result^^.Fit_params.First_in_Roi[Chosen_Region];			            IF (Chosen_Region = Number_of_PeakRois - 1) THEN			              index2 := Analysis_Result^^.Fit_params.Number_of_Peaks - 			            Analysis_Result^^.Fit_params.First_in_Roi[Chosen_Region] + 1            ELSE              index2 := Analysis_Result^^.Fit_params.First_in_Roi[Chosen_Region + 1] -                        Analysis_Result^^.Fit_params.First_in_Roi[Chosen_Region];  {         numtostring(Chosen_Region,str1);       numtostring(index2,str2);      putmessage('number of peaks in the clicked region=', str2,'Chosen_Region=',str1); }                 index := 0;            FOR j := 1 TO index2 DO { step across the number of peaks in the clicked region }              BEGIN                IF j >= 19 THEN                  BEGIN                    exit(Simplex_Output_Handler);                  END;                jj := j + kk - 1;                index := index + 1;      		 (* IF (Analysis_Result^^.Fit_params.Siegbahn[jj] = 'KA2  ') THEN Cycle;                IF (Analysis_Result^^.Fit_params.Siegbahn[jj] = 'KA1  ') THEN                  BEGIN                    numtostring(Analysis_Result^^.Fit_params.Atomic_Number[jj], Str);                    str1 := CONCAT(Str, ' KA       ');                    RealToString((Analysis_Result^^.Fit_Result.Area[jj] + Analysis_Result^^.                                 Fit_Result.Area[jj + 1]), 7, 2, Str2);                    Str2 := CONCAT(str1, Str2);                    RealToString((2 * Analysis_Result^^.Fit_Result.Err_or_Energy[jj] +                                 Analysis_Result^^.Fit_Result.Err_or_Energy[jj + 1]) / 3, 9, 4,                                 Str3);                    RealToString(Analysis_Result^^.Fit_Result.Peak_to_Local_Bkg[jj] +                                 Analysis_Result^^.Fit_Result.Peak_to_Local_Bkg[jj + 1], 7, 2,                                 Str4);                  END                ELSE                  IF (Analysis_Result^^.Fit_params.Siegbahn[jj] <> 'KA2  ') THEN                    BEGIN	*)                      numtostring(Analysis_Result^^.Fit_params.Atomic_Number[jj], Str);                      str1 := CONCAT(Str, ' ', Analysis_Result^^.Fit_params.Siegbahn[jj], '    ');                      RealToString(Analysis_Result^^.Fit_Result.Area[jj], 5, 2, Str2);                      Str2 := CONCAT(str1, Str2);                      RealToString(Analysis_Result^^.Fit_Result.Err_or_Energy[jj], 5, 4, Str3);                      RealToString(Analysis_Result^^.Fit_Result.Peak_to_Local_Bkg[jj], 5, 2, Str4);               (*    END;	*)                IF index < 9 THEN                  BEGIN                    MoveTo(1, 29 + (index - 1) * Y_OffSet);                    DrawString(Str2);                    MoveTo(60 + Print_Offset, 29 + (index - 1) * Y_OffSet);                    DrawString(Str3);                    MoveTo(70 + 2 * Print_Offset, 29 + (index - 1) * Y_OffSet);                    DrawString(Str4);                  END;                IF index > 8 THEN                  BEGIN                    MoveTo(1 + X_OffSet, 29 + (index - 9) * Y_OffSet);                    DrawString(Str2);                    MoveTo(60 + X_OffSet + Print_Offset, 29 + (index - 9) * Y_OffSet);                    DrawString(Str3);                    MoveTo(70 + X_OffSet + 2 * Print_Offset, 29 + (index - 9) * Y_OffSet);                    DrawString(Str4);                  END;              END; { for index:=index...}            SetFont('Geneva', 12, [bold]);          END; { CASE OF 3:}        END; { of CASE }    END; { PROCEDURE Simplex_Output_Handler }END. { of UNIT CurveFit }