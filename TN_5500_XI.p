UNIT TN_5500_XI_Plug;INTERFACEUSES	Types, QuickDraw, Memory, fp, StandardFile, GestaltEqu, Errors, Files,	TextUtils, {PascalA4,} FilePlugIns;const		__procinfo : longint = $3F80;{$Main}PROCEDURE	ENTRYPOINT(message:Integer; VAR InPtr:IOPlugPtr; VAR theResult:OSerr);IMPLEMENTATION{$IFC NOT POWERPC}uses PascalA4;{$ENDC}PROCEDURE TN_5500_XI(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);FORWARD;PROCEDURE DoAbout(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);FORWARD;PROCEDURE DoOpen(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);FORWARD;PROCEDURE DoWrite(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);FORWARD;FUNCTION	Str2Num(s: Str255): Real;FORWARD;PROCEDURE 	ENTRYPOINT{(message:Integer; VAR InPtr:IOPlugPtr; VAR theResult:OSErr)};		{ Main dispatching routine.  Initializes and sets up the global variables,	}		{		and performs the operation specified by the message. 				}VAR	firstTime	: BOOLEAN;	OldA4		: Longint;BEGIN{$IFC NOT POWERPC}	oldA4 := SetCurrentA4();	RememberA4();{$ENDC}	theResult:=noErr;	firstTime:=(InPtr=NIL);					{ See if this is the first time called }	IF firstTime THEN BEGIN						{ If so, allocate and initialize a data area }		InPtr:= IOPlugPtr(NewPtrClear(sizeof(IOPlug)));		IF (InPtr=NIL) THEN BEGIN			debugstr('memFullErr');			theResult:=memFullErr;{$IFC NOT POWERPC}	oldA4 := SetA4(oldA4);{$ENDC}			EXIT(ENTRYPOINT);		END;				END;		CASE message OF					{ Perform the requested operation }		fileAbout		:DoAbout(InPtr, theResult);		ImpFile			:TN_5500_XI(InPtr, theResult);		ExpFile			:DoWrite(InPtr, theResult);		OpenInPlug		:DoOpen(InPtr, theResult);		OpenExPlug		:DoOpen(InPtr, theResult);		END; {CASE message}		{$IFC NOT POWERPC}	oldA4 := SetA4(oldA4);{$ENDC}END;PROCEDURE DoAbout(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);	Begin	End;	PROCEDURE DoOpen(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);	Begin		InPtr^.PlugInName:='TN 5500 XI';		{Debugstr('Inside of TN_5500_XI - Do Open');}		theResult := noErr;	End;	PROCEDURE DoWrite(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);	Begin	End;PROCEDURE TN_5500_XI(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);          CONST      tBufferSize            = 100000; {Never more than a single spectrum, 8192 chans ┼ 80K}    TYPE      tBuffer                 = PACKED ARRAY [1..tBufferSize] OF signedbyte;      tBufPtr                 = ^tBuffer;	  TByte                   = PACKED ARRAY [1..1] OF byte;    VAR      index, nn, jj, kk             : integer;      err                           : integer;      refnum                        : integer;      FileSize                      : longint;      tipBufPtr                     : tBufPtr;      indexL                        : longint;      {counter                       : integer;}      strLength                     : TByte;      bytecount                     : longint;      str, str1, str2               : str255;      theWhere                      : Point;      theReply                      : SFReply;      finished                      : Boolean;      Car_Ret                       : Boolean;	  IValue						: longint;	  RValue                        : real;    	BEGIN		refnum := InPtr^.Rd_Refnum;		{Debugstr('Inside of TN_5500_XI');}		InPtr^.Specimen_Comment_Field := '';			nn := 0;		err := GetEOF(refnum, FileSize);		tipBufPtr := tBufPtr(NewPtr(sizeof(tBuffer)));		err := FSRead(refnum, FileSize, Pointer(tipBufPtr));		theResult := err;        indexL := 0; { indexL will be the "file" pointer }        REPEAT { find TN-5500 in the string and sync}            indexL := indexL + 1;            IF indexL > FileSize THEN begin				DisposePtr(Ptr(tipBufPtr));				theResult := badFileFormat;				exit(TN_5500_XI);			end;          UNTIL (tipBufPtr^[indexL] = $54) AND (tipBufPtr^[indexL + 1] = $4E) AND (tipBufPtr^[indexL + 2] = $2D) AND (tipBufPtr^[                indexL + 3] = $35) AND (tipBufPtr^[indexL + 4] = $35) AND (tipBufPtr^[indexL + 5] = $30) AND (tipBufPtr^[indexL +                6] = $30);          REPEAT { indexL to beginning of next line, now that we are synched }            indexL := indexL + 1;            IF indexL > FileSize THEN begin				DisposePtr(Ptr(tipBufPtr));				theResult := badFileFormat;				exit(TN_5500_XI);			end;          UNTIL (tipBufPtr^[indexL] = $0D);          indexL := indexL + 7; { skim off the junk characters }          WHILE (tipBufPtr^[indexL] <> $0D) DO { now pick up the header}            BEGIN              InPtr^.Specimen_Comment_Field := CONCAT(InPtr^.Specimen_Comment_Field, chr(tipBufPtr^[indexL]));              indexL := indexL + 1;              IF indexL > FileSize THEN begin				DisposePtr(Ptr(tipBufPtr));				theResult := badFileFormat;				exit(TN_5500_XI);			end;            END; { While }          REPEAT { find LT =}            indexL := indexL + 1;            IF indexL > FileSize THEN begin				DisposePtr(Ptr(tipBufPtr));				theResult := badFileFormat;				exit(TN_5500_XI);			end;          UNTIL (tipBufPtr^[indexL] = $4C) AND (tipBufPtr^[indexL + 1] = $54) AND ((tipBufPtr^[indexL + 2] = $20) OR (tipBufPtr^[                indexL + 2] = $09)) AND (tipBufPtr^[indexL + 3] = $3D);          {$4C = L, $54 = T, $20 = space, $09 is a tab and $3D is an =}          indexL := indexL + 4; { stop at the = sign }          WHILE ((tipBufPtr^[indexL] = $20) OR (tipBufPtr^[indexL + 2] = $09)) DO            indexL := indexL + 1; { jump over a run of spaces or tabs}          str := '';          WHILE NOT ((tipBufPtr^[indexL] = $20) OR (tipBufPtr^[indexL] = $09)) DO            BEGIN              str := CONCAT(str, chr(tipBufPtr^[indexL]));              indexL := indexL + 1;              IF indexL > FileSize THEN begin				DisposePtr(Ptr(tipBufPtr));				theResult := badFileFormat;				exit(TN_5500_XI);			end;            END; { While }          IF (LENGTH(str) > 0) {AND ((ClassExtended(str2num(str)) = NormalNum) OR (ClassExtended(str2num(str)) = ZeroNum))} THEN            InPtr^.Live_Time := str2num(str);          REPEAT { find RT =}            indexL := indexL + 1;            IF indexL > FileSize THEN begin				DisposePtr(Ptr(tipBufPtr));				theResult := badFileFormat;				exit(TN_5500_XI);			end;          UNTIL (tipBufPtr^[indexL] = $52) AND (tipBufPtr^[indexL + 1] = $54) AND ((tipBufPtr^[indexL + 2] = $20) OR (tipBufPtr^[                indexL + 2] = $09)) AND (tipBufPtr^[indexL + 3] = $3D);          indexL := indexL + 4; { stop at the = sign }          WHILE ((tipBufPtr^[indexL] = $20) OR (tipBufPtr^[indexL] = $09)) DO            indexL := indexL + 1; { jump over a run of spaces }          str := '';          WHILE NOT ((tipBufPtr^[indexL] = $20) OR (tipBufPtr^[indexL] = $09)) DO            BEGIN              str := CONCAT(str, chr(tipBufPtr^[indexL]));              indexL := indexL + 1;              IF indexL > FileSize THEN begin				DisposePtr(Ptr(tipBufPtr));				theResult := badFileFormat;				exit(TN_5500_XI);			end;            END; { While }          IF (LENGTH(str) > 0) {AND ((ClassExtended(str2num(str)) = NormalNum) OR (ClassExtended(str2num(str)) = ZeroNum))} THEN            InPtr^.Real_Time := str2num(str);          jj := 1; { jj will be the channel number }          REPEAT            indexL := indexL + 1;            IF indexL > FileSize THEN begin				DisposePtr(Ptr(tipBufPtr));				theResult := badFileFormat;				exit(TN_5500_XI);			end;          UNTIL tipBufPtr^[indexL] = $23 { find and sync on #} ;          indexL := indexL + 1;          WHILE ((tipBufPtr^[indexL] = $20) OR (tipBufPtr^[indexL] = $09)) DO            indexL := indexL + 1; { jump over a run of spaces }          str := '';          WHILE NOT ((tipBufPtr^[indexL] = $20) OR (tipBufPtr^[indexL] = $09)) OR (str = '') DO            BEGIN              str := CONCAT(str, chr(tipBufPtr^[indexL]));              indexL := indexL + 1;              IF indexL > FileSize THEN begin				DisposePtr(Ptr(tipBufPtr));				theResult := badFileFormat;				exit(TN_5500_XI);			end;            END; { While }          indexL := indexL + 1;          WHILE ((tipBufPtr^[indexL] = $20) OR (tipBufPtr^[indexL] = $09)) DO            indexL := indexL + 1; { jump over a run of spaces }          str := '';          WHILE NOT ((tipBufPtr^[indexL] = $20) OR (tipBufPtr^[indexL] = $09)) DO            BEGIN              str := CONCAT(str, chr(tipBufPtr^[indexL]));              indexL := indexL + 1;              IF indexL > FileSize THEN begin				DisposePtr(Ptr(tipBufPtr));				theResult := badFileFormat;				exit(TN_5500_XI);			end;            END; { While }          IF (LENGTH(str) > 0) THEN InPtr^.Number_of_Channels := rinttol(str2num(str));          IF InPtr^.Number_of_Channels <= 0 THEN begin				DisposePtr(Ptr(tipBufPtr));				theResult := badFileFormat;				exit(TN_5500_XI);			end;          indexL := indexL + 1;          REPEAT {еееее This part reads in the spectrum еееее}            IF (tipBufPtr^[indexL] = $0D {CR} ) THEN indexL := indexL + 1;            IF (tipBufPtr^[indexL] = $3E {>} ) THEN indexL := indexL + 1;            IF (tipBufPtr^[indexL] = $45 {E} ) THEN begin				DisposePtr(Ptr(tipBufPtr));				theResult := badFileFormat;				exit(TN_5500_XI);			end;            WHILE ((tipBufPtr^[indexL] = $20) OR (tipBufPtr^[indexL] = $09)) DO              indexL := indexL + 1; { jump over a run of spaces }            str := '';            WHILE NOT ((tipBufPtr^[indexL] = $20) OR (tipBufPtr^[indexL] = $09)) AND (tipBufPtr^[indexL] <> $0D) DO              BEGIN                IF (tipBufPtr^[indexL] = $45 {E} ) THEN begin				DisposePtr(Ptr(tipBufPtr));				theResult := badFileFormat;				exit(TN_5500_XI);			end;                str := CONCAT(str, chr(tipBufPtr^[indexL]));                indexL := indexL + 1;              END; { While }            IF (LENGTH(str) > 0) {AND ((ClassExtended(str2num(str)) = NormalNum) OR (ClassExtended(str2num(str)) = ZeroNum))}               THEN              BEGIN                InPtr^.Spec_cts[jj] := str2num(str);                jj := jj + 1;              END;            indexL := indexL + 1;          UNTIL jj >= InPtr^.Number_of_Channels; {еееее This part read in the spectrum еееее}        DisposePtr(Ptr(tipBufPtr));      END; { IF Which_Format = 11 THEN...... TN 5500 XI format }{*****************************************************************************}FUNCTION Str2Num(s: Str255): Real;   { Pascal implementation of Str2Num (fp.p: Str2Dec, Dec2Str) }VAR	aDecimal		: Decimal;	aCStr			: ConstCStringPtr;	anIndex			: Integer;	aValidPrefix	: Integer; { ignore }BEGIN	aCStr := P2CStr(@s);	anIndex := 0;	str2dec( aCStr, anIndex, aDecimal, aValidPrefix );	Str2Num := dec2num( aDecimal );END;END.