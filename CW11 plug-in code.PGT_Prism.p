UNIT PGT_Prism_Plug;INTERFACEUSES	Types, QuickDraw, Memory, fp, StandardFile, GestaltEqu, Errors, Files,	TextUtils, {PascalA4,} FilePlugIns;const		__procinfo : longint = $3F80;{$Main}PROCEDURE	ENTRYPOINT(message:Integer; VAR InPtr:IOPlugPtr; VAR theResult:OSerr);IMPLEMENTATION{$IFC NOT POWERPC}uses PascalA4;{$ENDC}PROCEDURE PGT_Prism(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);FORWARD;PROCEDURE DoAbout(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);FORWARD;PROCEDURE DoOpen(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);FORWARD;PROCEDURE DoWrite(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);FORWARD;FUNCTION	Str2Num(s: Str255): Real;FORWARD;PROCEDURE 	ENTRYPOINT{(message:Integer; VAR InPtr:IOPlugPtr; VAR theResult:OSErr)};		{ Main dispatching routine.  Initializes and sets up the global variables,	}		{		and performs the operation specified by the message. 				}VAR	firstTime	: BOOLEAN;	OldA4		: Longint;BEGIN{$IFC NOT POWERPC}	oldA4 := SetCurrentA4();	RememberA4();{$ENDC}	theResult:=noErr;	firstTime:=(InPtr=NIL);					{ See if this is the first time called }	IF firstTime THEN BEGIN						{ If so, allocate and initialize a data area }		InPtr:= IOPlugPtr(NewPtrClear(sizeof(IOPlug)));		IF (InPtr=NIL) THEN BEGIN			debugstr('memFullErr');			theResult:=memFullErr;{$IFC NOT POWERPC}	oldA4 := SetA4(oldA4);{$ENDC}			EXIT(ENTRYPOINT);		END;				END;		CASE message OF					{ Perform the requested operation }		fileAbout		:DoAbout(InPtr, theResult);		ImpFile			:PGT_Prism(InPtr, theResult);		ExpFile			:DoWrite(InPtr, theResult);		OpenInPlug		:DoOpen(InPtr, theResult);		OpenExPlug		:DoOpen(InPtr, theResult);		END; {CASE message}		{$IFC NOT POWERPC}	oldA4 := SetA4(oldA4);{$ENDC}END;PROCEDURE DoAbout(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);	Begin	End;	PROCEDURE DoOpen(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);	Begin		InPtr^.PlugInName:='PGT Prism';		{Debugstr('Inside of PGT_Prism - Do Open');}		theResult := noErr;	End;	PROCEDURE DoWrite(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);	Begin	End;  PROCEDURE PGT_Prism(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);        CONST      tSerial_BufferSize            = 50000; {Never more than a single spectrum, 2048 chans}    TYPE      tPAC256Buffer                 = PACKED ARRAY [1..tSerial_BufferSize] OF signedbyte;      tPAC256BufPtr                 = ^tPAC256Buffer;	  TByte                         = PACKED ARRAY [1..1] OF byte;    VAR      index, nn, jj, kk             : integer;      FileSize                      : longint;      theRefnum                     : integer;      tipBufPtr                     : tPAC256BufPtr;      indexL, pos                   : longint;      strLength, lenth              : TByte;      bytecount                     : longint;      str, str1, str2               : str255;      Car_Ret                       : Boolean;      START_EV                      : Real;	  END_EV                        : Real;	  num_channels					: integer;	  errCode                       : OSErr;	  Function search_str(len : TByte; VAR strx : str255):longint;	VAR		strr	: str255;	BEGIN        strLength[1] := len[1];        BlockMove(@strLength, @strr[0], 1);        REPEAT          BlockMove(@tipBufPtr^[indexL], @strr[1], strLength[1]);          indexL := indexL + 1;        UNTIL ((strr = strx) OR (indexL >= FileSize));		if (indexL >= FileSize) then begin			search_str := indexL;			{Debugstr('indexL >= FileSize');}			exit(search_str);		end;        indexL := indexL + strLength[1];		search_str := indexL;		if (strx = 'channel counts:') then exit(search_str);        WHILE ((tipBufPtr^[indexL] = $20) OR (tipBufPtr^[indexL] = $09) OR (tipBufPtr^[indexL] = $0A)) DO          indexL := indexL + 1; { jump over a run of spaces }        strr := '';       (* WHILE (tipBufPtr^[indexL] <> $0D) DO          BEGIN*)          indexL := indexL - 1;          REPEAT            indexL := indexL + 1;            strr := CONCAT(strr, chr(tipBufPtr^[indexL]));            {Debugstr(strr);}          UNTIL (tipBufPtr^[indexL] = $0D);         (* END; { While }*)		  strx := strr;		  search_str := indexL;	END;    BEGIN		theRefnum := InPtr^.Rd_Refnum;		{Debugstr('Inside of PGT_Prism');}		InPtr^.Specimen_Comment_Field := '';					  errCode := GetEOF(theRefnum, FileSize);      tipBufPtr := tPAC256BufPtr(NewPtr(sizeof(tPAC256Buffer)));      IF tipBufPtr = NIL THEN        BEGIN          exit(PGT_Prism);        END;        {Debugstr('Begin reading the file');}      errCode :=  FSRead(theRefnum, FileSize, Pointer(tipBufPtr));		  theResult := errCode;{Debugstr('Finished reading file');}      Car_Ret := false;        indexL := 0;		lenth[1] := 19;		str := 'number of channels:';		pos := search_str(lenth, str);		if (indexL >= FileSize) then begin			theResult := errCode {badFileFormat};			{Debugstr('cannot find no. of chan');}			exit(PGT_Prism);		end;		IF (LENGTH(str) > 0) THEN num_channels := rinttol(str2num(str));{Debugstr('Finished no of chan');}		lenth[1] := 6;		str := 'label:';		pos := search_str(lenth, str);		if (indexL >= FileSize) then begin			theResult := badFileFormat;			exit(PGT_Prism);		end;		IF (LENGTH(str) > 0) THEN InPtr^.Specimen_Comment_Field := str;{Debugstr('Finished labels');}		lenth[1] := 15;		str := 'ev per channel:';		pos := search_str(lenth, str);		if (indexL >= FileSize) then begin			theResult := badFileFormat;			exit(PGT_Prism);		end;		IF (LENGTH(str) > 0) THEN InPtr^.dE := str2num(str);{Debugstr('Finished ev/chan');}		lenth[1] := 10;		str := 'live time:';		pos := search_str(lenth, str);		if (indexL >= FileSize) then begin			theResult := badFileFormat;			exit(PGT_Prism);		end;		IF (LENGTH(str) > 0) THEN InPtr^.Live_Time := str2num(str);{Debugstr('Finished live time');}		lenth[1] := 14;		str := 'probe current:';		pos := search_str(lenth, str);		if (indexL >= FileSize) then begin			theResult := badFileFormat;			exit(PGT_Prism);		end;		IF (LENGTH(str) > 0) THEN InPtr^.Begin_Faraday := str2num(str);		IF (LENGTH(str) > 0) THEN InPtr^.End_Faraday := str2num(str);{Debugstr('Finished current');}		lenth[1] := 21;		str := 'accelerating voltage:';		pos := search_str(lenth, str);		if (indexL >= FileSize) then begin			theResult := badFileFormat;			exit(PGT_Prism);		end;		IF (LENGTH(str) > 0) THEN InPtr^.kV := str2num(str);{Debugstr('Finished kV');}		lenth[1] := 10;		str := 'real time:';		pos := search_str(lenth, str);		if (indexL >= FileSize) then begin			theResult := badFileFormat;			exit(PGT_Prism);		end;		IF (LENGTH(str) > 0) THEN InPtr^.Real_Time := str2num(str);{Debugstr('Finished real time');}		lenth[1] := 15;		str := 'date collected:';		pos := search_str(lenth, str);		if (indexL >= FileSize) then begin			theResult := badFileFormat;			exit(PGT_Prism);		end;		{IF (LENGTH(str) > 0) THEN ;}	{this is the date}{Debugstr('Began reading spectrum');}		lenth[1] := 15;		str := 'channel counts:';		pos := search_str(lenth, str);		if (indexL >= FileSize) then begin			theResult := badFileFormat;			exit(PGT_Prism);		end;				indexL := indexL + 1;		jj := 0;		REPEAT			str := '';			WHILE NOT ((tipBufPtr^[indexL] = $0D) OR (tipBufPtr^[indexL] = $0A)) DO			  BEGIN				str := CONCAT(str, chr(tipBufPtr^[indexL]));				indexL := indexL + 1;			  END; { While }			jj := jj + 1;			InPtr^.Spec_cts[jj] := str2num(str);			indexL := indexL + 1;		UNTIL jj = num_channels;		InPtr^.Number_of_Channels := num_channels;		InPtr^.LastChannel := InPtr^.Number_of_Channels;       	DisposePtr(Ptr(tipBufPtr));		theResult := noErr;    END; { Procedure PGT_Prism }{*****************************************************************************}FUNCTION Str2Num(s: Str255): Real;   { Pascal implementation of Str2Num (fp.p: Str2Dec, Dec2Str) }VAR	aDecimal		: Decimal;	aCStr			: ConstCStringPtr;	anIndex			: Integer;	aValidPrefix	: Integer; { ignore }BEGIN	aCStr := P2CStr(@s);	anIndex := 0;	str2dec( aCStr, anIndex, aDecimal, aValidPrefix );	Str2Num := dec2num( aDecimal );END;END. 