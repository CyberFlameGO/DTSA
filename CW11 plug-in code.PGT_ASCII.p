UNIT PGT_ASCII_Plug;INTERFACEUSES	Types, QuickDraw, Memory, fp, StandardFile, GestaltEqu, Errors, Files,	TextUtils, {PascalA4,} FilePlugIns;const		__procinfo : longint = $3F80;{$Main}PROCEDURE	ENTRYPOINT(message:Integer; VAR InPtr:IOPlugPtr; VAR theResult:OSerr);IMPLEMENTATION{$IFC NOT POWERPC}uses PascalA4;{$ENDC}PROCEDURE PGT_ASCII(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);FORWARD;PROCEDURE DoAbout(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);FORWARD;PROCEDURE DoOpen(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);FORWARD;PROCEDURE DoWrite(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);FORWARD;FUNCTION	Str2Num(s: Str255): Real;FORWARD;PROCEDURE 	ENTRYPOINT{(message:Integer; VAR InPtr:IOPlugPtr; VAR theResult:OSErr)};		{ Main dispatching routine.  Initializes and sets up the global variables,	}		{		and performs the operation specified by the message. 				}VAR	firstTime	: BOOLEAN;	OldA4		: Longint;BEGIN{$IFC NOT POWERPC}	oldA4 := SetCurrentA4();	RememberA4();{$ENDC}	theResult:=noErr;	firstTime:=(InPtr=NIL);					{ See if this is the first time called }	IF firstTime THEN BEGIN						{ If so, allocate and initialize a data area }		InPtr:= IOPlugPtr(NewPtrClear(sizeof(IOPlug)));		IF (InPtr=NIL) THEN BEGIN			debugstr('memFullErr');			theResult:=memFullErr;{$IFC NOT POWERPC}	oldA4 := SetA4(oldA4);{$ENDC}			EXIT(ENTRYPOINT);		END;				END;		CASE message OF					{ Perform the requested operation }		fileAbout		:DoAbout(InPtr, theResult);		ImpFile			:PGT_ASCII(InPtr, theResult);		ExpFile			:DoWrite(InPtr, theResult);		OpenInPlug		:DoOpen(InPtr, theResult);		OpenExPlug		:DoOpen(InPtr, theResult);		END; {CASE message}		{$IFC NOT POWERPC}	oldA4 := SetA4(oldA4);{$ENDC}END;PROCEDURE DoAbout(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);	Begin	End;	PROCEDURE DoOpen(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);	Begin		InPtr^.PlugInName:='PGT ASCII';		{Debugstr('Inside of PGT_ASCII - Do Open');}		theResult := noErr;	End;	PROCEDURE DoWrite(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);	Begin	End;    PROCEDURE PGT_ASCII(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);            CONST      tBufferSize            = 100000; {Never more than a single spectrum, 8192 chans ┼ 80K}    TYPE      tBuffer                 = PACKED ARRAY [1..tBufferSize] OF signedbyte;      tBufPtr                 = ^tBuffer;	  TByte                   = PACKED ARRAY [1..1] OF byte;    VAR      index, nn, jj, kk             : integer;      err                           : integer;      refnum                        : integer;      FileSize                      : longint;      tipBufPtr                     : tBufPtr;      indexL                        : longint;      {counter                       : integer;}      strLength                     : TByte;      bytecount                     : longint;      str, str1, str2               : str255;      theWhere                      : Point;      theReply                      : SFReply;      finished                      : Boolean;      Car_Ret                       : Boolean;	  IValue						: longint;	  RValue                        : real;        LABEL        100, 101, 401;  	BEGIN		refnum := InPtr^.Rd_Refnum;		{Debugstr('Inside of PGT_ASCII_Files');}		InPtr^.Specimen_Comment_Field := '';						nn := 0;		err := GetEOF(refnum, FileSize);		tipBufPtr := tBufPtr(NewPtr(sizeof(tBuffer)));		err := FSRead(refnum, FileSize, Pointer(tipBufPtr));		theResult := err;        Car_Ret := false;        indexL := 0;        strLength[1] := 7;        BlockMove(@strLength, @str[0], 1);        FOR nn := 1 TO 100 DO { move into the buffer until the string "nchans:" found }          BEGIN            indexL := indexL + 1;            BlockMove(@tipBufPtr^[indexL], @str[1], strLength[1]);            IF str = 'nchans:' THEN GOTO 101;          END;        DisposePtr(Ptr(tipBufPtr));		theResult := badFileFormat;        exit(PGT_ASCII);      101:        indexL := 0; { RESET to 0, indexL will now be the "file" pointer } (*nchans: 1920 evperchan:     10.417 startev:      0.000 endev:  20000.000label: Al2O3 part. sec. bakeoutcounts:00etc.*)       (* REPEAT { go thru a series of spectra until FINISHED := true; }*)          strLength[1] := 7;          BlockMove(@strLength, @str[0], 1);          FOR nn := 1 TO 100 DO { move into the buffer until the string "nchans:" found, and register from this}            BEGIN              indexL := indexL + 1;              BlockMove(@tipBufPtr^[indexL], @str[1], strLength[1]);              IF str = 'nchans:' THEN                BEGIN                  indexL := indexL + strLength[1];                  GOTO 100;                END;            END;          GOTO 401;        100:          WHILE ((tipBufPtr^[indexL] = $20) OR (tipBufPtr^[indexL + 2] = $09)) DO            indexL := indexL + 1; { jump over a run of spaces or tabs}          str := '';          WHILE NOT ((tipBufPtr^[indexL] = $20) OR (tipBufPtr^[indexL] = $09)) DO            BEGIN              str := CONCAT(str, chr(tipBufPtr^[indexL]));              indexL := indexL + 1;              IF indexL > FileSize THEN GOTO 401;            END; { While }          IF (LENGTH(str) > 0) {AND ((ClassExtended(str2num(str)) = NormalNum) OR (ClassExtended(str2num(str)) = ZeroNum))} THEN            InPtr^.Number_of_Channels := rinttol(str2num(str));          WHILE ((tipBufPtr^[indexL] = $20) OR (tipBufPtr^[indexL + 2] = $09)) DO            indexL := indexL + 1; { jump over a run of spaces or tabs}          strLength[1] := 10;          BlockMove(@strLength, @str[0], 1);          REPEAT            BlockMove(@tipBufPtr^[indexL], @str[1], strLength[1]);            indexL := indexL + 1;          UNTIL str = 'evperchan:';          indexL := indexL + strLength[1];          WHILE ((tipBufPtr^[indexL] = $20) OR (tipBufPtr^[indexL + 2] = $09)) DO            indexL := indexL + 1; { jump over a run of spaces or tabs}          str := '';          WHILE NOT ((tipBufPtr^[indexL] = $20) OR (tipBufPtr^[indexL] = $09)) DO            BEGIN              str := CONCAT(str, chr(tipBufPtr^[indexL]));              indexL := indexL + 1;            END;          IF (LENGTH(str) > 0) {AND (ClassExtended(str2num(str)) = NormalNum)} THEN InPtr^.dE := str2num(str)          ELSE InPtr^.dE := 10.0;          strLength[1] := 6;          BlockMove(@strLength, @str[0], 1);          REPEAT            indexL := indexL + 1;            BlockMove(@tipBufPtr^[indexL], @str[1], strLength[1]);          UNTIL str = 'label:';          indexL := indexL + strLength[1];          WHILE ((tipBufPtr^[indexL] = $20) OR (tipBufPtr^[indexL + 2] = $09)) DO            indexL := indexL + 1; { jump over a run of spaces or tabs}          jj := 0;          REPEAT            jj := jj + 1;          UNTIL tipBufPtr^[indexL + jj] = 13; {measure the length of the line }          strLength[1] := jj - 1;          BlockMove(@strLength, @str[0], 1);          BlockMove(@tipBufPtr^[indexL], @str[1], strLength[1]);          InPtr^.Specimen_Comment_Field := str;          indexL := indexL + strLength[1];          InPtr^.Live_Time := 0.0; { Since PGT does not provide this }          InPtr^.Real_Time := 0.0; { Since PGT does not provide this }          strLength[1] := 7;          BlockMove(@strLength, @str[0], 1);          REPEAT            indexL := indexL + 1;            BlockMove(@tipBufPtr^[indexL], @str[1], strLength[1]);          UNTIL str = 'counts:';          indexL := indexL + strLength[1];          jj := 0;          REPEAT {еееее This part reads in the spectrum еееее}            WHILE ((tipBufPtr^[indexL] = $20) OR (tipBufPtr^[indexL + 2] = $09)) DO              indexL := indexL + 1; { jump over a run of spaces or tabs}            str := '';            IF (tipBufPtr^[indexL] = $0D {CR} ) THEN indexL := indexL + 1;            WHILE ((tipBufPtr^[indexL] = $20) OR (tipBufPtr^[indexL + 2] = $09)) DO              indexL := indexL + 1; { jump over a run of spaces or tabs}            WHILE (tipBufPtr^[indexL] <> $20) AND (tipBufPtr^[indexL] <> $0D) DO              BEGIN                str := CONCAT(str, chr(tipBufPtr^[indexL]));                indexL := indexL + 1;              END; { While }            IF LENGTH(str) > 0 THEN              BEGIN                jj := jj + 1;                InPtr^.Spec_cts[jj] := str2num(str);              END;            indexL := indexL + 1;          UNTIL jj >= InPtr^.Number_of_Channels; {еееее This part read in the spectrum еееее}        (*UNTIL finished;*)      401:        DisposePtr(Ptr(tipBufPtr));      END;{*****************************************************************************}FUNCTION Str2Num(s: Str255): Real;   { Pascal implementation of Str2Num (fp.p: Str2Dec, Dec2Str) }VAR	aDecimal		: Decimal;	aCStr			: ConstCStringPtr;	anIndex			: Integer;	aValidPrefix	: Integer; { ignore }BEGIN	aCStr := P2CStr(@s);	anIndex := 0;	str2dec( aCStr, anIndex, aDecimal, aValidPrefix );	Str2Num := dec2num( aDecimal );END;END.