UNIT EDAX_MTI_Plug;INTERFACEUSES	Types, QuickDraw, Memory, fp, StandardFile, GestaltEqu, Errors, Files,	TextUtils, {PascalA4,} FilePlugIns;const		__procinfo : longint = $3F80;{$Main}PROCEDURE	ENTRYPOINT(message:Integer; VAR InPtr:IOPlugPtr; VAR theResult:OSerr);IMPLEMENTATION{$IFC NOT POWERPC}uses PascalA4;{$ENDC}PROCEDURE EDAX_MTI(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);FORWARD;PROCEDURE DoAbout(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);FORWARD;PROCEDURE DoOpen(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);FORWARD;PROCEDURE DoWrite(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);FORWARD;FUNCTION	Str2Num(s: Str255): Real;FORWARD;PROCEDURE 	ENTRYPOINT{(message:Integer; VAR InPtr:IOPlugPtr; VAR theResult:OSErr)};		{ Main dispatching routine.  Initializes and sets up the global variables,	}		{		and performs the operation specified by the message. 				}VAR	firstTime	: BOOLEAN;	OldA4		: Longint;BEGIN{$IFC NOT POWERPC}	oldA4 := SetCurrentA4();	RememberA4();{$ENDC}	theResult:=noErr;	firstTime:=(InPtr=NIL);					{ See if this is the first time called }	IF firstTime THEN BEGIN						{ If so, allocate and initialize a data area }		InPtr:= IOPlugPtr(NewPtrClear(sizeof(IOPlug)));		IF (InPtr=NIL) THEN BEGIN			debugstr('memFullErr');			theResult:=memFullErr;{$IFC NOT POWERPC}	oldA4 := SetA4(oldA4);{$ENDC}			EXIT(ENTRYPOINT);		END;				END;		CASE message OF					{ Perform the requested operation }		fileAbout		:DoAbout(InPtr, theResult);		ImpFile			:EDAX_MTI(InPtr, theResult);		ExpFile			:DoWrite(InPtr, theResult);		OpenInPlug		:DoOpen(InPtr, theResult);		OpenExPlug		:DoOpen(InPtr, theResult);		END; {CASE message}		{$IFC NOT POWERPC}	oldA4 := SetA4(oldA4);{$ENDC}END;PROCEDURE DoAbout(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);	Begin	End;	PROCEDURE DoOpen(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);	Begin		InPtr^.PlugInName:='EDAX MTI ASCII';		{Debugstr('Inside of PGT_Prism - Do Open');}		theResult := noErr;	End;	PROCEDURE DoWrite(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);	Begin	End;  PROCEDURE EDAX_MTI(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);        CONST      tSerial_BufferSize            = 50000; {Never more than a single spectrum, 2048 chans}    TYPE      tPAC256Buffer                 = PACKED ARRAY [1..tSerial_BufferSize] OF signedbyte;      tPAC256BufPtr                 = ^tPAC256Buffer;	  TByte                         = PACKED ARRAY [1..1] OF byte;    VAR      index, nn, jj, kk             : integer;      FileSize                      : longint;      theRefnum                     : integer;      tipBufPtr                     : tPAC256BufPtr;      indexL, pos                   : longint;      strLength, lenth              : TByte;      bytecount                     : longint;      str, str1, str2               : str255;      Car_Ret                       : Boolean;      START_EV                      : Real;	  END_EV                        : Real;	  num_channels					: integer;	  errCode                       : OSErr;	  Function search_str(len : TByte; VAR strx : str255):longint;	VAR		strr	: str255;	BEGIN        strLength[1] := len[1];        BlockMove(@strLength, @strr[0], 1);        REPEAT          BlockMove(@tipBufPtr^[indexL], @strr[1], strLength[1]);          indexL := indexL + 1;        UNTIL ((strr = strx) OR (indexL >= FileSize));		if (indexL >= FileSize) then begin			search_str := indexL;			exit(search_str);		end;        indexL := indexL + strLength[1];		search_str := indexL;        WHILE ((tipBufPtr^[indexL] = $20) OR (tipBufPtr^[indexL] = $09)) DO          indexL := indexL + 1; { jump over a run of spaces }        strr := '';        WHILE NOT (tipBufPtr^[indexL] = $0D) DO          BEGIN            strr := CONCAT(strr, chr(tipBufPtr^[indexL]));            indexL := indexL + 1;          END; { While }		  strx := strr;		  search_str := indexL;	END;    BEGIN		theRefnum := InPtr^.Rd_Refnum;		{Debugstr('Inside of EDAX_MTI');}		InPtr^.Specimen_Comment_Field := '';					  errCode := GetEOF(theRefnum, FileSize);      tipBufPtr := tPAC256BufPtr(NewPtr(sizeof(tPAC256Buffer)));      IF tipBufPtr = NIL THEN        BEGIN          exit(EDAX_MTI);        END;      IF FSRead(theRefnum, FileSize, Pointer(tipBufPtr)) <> NoErr THEN        BEGIN		  theResult := badFileFormat;		  DisposePtr(Ptr(tipBufPtr));          exit(EDAX_MTI);        END;      Car_Ret := false;		num_channels := 2048;        indexL := 0;		lenth[1] := 10;		str := 'Filename :';		pos := search_str(lenth, str);		if (indexL >= FileSize) then begin			theResult := badFileFormat;			exit(EDAX_MTI);		end;		(*IF (LENGTH(str) > 0) THEN num_channels := rinttol(str2num(str));*)		lenth[1] := 7;		str := 'Label :';		pos := search_str(lenth, str);		if (indexL >= FileSize) then begin			theResult := badFileFormat;			exit(EDAX_MTI);		end;		IF (LENGTH(str) > 0) THEN InPtr^.Specimen_Comment_Field := str;		lenth[1] := 6;		str := 'Date :';		pos := search_str(lenth, str);		if (indexL >= FileSize) then begin			theResult := badFileFormat;			exit(EDAX_MTI);		end;		IF (LENGTH(str) > 0) THEN InPtr^.Specimen_Comment_Field := concat(									InPtr^.Specimen_Comment_Field, str);		{IF (LENGTH(str) > 0) THEN InPtr^.dE := str2num(str);}		lenth[1] := 6;		str := 'Time :';		pos := search_str(lenth, str);		if (indexL >= FileSize) then begin			theResult := badFileFormat;			exit(EDAX_MTI);		end;		IF (LENGTH(str) > 0) THEN InPtr^.Specimen_Comment_Field := concat(									InPtr^.Specimen_Comment_Field, str);		lenth[1] := 4;		str := 'kV :';		pos := search_str(lenth, str);		if (indexL >= FileSize) then begin			theResult := badFileFormat;			exit(EDAX_MTI);		end;		IF (LENGTH(str) > 0) THEN InPtr^.kV := str2num(str);		lenth[1] := 6;		str := 'Tilt :';		pos := search_str(lenth, str);		if (indexL >= FileSize) then begin			theResult := badFileFormat;			exit(EDAX_MTI);		end;		IF (LENGTH(str) > 0) THEN InPtr^.X_Tilt := str2num(str);		lenth[1] := 9;		str := 'Takeoff :';		pos := search_str(lenth, str);		if (indexL >= FileSize) then begin			theResult := badFileFormat;			exit(EDAX_MTI);		end;		IF (LENGTH(str) > 0) THEN InPtr^.Specimen_Comment_Field := concat(									InPtr^.Specimen_Comment_Field,' TOA = ', str);		lenth[1] := 21;		str := 'Beam Current Factor :';		pos := search_str(lenth, str);		if (indexL >= FileSize) then begin			theResult := badFileFormat;			exit(EDAX_MTI);		end;		IF (LENGTH(str) > 0) THEN InPtr^.Begin_Faraday := str2num(str);		IF (LENGTH(str) > 0) THEN InPtr^.End_Faraday := str2num(str);		indexL := indexL + 1;		jj := 0;		REPEAT			str := '';			WHILE NOT ((tipBufPtr^[indexL] = $0D) OR (tipBufPtr^[indexL] = $0A)) DO			  BEGIN				str := CONCAT(str, chr(tipBufPtr^[indexL]));				indexL := indexL + 1;			  END; { While }			jj := jj + 1;			InPtr^.Spec_cts[jj] := str2num(str);			indexL := indexL + 1;		UNTIL (jj = num_channels) OR (indexL >= FileSize);		InPtr^.Number_of_Channels := num_channels;		InPtr^.LastChannel := InPtr^.Number_of_Channels;       	DisposePtr(Ptr(tipBufPtr));		theResult := noErr;    END; { Procedure EDAX_MTI }{*****************************************************************************}FUNCTION Str2Num(s: Str255): Real;   { Pascal implementation of Str2Num (fp.p: Str2Dec, Dec2Str) }VAR	aDecimal		: Decimal;	aCStr			: ConstCStringPtr;	anIndex			: Integer;	aValidPrefix	: Integer; { ignore }BEGIN	aCStr := P2CStr(@s);	anIndex := 0;	str2dec( aCStr, anIndex, aDecimal, aValidPrefix );	Str2Num := dec2num( aDecimal );END;END. 