{[j=30/55,:+,u+,r+,o=120,k+,n+,#+,v+,q+,b+]}{       ----------------------------------------------------------------------}{       -----              CITZAF1 VERS. 3.02 -- 22 JUN 90               -----}{       -----        Copyright, John T. Armstrong, Caltech, 1988         -----}{       ----------------------------------------------------------------------}{                   Written by J. Armstrong, Caltech, Geology Dept.           }{        MacIntosh Interface by C.E. Fiori, NIST,  and J. Armstrong, Caltech  }{       ----------------------------------------------------------------------}{       -----                 *****  MAIN CODE UNIT  *****               -----}UNIT CITZAFCode;INTERFACE  USES  QuickDraw, Types, OSUtils, ToolUtils, Timer, Errors, Menus, Files, Lists, Memory,   Packages, Printing, StandardFile, PasLibIntf, fenv, fp, SegLoad, Retrace, CitInitialize,  Spectrum_Structures, Declarations, INITIALIZE, Xray_Energies, Global_Functions, physics, xray ;   PROCEDURE Show_Std_Result;  PROCEDURE Show_Smp_Result;  PROCEDURE SMP_ZAF;  PROCEDURE List_Element_Corrections;  PROCEDURE Which_Elements_Done;  PROCEDURE SETUP_Fluorescence;  PROCEDURE STD_ZAF;  PROCEDURE Load_Energies;  PROCEDURE GetMACs;  PROCEDURE Type_of_Stored_Output;  PROCEDURE Heading;  FUNCTION  PowerF(Term: real {double_t}; Exponent: real {double_t}): real {double_t};IMPLEMENTATION  {$S CITZAFCode}    VAR    eta, fp, XP                       : real {double_t};        MEANZ, JBAR, XI, Hp, ZN, ZP,  SUMATOM1, SUMATOM: real {double_t};  FUNCTION FNLint(X9: real {double_t}): real {double_t}; { Logarithmic Integral }        VAR      XX1, XX4, XX5, X8, X7, XX3    :double_t;    BEGIN      XX1 := Ln(X9);      XX4 := 0;      XX3 := 1;      XX5 := 1;      X8 := Ln(ABS(XX1)) + 0.577216;      REPEAT        XX4 := XX4 + 1;        XX5 := XX5 * XX4;        X7 := X8;        X8 := X8 + PowerF(XX1, XX4) / (XX4 * XX5);        XX3 := ABS(X8 - X7);      UNTIL (XX3 < 0.00005) AND (XX4 > 2);      FNLint := X8;    END;  FUNCTION PowerF(Term: real {double_t}; Exponent: real {double_t}): real {double_t};    BEGIN      PowerF := Exp(Exponent * Ln(Term));    END;  PROCEDURE Get_MAC_K_Table;    VAR      mac_kx                        : ARRAY [4..40, 1..95] OF real;      IREAD, i, i1		            : Integer;      IDummy			            : Integer;      dummy                         : real;      {header                        : str255;}	  {File_Name_K                   : fnamestr; 	  TxtFile_K                     : Text;}    BEGIN      File_Name1 := 'MAC_K_Data';      Reset(TxtFile1, File_Name1);      FOR IREAD := 1 TO 5 DO        BEGIN          FOR i := 1 TO 8 DO            BEGIN              read(TxtFile1, G^^.IMR[i]);            END;          FOR i1 := 1 TO 95 DO            BEGIN              read(TxtFile1, IDummy);              FOR i := 1 TO 8 DO                BEGIN                  IF G^^.IMR[i] > 0 THEN                    BEGIN                      read(TxtFile1, mac_kx[G^^.IMR[i], i1]);                    END                  ELSE                    BEGIN                      read(TxtFile1, dummy);                    END;                END;            END; { for i := 1 to 95 }          Readln(TxtFile1, header);          Readln(TxtFile1, header);        END; { for Iread := 1 to 5 }      Close(TxtFile1);      FOR i := 1 TO IN1 DO        BEGIN          IF G4^^.IL[i] = 1 THEN            BEGIN              FOR i1 := 1 TO I_N DO                G2^^.P[i1, i] := mac_kx[A^.IZ[i], A^.IZ[i1]];            END;        END;    END; { PROCEDURE Get_MAC_K_Table; }{$S CITZAFCode45}  PROCEDURE Get_MAC_L_Table;    VAR      mac_lx                        : ARRAY [22..92, 1..95] OF real;      IREAD, i, i1                  : Integer;      dummy                         : real;      IDummy                        : Integer;      {header                        : str255;}	 { File_Name_L                   : fnamestr; 	  TxtFile_L                     : Text;}    BEGIN      File_Name1 := 'MAC_L_Data';      Reset(TxtFile1, File_Name1);      FOR IREAD := 1 TO 9 DO        BEGIN          FOR i := 1 TO 8 DO            BEGIN              read(TxtFile1, G^^.IMR[i]);            END;          FOR i1 := 1 TO 95 DO            BEGIN              read(TxtFile1, IDummy);              FOR i := 1 TO 8 DO                IF G^^.IMR[i] > 0 THEN                  BEGIN                    read(TxtFile1, mac_lx[G^^.IMR[i], i1]);                  END                ELSE                  BEGIN                    read(TxtFile1, dummy);                  END;            END; { for i := 1 to 95 }          Readln(TxtFile1, header);          Readln(TxtFile1, header);        END; { for Iread := 1 to 9 }      Close(TxtFile1);      FOR i := 1 TO IN1 DO        BEGIN          IF G4^^.IL[i] = 2 THEN            BEGIN              FOR i1 := 1 TO I_N DO                G2^^.P[i1, i] := mac_lx[A^.IZ[i], A^.IZ[i1]];            END;        END;    END; { PROCEDURE Get_MAC_L_Table; }{$S CITZAFCode46}  PROCEDURE Get_MAC_M_Table;    VAR      mac_mx                        : ARRAY [72..95, 1..95] OF real;      IREAD, i, i1                  : Integer;      dummy                         : real;      IDummy                        : Integer;      {header                        : str255;}	 { File_Name_M                   : fnamestr; 	  TxtFile_M                     : Text;}    BEGIN      File_Name1 := 'MAC_M_Data';      Reset(TxtFile1, File_Name1);      FOR IREAD := 1 TO 3 DO        BEGIN          FOR i := 1 TO 8 DO            BEGIN              read(TxtFile1, G^^.IMR[i]);            END;          FOR i1 := 1 TO 95 DO            BEGIN              read(TxtFile1, IDummy);              FOR i := 1 TO 8 DO                IF G^^.IMR[i] > 0 THEN                  BEGIN                    read(TxtFile1, mac_mx[G^^.IMR[i], i1]);                  END                ELSE                  BEGIN                    read(TxtFile1, dummy);                  END;            END; { for i := 1 to 95 }          Readln(TxtFile1, header);          Readln(TxtFile1, header);        END; { for Iread := 1 to 3 }      Close(TxtFile1);      FOR i := 1 TO IN1 DO        BEGIN          IF G4^^.IL[i] = 3 THEN            BEGIN              FOR i1 := 1 TO I_N DO                G2^^.P[i1, i] := mac_mx[A^.IZ[i], A^.IZ[i1]];            END;        END;    END; { PROCEDURE Get_MAC_M_Table; }  {=================================}  PROCEDURE MACCAL(i : integer);          VAR      i1                          : Integer;    BEGIN      M7 := 0;      FOR i1 := 1 TO I_N DO        M7 := M7 + G^^.C[i1] * G2^^.P[i1, i];    END; { PROCEDURE MACCAL }  PROCEDURE Heading;   {----------------------------------------------------------------------}   {               -----       PRINTOUT OF CORRECTION FACTORS USED       -----}   {         ----------------------------------------------------------------------}        VAR      dummy                         : Integer;    BEGIN      IF IFirstRun = 0 THEN exit(Heading);      CASE IABS OF        1:          writeln(Out_TxtFile, '     ... ABSORPTION CORRECTION OF PHILIBERT');        2:          writeln(Out_TxtFile, '     ... ABSORPTION CORRECTION OF HEINRICH/AN. CHEM.');        3:          writeln(Out_TxtFile, '     ... ABSORPTION CORRECTION OF HEINRICH/1985 MAS');        4:          writeln(Out_TxtFile, '     ... ABSORPTION CORRECTION OF LOVE/SCOTT -- 1983');        5:          writeln(Out_TxtFile, '     ... ABSORPTION CORRECTION OF LOVE/SCOTT I -- 1985');        6:          writeln(Out_TxtFile, '     ... ABSORPTION CORRECTION OF LOVE/SCOTT II -- 1985');        7:          writeln(Out_TxtFile, '     ... PHI(PZ) ABSORPTION CORRECTION OF PACKWOOD/BROWN 1982/XRS');        8:          writeln(Out_TxtFile, '     ... PHI(PZ) ABSORPTION CORRECTION OF BASTIN 1984/XRS');        9:          writeln(Out_TxtFile, '     ... PHI(PZ) ABSORPTION CORRECTION OF ARMSTRONG(P/B) 1981/MAS');        10:          writeln(Out_TxtFile, '     ... PHI(PZ) ABSORPTION CORRECTION OF BASTIN 1986/SCANNING');        11:          writeln(Out_TxtFile, '     ... PHI(PZ) ABSORPTION CORRECTION OF RIVEROS 1987/XRS');        12:          writeln(Out_TxtFile, '     ... ABSORPTION CORRECTION OF POUCHOU & PICHOIR -- Full PAP');        13:          writeln(Out_TxtFile, '     ... ABSORPTION CORRECTION OF POUCHOU & PICHOIR -- Simple PAP');        14:          writeln(Out_TxtFile, '     ... PHI(PZ) ABSORPTION CORRECTION OF PACKWOOD (EPQ-91)');        15:          writeln(Out_TxtFile, '     ... PHI(PZ) ABSORPTION CORRECTION OF BASTIN PROZA (EPQ-91)');		          END;      CASE ISTP OF        1:          writeln(Out_TxtFile, '     ... STOPPING POWER CORRECTION OF DUNCUMB/REED(FRAME)');        2:          writeln(Out_TxtFile, '     ... STOPPING POWER CORRECTION OF PHILIBERT & TIXIER');        3:          writeln(Out_TxtFile, '     ... STOPPING POWER CORRECTION BY NUMERICAL INTEGRATION');        4:          writeln(Out_TxtFile, '     ... STOPPING POWER CORRECTION OF LOVE & SCOTT');        5:          writeln(Out_TxtFile, '     ... STOPPING POWER CORRECTION OF POUCHOU & PICHOIR');        6:          writeln(Out_TxtFile, '     ... ATOMIC NUMBER CORRECTION OF PHI(PZ) INTEGRATION');       		END;      CASE IBKS OF        1:          writeln(Out_TxtFile, '     ... BACKSCATTER CORRECTION OF DUNCUMB/REED(FRAME-I]');        2:          writeln(Out_TxtFile, '     ... BACKSCATTER CORRECTION OF DUNCUMB/REED(COR-2]');        3:          writeln(Out_TxtFile, '     ... BACKSCATTER CORRECTION OF DUNCUMB/REED(HEINRICH-MOD.)');        4:          writeln(Out_TxtFile, '     ... BACKSCATTER CORRECTION OF LOVE & SCOTT');        5:          writeln(Out_TxtFile, '     ... BACKSCATTER CORRECTION OF AUGUST, RAZKA & WERNISCH');        6:          writeln(Out_TxtFile, '     ... BACKSCATTER CORRECTION OF MYKLEBUST & FIORI');        7:          writeln(Out_TxtFile, '     ... BACKSCATTER CORRECTION OF POUCHOU & PICHOIR');		  		          END;      CASE IPHI OF        0:          dummy := 1; { Case of no phi zero being used }        1:          writeln(Out_TxtFile, '     ... PHI(0) EQUATION OF REUTER');        2:          writeln(Out_TxtFile, '     ... PHI(0) EQUATION OF LOVE/SCOTT');        3:          writeln(Out_TxtFile, '     ... PHI(0) EQUATION OF RIVEROS');        4:          writeln(Out_TxtFile, '     ... PHI(0) EQUATION OF Pouchout & Pichoir');        5:          writeln(Out_TxtFile, '     ... PHI(0) EQUATION OF KARDUCK & REHBACH');        6:          writeln(Out_TxtFile, '     ... PHI(0) EQUATION OF AUGUST & WERNISCH');        7:          writeln(Out_TxtFile, '     ... PHI(0) EQUATION OF PACKWOOD');		  		  		          END;      CASE IMIP OF        1:          writeln(Out_TxtFile, '     ... MEAN IONIZATION POTENTIALS OF BERGER/SELTZER');        2:          writeln(Out_TxtFile, '     ... MEAN IONIZATION POTENTIALS OF DUNCUMB/DA CASA');        3:          writeln(Out_TxtFile, '     ... MEAN IONIZATION POTENTIALS OF RUSTE/ZELLER');        4:          writeln(Out_TxtFile, '     ... MEAN IONIZATION POTENTIALS OF SPRINGER');        5:          writeln(Out_TxtFile, '     ... MEAN IONIZATION POTENTIALS OF Wilson');        6:          writeln(Out_TxtFile, '     ... MEAN IONIZATION POTENTIALS OF Heinrich');        7:          writeln(Out_TxtFile, '     ... MEAN IONIZATION POTENTIALS OF Bloch(Love/Scott)');        END;      CASE IBSC OF        0:          dummy := 1; { Case of no backscatter coefficients being used }        1:          writeln(Out_TxtFile, '     ... BACKSCATTER COEFFICIENTS OF HEINRICH');        2:          writeln(Out_TxtFile, '     ... BACKSCATTER COEFFICIENTS OF LOVE/SCOTT');        3:          writeln(Out_TxtFile, '     ... BACKSCATTER COEFFICIENTS OF Pouchou & Pichoir');        4:          writeln(Out_TxtFile, '     ... BACKSCATTER COEFFICIENTS OF HUNGER & KUCHLER (A&W-mod.)');		          END;      CASE IICS OF        0:          dummy := 1; { Case of no backscatter coefficients being used }	          1:          writeln(Out_TxtFile, '     ... IONIZATION CROSS SECTION OF BETHE-POWELL');        2:          writeln(Out_TxtFile, '     ... IONIZATION CROSS SECTION OF BETHE-BROWN.');        3:          writeln(Out_TxtFile, '     ... IONIZATION CROSS SECTION OF GREEN-COSSLETT');        4:          writeln(Out_TxtFile, '     ... IONIZATION CROSS SECTION OF HUTCHENS');        5:          writeln(Out_TxtFile, '     ... IONIZATION CROSS SECTION OF FABRE');        6:          writeln(Out_TxtFile, '     ... IONIZATION CROSS SECTION OF WORTHINGTON-TOMLIN');        7:          writeln(Out_TxtFile, '     ... IONIZATION CROSS SECTION OF GRYZINSKI');        8:          writeln(Out_TxtFile, '     ... IONIZATION CROSS SECTION OF CASNATI');        9:          writeln(Out_TxtFile, '     ... IONIZATION CROSS SECTION OF JAKOBY');        10:          writeln(Out_TxtFile, '     ... IONIZATION CROSS SECTION OF REZ');		END; { CASE }        CASE IERE OF        0:          dummy := 1; { Case of no backscatter coefficients being used }	          1:          writeln(Out_TxtFile, '     ... ELECTRON RETARDATION EXPRESSION OF BETHE.');        2:          writeln(Out_TxtFile, '     ... ELECTRON RETARDATION EXPRESSION OF WITRY, RAO-SAHIB');        3:          writeln(Out_TxtFile, '     ... ELECTRON RETARDATION EXPRESSION OF LOVE-SCOTT');        4:          writeln(Out_TxtFile, '     ... ELECTRON RETARDATION EXPRESSION OF JOY');		END; { CASE }        CASE IMAC OF        1:          writeln(Out_TxtFile, '     ... MASS ABSORPTION COEFFICIENTS FROM CITZAF TABLES');        2:          writeln(Out_TxtFile, '     ... MASS ABSORPTION COEFFICIENTS FROM Heinrich 1988');        3:          writeln(Out_TxtFile, '     ... MASS ABSORPTION COEFFICIENTS FROM Heinrich/FRAME');        END;      IF imac_Input THEN writeln(Out_TxtFile, 'DATA ENTRY OF MASS ABSORPTION COEFFICIENTS');    END;{$S CITZAFCode47}  PROCEDURE Type_of_Stored_Output; { CHOICE OF FILE PRINTOUT MODE }    BEGIN      CASE IPRN OF        0:          exit(Type_of_Stored_Output);        1:          BEGIN            ICEL := 1;            ICOX := 1;            ICAT := 1;            ILIN := 1;          END;        2:          BEGIN            IKEL := 1;            ICOX := 1;            ICAT := 1;            ILIN := 1;          END;        3:          BEGIN            IKEL := 1;            ICEL := 1;            ICAT := 1;            ILIN := 1;          END;        4:          BEGIN            IKEL := 1;            ICEL := 1;            ICOX := 1;            ILIN := 1;          END;        5:          BEGIN            IKEL := 1;            ICOX := 1;          END;        6:          BEGIN            IKEL := 1;            ICEL := 1;          END;        7:          BEGIN            ICOX := 1;          END;        8:          BEGIN            ICEL := 1;          END;        9:          BEGIN            IKEL := 1;          END;        END; { Case }    END;{$S CITZAFCode48}  PROCEDURE Load_Energies;   {----- READ AT.WT., LINE & EDGE ENERGIES, FLUOR. YIELDS-----}    VAR      i, IM4, IM5, IEL              : Integer;      M2, AA                         : real {double_t};    BEGIN { Procedure }      FOR i := 1 TO I_N DO        BEGIN          M2 := Ln(G^^.ZZZ[i]);          IM4 := G4^^.IL[i];          IF G4^^.IL[i] = 0 THEN IM4 := 1;          IF (G4^^.IL[i] > 3) AND (G^^.ZZZ[i] < 31) THEN IM4 := 1;          IF (G4^^.IL[i] > 3) AND (G^^.ZZZ[i] > 30) THEN IM4 := 2;          IF (G4^^.IL[i] > 3) AND (G^^.ZZZ[i] > 73) THEN IM4 := 3;          IM5 := IM4 * IM4;          IEL := A^.IZ[i];          Xray_Data_Request := TRUE;          Get_Energies(IEL); { This will load the following globals with the appropriate values for atomic number IEL }		  Xray_Data_Request := FALSE;		            G2^^.O[1, i] := A^.edge[1] / 1000.0;          G2^^.O[2, i] := A^.edge[2] / 1000.0;          G2^^.O[3, i] := A^.edge[3] / 1000.0;          G2^^.O[4, i] := A^.edge[4] / 1000.0;          G2^^.O[5, i] := A^.edge[5] / 1000.0;          G2^^.O[6, i] := A^.edge[6] / 1000.0;          G2^^.O[7, i] := A^.edge[7] / 1000.0;          G2^^.O[8, i] := A^.edge[8] / 1000.0;          G2^^.O[9, i] := A^.edge[9] / 1000.0;          G4^^.B[i] := Atomic_Weight;          G2^^.G[1, i] := eV_Line[1] / 1000.0;          G2^^.G[2, i] := eV_Line[42] / 1000.0;          G2^^.G[3, i] := (eV_Line[72] + eV_Line[73])/2 / 1000.0;          AA := 0.015 + 0.0327 * G^^.ZZZ[i] - 6.4E-7 * G^^.ZZZ[i] * G^^.ZZZ[i] * G^^.ZZZ[i];          G2^^.OM[1, i] := AA * AA * AA * AA / (1 + AA * AA * AA * AA);          AA := - 0.11107 + 0.01368 * G^^.ZZZ[i] - 2.1772E-7 * G^^.ZZZ[i] * G^^.ZZZ[i] * G^^.ZZZ[i];          G2^^.OM[2, i] := AA * AA * AA * AA / (1 + AA * AA * AA * AA);          IF A^.IZ[i] < 76 THEN G2^^.OM[3, i] := 0.0          ELSE G2^^.OM[3, i] := 0.00237 * A^.IZ[i] - 0.163;          G4^^.EC[i] := G2^^.O[IM5, i];          G^^.E[i] := G2^^.G[IM4, i];          G^^.U0[i] := E0 / G4^^.EC[i]; { ----- U0 -- overvoltage}          G^^.Y[i] := G^^.U0[i];          IF G^^.U0[i] > 10 THEN G^^.U0[i] := 10;          IF (G^^.U0[i] < 1.5) THEN            BEGIN              IF (IFirstRun = 1) AND (G^^.IT[i] <> 1) THEN                BEGIN                  writeln(Out_TxtFile, 'WARNING: THE OVERVOLTAGE OF ELEMENT ', A^.IZ[i], ' IS BELOW 1.5');                  writeln(Out_TxtFile);                END;            END;        END; { 1 to I_N loop }    END; { Procedure Load_Energies }	{$S CITZAFCode22}  PROCEDURE GetMACs;    VAR      i1, i, IM4, I3                : Integer;      I_Shell                       : Integer;      { READ MASS ABSORPTION COEFFICIENTS (MAC's) }    BEGIN      FOR i := 1 TO IN1 DO        BEGIN          IF G4^^.IL[i] <= 3 THEN            BEGIN              IM4 := G4^^.IL[i];              FOR i1 := 1 TO I_N DO                BEGIN                  IF G^^.IT[i] + G^^.IT[i1] = 0 THEN                    BEGIN                      FOR I3 := 1 TO 9 DO                        BEGIN                          IF (G2^^.O[I3, i1] > G2^^.G[IM4, i] - 0.1) AND (G2^^.O[I3, i1] < G2^^.G[IM4, i] + 0.03) THEN                            BEGIN                              IF IFirstRun = 1 THEN                                BEGIN                                  Write(Out_TxtFile, 'WARNING: THE ', G^^.Line_Name[IM4], '-LINE OF ', A^.IZ[i]: 3);                                  writeln(Out_TxtFile, ' IS CLOSE TO THE ', G^^.Edge_Name[I3], '-EDGE OF ', A^.IZ[i1]: 3);                                END; { IF IFirstRun := 1 }                            END; { IF ( O(I3, I1)... THEN }                        END; { FOR I3 := 1 TO 9 }                    END; { IF IT(I) + G^^.IT[I1] = 0 }                END; { FOR I1 := 1 TO I_N }            END; { IF G4^^.IL[I] <= 3 }        END; { FOR I := 1 TO IN1 }	 	  Xray_Data_Request := TRUE;      FOR i := 1 TO IN1 DO        BEGIN          IF G4^^.IL[i] <= 3 THEN            BEGIN              IM4 := G4^^.IL[i];			                FOR i1 := 1 TO I_N DO                BEGIN                  Atomic_Weight := G4^^.B[i1];                  Get_Energies(A^.IZ[i1]);                  IF IMAC >= 2 THEN { temporarily because code 3 frame mac's not hooked up }                    G2^^.P[i1, i] := MassAbsCoeff(G2^^.G[IM4, i], A^.IZ[i1]);                END; { FOR I1 := 1 TO I_N }                           END; { IF G4^^.IL[I] <= 3 }        END; { FOR I := 1 TO IN1 }        Xray_Data_Request := FALSE;      IF IMAC = 1 THEN        BEGIN		  errCode := getvol(Save_Volume_Name, save_vol);{ Get the volume refnum being worked out of}		  errCode := setvol(NIL, Default_Volume_Ref_Num); { Set the home folder for reading MAC's}          I_Shell := 0;          FOR i := 1 TO IN1 DO            IF G4^^.IL[i] = 1 THEN I_Shell := 1;          IF I_Shell = 1 THEN Get_MAC_K_Table;          I_Shell := 0;          FOR i := 1 TO IN1 DO            IF G4^^.IL[i] = 2 THEN I_Shell := 1;          IF I_Shell = 1 THEN Get_MAC_L_Table;          I_Shell := 0;          FOR i := 1 TO IN1 DO            IF G4^^.IL[i] = 3 THEN I_Shell := 1;          IF I_Shell = 1 THEN Get_MAC_M_Table;		  		  errCode := setvol(NIL, save_vol);	{ Restore the volume being worked out of}	          END;      {     IF imac_Input}      {        THEN}      {          BEGIN}      {            writeln(Out_TxtFile, 'DATA ENTRY OF MASS ABSORPTION COEFFICIENTS -- ');}      {            I := 1;}      {            WHILE I > 0 DO}      {              BEGIN}      {                Write('Atomic Number of Absorbed Element or 0 to quit');}      {                Readln(I);}      {                IF I > 0}      {                  THEN}      {                    BEGIN}      {                      Write('Atomic Number of Absorbing Element ');}      {                      Readln(I1);}      {                      Write('Mass Absorption Coefficient');}      {                      Readln(P[I1, I]);}      {                      writeln;}      {                    END;          { IF I > 0 }      {end; }      { While I > 0 }      {end; }      { IF IMAC := 1 }    END; { Procedure GetMACs }{$S CITZAFCode50}  PROCEDURE SMP_Mean_Ionization_Potential;    BEGIN      CASE IMIP OF        1: { BERGER/SELTZER MEAN IONIZ. POTEN. FOR SAMPLE }          MIP_SMP := (9.76 * Z_SMP + 58.5 * PowerF(Z_SMP, ( - 0.19))) / 1000;        2:          BEGIN { DUNCUMB/DA CASA MEAN IONIZ. POTEN. FOR SAMPLE }            MIP_SMP := 14 * (1 - Exp( - 0.1 * Z_SMP)) + 75.5 / PowerF(Z_SMP, (Z_SMP / 7.5)) - Z_SMP / (100 + Z_SMP);            MIP_SMP := Z_SMP * MIP_SMP / 1000;          END;        3:          BEGIN { RUSTE/ZELLER MEAN IONIZ. POTEN. FOR SAMPLE }            MIP_SMP := 10.04 + 8.25 * Exp( - Z_SMP / 11.22);            MIP_SMP := Z_SMP * MIP_SMP / 1000;          END;        4:          BEGIN { SUBROUTINE: SPRINGER MEAN IONIZ. POTEN. FOR SAMPLE }            MIP_SMP := 9 * (1 + PowerF(Z_SMP, ( - 2 / 3))) + 0.03 * Z_SMP;            MIP_SMP := Z_SMP * MIP_SMP / 1000;          END;        5:          BEGIN { SUBROUTINE: Wilson MEAN IONIZ. POTEN. FOR SAMPLE }            MIP_SMP := 11.5;            MIP_SMP := Z_SMP * MIP_SMP / 1000;          END;        6:          BEGIN { Heinrich MEAN IONIZ. POTEN. FOR SAMPLE }            MIP_SMP := 9.94 + 19.52 / Z_SMP;            MIP_SMP := Z_SMP * MIP_SMP / 1000;          END;        7:          BEGIN { SUBROUTINE: Bloch MEAN IONIZ. POTEN. FOR SAMPLE }            MIP_SMP := 13.5;            MIP_SMP := Z_SMP * MIP_SMP / 1000;          END;		          8:          BEGIN { SUBROUTINE: Armstrong (Springer/Berg.-Sel.) MIP Smp}             IF Z_SMP < 30 THEN                MIP_SMP := 9 * (1 + PowerF(Z_SMP, ( - 2 / 3))) + 0.03 * Z_SMP 				ELSE                MIP_SMP := 9.76 + 58.5 * PowerF(Z_SMP, ( - 1.19));                          MIP_SMP := Z_SMP * MIP_SMP / 1000;          END;        9:          BEGIN { SUBROUTINE: Joy(Wilson/Berg.-Sel.) MIP Smp}             IF Z_SMP < 13 THEN                MIP_SMP := 11.5              ELSE                MIP_SMP := 9.76 + 58.5 * PowerF(Z_SMP, ( - 1.19));            MIP_SMP := Z_SMP * MIP_SMP / 1000;          END;        END; { CASE }    END; { PROCEDURE SMP_Mean_Ionization_Potential }  PROCEDURE PHI_Zero_Calc;    VAR      JPU, GPU, A1, A2, A3, ZM, AX, ZR, ZRA, ZRB: real {double_t};		i	:	integer;    BEGIN      CASE IPHI OF        1:          Phi_zero := 1 + 2.8 * (1 - 0.9 / U_zero) * H_SMP; { REUTER PHI(0) EXPRESSION }        2:          BEGIN { LOVE/SCOTT PHI(0) EXPRESSION }            JPU := 3.43378 - 10.7872 / U_zero + 10.97628 / (U_zero * U_zero) - 3.62286 / (U_zero * U_zero * U_zero);            GPU := - 0.59299 + 21.55329 / U_zero - 30.55248 / (U_zero * U_zero) + 9.59218 / (U_zero * U_zero * U_zero);            Phi_zero := 1 + H_SMP / (1 + H_SMP) * (JPU + GPU * Ln(1 + H_SMP));          END;        3:          Phi_zero := 1 + H_SMP * U_zero * Ln(U_zero) / (U_zero - 1); { RIVEROS PHI(0) EXPRESSION }        4: {POUCHOU & PICHOIR }          Phi_zero := 1 + 3.3 * (1 - Exp((2.3 * H_SMP - 2) * Ln(U_zero))) * Exp(1.2 * Ln(H_SMP));        5: { KARDUCK & REHBACH }          BEGIN            JPU := (1 + 0.005 * Z_SMP / G4^^.EC[i]) * (0.68 + 3.7 / Z_SMP);            GPU := - 0.01 + 0.04805 * Z_SMP - 0.51599E-3 * Z_SMP * Z_SMP + 0.20802E-5 * Z_SMP * Z_SMP * Z_SMP;            GPU := (1 + 0.05 / G4^^.EC[i]) * GPU;            Phi_zero := 1 + PowerF((1 - 1 / SQRT(U_zero)), JPU) * GPU;          END;        6: {AUGUST & WERNISCH}          BEGIN            IF G4^^.IL[i] = 1 THEN JPU := 0.86 + 0.12 * Exp( - SQR(G^^.ZZZ[i] / 5))            ELSE              IF G4^^.IL[i] = 2 THEN JPU := 0.82              ELSE JPU := 0.78;            ZM := 0.52 + 1.28 * H_SMP - 0.72 * H_SMP * H_SMP;            A1 := 67.2945 + 279.67 * ZM - 383.52 * ZM * ZM + 179.276 * ZM * ZM * ZM;            A2 := 1 / (1.3956 - 3.7819 * ZM + 4.5441 * ZM * ZM - 2.0704 * ZM * ZM * ZM);            A3 := 24.3 - 78.4 * ZM + 127.44 * ZM * ZM - 68.733 * ZM * ZM * ZM;            AX := H_SMP / (0.5 + 8.34 / (A1 + 1) - A3 / (A2 + 1));            ZR := (JPU - A1) - 1;            ZRA := ( - ZR * Ln(U_zero) - 1 + PowerF(U_zero, ZR)) / (ZR * ZR);            ZR := (JPU - A2) - 1;            ZRB := ( - ZR * Ln(U_zero) - 1 + PowerF(U_zero, ZR)) / (ZR * ZR);            GPU := AX * PowerF((1 / U_zero), JPU) * (ZRB + 8.34 * ZRA - A3 * ZRA);            Phi_zero := 1 + 2 * (GPU * PowerF(U_zero, JPU)) / Ln(U_zero);          END;        7: { PACKWOOD }          Phi_zero := 1 + 0.75 * 3.14159 * H_SMP * (1 - Exp((1 - U_zero) / 2));        OTHERWISE          noOp := 0;        END; { CASE }    END; { PROCEDURE PHI_Zero_Calc }  PROCEDURE Error_Function;    VAR      Erfs                          : real {double_t};      i1                            : Integer;    BEGIN      Erfs := 1;      ERFT := 1 / (1 + ERFP * ERFX);      ERF_C := 0;      FOR i1 := 1 TO 5 DO        BEGIN          Erfs := Erfs * ERFT;          ERF_C := ERF_C + G^^.ERF[i1] * Erfs;        END;    END;{$S CITZAFCode55}  PROCEDURE PAPABS(i : integer);        VAR	  J, i1 : Integer;      R0, RR0, R00, U0, G1, G2, G3, DEE, Q0, RX, QQ, DELTA, PHI0, FF, FP1, FP2, FP3, 	  FFF, RM, QE0,  RC, A1, A2, B1: real {double_t};    BEGIN      G1 := 0.11 + 0.41 * Exp( - Exp(0.75 * Ln(ZP / 12.75)));      G2 := 1 - Exp( - Exp(0.35 * Ln(G^^.Y[i] - 1)) / 1.19);      G3 := 1 - Exp( - (G^^.Y[i] - 0.5) * (Exp(0.4 * Ln(ZP)) / 4));      G^^.DP[2] := 0.0000112 * (1.35 - 0.45 * JBAR * JBAR);      G^^.DP[3] := 0.0000022 / JBAR;      G^^.PP[3] := - (0.5 - 0.25 * JBAR);      R0 := 0;      U0 := G^^.Y[i];      FOR J := 1 TO 3 DO        BEGIN		  i1 := J;          R00 := Exp((1 - G^^.PP[i1]) * Ln(JBAR)) * G^^.DP[i1];          RR0 := Exp((1 + G^^.PP[i1]) * Ln(G4^^.EC[i]));          R0 := R0 + R00 * (Exp((1 + G^^.PP[i1]) * Ln(E0)) - RR0) / 		                   (1 + G^^.PP[i1]) / SUMATOM1 {IONIZ. RANGE}        END; { FOR I1 := 1 TO 3 do }      DEE := 1 + Exp( - Exp(0.45 * Ln(ZP)) * Ln(G^^.Y[i]));      Q0 := 1 - 0.535 * Exp( - Exp(1.2 * Ln(21 / ZN))) - 0.00025 * (Exp(3.5 * Ln(ZN / 20)));      QQ := Q0 + (1 - Q0) * Exp( - (U0 - 1) * ZP / 40);      RX := QQ * DEE * R0 { DEPTH RANGE OF IONIZATION} ;      RM := G1 * G2 * G3 * RX { DEPTH OF MAX PHI} ;      QE0 := Ln(G^^.Y[i]) / (G4^^.EC[i] * G4^^.EC[i] * Exp(G^^.EM[i] * Ln(G^^.Y[i])));      XP := XP / (G^^.ZIPI[i] * 66892) * G4^^.B[i];      FF := XP / QE0;      PHI0 := 1 + 3.3 * (1 - Exp((2.3 * Hp - 2) * Ln(G^^.Y[i]))) * Exp(1.2 * Ln(Hp)) { PHI[0) } ;      DELTA := (RX - RM) * (FF - PHI0 * RX / 3) * ((RX - RM) * FF - PHI0 * RX * (RM + RX / 3));      RC := 1.5 * ((FF - PHI0 * RX / 3) / PHI0 - SQRT(ABS(DELTA)) / PHI0 / (RX - RM));      A1 := PHI0 / RM / (RC - RX * (RC / RM - 1));      B1 := PHI0 - A1 * RM * RM;      A2 := A1 * (RC - RM) / (RC - RX);      FP1 := ((RC - RM) * (RC - RM + 2 / XI) + 2 / XI / XI) * Exp( - XI * RC);      FP1 := - A1 / XI * (FP1 - RM * (RM - 2 / XI) - 2 / XI / XI);      FP2 := - B1 / XI * (Exp( - XI * RC) - 1);      FP3 := ((RC - RX) * (RC - RX + 2 / XI) + 2 / XI / XI) * Exp( - XI * RC);      FP3 := - A2 / XI * ( - FP3 + 2 / XI / XI * Exp( - XI * RX));      FFF := A1 / 3 * ((RC - RM) * (RC - RM) * (RC - RM) + RM * RM * RM) + B1 * RC;      FFF := FFF + A2 / 3 * (RX - RC) * (RX - RC) * (RX - RC);      fp := (FP1 + FP2 + FP3) / FFF;    END;  PROCEDURE PAPABS1(i : integer);        VAR      QE0, PHI0, FF, EXX, GAMMA, GG, RBAR, ETAS, HH, PEE, B10, A10, B11, A11: real {double_t};    BEGIN      QE0 := Ln(G^^.Y[i]) / (G4^^.EC[i] * G4^^.EC[i] * Exp(G^^.EM[i] * Ln(G^^.Y[i])));      XP := XP / (G^^.ZIPI[i] * 66892) * G4^^.B[i];       FF := XP / QE0;      PHI0 := 1 + 3.3 * (1 - Exp((2.3 * Hp - 2) * Ln(G^^.Y[i]))) * Exp(1.2 * Ln(Hp)); { PHI(0)}      GAMMA := 0.2 + MEANZ / 200;      EXX := 1 + 1.3 * Ln(MEANZ);      RBAR := FF / (1 + (EXX * Ln(1 + GAMMA * (1 - Exp( - 0.42 * Ln(G^^.Y[i]))))) / Ln(1 + GAMMA));      IF FF / RBAR < PHI0 THEN RBAR := FF / PHI0; { AVER IONIZ. DEPTH}      GG := 0.22 * Ln(4 * MEANZ) * (1 - 2 * Exp( - MEANZ * (G^^.Y[i] - 1) / 15));      HH := 1 - 10 * (1 - 1 / (1 + G^^.Y[i] / 10)) / (MEANZ * MEANZ);      PEE := GG * HH * HH * HH * HH * FF / (RBAR * RBAR);      B10 := SQRT(2) * (1 + SQRT(1 - RBAR * PHI0 / FF)) / RBAR;      A10 := (PEE + B10 * (2 * PHI0 - B10 * FF)) / (B10 * FF * (2 - B10 * RBAR) - PHI0);      ETAS := (A10 - B10) / B10;      IF ETAS < 0.000001 THEN A10 := B10 * (1 + ETAS);      B11 := (B10 * B10 * FF * (1 + ETAS) - PEE - PHI0 * B10 * (2 + ETAS)) / ETAS;      A11 := (B11 / B10 + PHI0 - B10 * FF) * (1 + ETAS) / ETAS;      fp := (PHI0 + B11 / (B10 + XI) - A11 * B10 * ETAS / (B10 * (1 + ETAS) + XI)) / (B10 + XI);      fp := fp / FF;     END;  PROCEDURE Phi_Rho_Z;    VAR      RBAS, QE0, FF, Xb, ZA, A_SMP, P_SMP,       A1, A2, R1, R2, R3, X2, X3, X4, X5,       T2, T3, T4, GPT, CHI, D : real {double_t};      i1, ii, i                           : Integer;	  	      PROCEDURE Particle_Calc;       VAR         R4,R5,R6,R9,Q1,Q2,D1,D2,D4,P4,P5,P6,S1,B9,X       : real {double_t};		          J1                                                : Integer;		 Label 9599;		        BEGIN         X := 8/9;         E_RANGE[i] := 2.76E-6 * PowerF(E0,1.67) * A_SMP / PowerF(Z_SMP, X);         R3 := E_RANGE[i];         X := M7;         D4 := X * T3;         R1 := 0;         R2 := 0;         J1 := 0;         A1 := 0;         A2 := 0;         Q1 := 0;         Q2 := 0;         {  Begin numerical integration of Phi(PZ) expression for ptc/tf }9599 :   J1 := J1 + 1;         D1 := R1 * T4;         D2 := D - D1;         P4 := X * T1 * R1;         P5 := EXP(-P4);         P6 := EXP(-X * GPT * R1);         R4 := R1 * 10000.0;         B9 := X2 * (1 - X5 * EXP(-X3 * R1)) * EXP(-X4 * X4 * R1 * R1);         IF B9 < 0.000001 THEN             BEGIN              E_RANGE[i] := R1;              Exit(Particle_Calc);            END;  { if }         S1 := 0;         IF R1 <= J9 * D THEN            BEGIN             CASE IMN OF               1:  { Thin Film model }                 BEGIN                   S1 := B9 * P5;                 END;  { Case 1 }               2:  { Rectangular Prism model }                 BEGIN                   IF R1 = 0 THEN S1 := B9;                   IF R1 <> 0 THEN                        IF D2 > 0 THEN                           S1 := 1 / D * (D2 * P5 + (1 - P5) / D4) * B9                       ELSE                          S1 := 1 / D * (1 - EXP(-D4 * D)) / D4 * B9;                  END;  { Case 2 }				                3:  { Tetragonal Prism model }                 BEGIN                   IF R1 = 0 THEN S1 := B9;                   IF R1 <> 0 THEN                     BEGIN                       IF D2 > 0 THEN                          BEGIN                          S1 := (P5 - 1) / (2 * D4 * D4) + D1 / (2 * D4);                          S1 := S1 + (D2 / 2) * (D2 / 2) * P5 + D2 / (2 * D4) * (1 - P5);                          S1 := 4 / (D * D) * S1 * B9;                         END                       ELSE                         BEGIN                          S1 := (EXP(-D4 * D) - 1) / (2 * D4 * D4) + D / (2 * D4);                          S1 := 4 / (D * D) * S1 * B9;                         END;  { IF D2 }                     END;    { IF R1 }                 END;  { Case 3 }               4:  { Triangular Prism model }                 BEGIN                   R9 := D / 2;                   IF R1 > R9 THEN                      BEGIN                        S1 := 0;                      END                   ELSE                      BEGIN                        S1 := (P6 - EXP(-X * GPT * (D - R1))) / (2 * X * GPT);                        S1 := (S1 + (R9 - R1) * P6) / D * B9                      END;  { IF R1 }                 END;  { Case 4 }               5:  { Square Pyramid model }                 BEGIN                   R9 := D / 2;                   IF R1 > R9 THEN                      BEGIN                        S1 := 0;                      END                   ELSE                      BEGIN                        S1 := (D - 2 * R1) * P6 / (X * GPT);                        S1 := S1 + (EXP(-X * GPT * D) / P6 - P6) / (X * X * GPT * GPT);                        S1 := S1 + (D * D - 4 * D * R1 + 8 * R1 * R1) * P6 / 2;                        S1 := S1 / (D * D) * B9;                      END  { IF R1 }                 END;  { Case 5 }               6:  { Sidescatter-modified Rectangular Prism model }                 BEGIN                   IF R1 < D * T2 / 2 THEN                      BEGIN                       S1 := (0.75 * D - D1 / 2 - D1 * D1 / (2 * D) - D1 / (D4 * D)) * P5;                       S1 := S1 + (1 - P5) / (2 * D4) + (1 - P5) / (D4 * D4 * D);                      END;  { IF #1 }                   IF (R1 >= D * T2 / 2) AND (R1 < D * T2) THEN                      BEGIN                       S1 := (D - 3 * D1 / 2 + D1 * D1 / (2 * D) + D1 / (D4 * D) - 1 / D4) * P5;                       S1 := S1 + (1 - P5) / (2 * D4) + (1 + P5) / (D4 * D4 * D);                       S1 := S1 - 2 * EXP(-D4 * D / 2) / (D4 * D4 * D);                      END;  { IF #2 }                   IF (R1 >= D * T2) THEN                      BEGIN                       S1 := (1 - EXP(-D4 * D)) / (2 * D4) + (1 + EXP(-D4 * D)) / (D4 * D4 * D);                       S1 := S1 - 2 * EXP(-D4 * D / 2) / (D4 * D4 * D);                      END;  { IF #3 }                   S1 := S1 * B9 / D;                 END;  { Case 6 }               Otherwise                 noOp := 0;             END; { CASE }           END;   {  IF  }           IF J1 > 1 THEN              BEGIN                R6 := R4 - R5;                A1 := A1 + (Q1 + B9) / 2 * R6;                A2 := A2 + (Q2 + S1) / 2 * R6;              END; { IF J1 }           Q1 := B9;           Q2 := S1;           R5 := R4;           IF R1 >= R3 THEN EXIT(Particle_Calc);           R1 := R1 + X1;           IF R1 > R3 THEN R1 := R3;           GOTO 9599;       {-----       END NUMERICAL INTEGRATION OF PHI(PZ) EXPRESSION      ----}       END; { PROCEDURE Particle_Calc }    BEGIN      (*---------------------------------------------------------------------*)      (* -----PACKWOOD/BROWN PHI(PZ) EXPRESSIONS FOR ABS & ZED CORRECTIONS----*)      (*---------------------------------------------------------------------*)             T2 := TAN(T);	  T3 := SIN(T)/T2;      T3 := 1.0 / T3;      T4 := 1.0 / T2;      GPT := T3 / (1 + T2);      FOR ii := 1 TO IN1 DO        BEGIN          i := ii;          IF (G4^^.IL[i] <= 3) AND ((INIT = 0) OR (G^^.C[i] > 0)) THEN { Don't calculate if it's a sample and the                                                                       concentration is zero or the element is                                                                       unanalyzed }            BEGIN              CASE INIT OF                0:                  BEGIN { Calculation for pure element standards }				                      IF IPTC = 1 THEN                      BEGIN                        D := 1;                        IMN := 1;                        J9 := 1;                        X1 := 0.00001;						pRHO := 1.0;						PtcRho := 1.0;                      END;  { IF }				                      Z_SMP := G^^.ZZZ[i];                    A_SMP := G4^^.B[i];                    H_SMP := G^^.HB[i];                    MIP_SMP := G^^.JM[i];                    M7 := G2^^.P[i, i];                  END; { case }                1:                  BEGIN { Calculation for samples }				                      IF IPTC = 1 THEN                      BEGIN                        D := pRHO * DIA[IPtcD] / 10000.0;                        IMN := IMD[IPtcM];                      END;  { IF } 			                      Z_SMP := 0;                    A_SMP := 0;                    P_SMP := 0;                    H_SMP := 0;                    FOR i1 := 1 TO I_N DO                      BEGIN                        Z_SMP := Z_SMP + G^^.C[i1] * G^^.ZZZ[i1] / G4^^.B[i1];                        A_SMP := A_SMP + G^^.C[i1];                        P_SMP := P_SMP + G^^.C[i1] / G4^^.B[i1];                        H_SMP := H_SMP + G^^.C[i1] * G^^.HB[i1];                      END; { FOR I1 := 1 TO I_N }                    Z_SMP := Z_SMP / P_SMP;                    A_SMP := A_SMP / P_SMP;                    MACCAL(i);                    SMP_Mean_Ionization_Potential;                  END;                END; { Case }              U_zero := E0 / G4^^.EC[i];              X2 := 5 * pi * U_zero / (Ln(U_zero) * (U_zero - 1)) * (Ln(U_zero) - 5 + 5 * PowerF(U_zero, ( - 0.2)));              CASE IABS OF                7: { PACK/BROWN 1982 XRS PHI(PZ) ALPHA EQN. }                  BEGIN                    X4 := 395000 * PowerF(Z_SMP, 0.95) / (A_SMP * PowerF(E0, 1.25)) * SQRT(Ln(1.166 * E0 / MIP_SMP) /                          (E0 - G4^^.EC[i]));                    X3 := 0.4 * X4 * PowerF(Z_SMP, 0.6);                  END; { case 7}                8: { BASTIN 1984 XRS PHI(PZ) ALPHA EQN. }                  BEGIN                    X4 := 175000 / (PowerF(E0, 1.25) * PowerF((U_zero - 1), 0.55)) * SQRT(Ln(1.166 * E0 / MIP_SMP) / G4^^.EC[i]);                    X2 := 0.98 * X2 * Exp(0.001 * Z_SMP);                    X3 := 0.4 * X4 * (PowerF(Z_SMP, 1.7) / A_SMP) * PowerF((U_zero - 1), 0.3);                  END; { case 8}                9: { ARMSTRONG 1981 MAS PHI(PZ) ALPHA EQN. }                  BEGIN                    X4 := 297000 * PowerF(Z_SMP, 1.05) / (A_SMP * PowerF(E0, 1.25)) * SQRT(Ln(1.166 * E0 / MIP_SMP) /                          (E0 - G4^^.EC[i]));                    X3 := 850000 * Z_SMP * Z_SMP / (A_SMP * E0 * E0 * (X2 - 1));                  END; { case 9}                10: { BASTIN 1986 SCANNING PHI(PZ) ALPHA EQN. }                  BEGIN                    X4 := 175000 / (PowerF(E0, 1.25) * PowerF((U_zero - 1), 0.55)) * SQRT(Ln(1.166 * E0 / MIP_SMP) / G4^^.EC[i]);                    X2 := 5 * pi * (U_zero + 1) / (Ln(U_zero + 1) * U_zero) * (Ln(U_zero + 1) - 5 + 5 * PowerF((                          U_zero + 1), ( - 0.2)));                    IF (U_zero < 3) THEN X2 := 1 + (U_zero - 1) / (0.3384 + 0.4742 * (U_zero - 1));                    X3 := Z_SMP / (0.4765 + 0.5473 * Z_SMP);                    X3 := X4 * PowerF(Z_SMP, X3) / A_SMP;                  END; { case 8}                11: {RIVEROS 1987 XRS PHI(PZ) ALPHA EQN. }                  BEGIN                    X4 := 214000 * PowerF(Z_SMP, 1.16) / (A_SMP * PowerF(E0, 1.25)) * SQRT(Ln(1.166 * E0 / MIP_SMP) /                          (E0 - G4^^.EC[i]));                    X2 := (1 + H_SMP) * U_zero * Ln(U_zero) / (U_zero - 1);                    X3 := 10900 * PowerF(Z_SMP, 1.5) / (A_SMP * (E0 - G4^^.EC[i]));                  END; { case 11}                14: {PACKWOOD EPQ 1991 PHI(PZ) ALPHA EQN. }                  BEGIN                    X2 := 10 * 3.14159 * (U_zero / (U_zero - 1)) * (1 + (10 / Ln(U_zero)) * (PowerF(U_zero, - 0.1) -                          1));                    IF INIT = 0 THEN                      BEGIN                        X4 := 4.5E5 * ((Z_SMP - 1.3) / Z_SMP) * PowerF((Z_SMP / A_SMP), 0.5) * PowerF(E0, - 0.75);                        X4 := X4 * SQRT((Z_SMP / A_SMP) * Ln(1.166 * ((E0 + G4^^.EC[i]) / (2 * MIP_SMP))) / (E0 * E0 -                                        G4^^.EC[i] * G4^^.EC[i]));                        X3 := 0.4 * X4 * PowerF(Z_SMP, 0.6);                      END                    ELSE                      IF INIT = 1 THEN                        BEGIN                          Z_SMP := 0;                          ZA := 0;                          MIP_SMP := 0;                          FOR i1 := 1 TO I_N DO                            BEGIN                              Z_SMP := Z_SMP + G^^.C[i1] * G^^.ZZZ[i1];                              ZA := ZA + G^^.C[i1] * G^^.ZZZ[i1] / G4^^.B[i1];                              MIP_SMP := MIP_SMP + G^^.C[i1] * (G^^.ZZZ[i1] / G4^^.B[i1]) * Ln(1.166 * (E0 + G4^^.EC[i])                                         / (2 * G^^.JM[i1]));                            END; { FOR I1 := 1 TO IN do... }                          X4 := 4.5E5 * ((Z_SMP - 1.3) / Z_SMP) * PowerF(ZA, 0.5) * PowerF(E0, - 0.75);                          X4 := X4 * SQRT(MIP_SMP / (E0 * E0 - G4^^.EC[i] * G4^^.EC[i]));                          X3 := 0.4 * X4 * PowerF(Z_SMP, 0.6);                        END                      ELSE noOp := 0;                  END; { case 14}                15: {BASTIN PROZA EPQ 1991 PHI(PZ) ALPHA EQN. }                  BEGIN				                      IF INIT = 0 THEN                      BEGIN                        X4 := G^^.PZ[i, i];                        Xb := G2^^.R[i, i] / G2^^.S[i, i];						ZP := G^^.ZZZ[i];                      END                    ELSE                      IF INIT = 1 THEN                        BEGIN                          X4 := 0;                          ZP := 0;                          ZA := 0;                          Xb := G^^.BKS[i] / G^^.STP[i];                          FOR i1 := 1 TO I_N DO                            BEGIN                              ZP := ZP + G^^.C[i1] * G^^.ZZZ[i1];                              ZA := ZA + G^^.C[i1] * G^^.ZZZ[i1] / G4^^.B[i1];                              X4 := X4 + G^^.C[i1] * G^^.ZZZ[i1] / (G4^^.B[i1] * G^^.PZ[i, i1]);                            END;                          X4 := X4 / ZA;                          X4 := 1 / X4;                        END                      ELSE noOp := 0;                    IF U_zero > 6 THEN X2 := 2.814333 * 					                      PowerF(U_zero, (0.262702 * Fast_Power(ZP, - 0.1614454)))                    ELSE                      X2 := 3.98352 * PowerF(U_zero, - 0.0516861) * 					   (1.2276233 - PowerF(U_zero, ( - 1.225558 *  Fast_Power(ZP, - 0.1424549))));                    IF G4^^.EC[i] < 0.7 THEN X2 := X2 * G4^^.EC[i] / 					                                           ( - 0.041878 + 1.05975 * G4^^.EC[i]); END; { case 15}                OTHERWISE                  noOp := 0;                END; { CASE }              PHI_Zero_Calc;              X5 := (X2 - Phi_zero);              IF IPTC = 1 THEN X5 := X5/X2;              CASE IABS OF                15: {BASTIN PROZA}                  BEGIN                    QE0 := Ln(G^^.Y[i]) / (G4^^.EC[i] * G4^^.EC[i] * Exp(G^^.EM[i] * Ln(G^^.Y[i])));                    Xb := Xb / (G^^.ZIPI[i] * 66892) * G4^^.B[i];                    FF := Xb / QE0;                    RBAS := (X2 - X4 * FF / SPI) / X5;                    IF (RBAS <= 0) OR (RBAS >= 1) THEN                      BEGIN                        X4 := (Phi_zero + X2) * SPI / (2 * FF);                        RBAS := 0.5;                      END;                    IF (RBAS >= 0.9) AND (RBAS < 1) THEN X3 := 0.9628832 - 0.9642440 * RBAS;                    IF (RBAS > 0.8) AND (RBAS < 0.9) THEN X3 := 1.122405 - 1.141942 * RBAS;                    IF (RBAS > 0.7) AND (RBAS <= 0.8) THEN X3 := 13.43810 * Exp( - 5.180503 * RBAS);                    IF (RBAS > 0.57) AND (RBAS <= 0.7) THEN X3 := 5.909606 * Exp( - 4.015891 * RBAS);                    IF (RBAS > 0.306) AND (RBAS <= 0.57) THEN X3 := 4.852357 * Exp( - 3.680818 * RBAS);                    IF (RBAS > 0.102) AND (RBAS <= 0.306) THEN X3 := (1 - 0.5379956 * RBAS) / (1.685638 * RBAS);                    IF (RBAS > 0.056) AND (RBAS <= 0.102) THEN X3 := (1 - 1.043744 * RBAS) / (1.604820 * RBAS);                    IF (RBAS > 0.03165) AND (RBAS <= 0.056) THEN X3 := (1 - 2.749786 * RBAS) / (1.447465 * RBAS);                    IF (RBAS > 0) AND (RBAS <= 0.03165) THEN X3 := (1 - 4.894396 * RBAS) / (1.341313 * RBAS);                  END; { case 15 }                OTHERWISE                  noOp := 0;                END; { Case IABS }               CHI := M7 * T1;			  			                IF IPTC = 0 THEN                BEGIN			                ERFX := X3 / (2 * X4);              Error_Function;              R1 := ERF_C;              ERFX := CHI / (2 * X4);              Error_Function;              R2 := ERF_C;              ERFX := (X3 + CHI) / (2 * X4);              Error_Function;              R3 := ERF_C;              A1 := SPI * (X2 - X5 * R1) / X4;              A2 := SPI * (X2 * R2 - X5 * R3) / X4;                END              ELSE                BEGIN                  Particle_Calc;                END;  { IF }              G^^.PHI[i] := A1;              IF INIT = 1 THEN G^^.E[i] := A1 / A2;              IF INIT = 0 THEN G^^.W[i] := A1 / A2;            END; { IF (G4^^.IL[I] <= 3) }        END; { FOR I := 1 TO IN1 }    END;  {$S CITZAFCode_d}  PROCEDURE Elem_BackScatter;    VAR      d, H1, H2, LU						: real {double_t};      N2, N3, N4, N5					: real {double_t};      i1, i2, i, ij						: Integer;      W1, W2, W3, W4, W5, Z1, Z2, Z3, Z4, Z5, MEANW, JU0, GU0: real {double_t};      Aug								: ARRAY [1..5, 1..5] OF real {double_t};    BEGIN      {-----        CALCULATION OF PURE ELEM. ABSFAC's & ZEDFAC's       -----}      {----------------------------------------------------------------------}      INIT := 0; { 0 when pure element, 1 when sample }      CASE IBSC OF      {[f-]}			1:        { CALC'N OF HEINRICH BACKSCATTER COEFFICIENTS  }				for I := 1 to I_N do					begin						d := G^^.ZZZ[I];						if E0 < 11 then							begin								H1 := -0.007447 + 0.0113 * d + 0.0003298 * d * d - 2.045E-05 * d * d * d;								H1 := H1 + 3.994E-07 * d * d * d * d - 3.468E-09 * d * d * d * d * d + 1.128E-11 * d * d * d * d * d * d;							end						else if E0 < 16 then							begin								H1 := -0.01322 + 0.01191 * d + 0.0002676 * d * d - 1.765E-05 * d * d * d;								H1 := H1 + 3.426E-07 * d * d * d * d - 2.931E-09 * d * d * d * d * d + 9.364E-12 * d * d * d * d * d * d;							end						else if E0 < 21 then							begin								H1 := -0.01392 + 0.01104 * d + 0.0003201 * d * d - 1.848E-05 * d * d * d;								H1 := H1 + 3.36E-07 * d * d * d * d - 2.68E-09 * d * d * d * d * d + 7.907E-12 * d * d * d * d * d * d;							end						else							begin								H1 := -0.01629 + 9.371999E-03 * d + 0.0004598 * d * d - 0.0000249 * d * d * d;								H1 := H1 + 4.944E-07 * d * d * d * d - 4.478E-09 * d * d * d * d * d + 1.53E-11 * d * d * d * d * d * d;							end;{[f+]}              IF H1 <= 0 THEN H1 := 0.000001;              G^^.HB[i] := H1;            END; { FOR I := 1 TO I_N }        2: { ----- CALC'N OF LOVE/SCOTT BACKSCATTER COEFFICIENTS -----}          FOR i := 1 TO I_N DO            BEGIN              d := G^^.ZZZ[i];              H1 := ( - 52.3791 + 150.48371 * d - 1.67373 * d * d + 0.00716 * d * d * d) / 10000;              H2 := ( - 1112.8 + 30.289 * d - 0.15498 * d * d) / 10000;              G^^.HB[i] := H1 * (1 + H2 * Ln(E0 / 20));              { HB(I):=.891*((HB(I)/.891)^(COS(ALPHA))) -- ALPHA:=BEAM INCLINAT. ANGLE }            END; { FOR I := 1 TO I_N }        3: {Calc'n of POUCHOU & PICHOIR elem. backscatter coefficients}          FOR i := 1 TO I_N DO            BEGIN              d := G^^.ZZZ[i];              H1 := 0.00175 * d + 0.37 * (1 - Exp( - 0.015 * Exp(1.3 * Ln(d))));              G^^.HB[i] := H1            END;        4: { HUNGLER & KUCHLER (AUGUST & WERNISCH MOD.) }          FOR i := 1 TO I_N DO            BEGIN              d := G^^.ZZZ[i];              H1 := 0.1904 - 0.2236 * Ln(d) + 0.1292 * Ln(d) * Ln(d) - 0.01491 * Ln(d) * Ln(d) * Ln(d);              H2 := 0.0002167 * d + 0.9987;              H1 := H1 * H2 * PowerF(E0, (0.1382 - 0.9211 / SQRT(d)));              G^^.HB[i] := H1;            END;        OTHERWISE          noOp := 0;        END; { CASE }      CASE IBKS OF { ----- BACKSCATTER CORRECTION for pure elements -----}        1:          FOR i := 1 TO IN1 DO { DUNCUMB/REED(FRAME-1) }            BEGIN              IF (G4^^.IL[i] <= 3) THEN                BEGIN                  N2 := 0.00873 * G^^.U0[i] * G^^.U0[i] * G^^.U0[i] - 0.1669 * G^^.U0[i] * G^^.U0[i] + 0.9662 * G^^.U0[                        i] + 0.4523;                  N3 := 0.002703 * G^^.U0[i] * G^^.U0[i] * G^^.U0[i] - 0.05182 * G^^.U0[i] * G^^.U0[i] + 0.302 * G^^.U0                        [i] - 0.1836;                  N4 := 0.887 - 3.44 / G^^.U0[i] + 9.33 / (G^^.U0[i] * G^^.U0[i]) - 6.43 / (G^^.U0[i] * G^^.U0[i] * G^^                        .U0[i]);                  FOR i1 := 1 TO I_N DO                    G2^^.R[i1, i] := N2 - N3 * Ln(N4 * G^^.ZZZ[i1] + 25);                END;            END;        2, 3: {DUNCUMB & REED (COR-II) & HEINRICH }          FOR i := 1 TO IN1 DO            BEGIN              IF (G4^^.IL[i] <= 3) THEN                BEGIN                  W1 := G4^^.EC[i] / E0;                  W2 := W1 * W1;                  W3 := W2 * W1;                  W4 := W3 * W1;                  W5 := W4 * W1;                  FOR i1 := 1 TO I_N DO                    BEGIN                      Z1 := G^^.ZZZ[i1];                      Z2 := Z1 * Z1;                      Z3 := Z2 * Z1;                      Z4 := Z3 * Z1;                      Z5 := Z4 * Z1;                      N1 := ( - 0.581 + 2.162 * W1 - 5.137 * W2 + 9.213 * W3 - 8.619 * W4 + 2.962 * W5) * 0.01 * Z1;                      N2 := ( - 1.609 - 8.298 * W1 + 28.791 * W2 - 47.744 * W3 + 46.54 * W4 - 17.676 * W5) * 0.0001 *                            Z2;                      N3 := (5.4 + 19.184 * W1 - 75.733 * W2 + 120.05 * W3 - 110.7 * W4 + 41.792 * W5) * 0.000001 * Z3;                      N4 := ( - 5.725 - 21.645 * W1 + 88.128 * W2 - 136.06 * W3 + 117.75 * W4 - 42.445 * W5) * 1E-08 *                            Z4;                      N5 := (2.095 + 8.947 * W1 - 36.51 * W2 + 55.694 * W3 - 46.079 * W4 + 15.851 * W5) * 1E-10 * Z5;                      G2^^.R[i1, i] := 1 + N1 + N2 + N3 + N4 + N5;                      IF IBKS = 3 THEN                        BEGIN                          N1 := G4^^.B[i1] / ( - 0.7585 + 2.058183 * Z1 + 0.005077 * Z2);                          G2^^.R[i1, i] := 1 - ((1 - G2^^.R[i1, i]) * N1);                        END; { IF IBKS = 3 THEN... }                    END; { FOR I1 := 1 TO IN do... }                END; { IF (G4^^.IL[I] <= 3) THEN ... }            END; { FOR I := 1 TO IN1 do... }        4:          BEGIN            FOR i := 1 TO I_N DO { LOVE/SCOTT ATOMIC NUMBER CORRECTION FOR STANDARDS }              BEGIN                IF (G4^^.IL[i] <= 3) THEN                  BEGIN                    LU := Ln(G^^.Y[i]);                    G^^.JU[i] := 0.33148 * LU + 0.05596 * LU * LU - 0.06339 * LU * LU * LU + 0.00947 * LU * LU * LU *                                 LU;                    G^^.GU[i] := 2.87898 * LU - 1.51307 * LU * LU + 0.81313 * LU * LU * LU;                    G^^.GU[i] := (G^^.GU[i] - 0.08241 * LU * LU * LU * LU) / G^^.Y[i];                  END;              END;            FOR i := 1 TO IN1 DO              BEGIN                IF G4^^.IL[i] <= 3 THEN                  BEGIN                    N5 := G^^.JM[i];                    G2^^.S[i, i] := G4^^.B[i] * (1 + 16.05 * SQRT(N5 / G4^^.EC[i]) * PowerF((SQRT(G^^.Y[i]) - 1) / (G^^.                                                                                         Y[i] - 1), 1.07)) / G^^.ZZZ[i];                    G2^^.S[i, i] := 1 / G2^^.S[i, i];                    G2^^.R[i, i] := 1 - G^^.HB[i] * PowerF((G^^.JU[i] + G^^.HB[i] * G^^.GU[i]), 1.67);                  END;              END;          END; { CASE 4 }        5: {AUGUST, RAZKA & WERNISCH}          BEGIN            FOR i1 := 1 TO 5 DO              FOR I2 := 1 TO 5 DO                Aug[i1, I2] := 0;            Aug[1, 1] := 0.5580848699E-2;            Aug[1, 2] := 0.2709177328E-3;            Aug[1, 3] := - 0.5531081141E-5;            Aug[1, 4] := 0.5955796251E-7;            Aug[1, 5] := - 0.3210316856E-9;            Aug[2, 1] := 0.3401533559E-1;            Aug[2, 2] := - 0.1601761397E-3;            Aug[2, 3] := 0.2473523226E-5;            Aug[2, 4] := - 0.3020861042E-7;            Aug[3, 1] := 0.9916651666E-1;            Aug[3, 2] := - 0.4615018255E-3;            Aug[3, 3] := - 0.4332933627E-6;            Aug[4, 1] := 1.0300997920E-1;            Aug[4, 2] := - 0.3113053618E-3;            Aug[5, 1] := 0.3630169747E-1;            FOR i := 1 TO IN1 DO              BEGIN                IF (G4^^.IL[i] <= 3) THEN                  BEGIN                    Aug[5, 5] := 1;                    FOR i1 := 1 TO I_N DO                      BEGIN                        FOR ij := 1 TO 5 DO                          FOR I2 := 1 TO ij DO                            Aug[5, 5] := Aug[5, 5] + Aug[I2, ij - I2 + 1] * PowerF((1 / G^^.Y[i] - 1), ij) * PowerF(G^^                                         .ZZZ[i1], (ij - I2 + 1));                        G2^^.R[i1, i] := Aug[5, 5];                      END; { FOR I1 := 1 TO I_N do... }                  END; { IF (IL[I] <= 3) THEN... }              END; { FOR I := 1 TO IN1 do... }          END; { case 5}        6: {MYKLEBUST & FIORI}          BEGIN          END;        7: {POUCHOU & PICHOIR}          BEGIN            FOR i := 1 TO IN1 DO              BEGIN                IF (G4^^.IL[i] <= 3) THEN                  BEGIN                    MEANW := 0.595 + G^^.HB[i] / 3.7 + Exp(4.55 * Ln(G^^.HB[i]));                    JU0 := 1 + G^^.Y[i] * (Ln(G^^.Y[i]) - 1);                    ALPHA := (2 * MEANW - 1) / (1 - MEANW);                    GU0 := (G^^.Y[i] - 1 - (1 - Exp((ALPHA + 1) * Ln(1 / G^^.Y[i]))) / (1 + ALPHA)) / (2 + ALPHA) / JU0;                    G2^^.R[i, i] := 1 - G^^.HB[i] * MEANW * (1 - GU0);                  END; { IF (G4^^.IL[I] <= 3) THEN... }              END; { FOR I := 1 TO IN1 do... }          END; { case }        OTHERWISE          noOp := 0;        END; { CASE }	END; { PROCEDURE Elem_BackScatter; }  PROCEDURE Elem_Stopping_Power;    VAR                                                     N2, N3, N4, N5         : real {double_t};      i1,   i                      : Integer;      M5, M6, Emm, Wght, Omega, ElinShell: real {double_t};      TE1, TE2, TE3, VEE0, XPP1, XPP2, XPP3,  U0: real {double_t};     BEGIN      CASE IMIP OF { ----- MEAN IONIZ. POTENTIALS }        1:          FOR i := 1 TO I_N DO { ----- CALC'N BERGER/SELTZER MEAN IONIZ. POTENTIALS -----}            G^^.JM[i] := (9.76 * G^^.ZZZ[i] + 58.5 * PowerF(G^^.ZZZ[i], - 0.19)) / 1000.0;        2:          FOR i := 1 TO I_N DO { CALC'N DUNCUMB/DA CASA MEAN IONIZ. POTENTIALS -----}            BEGIN              G^^.JM[i] := 14 * (1 - Exp( - 0.1 * G^^.ZZZ[i])) + 75.5 / PowerF(G^^.ZZZ[i], (G^^.ZZZ[i] / 7.5)) - G^^.                           ZZZ[i] / (100 + G^^.ZZZ[i]);              G^^.JM[i] := G^^.ZZZ[i] * G^^.JM[i] / 1000;            END;        3:          FOR i := 1 TO I_N DO { CALC'N RUSTE/ZELLER MEAN IONIZ. POTENTIALS }            BEGIN              G^^.JM[i] := 10.04 + 8.25 * Exp( - G^^.ZZZ[i] / 11.22);              G^^.JM[i] := G^^.ZZZ[i] * G^^.JM[i] / 1000;            END;        4:          FOR i := 1 TO I_N DO { CALC'N SPRINGER MEAN IONIZ. POTENTIALS }            BEGIN              G^^.JM[i] := 9 * (1 + PowerF(G^^.ZZZ[i], ( - 2 / 3))) + 0.03 * G^^.ZZZ[i];              G^^.JM[i] := G^^.ZZZ[i] * G^^.JM[i] / 1000;            END;        5:          FOR i := 1 TO I_N DO { CALC'N Wilson MEAN IONIZ. POTENTIALS }            BEGIN              G^^.JM[i] := 11.5;              G^^.JM[i] := G^^.ZZZ[i] * G^^.JM[i] / 1000;            END;        6:          FOR i := 1 TO I_N DO { CALC'N Heinrich MEAN IONIZ. POTENTIALS }            BEGIN              G^^.JM[i] := 9.94 + 19.52 / G^^.ZZZ[i];              G^^.JM[i] := G^^.ZZZ[i] * G^^.JM[i] / 1000;            END;        7:          FOR i := 1 TO I_N DO { CALC'N Bloch MEAN IONIZ. POTENTIALS }            BEGIN              G^^.JM[i] := 13.5;              G^^.JM[i] := G^^.ZZZ[i] * G^^.JM[i] / 1000;            END;			        8:          FOR i := 1 TO I_N DO { CALC'N Armstrong MEAN IONIZ. POTENTIALS }            BEGIN              IF G^^.ZZZ[i] < 30 THEN                 G^^.JM[i] := 9 * (1 + PowerF(G^^.ZZZ[i], ( - 2 / 3))) + 0.03 * G^^.ZZZ[i]              ELSE G^^.JM[i] := (9.76 + 58.5 * PowerF(G^^.ZZZ[i], - 1.19));             G^^.JM[i] := G^^.ZZZ[i] * G^^.JM[i] / 1000;            END;        9:          FOR i := 1 TO I_N DO { CALC'N Joy MEAN IONIZ. POTENTIALS }            BEGIN              IF G^^.ZZZ[i] < 13 THEN G^^.JM[i] := 11.5              ELSE G^^.JM[i] := (9.76 + 58.5 * PowerF(G^^.ZZZ[i], - 1.19));              G^^.JM[i] := G^^.ZZZ[i] * G^^.JM[i] / 1000;            END;        END; { of CASE }      CASE ISTP OF { ----- Stopping Power CORRECTION -----}        1:          FOR i := 1 TO IN1 DO { DUNCUMB/REED(FRAME) FOR STANDARDS }            BEGIN              IF (G4^^.IL[i] <= 3) THEN                BEGIN                  FOR i1 := 1 TO I_N DO                    BEGIN                      N5 := 1000 * G^^.JM[i1];                      G2^^.S[i1, i] := 2 * G^^.ZZZ[i1] / (G4^^.B[i1] * (E0 + G4^^.EC[i])) * Ln(583 * (E0 + G4^^.EC[i]) /                                      N5);                    END;                END;            END;        2: {PHILIBERT & TIXIER }          BEGIN            FOR i := 1 TO IN1 DO              BEGIN                G2^^.S[i, i] := 0;                IF (G4^^.IL[i] <= 3) THEN                  BEGIN                    M5 := G^^.ZZZ[i] / G4^^.B[i];                    M6 := 1.166 * G4^^.EC[i] / G^^.JM[i];                    N2 := M6 * G^^.Y[i];                    N3 := FNLint(N2);                    N4 := FNLint(M6);                    G2^^.S[i, i] := (G^^.Y[i] - 1 - (Ln(M6) / M6) * (N3 - N4)) / M5;                    G2^^.S[i, i] := 1 / G2^^.S[i, i];                  END;              END; { for I := 1 TO IN1...}          END;        3: { Numerical Integration, not implemented yet }          BEGIN            FOR i := 1 TO IN1 DO              BEGIN                G2^^.S[i, i] := 0;                IF (G4^^.IL[i] <= 3) THEN                  BEGIN                    G2^^.S[i, i] := 1;                  END;              END; { for I := 1 TO IN1...}          END;        4:          BEGIN            FOR i := 1 TO IN1 DO { LOVE/SCOTT ATOMIC NUMBER CORRECTION FOR STANDARDS }              BEGIN                IF G4^^.IL[i] <= 3 THEN                  BEGIN                    N5 := G^^.JM[i];                    G2^^.S[i, i] := G4^^.B[i] * (1 + 16.05 * SQRT(N5 / G4^^.EC[i]) * PowerF((SQRT(G^^.Y[i]) - 1) / (G^^.                                                                                         Y[i] - 1), 1.07)) / G^^.ZZZ[i];                    G2^^.S[i, i] := 1 / G2^^.S[i, i];                  END;              END;          END; { CASE 4 }        5: {POUCHOU & PICHOIR}          FOR i := 1 TO IN1 DO            BEGIN              IF G4^^.IL[i] <= 3 THEN                BEGIN                  JBAR := G^^.JM[i];                  CASE G4^^.IL[i] OF                    1: {Ka }                      BEGIN                        Emm := 0.86 + 0.12 * Exp( - G^^.ZZZ[i] * G^^.ZZZ[i] / 25);                        IF G^^.ZZZ[i] < 12 THEN Wght := 0;                        IF (G^^.ZZZ[i] >= 12) AND (G^^.ZZZ[i] <= 33) THEN                          BEGIN                            Wght := 2.0988 - 0.569943 * G^^.ZZZ[i] + 0.05759217 * G^^.ZZZ[i] * G^^.ZZZ[i];                            Wght := Wght - 0.0026994591 * PowerF(G^^.ZZZ[i], 3) + 6.008776E-05 * PowerF(G^^.ZZZ[i], 4);                            Wght := Wght - 5.14088E-07 * PowerF(G^^.ZZZ[i], 5);                          END;                        IF G^^.ZZZ[i] > 33 THEN Wght := 0.14;                        Wght := 1 - Wght;                        ElinShell := 2;                        Omega := Exp(2.373 * Ln(G^^.ZZZ[i]) - 8.902);                      END;                    2: {La }                      BEGIN                        Emm := 0.82;                        Wght := 0.979 - 0.00187 * G^^.ZZZ[i];                        ElinShell := 4;                        Omega := Exp(2.946 * Ln(G^^.ZZZ[i]) - 13.94);                      END;                    3: {Ma }                      BEGIN                        Emm := 0.78;                        Wght := 1;                        ElinShell := 6;                        Omega := 0.5 * Exp(2.946 * Ln(G^^.ZZZ[i] / 2) - 13.94);                      END;                    OTHERWISE                      noOp := 0;                    END; {case }                  G^^.EM[i] := Emm;                  G^^.ZIPI[i] := 0.38 * Omega * Wght * ElinShell;                  TE1 := 1.78 - Emm;                  TE2 := 1.1 - Emm;                  TE3 := 0.5 + JBAR / 4 - Emm;                  VEE0 := E0 / JBAR;                  U0 := G^^.Y[i];                  N2 := Exp(TE1 * Ln(G^^.Y[i]));                  N3 := Ln(G^^.Y[i]);                  XPP1 := 0.0000066 * Exp(0.78 * Ln(VEE0 / G^^.Y[i])) * (TE1 * N2 * N3 - Exp(TE1 * N3) + 1) / TE1 / TE1;                  XPP2 := 0.0000112 * (1.35 - 0.45 * JBAR * JBAR) * Exp(0.1 * Ln(VEE0 / U0));                  XPP2 := XPP2 * (TE2 * Exp(TE2 * Ln(G^^.Y[i])) * Ln(G^^.Y[i]) - Exp(TE2 * N3) + 1) / TE2 / TE2;                  XPP3 := 0.0000022 / JBAR * Exp(( - 0.5 + JBAR / 4) * Ln(VEE0 / G^^.Y[i]));                  XPP3 := XPP3 * (TE3 * Exp(TE3 * N3) * N3 - Exp(TE3 * N3) + 1) / TE3 / TE3;                  XP := 66892 * G^^.ZIPI[i] / G4^^.B[i] * (G^^.Y[i] / VEE0 / (G^^.ZZZ[i] / G4^^.B[i])) * (XPP1 + XPP2 + XPP3);                  G2^^.S[i, i] := 1 / XP;                END; { IF IL[I] <= 3 THEN do.... }            END; { FOR I := 1 TO IN1 do... }        OTHERWISE          noOp := 0;        END; { CASE }	END; { PROCEDURE Elem_Stopping_Power; }  PROCEDURE Elem_Absorption;    VAR            HA, HAL, PS, PZZ, LU: real {double_t};      A1, A2, A3, AX, HX, XX, ZM, ZR, ZRA, ZRB, ZRC: real {double_t};      i1,   i                     : Integer;         		BEGIN      CASE IABS OF { Standard Absorption Corrections }        1:          BEGIN            FOR i := 1 TO I_N DO { PHILIBERT(FRAME) ABSORPTION CORRECTION FOR STANDARDS }              BEGIN                G^^.F0[i] := 1.2 * G4^^.B[i] / (G^^.ZZZ[i] * G^^.ZZZ[i]);              END;            FOR i := 1 TO IN1 DO              BEGIN                IF (G4^^.IL[i] <= 3) THEN                  BEGIN                    G4^^.HH[i] := 450000 / (PowerF(E0, 1.65) - PowerF(G4^^.EC[i], 1.65));                    G^^.W[i] := 1 + G^^.F0[i] / (1 + G^^.F0[i]) * G2^^.P[i, i] * T1 / G4^^.HH[i];                    G^^.W[i] := G^^.W[i] * (1 + G2^^.P[i, i] * T1 / G4^^.HH[i]);                  END;              END;          END; { CASE 1 }        2:          FOR i := 1 TO IN1 DO { HEINRICH/AN. CHEM. ABSORPTION CORRECTION FOR STANDARDS }            BEGIN              IF (G4^^.IL[i] <= 3) THEN                BEGIN                  G4^^.HH[i] := 0.0000012 * (PowerF(E0, 1.65) - PowerF(G4^^.EC[i], 1.65));                  G^^.W[i] := (1 + G4^^.HH[i] * G2^^.P[i, i] * T1) * (1 + G4^^.HH[i] * G2^^.P[i, i] * T1);                END;            END;        3:          FOR i := 1 TO IN1 DO { HEINRICH/1985 MAS ABSORPTION CORRECTION FOR STANDARDS }            BEGIN              IF (G4^^.IL[i] <= 3) THEN                BEGIN                  G4^^.HH[i] := PowerF(E0, 1.65) - PowerF(G4^^.EC[i], 1.65);                  HA := 1.65E-06;                  HAL := 0.18 + 2 / G4^^.HH[i] + 8E-06 * G4^^.EC[i] + 0.005 * SQRT(G^^.ZZZ[i]);                  G^^.W[i] := (1 + HAL * HA * G4^^.HH[i] * G2^^.P[i, i] * T1) / ((1 + HA * G2^^.P[i, i] * T1) * (1 + HA *                              G2^^.P[i, i] * T1));                  G^^.W[i] := 1 / G^^.W[i];                END;            END;        4:          FOR i := 1 TO IN1 DO { LOVE/SCOTT 1983 ABSORPTION CORRECTION FOR STANDARDS }            BEGIN              IF (G4^^.IL[i] <= 3) THEN                BEGIN                  PS := (7.87E-06 * SQRT(G^^.JM[i]) * PowerF(E0, 1.5) + 7.35E-07 * E0 * E0) / (G^^.ZZZ[i] / G4^^.B[i]);                  PZZ := PS * (0.49269 - 1.0987 * G^^.HB[i] + 0.78557 * G^^.HB[i] * G^^.HB[i]) * Ln(G^^.Y[i]);                  PZZ := PZZ / (0.70256 - 1.09865 * G^^.HB[i] + 1.0046 * G^^.HB[i] * G^^.HB[i] + Ln(G^^.Y[i]));                  G^^.W[i] := (1 - Exp( - 2 * G2^^.P[i, i] * T1 * PZZ)) / (2 * G2^^.P[i, i] * T1 * PZZ);                  G^^.W[i] := 1 / G^^.W[i];                END;            END;        5:          FOR i := 1 TO I_N DO { LOVE/SCOTT 1985-I ABSORPTION CORRECTION FOR STANDARDS }            BEGIN              IF (G4^^.IL[i] <= 3) THEN                BEGIN                  PS := (7.87E-06 * SQRT(G^^.JM[i]) * PowerF(E0, 1.5) + 7.35E-07 * E0 * E0) / (G^^.ZZZ[i] / G4^^.B[i]);                  LU := Ln(G^^.Y[i]);                  G^^.PZ1[i] := PS * LU / ((2.4 + 0.07 * G^^.ZZZ[i]) * LU + 1.04 + 0.48 * G^^.HB[i]);                  IF (i < I_N) OR (IN1 = I_N) THEN                    BEGIN                      G^^.W[i] := (1 - Exp( - 2 * G2^^.P[i, i] * T1 * G^^.PZ1[i])) / (2 * G2^^.P[i, i] * T1 * G^^.PZ1[i]);                      G^^.W[i] := 1 / G^^.W[i];                    END;                END;            END;        6:          FOR i := 1 TO I_N DO { LOVE/SCOTT 1985-II ABSORPTION CORRECTION FOR STANDARDS }            BEGIN              IF (G4^^.IL[i] <= 3) THEN                BEGIN                  LU := Ln(G^^.Y[i]);                  PS := (7.87E-06 * SQRT(G^^.JM[i]) * PowerF(E0, 1.5) + 7.35E-07 * E0 * E0) / (G^^.ZZZ[i] / G4^^.B[i]);                  G^^.PZ1[i] := PS * LU / ((2.4 + 0.07 * G^^.ZZZ[i]) * LU + 1.04 + 0.48 * G^^.HB[i]);                  IF (i < I_N) OR (IN1 = I_N) THEN                    BEGIN                      A1 := 2.2 + 0.00188 * G^^.ZZZ[i];                      A3 := 0.01 + 0.00719 * G^^.ZZZ[i];                      A2 := (A1 - 1) * Exp(A3);                      AX := 1.23 - 1.25 * G^^.HB[i];                      HX := A1 - A2 * Exp( - A3 * PowerF(G^^.Y[i], AX));                      ZM := G^^.PZ1[i] * (0.29 + (0.662 + 0.443 * PowerF(G^^.Y[i], 0.2)) / SQRT(G^^.ZZZ[i]));                      ZRA := HX;                      ZRB := HX * (ZM - 3 * G^^.PZ1[i]);                      ZRC := ZM * (ZM - 3 * G^^.PZ1[i]);                      ZR := ( - ZRB + SQRT(ZRB * ZRB - 4 * ZRA * ZRC)) / (2 * ZRA);                      XX := G2^^.P[i, i] * T1;                      G^^.W[i] := (Exp( - XX * ZM) * (ZR - HX * ZR) + HX * ZR - ZR) / ZM;                      G^^.W[i] := G^^.W[i] - Exp( - XX * ZM) + HX * Exp( - XX * ZR) + XX * (ZR - ZM) - HX + 1;                      G^^.W[i] := G^^.W[i] * 2 / ((ZR - ZM) * (ZM + HX * ZR) * XX * XX);                      G^^.W[i] := 1 / G^^.W[i];                    END;                END;            END;        7, 8, 9, 10, 11:          Phi_Rho_Z;        12: {FULL PAP -- POUCHOUT & PICHOIR }          BEGIN            G^^.DP[1] := 0.0000066;            G^^.PP[1] := 0.78;            G^^.PP[2] := 0.1;            FOR i := 1 TO IN1 DO              BEGIN                IF G4^^.IL[i] <= 3 THEN                  BEGIN                    ZP := G^^.ZZZ[i];                    ZN := G^^.ZZZ[i];                    XP := G2^^.R[i, i] / G2^^.S[i, i];                    JBAR := G^^.JM[i];                    Hp := G^^.HB[i];                    XI := G2^^.P[i, i] * T1;                    SUMATOM1 := G^^.ZZZ[i] / G4^^.B[i];                    PAPABS(i);                    G^^.W[i] := 1 / fp;                  END; { IF IL[I] <= 3 THEN... }              END; { FOR I := 1 TO IN1 do... }          END; {case 12}        13: {SIMPLIFIED PAP -- POUCHOUT & PICHOIR}          BEGIN 		              FOR i := 1 TO IN1 DO              BEGIN                IF G4^^.IL[i] <= 3 THEN                  BEGIN                    ZP := G^^.ZZZ[i];                    ZN := G^^.ZZZ[i];                    MEANZ := G^^.ZZZ[i];                    XP := G2^^.R[i, i] / G2^^.S[i, i];                    JBAR := G^^.JM[i];                    Hp := G^^.HB[i];                    XI := G2^^.P[i, i] * T1;                    SUMATOM1 := 1;                    PAPABS1(i);                    G^^.W[i] := 1 / fp;                  END; { IF G4^^.IL[I] <= 3 THEN... }              END; { FOR I := 1 TO IN1 DO... }          END; {case 13}        14:          Phi_Rho_Z;        15: {BASTIN PROZA PHI(PZ) MODEL (EPQ-91)}          BEGIN            FOR i := 1 TO IN1 DO              BEGIN                FOR i1 := 1 TO I_N DO                  BEGIN                    G^^.PZ[i, i1] := 2.1614E5 * PowerF(G^^.ZZZ[i1], 1.163) / (SQRT(E0 / 					                 G4^^.EC[i] - 1) * PowerF(E0, 1.25) * G4^^.B[i1]);                    G^^.PZ[i, i1] := G^^.PZ[i, i1] * sqrt(Ln(1.166 * E0 / G^^.JM[i]) / G4^^.EC[i]);                  END; { FOR I1 := 1 TO IN do... }              END; { FOR I := 1 TO IN1 do... }            Phi_Rho_Z;          END; {Case 15 }        END; { CASE }      FOR i := 1 TO IN1 DO        BEGIN          IF (G4^^.IL[i] <= 3) AND (G^^.IT[i] = 0) THEN            BEGIN              M9 := 1 / G^^.W[i];              IF M9 < 0.75 THEN                BEGIN                  IF IFirstRun = 1 THEN                    BEGIN                      writeln(Out_TxtFile, 'WARNING: THE F(X) OF ELEMENT ', A^.IZ[i], ' IS ', M9);                    END;                END;            END;        END;      { Calculation of atomic number correction by phi-rho-z integration}      IF (ISTP = 6) THEN        FOR i := 1 TO IN1 DO { BROWN PHI(PZ) ATOMIC NUMBER CORRECTION FOR STANDARDS }          BEGIN            IF (G4^^.IL[i] <= 3) THEN              BEGIN                G2^^.R[i, i] := G^^.PHI[i] * 1000.0;                G2^^.S[i, i] := 1.0;              END;          END;		END; { PROCEDURE Elem_Absorption; }  PROCEDURE STD_ZAF;    BEGIN		Elem_BackScatter; 		Elem_Stopping_Power;		Elem_Absorption;    END;  		{$S CITZAFCode59}  PROCEDURE SETUP_Fluorescence; { INITIALIZATION OF FLUORESCENCE CORRECTION FACTORS }    VAR      i1, I2, i, IM4, IN7, IN_8, I4      : Integer;      N6                            : real {double_t};    LABEL      6700, 6950;    BEGIN      FOR i := 1 TO IN1 DO        BEGIN          IM4 := G4^^.IL[i];          IF IM4 <= 3 THEN            BEGIN              IF IM4 = 1 THEN                BEGIN                  N6 := 5.0;                  IN7 := 0; {----- N6 is upper limit for fluorescence}                END;              IF IM4 = 2 THEN                BEGIN                  N6 := 3.5;                  IN7 := 1;                END;              IF IM4 = 3 THEN                BEGIN                  N6 := 3.5;                  IN7 := 2;                END;              FOR i1 := 1 TO I_N DO                BEGIN                  G2^^.IQ[i, i1] := 0;                  { ----- IQ is code for type of fluorescence -- 0 is none}                  {               1: K by K, 2: K by L, 3: L by K, 4: L by L, 5: M by K, 6: M by L }                  I2 := 1; { ----- 1st test for fluorescence by K-line }                6700:                  IF G2^^.G[I2, i1] > G4^^.EC[i] THEN                    BEGIN                      IN_8 := I2 * I2;                      IF (G2^^.G[I2, i1] > G4^^.EC[i] + N6) OR (G2^^.O[IN_8, i1] >= E0) THEN GOTO 6950;                      G2^^.IQ[i, i1] := I2 + 2 * IN7;                      IF IA <> 0 THEN                        BEGIN                          IF IFirstRun = 1 THEN                            BEGIN                              writeln(Out_TxtFile, 'THE ', G^^.Line_Name[IM4], '-LINE OF ELEMENT ', A^.IZ[i],                                      ' IS EXCITED BY THE ', G^^.Line_Name[I2], '-LINE OF ELEMENT ', A^.IZ[i1]);                            END; { IF IFirstRun = 1 }                        END; { IF IA <> 0 }                      G3^^.X[i, i1] := E0 / G2^^.O[IN_8, i1];                      { -----  get K or L shell mass absorption coef. for fluorescing elem. }                      IF I2 = G4^^.IL[i1] THEN                        FOR I4 := 1 TO I_N DO                          G3^^.fp[I2, I4, i1] := G2^^.P[I4, i1]                      ELSE                      	Xray_Data_Request := TRUE;                        FOR I4 := 1 TO I_N DO                          BEGIN                            Get_Energies(A^.IZ[I4]);                            G3^^.fp[I2, I4, i1] := MassAbsCoeff(G2^^.G[I2, i1], A^.IZ[I4]);                          END;                        Xray_Data_Request := FALSE;                    6950:                      IF (I2 = 1) AND (G2^^.IQ[i, i1] = 0) THEN                        BEGIN                          I2 := 2;                          GOTO 6700; { ----- next test for fluorescence by L line}                        END;                    END; { 6700: IF G2^^.G[I2, I1] > G4^^.EC[I] }                END; { FOR I1 := 1 TO I_N }              { ----- setup of fluor. yields, line wts & jump factors }              { ----- G^^.RI[I] := jump factor for element I  }              CASE G4^^.IL[i] OF                1:                  G^^.RI[i] := 1.11728 - 0.07368 * Ln(A^.IZ[i]); { K-LINE (0.88) }                2:                  G^^.RI[i] := 0.95478 - 0.00259 * A^.IZ[i]; { L-LINE (0.75) }                3:                  G^^.RI[i] := 0.5; { M-LINE }                END; { CASE }              FOR i1 := 1 TO I_N DO                BEGIN                  IF G2^^.IQ[i, i1] > 0 THEN                    BEGIN                      I2 := G2^^.IQ[i, i1] - 2 * (G4^^.IL[i] - 1);                      {----- OMJ(I,I1) := fluorescence yield for elem. I1}                      IF (I2 = 2) OR (I2 = 4) OR (I2 = 6) THEN G3^^.OMJ[i, i1] := G2^^.OM[2, i1]                      ELSE G3^^.OMJ[i, i1] := G2^^.OM[1, i1];                      CASE I2 OF { Relative Line Weights = PIJ[ ] }                        1:                          G3^^.PIJ[i, i1] := 1.0; { K by K }                        2:                          G3^^.PIJ[i, i1] := 4.2; { K by L }                        3:                          G3^^.PIJ[i, i1] := 0.24; { L by K }                        4:                          G3^^.PIJ[i, i1] := 1.0; { L by L }                        5:                          G3^^.PIJ[i, i1] := 0.02; { M by K }                        6:                          G3^^.PIJ[i, i1] := 0.02; { M by L }                        END; { CASE }                    END; { IF IQ[I, I1] > 0 }                END; { FOR I1 := 1 TO I_N }            END; { IF IM4 <= 3 }        END; { Main I := 1 TO IN1 loop }    END; { PROCEDURE SETUP_Fluorescence }  {$S CITZAFCode_88}  PROCEDURE SMP_ZAF;    VAR      d, HA, HAL, PS, PZZ, MEANW, GU0, JU0 				: real {double_t};      A1, A2, A3, AX, HX, XX, ZM, ZR, ZRA, ZRB, ZRC    : real {double_t};      AVEZ, TE1, TE2, TE3, XPP1, XPP2, XPP3,  U0       : real {double_t};      Emm, VEE0, N2, N3, N4, N5, ZED, M5, M6, M8       : real {double_t};	  DD,FLUA,FLUB,FLUC,FLUX,FLU                		: real {double_t};      i, ii, i1, I4, I2                                : Integer;    BEGIN      {-----          CALCULATION OF SAMPLE ABSFAC's & ZEDFAC's         -----}      {----------------------------------------------------------------------}      { Calculation of stopping power J factor for compound samples }      M5 := 0;      M6 := 0;      FOR i1 := 1 TO I_N DO        BEGIN          M5 := M5 + G^^.C[i1] * G^^.ZZZ[i1] / G4^^.B[i1];          M6 := M6 + G^^.C[i1] * G^^.ZZZ[i1] * Ln(G^^.JM[i1]) / G4^^.B[i1];        END; { FOR I1 := 1 TO I_N do... }      SUMATOM := M5;      JBAR := Exp(M6 / M5);	        CASE IBSC OF {Calculation of BS Coeff for samples }        1, 2, 4: {HEINRICH, LOVE/SCOTT, HUNGER/KUCHLER}          BEGIN            eta := 0;            FOR i1 := 1 TO I_N DO              eta := eta + G^^.C[i1] * G^^.HB[i1];          END; { case 1,2,4}        3: {POUCHOU & PICHOIR}          BEGIN            AVEZ := 0;            FOR i1 := 1 TO I_N DO              AVEZ := AVEZ + G^^.C[i1] * SQRT(G^^.ZZZ[i1]);            MEANZ := AVEZ * AVEZ;            eta := 0.00175 * MEANZ + 0.37 * (1 - Exp( - 0.015 * Exp(1.3 * Ln(MEANZ))));          END; {case 3}        OTHERWISE          noOp := 0;        END; { CASE }      CASE ISTP OF { ----- STOPPING POWER CORRECTION for samples -----}        1:          FOR ii := 1 TO IN1 DO { DUNCUMB/REED(FRAME) }            BEGIN              i := ii;              IF (G4^^.IL[i] <= 3) AND (G^^.C[i] > 0) THEN                BEGIN                  M5 := 0;                  FOR i1 := 1 TO I_N DO                    BEGIN                      M5 := M5 + G^^.C[i1] * G2^^.S[i1, i];                    END;                  G^^.STP[i] := M5;                END;            END;        2: {PHILIBERT & TIXIER}          BEGIN            M5 := SUMATOM;            FOR ii := 1 TO IN1 DO              BEGIN                i := ii;                G^^.STP[i] := 0;                IF (G4^^.IL[i] <= 3) AND (G^^.C[i] > 0) THEN                  BEGIN                    M6 := 0;                    FOR i1 := 1 TO I_N DO                      M6 := M6 + (G^^.C[i1] * G^^.ZZZ[i1] / G4^^.B[i1]) * Ln(1.166 * G4^^.EC[i] / G^^.JM[i1]);                    M6 := Exp(M6 / M5);                    N2 := M6 * G^^.Y[i];                    N3 := FNLint(N2);                    N4 := FNLint(M6);                    G^^.STP[i] := (G^^.Y[i] - 1 - (Ln(M6) / M6) * (N3 - N4)) / M5;                    G^^.STP[i] := 1 / G^^.STP[i];                  END; { IF (G4^^.IL[I] <= 3) AND (G^^.C[I] > 0) THEN... }              END; { FOR I := 1 TO IN1 do... }          END; { case }        3: {NUMERICAL INTEGRATION}          BEGIN            {not implemented yet }          END;        4:          BEGIN            FOR ii := 1 TO I_N DO { LOVE/SCOTT }              BEGIN                i := ii;                IF (Integer(G4^^.IL[i]) <= 3) AND (G^^.C[i] > 0) THEN                  BEGIN                    G^^.STP[i] := (1 + 16.05 * SQRT(JBAR / G4^^.EC[i]) * PowerF((SQRT(G^^.Y[i]) - 1) / (G^^.Y[i] - 1),                                                                               1.07)) / SUMATOM;                    G^^.STP[i] := 1 / G^^.STP[i];                  END;              END;          END; { CASE 4 }        5: {POUCHOU & PICHOIR}          BEGIN            M5 := SUMATOM;            FOR i := 1 TO IN1 DO              BEGIN                IF (G4^^.IL[i] <= 3) AND (G^^.C[i] > 0) THEN                  BEGIN                    VEE0 := E0 / JBAR;                    Emm := G^^.EM[i];                    U0 := G^^.Y[i];                    TE1 := 1.78 - Emm;                    TE2 := 1.1 - Emm;                    TE3 := 0.5 + JBAR / 4 - Emm;                    N2 := Exp(TE1 * Ln(G^^.Y[i]));                    N3 := Ln(G^^.Y[i]);                    XPP1 := 0.0000066 * Exp(0.78 * Ln(VEE0 / G^^.Y[i])) * (TE1 * N2 * N3 - Exp(TE1 * N3) + 1) / TE1 /                            TE1;                    XPP2 := 0.0000112 * (1.35 - 0.45 * JBAR * JBAR) * Exp(0.1 * Ln(VEE0 / U0));                    XPP2 := XPP2 * (TE2 * Exp(TE2 * Ln(G^^.Y[i])) * Ln(G^^.Y[i]) - Exp(TE2 * N3) + 1) / TE2 / TE2;                    XPP3 := 0.0000022 / JBAR * Exp(( - 0.5 + JBAR / 4) * Ln(VEE0 / G^^.Y[i]));                    XPP3 := XPP3 * (TE3 * Exp(TE3 * N3) * N3 - Exp(TE3 * N3) + 1) / TE3 / TE3;                    XP := 66892 * G^^.ZIPI[i] / G4^^.B[i] * ((G^^.Y[i] / VEE0) / M5) * (XPP1 + XPP2 + XPP3);                    G^^.STP[i] := 1 / XP;                  END; { IF (G4^^.IL[I] <= 3) AND (G^^.C[I] > 0) THEN ... }              END; { FOR I := 1 TO IN1 do... }          END; { case 5 }        OTHERWISE          noOp := 0;        END; { CASE }      CASE IBKS OF { ----- BACKSCATTER CORRECTION FOR SAMPLES -----}        1, 2, 3, 5, 6:          FOR ii := 1 TO IN1 DO { DUNCUMB/REED(FRAME) }            BEGIN              i := ii;              IF (G4^^.IL[i] <= 3) AND (G^^.C[i] > 0) THEN                BEGIN                  M6 := 0;                  FOR i1 := 1 TO I_N DO                    BEGIN                      M6 := M6 + G^^.C[i1] * G2^^.R[i1, i];                    END;                  G^^.BKS[i] := M6;                  G3^^.A[i] := G2^^.R[i, i] * G^^.STP[i] / (G2^^.S[i, i] * G^^.BKS[i]);                END;            END;        4:          BEGIN            FOR ii := 1 TO I_N DO { LOVE/SCOTT }              BEGIN                i := ii;                IF (Integer(G4^^.IL[i]) <= 3) AND (G^^.C[i] > 0) THEN                  BEGIN                    G^^.BKS[i] := 1 - eta * PowerF((G^^.JU[i] + eta * G^^.GU[i]), 1.67);                    G3^^.A[i] := G2^^.R[i, i] * G^^.STP[i] / (G2^^.S[i, i] * G^^.BKS[i]);                  END;              END;          END; { CASE 2 }        7: {POUCHOU & PICHOIR}          BEGIN            FOR i := 1 TO IN1 DO              BEGIN                IF (G4^^.IL[i] <= 3) THEN                  BEGIN                    MEANW := 0.595 + eta / 3.7 + Exp(4.55 * Ln(eta));                    JU0 := 1 + G^^.Y[i] * (Ln(G^^.Y[i]) - 1);                    ALPHA := (2 * MEANW - 1) / (1 - MEANW);                    GU0 := (G^^.Y[i] - 1 - (1 - Exp((ALPHA + 1) * Ln(1 / G^^.Y[i]))) / (1 + ALPHA)) / (2 + ALPHA) / JU0;                    G^^.BKS[i] := 1 - eta * MEANW * (1 - GU0);                    G3^^.A[i] := G2^^.R[i, i] * G^^.STP[i] / (G2^^.S[i, i] * G^^.BKS[i]);                  END; { IF (G4^^.IL[I] <:= 3) THEN ... }              END; { FOR I := 1 TO IN1 do... }          END; { case 7 }        OTHERWISE          noOp := 0;        END; { CASE }      CASE IABS OF { Sample Absorption Corrections }        1:          BEGIN            FOR ii := 1 TO IN1 DO { PHILIBERT(FRAME) ABSORPTION CORRECTION FOR SAMPLES }              BEGIN                i := ii;                IF (G4^^.IL[i] <= 3) AND (G^^.C[i] > 0) THEN                  BEGIN                    d := 0;                    MACCAL(i);                    FOR i1 := 1 TO I_N DO                      d := d + G^^.C[i1] * G^^.F0[i1];                    G^^.E[i] := (1 + d / (1 + d) * M7 * T1 / G4^^.HH[i]) * (1 + M7 * T1 / G4^^.HH[i]);                  END;              END;          END; { CASE 1 }        2:          FOR ii := 1 TO IN1 DO { HEINRICH/AN. CHEM. ABSORPTION CORRECTION FOR SAMPLES }            BEGIN              i := ii;              IF (G4^^.IL[i] <= 3) AND (G^^.C[i] > 0) THEN                BEGIN                  MACCAL(i);                  G^^.E[i] := (1 + G4^^.HH[i] * M7 * T1) * (1 + G4^^.HH[i] * M7 * T1);                END;            END;        3:          FOR ii := 1 TO IN1 DO { HEINRICH/1985 MAS ABSORPTION CORRECTION FOR SAMPLES }            BEGIN              i := ii;              HA := 1.65E-06;              IF (G4^^.IL[i] <= 3) AND (G^^.C[i] > 0) THEN                BEGIN                  ZED := 0;                  MACCAL(i);                  FOR i1 := 1 TO I_N DO                    ZED := ZED + G^^.C[i1] * G^^.ZZZ[i1];                  HAL := 0.18 + 2 / G4^^.HH[i] + 8.0E-06 * G4^^.EC[i] + 0.005 * SQRT(ZED);                  G^^.E[i] := (1 + HAL * HA * G4^^.HH[i] * M7 * T1) / ((1 + HA * G4^^.HH[i] * M7 * T1) * (1 + HA * 				                                        G4^^.HH[i] * M7 * T1));                  G^^.E[i] := 1 / G^^.E[i];                END;            END;        4:          FOR ii := 1 TO IN1 DO { LOVE/SCOTT 1983 ABSORPTION CORRECTION FOR SAMPLES }            BEGIN              i := ii;              IF (G4^^.IL[i] <= 3) AND (G^^.C[i] > 0) THEN                BEGIN                  M5 := 0;                  M6 := 0;                  d := 0;                  MACCAL(i);                  FOR i1 := 1 TO I_N DO                    BEGIN                      M5 := M5 + G^^.C[i1] * G^^.ZZZ[i1] / G4^^.B[i1];                      M6 := M6 + G^^.C[i1] * G^^.ZZZ[i1] * Ln(G^^.JM[i1]) / G4^^.B[i1];                      d := d + G^^.C[i1] * G^^.HB[i1];                    END;                  M6 := Exp(M6 / M5);                  PS := (7.87E-06 * SQRT(M6) * PowerF(E0, 1.5) + 7.35E-07 * E0 * E0) / M5;                  PZZ := PS * (0.49269 - 1.0987 * d + 0.78557 * d * d) * Ln(G^^.Y[i]);                  PZZ := PZZ / (0.70256 - 1.09865 * d + 1.0046 * d * d + Ln(G^^.Y[i]));                  G^^.E[i] := (1 - Exp( - 2 * M7 * T1 * PZZ)) / (2 * M7 * T1 * PZZ);                  G^^.E[i] := 1 / G^^.E[i];                END;            END;        5:          FOR ii := 1 TO I_N DO { LOVE/SCOTT 1985-I ABSORPTION CORRECTION FOR SAMPLES }            BEGIN              i := ii;              IF (G4^^.IL[i] <= 3) AND (G^^.C[i] > 0) THEN                BEGIN                  PZZ := 0;                  MACCAL(i);                  FOR i1 := 1 TO I_N DO                    PZZ := PZZ + G^^.C[i1] * G^^.PZ1[i1];                  G^^.E[i] := (1 - Exp( - 2 * M7 * T1 * PZZ)) / (2 * M7 * T1 * PZZ);                  G^^.E[i] := 1 / G^^.E[i];                END;            END;        6:          FOR ii := 1 TO I_N DO { LOVE/SCOTT 1985-II ABSORPTION CORRECTION FOR SAMPLES }            BEGIN              i := ii;              IF (G4^^.IL[i] <= 3) AND (G^^.C[i] > 0) THEN                BEGIN                  MACCAL(i);                  XX := M7 * T1;                  M5 := 0;                  PZZ := 0;                  d := 0;                  FOR i1 := 1 TO I_N DO                    BEGIN                      M5 := M5 + G^^.C[i1] * G^^.ZZZ[i1];                      PZZ := PZZ + G^^.C[i1] * G^^.PZ1[i1];                      d := d + G^^.C[i1] * G^^.HB[i1];                    END;                  A1 := 2.2 + 0.00188 * M5;                  A3 := 0.01 + 0.00719 * M5;                  A2 := (A1 - 1) * Exp(A3);                  AX := 1.23 - 1.25 * d;                  HX := A1 - A2 * Exp( - A3 * PowerF(G^^.Y[i], AX));                  ZM := PZZ * (0.29 + (0.662 + 0.443 * PowerF(G^^.Y[i], 0.2)) / SQRT(M5));                  ZRA := HX;                  ZRB := HX * (ZM - 3 * PZZ);                  ZRC := ZM * (ZM - 3 * PZZ);                  ZR := ( - ZRB + SQRT(ZRB * ZRB - 4 * ZRA * ZRC)) / (2 * ZRA);                  G^^.E[i] := (Exp( - XX * ZM) * (ZR - HX * ZR) + HX * ZR - ZR) / ZM;                  G^^.E[i] := G^^.E[i] - Exp( - XX * ZM) + HX * Exp( - XX * ZR) + XX * (ZR - ZM) - HX + 1;                  G^^.E[i] := G^^.E[i] * 2 / ((ZR - ZM) * (ZM + HX * ZR) * XX * XX);                  G^^.E[i] := 1 / G^^.E[i];                END;            END;        7, 8, 9, 10, 11:          Phi_Rho_Z;        14, 15:          Phi_Rho_Z;        12: {FULL PAP -- POUCHOUT & PICHOIR}          BEGIN            G^^.DP[1] := 0.0000066;            G^^.PP[1] := 0.78;            G^^.PP[2] := 0.1;            ZP := 0;            ZN := 0;            FOR i1 := 1 TO I_N DO              BEGIN                ZP := ZP + G^^.C[i1] * G^^.ZZZ[i1];                ZN := ZN + G^^.C[i1] * Ln(G^^.ZZZ[i1]);              END; { FOR I1 := 1 TO I_N do... }            ZN := Exp(ZN);            FOR i := 1 TO IN1 DO              BEGIN                IF (G^^.C[i] > 0) AND (G4^^.IL[i] <= 3) THEN                  BEGIN                    Hp := eta;                    XP := G^^.BKS[i] / G^^.STP[i];                    MACCAL(i);                    XI := M7 * T1;                    PAPABS(i);                    G^^.E[i] := 1 / fp;                  END; { IF (G^^.C[I] > 0) AND (G4^^.IL[I] <= 3) THEN ... }              END; { FOR I := 1 TO IN1 do... }          END; { case 12}        13: {SIMPLIFIED PAP -- POUCHOUT & PICHOIR}          BEGIN            ZP := 0;            ZN := 0;            AVEZ := 0;            FOR i1 := 1 TO I_N DO              BEGIN                ZP := ZP + G^^.C[i1] * G^^.ZZZ[i1];                ZN := ZN + G^^.C[i1] * Ln(G^^.ZZZ[i1]);                AVEZ := AVEZ + G^^.C[i1] * SQRT(G^^.ZZZ[i1]);              END;            ZN := Exp(ZN);            MEANZ := AVEZ * AVEZ;            FOR i := 1 TO IN1 DO              BEGIN                IF (G^^.C[i] > 0) AND (G4^^.IL[i] <= 3) THEN                  BEGIN                    Hp := eta;                    XP := G^^.BKS[i] / G^^.STP[i];                    MACCAL(i);                    XI := M7 * T1;                    PAPABS1(i);                    G^^.E[i] := 1 / fp;                  END; { IF (G^^.C[I] > 0) AND (G4^^.IL[I] <= 3) THEN... }              END; { FOR I := 1 TO IN1 do }          END; { case 13}        END; { CASE }      { Calculation of atomic number correction by phi-rho-z integration }      IF ISTP = 6 THEN        FOR ii := 1 TO IN1 DO { BROWN PHI(PZ) }          BEGIN            i := ii;            IF (G4^^.IL[i] <= 3) AND (G^^.C[i] > 0) THEN              BEGIN                G^^.BKS[i] := G^^.PHI[i] * 1000;                G^^.STP[i] := 1;                G3^^.A[i] := G2^^.R[i, i] / G^^.BKS[i];              END;          END;      { CASE IFLU OF.... there is only one fluorescence correction at this time. IE the Reed}      {                   correction with the Armstrong 1988 MAS modifications }      {----------------------------------------------------------------------}      {-----         SAMPLE FLUORESCENCE CORRECTION         -----}      {----------------------------------------------------------------------}	        IF (IPtc = 1) OR (IFLU > 1) then 	  begin		DD := pRHO * DIA[IPtcD] / 10000.0;		IMN := IMD[IPtcM];	  end;	  	  FOR ii := 1 TO IN1 DO        BEGIN          i := ii;          IF (G4^^.IL[i] <= 3) AND (G^^.C[i] > 0) THEN            BEGIN              G^^.Fluor[i] := 0;              MACCAL(i);              FOR i1 := 1 TO I_N DO                BEGIN                  IF G2^^.IQ[i, i1] > 0 THEN                    BEGIN                      M8 := 0;                      I2 := G2^^.IQ[i, i1] - 2 * (G4^^.IL[i] - 1);                      FOR I4 := 1 TO I_N DO M8 := M8 + G^^.C[I4] * G3^^.fp[I2, I4, i1];                      N2 := T1 * M7 / M8;                      N3 := 333000 / (PowerF(E0, 1.65) - PowerF(G4^^.EC[i], 1.65)) / M8;                      N4 := Ln(1 + N2) / N2 + Ln(1 + N3) / N3;                      N5 := G^^.C[i1] * G3^^.PIJ[i, i1] * G3^^.OMJ[i, i1] * G^^.RI[i] / 2;                      N5 := N5 * PowerF(((G3^^.X[i, i1] - 1) / (G^^.Y[i] - 1)), 1.67) * G4^^.B[i] / G4^^.B[i1];					                        IF (IFLU = 3) AND (DD * J9 < 0.001) THEN                         N4 := M8 * DD * J9 * (0.923 - Ln(M8 * DD * J9));                      { NOCKOLDS FLUORESCENCE CORRECTION FOR THIN FILMS }                            { MODIFIED TO USE REED REL. LINE INTEN. }                      { THIN FILM CORRECTION ACCURATE ONLY FOR FILMS < 1 mg/cm^2 THICK }					  					                        N5 := N5 * N4 * G3^^.fp[I2, i, i1] / M8;					                        IF (IFLU = 2) AND (IMN <> 1) THEN                         BEGIN                          FLUX := 1 - EXP(-M8 * DD / 2);                          FLUA := 0.026;                          FLUB := 1.1409 + 0.2012 * N2;                          FLUC := -0.2471 - 0.2741 * N2 + 0.01315 * N2 * N2;                          FLU := FLUA + FLUB * FLUX + FLUC * FLUX * FLUX;                          IF (FLU >= 0) AND (FLU <= 1) THEN N5 := FLU * N5;                        END;  { Particle flucor }					  					                        G^^.Fluor[i] := G^^.Fluor[i] + N5;                    END; {IF G2^^.IQ[I, I1] > 0}                END; { FOR I1 := 1 TO I_N }            END; { IF (G4^^.IL[I] <= 3) And (G^^.C[I] > 0) }        END; { FOR I := 1 TO IN1 }    END; { PROCEDURE SMP_ZAF; }  {$S CITZAFCode77}  PROCEDURE Which_Elements_Done; { PRINTOUT OF ANALYZED ELEMENTS, VALENCES & LINES }        VAR      i                             : Integer;    BEGIN      IF IFirstRun = 1 THEN        BEGIN          writeln(Out_TxtFile);          writeln(Out_TxtFile, 'Elem.  Valence   How concentration determined:');          writeln(Out_TxtFile);        END; { IF IFirstRun = 1 }      FOR i := 1 TO I_N DO        BEGIN          IF (G^^.IT[i] <> 1) AND (IFirstRun <> 0) THEN            BEGIN              Write(Out_TxtFile, A^.IZ[i]: 4, G^^.IVL[i]: 8, '    ');              CASE G4^^.IL[i] OF                0:                  writeln(Out_TxtFile, ' Calculated by stoichiometry.');                1:                  writeln(Out_TxtFile, ' Measured K-alpha line.');                2:                  writeln(Out_TxtFile, ' Measured L-alpha line.');                3:                  writeln(Out_TxtFile, ' Measured M-alpha line.');                4:                  writeln(Out_TxtFile, ' Calculated by difference from 100%.');                5:                  writeln(Out_TxtFile, ' Has fixed concentration.');                6:                  writeln(Out_TxtFile, ' Calc`d by stoichiometry rel. to element ', A^.IZ[I_N], '.');                END; { CASE }            END; { IF (G^^.IT[I] <> 1) and (IFirstRun <> 0) }        END; { FOR I := 1 TO I_N }      IF IFirstRun = 1 THEN        BEGIN          writeln(Out_TxtFile);          writeln(Out_TxtFile, 'Intensities measured relative to pure elements unless otherwise stated.');          writeln(Out_TxtFile);        END; { IF IFirstRun = 1 }    END; { PROCEDURE Which_Elements_Done }  PROCEDURE List_Element_Corrections; { PRINTOUT OF MAC's & ELEMENT CORRECTION FACTORS }        VAR      i, i1                         : Integer;    BEGIN      IF (IA > 0) AND (IFirstRun > 0) THEN        BEGIN          writeln(Out_TxtFile, 'Z-LINE    Z-ABSORBER     MASS ABS. COEFF.');          writeln(Out_TxtFile);          FOR i := 1 TO IN1 DO            BEGIN              IF G4^^.IL[i] <= 3 THEN                BEGIN                  FOR i1 := 1 TO I_N DO                    BEGIN                      Write(Out_TxtFile, A^.IZ[i]: 4, A^.IZ[i1]: 12);                      writeln(Out_TxtFile, G2^^.P[i1, i]: 21: 1);                    END; { FOR I1 := 1 TO I_N }                END; { IF G4^^.IL[I] <= 3 }            END; { FOR I := 1 TO IN1 }        END; { IF (IA > 0) and (IFirstRun > 0) }      IF (IB > 0) AND (IFirstRun > 0) THEN        BEGIN          writeln(Out_TxtFile);          writeln(Out_TxtFile, 'ELEMENT    ABSFAC      ZEDFAC      FINFAC     STP-POW     BKS-COR');          writeln(Out_TxtFile);          FOR i := 1 TO IN1 DO            BEGIN              IF G4^^.IL[i] <= 3 THEN                BEGIN                  Write(Out_TxtFile, A^.IZ[i]: 5);                  Write(Out_TxtFile, G^^.W[i]: 12: 4, G2^^.R[i, i] / G2^^.S[i, i]: 12: 4, G^^.W[i] * G2^^.R[i, i] / 				  G2^^.S[i, i]: 12: 4);                  writeln(Out_TxtFile, G2^^.S[i, i]: 12: 4, G2^^.R[i, i]: 12: 4);                END; { IF G4^^.IL[I] <= 3 }            END; {FOR I := 1 TO IN1 Do }          writeln(Out_TxtFile);        END; { IF (IB > 0) and (IFirstRun > 0) }      IF IFirstRun = 1 THEN        BEGIN          writeln(Out_TxtFile, ' ------------------------------------------------------------------------');          writeln(Out_TxtFile);        END;    END; { PROCEDURE List_Element_Corrections }   PROCEDURE Show_Std_Result;   {----------------------------------------------------------------------}   {-----                     PRINTOUT OF STD k-EL                   -----}   {----------------------------------------------------------------------}        VAR      i, kk                       : Integer;    BEGIN      IF IFirstRun = 0 THEN        BEGIN          ICPH2 := 0;          exit(Show_Std_Result);        END;      {----- Printout standard k-el subroutine -----}      IF (IPRN > 0) AND (ICPH2 = 1) THEN        BEGIN          writeln(Out_TxtFile);        END;	  kk := A^.IZ[IN8];      writeln(Out_TxtFile, st: 15, A^.Sym[kk], '  ---  Standard: ', ELEMSTD);	  	  if IPtc = 1 then 	  begin	    writeln(Out_TxtFile);	  	if IMD[IptcM] = 1 then		  begin		   Writeln(Out_TxtFile, 'Thin Film or Thick Polished Specimen  T= ',DIA[IptcD]*J9:10:2,' um');	       Writeln(Out_TxtFile, 'Density= ',PRho:6:2,' g/cc  Int. step Length= ',X1:10:5, ' g/cm^2'); 		  end		  else		  begin		   Writeln(Out_TxtFile, 'Particle Shape model= ',IMN:3,'  Diameter=',10000*DIA[IptcD]/PRho:10:2,' um');	       Writeln(Out_TxtFile, 'Density= ',PRho:6:2,' g/cc  Int. step Length= ',X1:10:5, ' g/cm^2'); 		  end;		   writeln(Out_TxtFile);	  end;	  	        IF IB = 1 THEN        BEGIN          writeln(Out_TxtFile);          writeln(Out_TxtFile, 'ELEMENT   K-VALUE   ELEM. WT %');          writeln(Out_TxtFile);          FOR i := 1 TO I_N DO            BEGIN              IF G^^.C[i] > 0 THEN                BEGIN                  kk := A^.IZ[i];                  Write(Out_TxtFile, A^.Sym[kk],'   ');                  IF i = IN8 THEN Write(Out_TxtFile, G4^^.K[i]: 12: 5)                  ELSE Write(Out_TxtFile, '            ');                  writeln(Out_TxtFile, 100 * G^^.C[i]: 11: 2);                END;            END; { i loop }          i := IN8;          writeln(Out_TxtFile);          Write(Out_TxtFile, ' TOTAL:               ');          writeln(Out_TxtFile, 100 * M4: 6: 2);          writeln(Out_TxtFile);          Write(Out_TxtFile, 'ELEMENT  ABSCOR    FLUCOR    ZEDCOR    ZAFCOR');          writeln(Out_TxtFile, '   STP-POW   BKS-COR');          writeln(Out_TxtFile);          kk := A^.IZ[i];          Write(Out_TxtFile, A^.Sym[kk],'   ');          Write(Out_TxtFile, G^^.E[i] / G^^.W[i]: 10: 4, 1 / (1 + G^^.Fluor[i]): 10: 4, G3^^.A[i]: 10: 4);          writeln(Out_TxtFile, G^^.E[i] / G^^.W[i] * G3^^.A[i] / (1 + G^^.Fluor[i]): 10: 4, G^^.STP[i]: 10: 4, G^^.BKS[                  i]: 10: 4);          writeln(Out_TxtFile);          writeln(Out_TxtFile, '-----------------------------------------------------------------');          writeln(Out_TxtFile);        END; { IF IB = 1 THEN }    END; { PROCEDURE Show_Std_Result }  PROCEDURE Show_Smp_Result;    VAR      SMPZAF                        : real {double_t};      i, kk                         : Integer;        LABEL      5000;    BEGIN	  if  Manual_Mode then      	writeln(Out_TxtFile, 'SAMPLE ', ID_Name, '   ***************   ', I5: 3, ' ITERATIONS.')      else      	writeln(Out_TxtFile, 'SAMPLE ', analysis_result^^.SpectrumStuff.Spectrum_Info.Spectrum_Number,'   ',      			 analysis_result^^.SpectrumStuff.Spectrum_Info.Spectrum_Comment_Field,'   ',      			 I5: 3, ' ITERATIONS.');      writeln(Out_TxtFile);	  if IPtc = 1 then 	  begin	  	if IMN = 1 then		  begin		   Writeln(Out_TxtFile, 'Thin Film or Thick Polished Specimen  T= ',DIA[IptcD]*J9:10:2,' um');	       Writeln(Out_TxtFile, 'Density= ',PRho:6:2,' g/cc  Int. step Length= ',X1:10:5, ' g/cm^2'); 		  end		  else		  begin		   Writeln(Out_TxtFile, 'Particle Shape model= ',IMN:3,'  Diameter=',10000*DIA[IptcD]/PRho:10:2,' um');	       Writeln(Out_TxtFile, 'Density= ',PRho:6:2,' g/cc  Int. step Length= ',X1:10:5, ' g/cm^2'); 		  end;		   writeln(Out_TxtFile);	  end;	        IF ISTAGE = 1 THEN        BEGIN          writeln(Out_TxtFile, '               X := ', XCoord: 8: 3, ' mm  ---  Y := ', YCoord: 8: 3, ' mm');          writeln(Out_TxtFile);        END;      writeln(Out_TxtFile, 'ELEMENT   K-VALUE   K-(STD)    EL. WT %  OX WT %  NORM EL %   NORM OX %  AT PROP');      writeln(Out_TxtFile);      SUMOX1 := 0;      FOR i := 1 TO IN1 DO        SUMOX1 := SUMOX1 + G^^.C[i] * G4^^.GR1[i];      IF Num_Oxs > 0 THEN SCAT := 0;      IF Num_Oxs = 0 THEN        BEGIN          FOR i := 1 TO IN1 DO            IF (ICCAT = 0) OR ((G4^^.IL[i] <> 6) AND (G4^^.GR1[i] > 0)) THEN SCAT := SCAT + G^^.C[i] / G4^^.B[i];        END; { IF Num_Oxs = 0 }      FOR i := 1 TO I_N DO        BEGIN          IF G^^.C[i] > 0 THEN            BEGIN              IF (Num_Oxs = 0) THEN CAT := (G^^.C[i] / G4^^.B[i]) * (NCAT / SCAT)              ELSE CAT := G^^.C[i] / G4^^.B[i] / (G^^.C[I_N] / G4^^.B[I_N]) * Num_Oxs;			  kk := A^.IZ[i];              Write(Out_TxtFile, A^.Sym[kk],'  ');              IF (G4^^.IL[I_N] = 0) AND (i = I_N) THEN ICHOICE := 2;              IF (G4^^.IL[I_N] = 0) AND (i = I_N) THEN GOTO 5000;              IF i = I_N THEN SUMOX2 := 100 * (G^^.C[i] - SUMOX1)              ELSE SUMOX2 := 100 * (G^^.C[i] * (1 + G4^^.GR1[i]));              IF (IM2 > 0) AND (G^^.C[i] < 0.01) THEN ICHOICE := 1              ELSE ICHOICE := 0;            5000:              CASE ICHOICE OF                0:                  BEGIN { regular analysis format }                    Write(Out_TxtFile, G4^^.K[i]: 13: 5, G4^^.KSMP[i]: 10: 5, 100 * G^^.C[i]: 10: 2, SUMOX2: 9: 2, 100 *                          G^^.C[i] / M4: 11: 2);                    writeln(Out_TxtFile, SUMOX2 / M4: 12: 2, CAT: 11: 3);                  END;                1:                  BEGIN { trace analysis format }                    Write(Out_TxtFile, G4^^.K[i]: 13: 6, G4^^.KSMP[i]: 10: 6, 100 * G^^.C[i]: 10: 4, SUMOX2: 9: 4, 100 *                          G^^.C[i] / M4: 11: 4);                    writeln(Out_TxtFile, SUMOX2 / M4: 12: 4, CAT: 11: 4);                  END;                2:                  BEGIN { oxygen analysis format }                    Write(Out_TxtFile, '       -----     -----    ');                    writeln(Out_TxtFile, 100 * G^^.C[i]: 7: 2, 100 * G^^.C[i] / M4: 20: 2, CAT: 23: 3);                  END; { case 2 }                END; { CASE }            END; { IF G^^.C[I] > 0 }        END; { i loop }      writeln(Out_TxtFile);      writeln(Out_TxtFile, ' TOTAL:                        ', 100 * M4: 6: 2);      writeln(Out_TxtFile);      writeln(Out_TxtFile);      IF IB > 0 THEN        BEGIN          Write(Out_TxtFile, 'ELEMENT  ABSCOR    FLUCOR    ZEDCOR    ZAFCOR');          writeln(Out_TxtFile, '    ZAF-STD    STP-POW    BKS-COR');          writeln(Out_TxtFile);          FOR i := 1 TO IN1 DO            BEGIN              IF (G^^.C[i] > 0) AND (G4^^.IL[i] <= 3) THEN                BEGIN                  SMPZAF := G^^.E[i] / G^^.W[i] * G3^^.A[i] / (1 + G^^.Fluor[i]);                  kk := A^.IZ[i];                  Write(Out_TxtFile, A^.Sym[kk],'  ', G^^.E[i] / G^^.W[i]: 11: 4, 1 / (1 + G^^.Fluor[i]): 10: 4, G3^^.A[i]: 10:                        4, SMPZAF: 10: 4);                  writeln(Out_TxtFile, SMPZAF / G4^^.STDZAF[i]: 11: 4, G^^.STP[i]: 11: 4, G^^.BKS[i]: 11: 4);                END; { IF (G^^.C[I] > 0) and (G4^^.IL[I] <= 3) }            END; { i loop }          writeln(Out_TxtFile);        END; { IF IB > 0 }      writeln(Out_TxtFile, '------------------------------------------------------------------------------');      writeln(Out_TxtFile);    END; { PROCEDURE Show_Smp_Result }END. (* stuff DECLARE SUB PrnHeading (IFirstRun%);DECLARE SUB PrnLines (IFirstRun%, IN%, IZ%(), IT%(), IVL%(), IL%(), Z$(), OX$(), AccP!, TOA!, E0!(), T0!());DECLARE SUB CompPrn (IFirstRun%, IZ%, IL%, AtW!, Conc!, EC!, IEC%, Q!(), S!());     REM ----------------------------------------------------------------------;     REM -----              CITZAF3 VERS. 3.04 -- 11 MAY 90               -----;     REM -----    Copyright, John T. Armstrong, Caltech Geology, 1990     -----;     REM ----------------------------------------------------------------------;     REM             Written by J. Armstrong, Caltech, Geology Dept.;     REM ----------------------------------------------------------------------;; ;     REM ----------------------------------------------------------------------;     REM -----                 INITIALIZATION OF CONSTANTS                -----;     REM ----------------------------------------------------------------------;;     QK := 6.51E-20;     CK := 5.18E-21;     BS3 := .61;;     I := 1: REM CALCULATIONS MADE FOR 1ST ELEMENT ONLY;;     SELECT CASE IL[I];       CASE 1;         NS := 2;         BS1 := .9                           ' Powell;         BS2 := .52 + .0029 * Z[I]           ' Brown;         BS4 := .4158 + .186 * LN(Z[I])     ' Rez;         BS5 := .35                          ' Mott & Massey;         CS1 := .65                          ' Powell;         CS4 := 1.3029 - .13845 * LN(Z[I])  ' Rez;         CS5 := 2.42                         ' Mott & Massey;       CASE 2;         NS := 4;         BS1 := .7                           ' Powell;         BS2 := .44 + .002 * Z[I]            ' Brown;         BS4 := .7749 + .0042 * Z[I]         ' Rez;         BS5 := .25                          ' Mott & Massey;         CS1 := .6                           ' Powell;         CS4 := 1.014 - .00052 * Z[I]        ' Rez;         CS5 := 2.42                         ' Mott & Massey;       CASE 3;         NS := 6;         BS1 := .7;         BS2 := .44 + .002 * Z[I];         BS4 := 1.224                        ' Rez;         BS5 := .25;         CS1 := .6;         CS4 := .702                         ' Rez;         CS5 := 2.42;       CASE ELSE;     END SELECT;;     RI := EC[I] / 511;     RI1 := 1 + RI;     RI2 := 2 + RI;     RB0 := 1 - (1 + RI] ^ -2;     EC2 := EC[I] * EC[I];     IEC := INT(10 * EC[I]);     CP := EC[I] / .013606;     F1C := 2.549E-22 / EC[I];     F4 := LN(1 / RB0);     FA := 5.14 * Z[I] ^ -.48;     FB := 5.76 - .04 * Z[I];     FC := .72 + .039 * Z[I] - .0006 * Z[I] ^ 2;;     REM ----------------------------------------------------------------------;     REM -----          CALCULATION OF MEAN IONIZATION POTENTIALS         -----;     REM ----------------------------------------------------------------------;     REM ----------------------------------------------------------------------;     REM -----        CALC'N OF PURE ELEMENT MEAN IONIZ. POTENTIALS       -----;     REM ----------------------------------------------------------------------;     FOR I := 1 TO IN;         REM CASE 1       BERGER & SELTZER;           J[1, I] := (9.76 * Z[I] + 58.5 * Z[I] ^ (-.19)) / 1000;         REM CASE 2       RUSTE & ZELLER;           J[2, I] := 10.04 + 8.25 * EXP(-Z[I] / 11.22);           J[2, I] := Z[I] * J[2, I] / 1000;         REM CASE 3       WILSON;           J[3, I] := Z[I] * 11.5 / 1000;         REM CASE 4       BLOCH (LOVE/SCOTT);           J[4, I] := Z[I] * 13.5 / 1000;         REM CASE 5       HEINRICH;           J[5, I] := 9.94 + 19.52 / Z[I];           J[5, I] := Z[I] * J[5, I] / 1000;         REM CASE 6       JOY (WILSON/BERGER);           JK[I] := .855 - .5124 / Z[I];           IF Z[I] < 13 THEN J[6, I] := J[3, I] ELSE J[6, I] := J[1, I];     NEXT I;     REM ----------------------------------------------------------------------;     REM -----         CALCULATION OF MEAN IONIZ. POTEN. FOR SAMPLE       -----;     REM ----------------------------------------------------------------------;     M5 := 0;     FOR I1 := 1 TO IN;       M5 := M5 + C[I1] * Z[I1] / B[I1];     NEXT I1;     ZA := M5;     FOR I := 1 TO 5;       M6 := 0;       FOR I1 := 1 TO IN;         M6 := M6 + C[I1] * Z[I1] * LN(J[I, I1]) / B[I1];       NEXT I1;       JM[I] := EXP(M6 / M5);     NEXT I;     REM ----------------------------------------------------------------------;     REM -----   CALCULATION OF IONIZ. CROSS SECTIONS & STOPPING POWERS   -----;     REM ----------------------------------------------------------------------;     FOR IE := 1 TO 300;         FOR I := 1 TO 10;             Q[I, IE] := 0;         NEXT I;         FOR I := 1 TO 12;             S[I, IE] := 0;         NEXT I;     NEXT IE;;     I := 1;     FOR IE := IEC TO 300;       E := IE / 10;       U := E / EC[I];       IF U <:= 1 THEN GOTO 1000;       U2 := U * EC2;       RT := E / 511;       RT1 := 1 + RT;       RT2 := 2 + RT;       RB := 1 - (1 + RT) ^ -2;;       REM CALCULATION OF IONIZATION CROSS SECTIONS;;       REM CASE 1     POWELL;       Q[1, IE] := QK * NS * BS1 * LN(CS1 * U) / U2;;       REM CASE 2     BROWN;       Q[2, IE] := QK * NS * BS2 * LN(U) / U2;;       REM CASE 3     GREEN & COSSLETT;       Q[3, IE] := QK * NS * BS3 * LN(U) / U2;;       REM CASE 4     HUTCHINS;       Q[4, IE] := QK * NS * BS3 * .667 * LN(U) / (U ^ .7 * EC2);;       REM CASE 5     FABRE;       Q[5, IE] := QK * NS * LN(U) / (1.18 * (U + 1.32) * EC2);;       REM CASE 6     WORTHINGTON & TOMLIN;       Q[6, IE] := QK * NS * BS5 * LN(4 * U / (1.65 + 2.35 * EXP(1 - U))) / U2;;       REM CASE 7     GRYZINSKI;       GU := (1 / U) * ((U - 1) / (U + 1)) ^ 1.5 * (1 + (2 / 3) * (1 - 1 / (2 * U)) * LN(2.7 + (U - 1) ^ .5));       Q[7, IE] := QK * NS * GU / EC2;;       REM CASE 8     CASNATI;       CF := 10.57 * EXP(-1.736 / U + .317 / U ^ 2);       CD := -.0318 + .316 / U - .1135 / U ^ 2;       RF := (RI2 / RT2) * (RT1 / RI1) ^ 2 * (((RT + RI) * RT2 * RI1 * RI1) / (RT * RT2 * RI1 * RI1 + RI * RI2))^ 1.5;       Q[8, IE] := CK * NS * RF * CP ^ CD * CF * LN(U) / U2;        REM CASE 9     JAKOBY;       F2 := LN(RB / (1 - RB)) - RB;       F5 := RB0 / RB;       F3 := 1 - F5;       Q(9, IE] := FA * (F1C / RB) * (F2 + FB * F3 + F4 * F5 ^ FC);        REM CASE 10    REZ;       Q[10, IE] := QK * NS * BS4 * LN(CS4 * U) / U2;       { CALCULATION OF ELECTRON RETARDATION }        FOR IJ := 1 TO 5;         REM CASE 1     BETHE (RAO-SAHIB AND WITTRY);         IF E >:= 6.34 * JM[IJ) THEN;            S[IJ, IE] := 78500 * ZA * LN(1.166 * E / JM[IJ)) / E;         ELSE;            S[IJ, IE] := 62400 * ZA / (E * JM[IJ)) ^ .5;         END IF;  ;         REM CASE 2     LOVE & SCOTT;         S[IJ + 5, IE] := ZA / (JM[IJ) * (.0000118 * (E / JM[IJ)) ^ .5 + 1.47E-06 * (E / JM[IJ))));       NEXT IJ;;       REM   CASE 3 & 4   JOY (WILSON/BERGER & HEINRICH);       JM[6] := 0: JM[7] := 0;       FOR I1 := 1 TO IN;         JJ1 := J[6, I1] / (1 + JK[I1] * J[6, I1] / E);         JJ2 := J[6, I1] / (1 + JK[I1] * J[5, I1] / E);         JM[6] := JM[6] + C[I1] * Z[I1] * LN(JJ1) / B[I1];         JM[7] := JM[7] + C[I1] * Z[I1] * LN(JJ2) / B[I1];       NEXT I1;       JM[6] := EXP(JM[6] / ZA);       JM[7] := EXP(JM[7] / ZA);       S[11, IE] := 78500 * ZA * LN(1.166 * E / JM[6]) / E;       S[12, IE] := 78500 * ZA * LN(1.166 * E / JM[7]) / E;;1000 NEXT IE;     CALL CompPrn(IFirstRun, IZ(1), IL(1), B(1), C(1), EC(1), IEC, Q(), S());     GOTO 11500;;     REM ----------------------------------------------------------------------;     REM -----      END OF MAIN PROGRAM --- BEGINNING OF SUBROUTINES      -----;     REM ----------------------------------------------------------------------;;     SUB CompPrn (IFirstRun, IZ, IL, AtW, Conc, EC, IEC, Q(), S());     DIM QS(10, 12);     REM ----------------------------------------------------------------------;     REM -----           SUBROUTINE: COMPRESSED PRINTOUT MODE             -----;     REM ----------------------------------------------------------------------;;     CLOSE #1;     IF IFirstRun := 1 THEN;        OPEN "QSCALC.PRN" FOR OUTPUT AS #1;     ELSE;        OPEN "QSCALC.PRN" FOR APPEND AS #1;     END IF;     PRINT #1, USING " ##  ##  ###.####"; IZ; IL; Conc;     FOR IE := 300 TO IEC STEP -1;       U := (IE / 10) / EC;       IF U > 1 THEN;          PRINT #1, USING " ###.####"; U;;          FOR I := 1 TO 10;              PRINT #1, USING "  ##.####^^^^"; Q(I, IE] * EC * EC;;          NEXT I;          PRINT #1,;       END IF;     NEXT IE;     PRINT #1,;     FOR IE := 300 TO IEC STEP -1;       U := (IE / 10) / EC;       IF U > 1 THEN;          PRINT #1, USING " ###.####"; U;;          FOR I := 1 TO 12;              PRINT #1, USING "  ##.####^^^^"; S(I, IE];;          NEXT I;          PRINT #1,;       END IF;     NEXT IE;     PRINT #1,;;     FOR IQ := 1 TO 10;         FOR IST := 1 TO 12;             QS(IQ, IST) := 0;         NEXT IST;     NEXT IQ;     Nav := 6.023E+23;     CLOSE #1;     IF IFirstRun := 1 THEN;        OPEN "QSRSLT.PRN" FOR OUTPUT AS #1;     ELSE;        OPEN "QSRSLT.PRN" FOR APPEND AS #1;     END IF;     PRINT #1, USING " ##  ##  ###.####"; IZ; IL; Conc;     FOR IE := IEC TO 300;       U := (IE / 10) / EC;       IF U > 1 THEN;          FOR I1 := 1 TO 10;            FOR I2 := 1 TO 12;              IF Q(I1, IE] > 0 THEN QS(I1, I2) := QS(I1, I2) + .1 * Q(I1, IE] / S(I2, IE];            NEXT I2;          NEXT I1;          SELECT CASE IE;            CASE 100, 150, 200, 250, 300;              PRINT #1, USING "  ###.#"; IE / 10;              FOR I2 := 1 TO 12;                  FOR I1 := 1 TO 10;                      PRINT #1, USING "  ##.####^^^^"; Conc * Nav * QS(I1, I2) / AtW;;                  NEXT I1;                  PRINT #1,;              NEXT I2;            CASE ELSE;              dummy := 0;          END SELECT;       END IF;     NEXT IE;     PRINT #1,;     CLOSE #1;;     END SUB;;*)