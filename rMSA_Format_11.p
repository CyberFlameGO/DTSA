UNIT MSA_Format_R_Plug;INTERFACEUSES	Types, QuickDraw, Memory, fp, StandardFile, GestaltEqu, Errors, Files,	TextUtils, {PascalA4,} FilePlugIns;const		__procinfo : longint = $3F80;{$Main}PROCEDURE	ENTRYPOINT(message:Integer; VAR InPtr:IOPlugPtr; VAR theResult:OSerr);IMPLEMENTATION{$IFC NOT POWERPC}uses PascalA4;{$ENDC}PROCEDURE MSA_Format_R(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);FORWARD;PROCEDURE DoAbout(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);FORWARD;PROCEDURE DoOpen(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);FORWARD;PROCEDURE DoWrite(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);FORWARD;FUNCTION	Str2Num(s: Str255): Real;FORWARD;PROCEDURE 	ENTRYPOINT{(message:Integer; VAR InPtr:IOPlugPtr; VAR theResult:OSErr)};		{ Main dispatching routine.  Initializes and sets up the global variables,	}		{		and performs the operation specified by the message. 				}VAR	firstTime	: BOOLEAN;	OldA4		: Longint;BEGIN{$IFC NOT POWERPC}	oldA4 := SetCurrentA4();	RememberA4();{$ENDC}	theResult:=noErr;	firstTime:=(InPtr=NIL);					{ See if this is the first time called }	IF firstTime THEN BEGIN						{ If so, allocate and initialize a data area }		InPtr:= IOPlugPtr(NewPtrClear(sizeof(IOPlug)));		IF (InPtr=NIL) THEN BEGIN			debugstr('memFullErr');			theResult:=memFullErr;{$IFC NOT POWERPC}	oldA4 := SetA4(oldA4);{$ENDC}			EXIT(ENTRYPOINT);		END;				END;		CASE message OF					{ Perform the requested operation }		fileAbout		:DoAbout(InPtr, theResult);		ImpFile			:MSA_Format_R(InPtr, theResult);		ExpFile			:DoWrite(InPtr, theResult);		OpenInPlug		:DoOpen(InPtr, theResult);		OpenExPlug		:DoOpen(InPtr, theResult);		END; {CASE message}		{$IFC NOT POWERPC}	oldA4 := SetA4(oldA4);{$ENDC}END;PROCEDURE DoAbout(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);	Begin	End;	PROCEDURE DoOpen(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);	Begin		InPtr^.PlugInName:='Read MSA 1.1';		{Debugstr('Inside of MSA_Format_R - Do Open');}		theResult := noErr;	End;	PROCEDURE DoWrite(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);	Begin	End;PROCEDURE MSA_Format_R(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);          CONST      tBufferSize            = 50000; {Never more than a single spectrum, 8192 chans ┼ 80K}										{Maximum size for this type is 4096 chans}    TYPE      tBuffer                 = PACKED ARRAY [1..tBufferSize] OF signedbyte;      tBufPtr                 = ^tBuffer;	  TByte                   = PACKED ARRAY [1..1] OF byte;    VAR      index, nn, jj, kk             : integer;      FileSize                      : longint;      Refnum                     	: integer;      tipBufPtr                     : tBufPtr;      indexL, posit                 : longint;      strLength, lenth              : TByte;      bytecount                     : longint;      str, str1, str2               : str255;	  num_channels					: real;	  err	                        : OSErr;	  IValue						: longint;	  Version, Rvalue, columns      : real;Function search_str(len : TByte; VAR strx : str255):longint;	VAR		strr	: str255;	BEGIN        strLength[1] := len[1];        BlockMove(@strLength, @strr[0], 1);        REPEAT          BlockMove(@tipBufPtr^[indexL], @strr[1], strLength[1]);          indexL := indexL + 1;        UNTIL ((strr = strx) OR (indexL >= FileSize));		if (indexL >= FileSize) then begin			search_str := indexL;			exit(search_str);		end;        indexL := indexL + strLength[1] -1;		search_str := indexL;        WHILE ((tipBufPtr^[indexL] = $20) OR (tipBufPtr^[indexL] = $09)) DO          indexL := indexL + 1; { jump over a run of spaces }        strr := '';        WHILE NOT (tipBufPtr^[indexL] = $0D) DO          BEGIN            {IF (tipBufPtr^[indexL] <> $20) then}            strr := CONCAT(strr, chr(tipBufPtr^[indexL]));            indexL := indexL + 1;          END; { While }		  strx := strr;		  search_str := indexL;	END;    	BEGIN		refnum := InPtr^.Rd_Refnum;		{Debugstr('Inside of MSA_Format');}		InPtr^.Specimen_Comment_Field := '';			nn := 0;		err := GetEOF(refnum, FileSize);		tipBufPtr := tBufPtr(NewPtr(sizeof(tBuffer)));		err := FSRead(refnum, FileSize, Pointer(tipBufPtr));		theResult := err;        indexL := 0; { indexL will be the "file" pointer }		lenth[1] := 10;		str := '#Title   :';		posit := search_str(lenth, str);		if (indexL >= FileSize) then begin			theResult := badFileFormat;			exit(MSA_Format_R);		end;		IF (LENGTH(str) > 0) THEN InPtr^.Specimen_Comment_Field := 					CONCAT(InPtr^.Specimen_Comment_Field, str);							str := '#Version :';		posit := search_str(lenth, str);		if (indexL >= FileSize) then begin			theResult := badFileFormat;			exit(MSA_Format_R);		end;		{IF (LENGTH(str) > 0) THEN Version := str2num(str);}		IF str <> '1.1' THEN begin			theResult := badFileFormat;			exit(MSA_Format_R);				end;				str := '#NPTS-   :';		posit := search_str(lenth, str);		if (indexL >= FileSize) then begin			theResult := badFileFormat;			exit(MSA_Format_R);		end;		IF (LENGTH(str) > 0) THEN num_channels := str2num(str);		str := '#NCOL-   :';		posit := search_str(lenth, str);		if (indexL >= FileSize) then begin			theResult := badFileFormat;			exit(MSA_Format_R);		end;		IF (LENGTH(str) > 0) THEN columns := str2num(str);		str := '#OFFS-EV :';		posit := search_str(lenth, str);		if (indexL >= FileSize) then begin			theResult := badFileFormat;			exit(MSA_Format_R);		end;		IF (LENGTH(str) > 0) THEN InPtr^.NDoffset := rinttol(str2num(str));		str := '#EVCH-   :';		posit := search_str(lenth, str);		if (indexL >= FileSize) then begin			theResult := badFileFormat;			exit(MSA_Format_R);		end;		IF (LENGTH(str) > 0) THEN InPtr^.dE := str2num(str);		str := '#VOLT-KV :';		posit := search_str(lenth, str);		if (indexL >= FileSize) then begin			theResult := badFileFormat;			exit(MSA_Format_R);		end;		IF (LENGTH(str) > 0) THEN InPtr^.kV := str2num(str);		str := '#ALPH-MR :';	{Incidence beam divergence - EELS}		posit := search_str(lenth, str);		if (indexL >= FileSize) then begin			theResult := badFileFormat;			exit(MSA_Format_R);		end;		IF (LENGTH(str) > 0) THEN Rvalue := str2num(str);		str := '#BETA-MR :';	{EELS}		posit := search_str(lenth, str);		if (indexL >= FileSize) then begin			theResult := badFileFormat;			exit(MSA_Format_R);		end;		IF (LENGTH(str) > 0) THEN Rvalue := str2num(str);		str := '#LTIM-MS :';		posit := search_str(lenth, str);		if (indexL >= FileSize) then begin			theResult := badFileFormat;			exit(MSA_Format_R);		end;		IF (LENGTH(str) > 0) THEN InPtr^.Live_Time := str2num(str)/1000.0;		str := '#DTIM-MS :';	{dead-time}		posit := search_str(lenth, str);		if (indexL >= FileSize) then begin			theResult := badFileFormat;			exit(MSA_Format_R);		end;		IF (LENGTH(str) > 0) THEN Rvalue := str2num(str);		str := '#BCUR-NA :';	{dead-time}		posit := search_str(lenth, str);		if (indexL >= FileSize) then begin			theResult := badFileFormat;			exit(MSA_Format_R);		end;		IF (LENGTH(str) > 0) THEN InPtr^.Begin_Faraday := str2num(str);			InPtr^.End_Faraday := InPtr^.Begin_Faraday;		str := '#BDIA-NM :';	{dead-time}		posit := search_str(lenth, str);		if (indexL >= FileSize) then begin			theResult := badFileFormat;			exit(MSA_Format_R);		end;		IF (LENGTH(str) > 0) THEN Rvalue := str2num(str);		str := '#THCK-NM :';	{Specimen thickness}		posit := search_str(lenth, str);		if (indexL >= FileSize) then begin			theResult := badFileFormat;			exit(MSA_Format_R);		end;		IF (LENGTH(str) > 0) THEN InPtr^.S_Thickness := str2num(str)/1.0E7;		str := '#SPECTRUM:';		posit := search_str(lenth, str);		if (indexL >= FileSize) then begin			theResult := badFileFormat;			exit(MSA_Format_R);		end;		IF (LENGTH(str) > 0) THEN str2 := str; {some text}		InPtr^.Specimen_Comment_Field := 					CONCAT(InPtr^.Specimen_Comment_Field, str2);{ееееееееееееееее}          jj := 0; { jj will be the channel number }                    InPtr^.Number_of_Channels := rinttol(num_channels);          InPtr^.LastChannel := InPtr^.Number_of_Channels;            indexL := indexL + 1;          REPEAT {еееее This part reads in the spectrum еееее}            WHILE ((tipBufPtr^[indexL] = $20) OR             		(tipBufPtr^[indexL] = $09) OR             		(tipBufPtr^[indexL] = $0D) OR            		(tipBufPtr^[indexL] = $0A)) DO              indexL := indexL + 1; { jump over a run of spaces, etc. }            str := '';            REPEAT	            WHILE NOT ((tipBufPtr^[indexL] = $20) OR	            			(tipBufPtr^[indexL] = $09) OR	            			(tipBufPtr^[indexL] = $2C)) DO	              BEGIN	                str := CONCAT(str, chr(tipBufPtr^[indexL]));	                indexL := indexL + 1;	              END; { While }	            IF (LENGTH(str) > 0) {AND ((ClassExtended(str2num(str)) = NormalNum) OR (ClassExtended(str2num(str)) = ZeroNum))}	               THEN	              BEGIN	                jj := jj + 1;	                InPtr^.Spec_cts[jj] := str2num(str);	              END;	        UNTIL  (tipBufPtr^[indexL] = $2C); {, or CR}            indexL := indexL + 1;          UNTIL ((jj >= InPtr^.Number_of_Channels) OR (tipBufPtr^[indexL] = $23)); {еееее This part read in the spectrum еееее}        DisposePtr(Ptr(tipBufPtr));      END; { MSA Format }{*****************************************************************************}FUNCTION Str2Num(s: Str255): Real;   { Pascal implementation of Str2Num (fp.p: Str2Dec, Dec2Str) }VAR	aDecimal		: Decimal;	aCStr			: ConstCStringPtr;	anIndex			: Integer;	aValidPrefix	: Integer; { ignore }BEGIN	aCStr := P2CStr(@s);	anIndex := 0;	str2dec( aCStr, anIndex, aDecimal, aValidPrefix );	Str2Num := dec2num( aDecimal );END;END.