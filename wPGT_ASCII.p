UNIT wPGT_ASCII_Plug;INTERFACEUSES	Types, QuickDraw, Memory, fp, StandardFile, GestaltEqu, Errors, Files,	TextUtils, {PascalA4,} FilePlugIns;const		__procinfo : longint = $3F80;{$Main}PROCEDURE	ENTRYPOINT(message:Integer; VAR InPtr:IOPlugPtr; VAR theResult:OSerr);IMPLEMENTATION{$IFC NOT POWERPC}uses PascalA4;{$ENDC}PROCEDURE wPGT_ASCII(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);FORWARD;PROCEDURE DoAbout(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);FORWARD;PROCEDURE DoOpen(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);FORWARD;PROCEDURE DoRead(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);FORWARD;{FUNCTION	Str2Num(s: Str255): Real;FORWARD;}PROCEDURE 	ENTRYPOINT{(message:Integer; VAR InPtr:IOPlugPtr; VAR theResult:OSErr)};		{ Main dispatching routine.  Initializes and sets up the global variables,	}		{		and performs the operation specified by the message. 				}VAR	firstTime	: BOOLEAN;	OldA4		: Longint;BEGIN{$IFC NOT POWERPC}	oldA4 := SetCurrentA4();	RememberA4();{$ENDC}	theResult:=noErr;	firstTime:=(InPtr=NIL);					{ See if this is the first time called }	IF firstTime THEN BEGIN						{ If so, allocate and initialize a data area }		InPtr:= IOPlugPtr(NewPtrClear(sizeof(IOPlug)));		IF (InPtr=NIL) THEN BEGIN			debugstr('memFullErr');			theResult:=memFullErr;{$IFC NOT POWERPC}	oldA4 := SetA4(oldA4);{$ENDC}			EXIT(ENTRYPOINT);		END;				END;		CASE message OF					{ Perform the requested operation }		fileAbout		:DoAbout(InPtr, theResult);		ImpFile			:DoRead(InPtr, theResult);		ExpFile			:wPGT_ASCII(InPtr, theResult);		OpenInPlug		:DoOpen(InPtr, theResult);		OpenExPlug		:DoOpen(InPtr, theResult);		END; {CASE message}		{$IFC NOT POWERPC}	oldA4 := SetA4(oldA4);{$ENDC}END;PROCEDURE DoAbout(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);	Begin	End;	PROCEDURE DoOpen(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);	Begin		InPtr^.PlugInName:='Write PGT ASCII';		{Debugstr('Inside of wMSA_Format_R - Do Open');}		theResult := noErr;	End;	PROCEDURE DoRead(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);	Begin	End;PROCEDURE wPGT_ASCII(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);          VAR      index, nn, jj, kk             : integer;      FileSize                      : longint;      Refnum                     	: integer;      indexL, posit                 : longint;      bytecount                     : longint;      str, str1, str2               : str255;	  num_channels					: real;	  err	                        : OSErr;	  IValue						: longint;	  Version, Rvalue, columns      : real;  	BEGIN		Refnum := InPtr^.rd_refNum;		{Debugstr('Inside of MSA_Format');}		str := 'nchans: ';		str := StringOf(str, InPtr^.Number_of_Channels);		IValue := length(str);		err := FSWrite(Refnum,IValue,@str[1]);							str := ' evperchan:     ';		str := StringOf(str, InPtr^.dE);		IValue := length(str);		err := FSWrite(Refnum,IValue,@str[1]);				str := ' startev:      0.000';		IValue := length(str);		err := FSWrite(Refnum,IValue,@str[1]);				str := ' endev:  ';		str := StringOf(str,InPtr^.kV*1000:9:3,chr(13));		IValue := length(str);		err := FSWrite(Refnum,IValue,@str[1]);				str := 'label: ';		str := CONCAT(str,InPtr^.Specimen_Comment_Field,chr(13));		IValue := length(str);		err := FSWrite(Refnum,IValue,@str[1]);				str := 'counts:';		str := CONCAT(str,chr(13));		IValue := length(str);		err := FSWrite(Refnum,IValue,@str[1]);		{ееееееееееееееее}          jj := 1; { jj will be the channel number }          num_channels := InPtr^.Number_of_Channels;          REPEAT {еееее This part writes the spectrum еееее}            str := '';          	  str := StringOf(round(InPtr^.Spec_cts[jj]), chr(13));          	  jj := jj + 1;			IValue := length(str);			err := FSWrite(Refnum,IValue,@str[1]);          UNTIL (jj > num_channels); {еееее This part read in the spectrum еееее}      END; { PGT Format }END.