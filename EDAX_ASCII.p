UNIT EDAX_ASCII_Plug;INTERFACEUSES	Types, QuickDraw, Memory, fp, StandardFile, GestaltEqu, Errors, Files,	TextUtils, {PascalA4,} FilePlugIns;const		__procinfo : longint = $3F80;{$Main}PROCEDURE	ENTRYPOINT(message:Integer; VAR InPtr:IOPlugPtr; VAR theResult:OSerr);IMPLEMENTATION{$IFC NOT POWERPC}uses PascalA4;{$ENDC}PROCEDURE EDAX_ASCII(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);FORWARD;PROCEDURE DoAbout(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);FORWARD;PROCEDURE DoOpen(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);FORWARD;PROCEDURE DoWrite(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);FORWARD;FUNCTION	Str2Num(s: Str255): Real;FORWARD;PROCEDURE 	ENTRYPOINT{(message:Integer; VAR InPtr:IOPlugPtr; VAR theResult:OSErr)};		{ Main dispatching routine.  Initializes and sets up the global variables,	}		{		and performs the operation specified by the message. 				}VAR	firstTime	: BOOLEAN;	OldA4		: Longint;BEGIN{$IFC NOT POWERPC}	oldA4 := SetCurrentA4();	RememberA4();{$ENDC}	theResult:=noErr;	firstTime:=(InPtr=NIL);					{ See if this is the first time called }	IF firstTime THEN BEGIN						{ If so, allocate and initialize a data area }		InPtr:= IOPlugPtr(NewPtrClear(sizeof(IOPlug)));		IF (InPtr=NIL) THEN BEGIN			debugstr('memFullErr');			theResult:=memFullErr;{$IFC NOT POWERPC}	oldA4 := SetA4(oldA4);{$ENDC}			EXIT(ENTRYPOINT);		END;				END;		CASE message OF					{ Perform the requested operation }		fileAbout		:DoAbout(InPtr, theResult);		ImpFile			:EDAX_ASCII(InPtr, theResult);		ExpFile			:DoWrite(InPtr, theResult);		OpenInPlug		:DoOpen(InPtr, theResult);		OpenExPlug		:DoOpen(InPtr, theResult);		END; {CASE message}		{$IFC NOT POWERPC}	oldA4 := SetA4(oldA4);{$ENDC}END;PROCEDURE DoAbout(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);	Begin	End;	PROCEDURE DoOpen(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);	Begin		InPtr^.PlugInName:='EDAX ASCII';		{Debugstr('Inside of EDAX_ASCII - Do Open');}		theResult := noErr;	End;	PROCEDURE DoWrite(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);	Begin	End;PROCEDURE EDAX_ASCII(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);         TYPE	TByte                         = PACKED ARRAY [1..1] OF byte;    tBuffer                 = PACKED ARRAY [1..100000] OF signedbyte;    tBufPtr                 = ^tBuffer;    VAR      xx                            : real;      End_of_File, nn               : longint;      Current_File_Position         : longint;	  FileSize               		: longint;      bytecount                     : longint;	  indexL                        : longint;      n, kk, jj            			: integer;      err                           : integer;      refnum                        : integer;      Value                         : Extended;      theType                       : OSType;      str			                : str255;      errCode                       : OSErr;      reply                         : SFReply;      FStr	                    	: str255;	  strLength                     : TByte;	  tipBufPtr                     : tBufPtr;    BEGIN		refnum := InPtr^.Rd_Refnum;		{Debugstr('Inside of Column_Plug - EDAX_ASCII');}		nn := 0;		err := GetEOF(refnum, FileSize);		tipBufPtr := tBufPtr(NewPtr(sizeof(tBuffer)));		err := FSRead(refnum, FileSize, Pointer(tipBufPtr));		indexL := 0;		kk := 1;	  FStr := ''; {еееее This fragment reads a channel еееее}	  if (tipBufPtr^[indexL] = $0A {lf} ) then indexL := indexL + 1;	  				 WHILE (tipBufPtr^[indexL] <> $2D {-}) do indexL := indexL + 1;		 indexL := indexL + 1;		WHILE (tipBufPtr^[indexL] <> $4B {K}) do begin		 	FStr := CONCAT(FStr, chr(tipBufPtr^[indexL]));			indexL := indexL + 1;		END;	{WHILE}		InPtr^.kV := str2num(FStr);		indexL := indexL + 2;		FStr := '';		WHILE tipBufPtr^[indexL] = $20 DO              indexL := indexL + 1; { jump over a run of spaces }		WHILE (tipBufPtr^[indexL] <> $45 {E}) do begin		 	FStr := CONCAT(FStr, chr(tipBufPtr^[indexL]));			indexL := indexL + 1;		END;	{WHILE}		  InPtr^.dE := str2num(FStr);		  indexL := indexL + 4;		  FStr := '';		WHILE tipBufPtr^[indexL] = $20 DO              indexL := indexL + 1; { jump over a run of spaces }		WHILE (tipBufPtr^[indexL] <> $54 {T}) do begin		 	FStr := CONCAT(FStr, chr(tipBufPtr^[indexL]));			indexL := indexL + 1;		END;	{WHILE}		InPtr^.Live_Time := str2num(FStr) * 10;		FStr := '';		WHILE tipBufPtr^[indexL] <> $0D {CR} DO              indexL := indexL + 1; { jump to CR }		indexL := indexL + 1;				WHILE (tipBufPtr^[indexL] <> $0D {cr} ) DO		{Skip a line}			indexL := indexL + 1;		indexL := indexL + 1;		WHILE (tipBufPtr^[indexL] <> $0D {cr} ) DO		{Skip a line}			indexL := indexL + 1;		indexL := indexL + 1;          jj := 1; { jj will be the channel number }          REPEAT {еееее This part reads in the spectrum еееее}            str := '';            IF (tipBufPtr^[indexL] = $0D {CR} ) THEN indexL := indexL + 1;            WHILE tipBufPtr^[indexL] = $0A DO              indexL := indexL + 1; { jump over a run of LF's }            WHILE tipBufPtr^[indexL] = $20 DO              indexL := indexL + 1; { jump over a run of spaces }            WHILE tipBufPtr^[indexL] = $09 DO              indexL := indexL + 1; { jump over a run of tabs }            WHILE (tipBufPtr^[indexL] <> $20) AND (tipBufPtr^[indexL] <> $0D) AND (tipBufPtr^[indexL] <> $09 {tab}) DO              BEGIN                str := CONCAT(str, chr(tipBufPtr^[indexL]));                indexL := indexL + 1;              END; { While }            IF LENGTH(str) > 0 THEN              BEGIN                InPtr^.Spec_cts[jj] := str2num(str);                jj := jj + 1;              END;            indexL := indexL + 1;          UNTIL indexL >= FileSize; {еееее This part read in the spectrum еееее}		 InPtr^.Number_of_Channels := jj;		InPtr^.LastChannel := InPtr^.Number_of_Channels;		theResult := noErr;        DisposePtr(Ptr(tipBufPtr));      END; { IF Which_Format = 10 THEN...... EDAX ASCII }{*****************************************************************************}FUNCTION Str2Num(s: Str255): Real;   { Pascal implementation of Str2Num (fp.p: Str2Dec, Dec2Str) }VAR	aDecimal		: Decimal;	aCStr			: ConstCStringPtr;	anIndex			: Integer;	aValidPrefix	: Integer; { ignore }BEGIN	aCStr := P2CStr(@s);	anIndex := 0;	str2dec( aCStr, anIndex, aDecimal, aValidPrefix );	Str2Num := dec2num( aDecimal );END;END.