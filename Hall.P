{[j=30/55,:+,u+,r+,o=120,k+,n+,#+,v+,q+,b+]}{[f-]}{*********************************} UNIT Hall ;{*********************************}{**********************************} INTERFACE {**********************************} USES  QuickDraw, QuickdrawText, Types, OSUtils, ToolUtils, Timer, Errors, Menus, Files, Lists, Memory, TextUtils, Finder, Dialogs,  Packages, Printing, StandardFile, Spectrum_Structures, Retrace, SegLoad, fenv, fp {SANE, StrLib}, Controls, Events, Windows,  Declarations, INITIALIZE, Global_Functions, Utilities, SANDIA,  CurveFit, Simplexer,  Linear_Least_Squares, Physics, xray ;  	PROCEDURE D_DialHall;	PROCEDURE Do_Hall_Quant;    PROCEDURE WriteToHall;    PROCEDURE Show_One_Hall;	{called from SiLiWin:ShowFit}    PROCEDURE Show_Hall;    PROCEDURE Show_HallSetup;    PROCEDURE Hall_Help;{******************************} IMPLEMENTATION {**********************************}{[f+]}{$S Hall_1}	VAR  	    showname:fnamestr;		show_vol:integer;        errcode:integer;		found, show_one, show_setup : boolean;		B_count, bytecount		: Longint;		{quant_work was made a global for ZAF}	Procedure FitBulk;	var  	 index, refnum, window_counter,	 savFR,savLR,savFD,savLD					: integer;	 savLoE,savHiE							    : real;		Read_Stuff 										: SimpS;		 str	   : str255; 		 Begin	   errCode := FSpOpenDF(Read_DTSA_Spec, fsRdWrPerm, refnum);	   RdBinaryName := Read_DTSA_Spec.name;	   IF errCode <> NoErr THEN BEGIN		 putmessage('I am trying to find and fit the bulk spectrum, but',					' you probably do not have a DTSA spectrum file opened.',					 ' GET DTSA SPECTRUM, then return to the HALL Dialog and select ACCEPT. ','');		 Update_Full;		  		 EXIT(FitBulk);	   END	{IF errCode...}		   ELSE BEGIN	{ errCode = NoErr...}		  B_count :=  sizeof(Expt_InfoRec) + sizeof(Plot_infoRec);		  errCode := FSread(refnum, B_count, @Plt_Spec[10]^^.Expt_Info);		  index := Plt_spec[10]^^.Expt_Info.FirstSpec-1;		  B_count := sizeof(Spectrum_Structure) +						 longint(Plt_spec[10]^^.Expt_Info.Number_of_Channels) * 4 ;		  Repeat			errCode := FSread(refnum, B_count, @Plt_Spec[10]^^.SpectrumStuff);			if errcode = noerr then 			with Plt_Spec[10]^^.SpectrumStuff. Spectrum_Info do begin 			    str:=				concat(Spectrum_class[1],Spectrum_class[2],Spectrum_class[3],Spectrum_class[4]);		 		end;		 Until (str = 'bulk') or (errcode = eoferr);		 errCode := FSClose(refnum);		 errCode := FlushVol(NIL, Read_DTSA_Spec.vRefNum);	   	  IF (str = 'bulk') then begin { found the BULK SPECTRUM }		   B_count := sizeof(simplex_fit);		   read_stuff:=SimpS(NewHandle(B_count));		   MoveHHi(Handle(read_stuff));		   HLock(Handle(read_stuff));		  {analysis_result must be changed from the setup		   stuff to something for the bulk line fit, so save the setup stuff in read_stuff}		   read_stuff^^ :=	analysis_result^^;			   WITH read_stuff^^,SpectrumStuff,Spectrum_Info,Acq_info,Fit_params,Fit_Result DO		   BEGIN	{ find the window with the bulk lines and sum the bulk line areas (for Simplex) }		    found := false;			index:=0;			window_counter := 0;			Repeat	{ go thru the windows looking for BulkZ family...}			  window_counter := window_counter + 1;			   Repeat	{ thru the peaks...}				index := index + 1;				if(Atomic_Number[index] = Hall_Setup^^.Bulk_Z) and				(siegbahn[index][1] = Hall_Setup^^.Bulk_Line[1]) then found := true;			   Until  (found) or (index = Number_of_peaks) or (index = first_in_roi[window_counter +1]-1);			Until (found) or (window_counter = Number_of_windows);			{set up for Fitting this window }			   IF (found) then begin	{ define analysis_result for bulk fit...the number of windows			                               becomes one and all window number dependent parameters										   are assigned to window 1; all peak number dependent										   parameters are unchanged but the first # for window 1										   becomes the first # in window window_counter}              {Next necessary because in the main of simplex we calculate Number_of_Peaks_in_Window.			   For that, Window_Counter = Number_of_Windows = 1. So Number_of_Peaks must always be			   First_in_Roi[window_counter] + Number_of_Peaks_in_Window -1.}			  IF (Window_Counter = Number_of_Windows) THEN               analysis_result^^.Fit_params.Number_of_Peaks := Number_of_Peaks              ELSE analysis_result^^.Fit_params.Number_of_Peaks := First_in_Roi[Window_Counter + 1] - 1;				 analysis_result^^.Fit_params.Number_of_Windows := 1;				 analysis_result^^.Fit_params.Fitting_Roi_Lo[1] := Fitting_Roi_Lo[window_counter];				 analysis_result^^.Fit_params.Fitting_Roi_Hi[1] := Fitting_Roi_Hi[window_counter];				 analysis_result^^.Fit_params.first_in_roi[1] := first_in_roi[window_counter];				 		         IF (simplex_active) then begin				 	fit_invisibly := false;				 	Sequential_SIMPLEX					end				 else if (LLSQ_active) then begin					savFR := ML_Setup^^.First_Ref[1];						savLR := ML_Setup^^.Last_Ref[1];					savFD := ML_Setup^^.First_Deriv[1];					savLD := ML_Setup^^.Last_deriv[1];					savLoE:= ML_Setup^^.ML_LoeV[1];					savHiE:= ML_Setup^^.ML_HieV[1];					ML_Setup^^.First_Ref[1]   := ML_Setup^^.First_Ref[Window_Counter];					ML_Setup^^.Last_Ref[1]    := ML_Setup^^.Last_Ref[Window_Counter];					ML_Setup^^.First_Deriv[1] := ML_Setup^^.First_Deriv[Window_Counter];					ML_Setup^^.Last_deriv[1]  := ML_Setup^^.Last_deriv[Window_Counter];					ML_Setup^^.ML_LoeV[1]     := ML_Setup^^.ML_LoeV[Window_Counter];					ML_Setup^^.ML_HieV[1]     := ML_Setup^^.ML_HieV[Window_Counter];				    Do_LLS_Fit;				 end;				 			  END	{IF found ...}			  ELSE begin	{IF not (found)...}				 putmessage('There is no bulk line  in the Work file "bulk" spectrum.',				 'Did you supply the correct bulk line in the Hall Dialog?','','');				 EXIT(FitBulk);			  END;	{ ELSE begin }		   END; { WITH read_stuff^^...}			{ next bit is the same for ML and Simplex because analysis_result has been			  defined in the setup and/or fit procedure }			 WITH analysis_result^^,SpectrumStuff,Spectrum_Info,Acq_info,Fit_params,Fit_Result DO			 BEGIN			  index := first_in_roi[1]-1;			  Hall_Setup^^.Bulk_Factor := zero;			  found := false;			  Repeat	{ find and sum bulk areas from the bulk analysis result just done}			   index := index + 1;			   if(Atomic_Number[index] = Hall_Setup^^.Bulk_Z) and			   (siegbahn[index][1] = Hall_Setup^^.Bulk_Line[1])			   then begin	{if(Atomic_Number...}				 Hall_Setup^^.Bulk_Factor := Hall_Setup^^.Bulk_Factor + Area[index];				 found := true;	{ only while reading the bulk family }			   end	{if(Atomic_Number...}			   else found := false;	{ when the bulk family is finished } 			  Until (index = Number_of_peaks) or					((not found) and (Hall_Setup^^.Bulk_Factor<>zero));			  Hall_Setup^^.Bulk_Factor := Chosen_norm_bkg/(Hall_Setup^^.Bulk_Factor * Live_Time);			  Hall_setup^^.bulkfile := RdBinaryName;			end; { WITH analysis_result^^...}		 END	{ if (str = 'bulk')...}		 ELSE BEGIN			  putmessage('There is no "bulk" spectrum in the Work file.',			  'If it IS there but you forgot to set the spectrum header class to `bulk`,',			  'correct the header, and try again.', '');			  EXIT(FitBulk);		 END;		 { Reestablish the original setup structures:}			analysis_result^^ := read_stuff^^;			H_UnLock_Dispose(Handle(read_stuff),'read_stuff xx');			if (LLSQ_active) then begin					ML_Setup^^.First_Ref[1]   := savFR;					ML_Setup^^.Last_Ref[1]    := savLR;					ML_Setup^^.First_Deriv[1] := savFD;					ML_Setup^^.Last_deriv[1]  := savLD;					ML_Setup^^.ML_LoeV[1] :=  savLoE;					ML_Setup^^.ML_HieV[1] :=  savHiE;		 	end;				   END;	{ if errCode = NoErr...}			END;	{ Procedure FitBulk}  Procedure WriteToHall;  VAR   hallcount:longint;  BEGIN       hallcount := sizeof(Hall_OutStuff);	   errCode := FSOpen_err(Hall_Name,Hall_Vol, FileRefNum,'');	   errcode := SetFPos_err(FileRefNum, fsFromLEOF,0,'');	   errcode := FSWrite_err(FileRefNum, hallcount, @Hall_Output^^,'');	errCode := FSClose(FileRefNum);	errCode := FlushVol(NIL, Hall_Vol);  END;  PROCEDURE AsciiHallResults;  VAR	n,nn,theZ, theVol, nf          				: integer;   HallPlainName								: fnamestr;   fndrInfo                     				: FInfo;   errcode,err					 				: OSerr;   theDirID										: longint;   theVname										: str31;   str,str1,str2,str3,str8,str6   : str255; 	     procedure writeHall_Text;  	VAR	   nn					:integer;  	BEGIN	WITH Hall_Output^^ do begin		if (Hall_Output^^.do_ML  ) then begin 		  if local then str:=concat(' Peak to local background ratios from ML fit ',										Hall_Output^^.ResultsName)		  else str:=concat(' Peak to chosen background ratios from ML fit ',										Hall_Output^^.ResultsName);		  end	{ if (Hall_Output^^.do_ML...}		else begin		  if (local) then str:=concat('  Peak to local background ratios from Simplex fit ',										Hall_Output^^.ResultsName)		  else str:=concat('  Peak to chosen background ratios from Simplex fit ',										Hall_Output^^.ResultsName);		end;	{ else begin...}    		  writeln(Plain);			  writeln(Plain, Str);			  numtostring(spectnum,str);			  writeln(Plain,'  DTSA file ',DTSAname,' spectrum ',str,': ',class);			  str:=' ';			  realtostring(Z_corr,5,4,str1);			  realtostring(BulkBk,5,4,str2);			  realtostring(totbk,5,4,str3);			  str := concat('  Concentration Z correction factor: ',str1);			  writeln(Plain, Str);			  str := concat('  Bulk background contribution: ',str2,'; corrected normalized background: ',str3); 			  writeln(Plain, Str);			  str:=' ';			  if (Hall_Output^^.do_ML) then str := '   Family       CONC(mM/kg)         stdev            P/B                '				  else  str := '   Family       CONC(mM/kg)            P/B                ';			      writeln(Plain, Str);			  str:=' ';			  if (Hall_Output^^.do_ML) then for nn := 1 to Hall_setup^^.number_of_peaks do begin			      str:=concat('   ',A^.Sym[Hall_setup^^.Atomic_Number[nn]],Hall_setup^^.Siegbahn[nn]);				  if Hall_setup^^.Std_File_Code[nn] = 99 then				  	   writeln(Plain,str, '        no quant')				  else if Hall_Output^^.ptob[nn] = 0.0 then				  	   {writeln(Plain,str, '        not in fit results')}                  else writeln(Plain,str, Conc[nn]: 16:3, stdev[nn]: 16:3, ptob[nn]:16:3); 				 str:=' ';				 end			  else begin			    theZ := 0;			    for nn := 1 to Hall_setup^^.number_of_peaks do begin				  if theZ = Hall_setup^^.Atomic_Number[nn] then			         str:=concat('   ',A^.Sym[Hall_setup^^.Atomic_Number[nn]],Hall_setup^^.Siegbahn[nn])         		  else begin				  	theZ := Hall_setup^^.Atomic_Number[nn];					str := copy(Hall_setup^^.Siegbahn[nn],1,1);					str:=concat('  ',A^.Sym[Hall_setup^^.Atomic_Number[nn]],' sum ',str);					if Hall_setup^^.Std_File_Code[nn] = 99 then					  	 writeln(Plain,str, '        no quant')					else if Hall_Output^^.ptob[nn] = 0.0 then					  	 {writeln(Plain,str, '        not in fit results')}					else writeln(Plain,str, Conc[nn]: 16:3, ptob[nn]:16:3); 		 		  end;		        { writeln(Plain,str, Conc[nn]: 16:3, ptob[nn]:16:3); ...wrinting only for the sum}				 str:=' ';				 end;			  end; {else...}		end;	{ WITH Hall_Output^^ ...}	   END;	{ procedure writeHall_Text; }   BEGIN	{ PROCEDURE AsciiHallResults;}        if show_one then begin			HallPlainName := 'OneHall_Ascii';	{this is written over each time}  		    show_Vol := 0;		end		else begin			HallPlainName := concat(showname,'_ASCii');			errcode := GetVol(Save_Volume_Name,save_vol);{keep track of current vol}			errcode := setvol(nil,Show_Vol); {only way to specify the vol for Plain}			errCode := FSOpen_err(showname,show_Vol, FileRefNum,'');{This is the binary}			B_count:=sizeof(Hall_stuff);			errcode := FSRead(FileRefNum,B_count,@Hall_Setup^^);			If Not show_setup then 			begin    	     B_count:=sizeof(Hall_outstuff);	         errcode := FSRead(FileRefNum,B_count,@Hall_Output^^);	        End;			{if errcode = EOFErr then putmessage('end of file at first read','','','');}		end;		{else begin}		Rewrite(Plain, HallPlainName);	{ plain:text}        Rewrite(Plain);		        fndrInfo.fdcreator := 'MSWD';        fndrInfo.fdtype := 'TEXT';        fndrInfo.fdFlags := 100;                                err := setfinfo(hallplainname, show_Vol, fndrInfo);		WITH Hall_Setup^^ do begin        Str := CONCAT('           ', HallPlainName);        writeln(Plain, Str);		str:=' ';		    theVol := show_Vol;			Get_WDInfo(theVName,theDirID,theVol); {in Utilities}			{...returns theVName,theDirID, and the Volume ref num in theVol}			Get_CreationDate(showname,theDirID,theVol);	{...defines theDateTime, a global}			str8:= DTRec2Str;			  IF (theDateTime.hour) >= 12 THEN str8 := CONCAT('           ',str8, ' pm')			  ELSE str8 := CONCAT('           ',str8, ' am');        writeln(Plain, Str8);        if show_setup then Str := CONCAT('           Setup file ', showname)        else Str := CONCAT('           Quant of fit results ', Hall_Output^^.ResultsName);        writeln(Plain, Str);		str:=' ';        writeln(Plain, Str);		If show_setup then		begin			str := ' Film and Bulk corrections and Average Z may be changed in Quant setup:';			writeln(Plain, Str);		end;		If (Filmcorr = 0.0) then 		   str := '  No Film correction. '		else begin		    realtostring(Filmcorr,2,-2,str);			str := concat('  Normalized correction from film = ',str,' from file ',filmfile);			end;        writeln(Plain, Str);		str:=' ';		If (do_bulk) then begin		    realtostring(bulk_factor,2,-2,str);			str := concat('  Bulk correction factor for ', A^.Sym[Bulk_Z],Bulk_Line,' = ',str,' from file ',bulkfile); 		    end		else str := '  No Bulk correction. ';        writeln(Plain, Str);		str:=' ';		realtostring(Average_Z,4,2,str);		str := concat('  Input average atomic number for the matrix: ',str);        writeln(Plain, Str);		str:=' ';		n := 1;		Repeat		  str6:= concat('  From file ',Standard_files[n],' K factors are:');		  str := '          '; 		  theZ := 0;		  nf := 0;		 		  FOR nn := 1 to number_of_peaks do begin			 if (Std_File_Code[nn] = n) then			 begin				 if (Hall_Output^^.do_ML) or (theZ = Atomic_number[nn]) then				  	str2:=concat(' for ',A^.Sym[Atomic_number[nn]],Siegbahn[nn][1],'; ')				  else begin				    theZ := Atomic_number[nn];					str8 := copy(Siegbahn[nn],1,1);				  	str2:=concat(' for sum ',A^.Sym[Atomic_number[nn]],Siegbahn[nn][1],'; ')				  end;				  {all internal calcs done in wtfract so convert for biologists to mm/kgdry}				  realtostring(K_Factor[nn] * 1.0e6/ At_Wt^^.Value [Atomic_Number[nn]],5,2,str1);				  str:= concat(str,str1,str2);				  if (nf = 0) and (length(str6) > 1) then writeln(Plain, Str6);				  nf := nf + 1;				  if (nf = 4) or (nn = number_of_peaks) then 				  begin {write the filename and k list}				   writeln(Plain, Str);				   nf := 0;				   str6 := '';			       str := '          ';				  end;			 end;	{ if (Std_File_Code...}		  END;	{for nn...}		  n := n + 1;		  str:=' ';		Until (n = 6) or (Standard_files[n] = ' ');		If (length(str6) > 1) then writeln(Plain, Str);	END;	{ WITH Hall_SetUp^^...}	   writeln(Plain);	   If show_setup then begin			errCode := FSClose(FileRefNum);			errCode := FlushVol(NIL, Show_Vol);	   End       Else Begin		    B_count:=sizeof(Hall_outstuff);			IF (show_one) THEN BEGIN				writeHall_text;				writeln(Plain);				writeln(Plain);		        writeln(Plain, '	***	USE "ADD FIT" to APPEND THESE DATA TO THE HALL FILE *** ');						    END			ELSE BEGIN			  REPEAT			   If (errcode = noerr) then			   begin			   	 writeHall_text;			     errcode := FSRead(FileRefNum,B_count,@Hall_Output^^);			   end;			  { if errcode = EOFErr then putmessage('end of file','','','');}			  UNTIL (errcode = EOFErr);			   errCode := FSClose(FileRefNum);			   errCode := FlushVol(NIL, Show_Vol);			 END;	{ELSE BEGIN}		End;	{Else Begin}	   Close(Plain);       errcode := setvol(Save_Volume_Name,save_vol);	    Fit_Invisibly := false;		ReviewFitResults(HallPlainName,Show_Vol);	{assumes one goes to main event loop}	{	errcode := FSDelete(HallPlainName,Show_Vol);}  		Mouse_Active_Window;  END;	{ PROCEDURE AsciiHallResults...}    PROCEDURE Show_One_Hall;  BEGIN      show_one := true;      show_setup := false;  	  AsciiHallResults;  END;	{ PROCEDURE Show_One_Hall; }     Procedure Show_Hall;	{called from Menus_D}  BEGIN      show_one := false;      show_setup := false;     { REPEAT}		mytype := 'MCAH';		myprompt := 'Get Hall File';		  Repeat	      Until (GetFileName(showname, mytype, mytype, myprompt)) or	            (File_Cancel_Button = False);	      IF (File_Cancel_Button) then begin				show_vol:= In_VolRefNum;				AsciiHallResults;		  end;  	 { UNTIL File_Cancel_Button = False;}  END;	{ PROCEDURE Show_Hall; }     PROCEDURE Show_HallSetup;  BEGIN        show_one := false;		mytype := 'Hals';		myprompt := 'Show Hall Setup File:';		  Repeat	{showname is global to the unit}	      Until (GetFileName(showname, mytype, mytype, myprompt)) or	            (File_Cancel_Button = False);	      IF (File_Cancel_Button) then begin	            show_setup := true;				show_vol:= In_VolRefNum;				AsciiHallResults;		  end;  END;	{ PROCEDURE Show_HallSetup; }   PROCEDURE MakeHallFile;{ opens the binary hall file; writes setup info to file }  VAR   errcode:integer;   bytecount:longint;  BEGIN(*numtostring(Hall_vol,str);putmessage('opening hall file',Hall_Name,'Hall_vol is',str);*)	   errCode := FSOpen_err(Hall_Name,Hall_Vol, FileRefNum,'');	   errcode := SetEOF(FileRefNum,0);	   errcode := SetFPos_err(FileRefNum, fsFromStart,0,'');	   bytecount:= sizeof(Hall_Stuff);	   errcode := FSWrite_err(FileRefNum,bytecount,@Hall_Setup^^,'');	   errCode := FSClose(FileRefNum);	   errCode := FlushVol(NIL, Hall_Vol);  END;	{ PROCEDURE MakeHallFile...}     PROCEDURE Quant_the_Fit;	{ called only if quanting a fit results file }  { Reads through a file of fit results and calculates concentrations. Does not quant the    film or bulk results...does now. }  VAR 	errcode,refnum,err : integer;		test_str : string[4];  	    bytecount,count	:longint;			  BEGIN			   errCode := FSOpen_err(MCA_ResultsName,MCA_Results_VolNum, refnum,'');			   MCA_File_Boolean := true;     		   errCode := SetFPos_err(refnum, fsFromStart,1,'');{ 1st byte has T or F for is_batch}			   bytecount := sizeof(Simplex_Fit);			   count := -bytecount;			   repeat			    {read next fit result}	              err := FSRead(refnum, bytecount, @Analysis_Result^^);				  IF (err = noerr) then				  WITH Analysis_result^^.SpectrumStuff.Spectrum_Info				  do begin		 			test_str := concat(Spectrum_class[1],Spectrum_class[2],Spectrum_class[3],Spectrum_class[4]);					{ Skip the fim and bulk spectra results if they are in the file }					(*if (test_str <> 'film') and (test_str <> 'bulk') then					begin*)				      Do_Hall_Quant;					  { go back to start of the same fit result}     		          errCode := SetFPos_err(refnum, fsFromMark,count,'');					  {write fit result with calculated concentrations}	                  errCode := FSWrite_err(refnum, bytecount, @Analysis_Result^^,'');	                  WriteToHall;	{ opens, writes to, closes HAll file}				    (*end;	{ if...}*)				  end; { IF... WITH Analysis_result^^... }			   Until (err = eoferr);			   	 errCode := FSClose(refnum);				 errCode := FlushVol(NIL, MCA_Results_VolNum);			 end;		   PROCEDURE Do_Hall_Quant;      { Film and Bulk corrections are done only for peak to chosen background. CORR, to be correct,	 must include all peaks in the spectrum not contributing to the average atomic number.	 StdConc (std dev of concentration) and AvgConc are left to Spread Sheet calculations. }	   Var	  BKGCOR,theVal,theconst,stdev	      : real {double_t};	  index,indek,theZ,zindek    : integer;      str   : str255;      BEGIN 	{ Do_Hall_Quant }   	{the MCA_stuff is all defined-for Work file from MakeBinaryResults in Curve_Fit	 or from GetFilename for fit results-so this should work.}		   local := false;             Hall_Output^^.totbk:=zero;			   blockmove(@MCA_ResultsName,@Hall_Output^^.ResultsName,sizeof(Hall_Output^^.ResultsName));		   Hall_Output^^.ResultsDirId := MCA_ResultsDirID;{probably 0 for old Hall}		   Hall_Output^^.ResultsVNum := MCA_ResultsVNum;{good number}	 WITH Analysis_result^^,ExptStuff,SpectrumStuff,Acq_Info,Spectrum_Info,Fit_params,Fit_result	 do begin	 	  {clear out from Analysis_result any concentrations from previous quants...}	      for index := 1 to MaxNumPks do conc[index] := 0.0;		  Hall_Output^^.spectnum:=spectrum_number;			  Hall_Output^^.DTSAname:=MCA_filename;			  Hall_Output^^.Class:=Spectrum_class;			  Hall_Output^^.BULKBK:=zero;			  Hall_Output^^.Z_CORR:=zero;				 if (Fit_Procedure = 'ML') then Hall_Output^^.Do_Ml := true			  else Hall_Output^^.do_ML := false;		  index := 1;		   		 IF (Hall_Setup^^.do_bulk) then begin		   found := false;		   Hall_Output^^.BULKBK := 0;		   Repeat		     if ((Atomic_Number[index] = Hall_Setup^^.Bulk_Z) and			     ( Siegbahn[index][1] = Hall_Setup^^.Bulk_Line[1])) then				begin					found:=true;					repeat					    Hall_Output^^.BULKBK := Area[index] + Hall_Output^^.BULKBK;						index := index + 1;					until (Atomic_Number[index] <> Hall_Setup^^.Bulk_Z) or					      ( index > Number_of_Peaks );			    end				else index := index + 1;		   until  ( found ) or ( index > Number_of_Peaks );		   if (found) then Hall_Output^^.BULKBK := Hall_Output^^.BULKBK * Hall_Setup^^.Bulk_Factor		   else begin		        Hall_Output^^.Bulkbk := zero;			    putmessage('The line to use for bulk correction is not in the fit results.',						   'I`ll go on with no correction.','','');		   end;		   index := 1;		 end;	{IF (Hall_Setup^^.do_bulk)...}		 		 		 Hall_Output^^.totbk := Analysis_result^^.Fit_result.Chosen_Norm_Bkg -				  Hall_Setup^^.FilmCorr * Live_Time * (end_faraday + begin_faraday)/2 - 				  Hall_Output^^.BULKBK;		 BKGCOR := Analysis_result^^.Fit_result.Chosen_Norm_Bkg / Hall_Output^^.totbk;		(* realtostring(BKGCOR,-1,5,str1);		 putmessage('BKGCOR',str1,'','');*)		 {remember that if a hall setup file was used the order of the peaks in the		  analysis_result and the setup file may not be the same...hence the search loop}		  theZ := 0;          For indeK := 1 to Hall_Setup^^.Number_of_Peaks do		  begin {go through Hall lines for match to anal_res line...if we didn't find		  	     a K factor and decided to skip the family in the quant, the K factor				 is zero so the line makes no contribution to the quant; 				 also the Hall_Setup^^.Std_File_Code[indek] := 99.				 if we didn't fit the family, it's not among 				 the Hall_Setup^^.Number_of_Peaks}		    if (Hall_Setup^^.Atomic_Number[indeK] = Hall_Setup^^. Bulk_Z) then			begin		     	Hall_Output^^.ptob[indek] := one;				Hall_Output^^.conc[indeK] := zero;				Hall_Output^^.stdev[indeK] := zero;			end		    else if (Hall_Setup^^.Atomic_Number[indeK] <> Hall_Setup^^. Bulk_Z)			then begin			  found := false;			  index := 0;			  repeat				 index := index + 1;				 if (( Atomic_Number[index] = Hall_Setup^^.Atomic_Number[indeK]) and					 (Siegbahn[index] = Hall_Setup^^.Siegbahn[indeK] ) and					 (((ev_loLine[index] = Hall_Setup^^.ev_loLine[indeK]) and					   (ev_hiLine[index] = Hall_Setup^^.ev_hiLine[indeK]))))					   then found := true;			  until  ( found ) or ( index = Analysis_result^^.Fit_params.Number_of_Peaks );			  			  IF (found) then begin			    theZ := Hall_Setup^^.Atomic_Number[indeK];				theVal := Hall_Setup^^.K_Factor[indeK] * BKGCOR * Hall_Setup^^.Average_Z;				theconst := (1.0E6/ At_Wt^^.Value [Atomic_Number[index]]);				IF NOT LOCAL then				begin	{ peak to local background...}			     if Hall_Output^^.Do_Ml then				 begin				   Hall_Output^^.ptob[indek] := Peak_to_Chosen_Bkg[index];				   Hall_Output^^.conc[indeK] := 0.0;				   if Hall_Setup^^.Std_File_Code[indek] <> 99 then				   begin					 CONC[index] := Peak_to_Chosen_Bkg[index] * theVal;					 {...wt fract for analysis_result}					 Hall_Output^^.stdev[indek] := theVal * err_or_energy[index] * theconst/Chosen_Norm_Bkg; 				     Hall_Output^^.conc[indeK] := CONC[index] * theconst;					 if (Hall_Setup^^.Siegbahn[indeK] = 'K    ') or (Hall_Setup^^.Siegbahn[indeK] = 'KA1  ')					 or (Hall_Setup^^.Siegbahn[indeK] = 'L    ') or (Hall_Setup^^.Siegbahn[indeK] = 'LA1  ')					 or (Hall_Setup^^.Siegbahn[indeK] = 'M    ') or (Hall_Setup^^.Siegbahn[indeK] = 'MA1  ')					 then Hall_Output^^.Z_CORR := Hall_Output^^.Z_CORR +  						 (Hall_Setup^^.Average_Z - Atomic_Number[index]) * CONC[index];				   end;	{if Hall_Setup^^.Std_File_Code...}				 end	{ ML }				 else	{ 'Sm' }				 begin			   {We are indeking over the setup # of pks. We have looked thru an anal res				and found a peak that matches the 1st setup pk for indek. We are doing a running				sum on the matching p/b for an element, assuming that all the lines for an element				in the setup are clustered. If the lo_ev or hi_ev changes we must start a new sum.}					zindek := index; 		            Hall_Output^^.ptob[indek] := 0.0;					stdev := 0.0;					Repeat				       Hall_Output^^.ptob[indek] := Hall_Output^^.ptob[indek] +					                                Peak_to_Chosen_Bkg[index];					   stdev := area[index] + stdev;					   conc[index] := 1.0;	{so we know line was used in quant}					   index := index + 1;					Until ((ev_loLine[index] <> Hall_Setup^^.ev_loLine[indeK]) or					       (ev_hiLine[index] <> Hall_Setup^^.ev_hiLine[indeK]) or						   (index > number_of_peaks));					Hall_Output^^.stdev[indek] := sqrt(stdev +					              Chosen_Norm_Bkg * (Chosen_ROI_Hi - Chosen_ROI_Lo)/DEN);					CONC[zindek] := Hall_Output^^.ptob[indeK] *theVal;					{...wt fract for analysis_result}					Hall_Output^^.conc[indeK] := CONC[zindek] * theconst;					{...concentration in mm/kg }					Hall_Output^^.Z_CORR := Hall_Output^^.Z_CORR +  							   (Hall_Setup^^.Average_Z - theZ) * CONC[zindek];				 end;	{ 'Sm'}			    End	{ peak to chosen background...}				Else If ( Local ) then begin			(*	  if (Hall_Setup^^.Siegbahn[indeK] = 'KA1  ') then begin {assume bkgs ~ the same}					CONC[index] :=(Peak_to_Local_Bkg[index] + Peak_to_Local_Bkg[index+1]) *								 Hall_Setup^^.K_Factor[indeK]*Hall_Setup^^.K_Factor[indeK+1] /								(Hall_Setup^^.K_Factor[indeK] + Hall_Setup^^.K_Factor[indeK+1]) *								 Hall_Setup^^.Average_Z;					CONC[index+1] := CONC[index];					Hall_Output^^.conc[indeK+1] := CONC[index] * 1.0e6/												At_Wt^^.Value [Atomic_Number[index]];{in mm/kg}					end				  else if(Hall_Setup^^.Siegbahn[indeK] <> 'KA2  ') then				    CONC[index] := Peak_to_Local_Bkg[index] * Hall_Setup^^.K_Factor[indeK] *									  Hall_Setup^^.Average_Z;			*)	End;	{if ( Local )...}								 			  END	{if (found) ...}			  ELSE begin			  	    Hall_Output^^.ptob[indek] := 0;			  	    Hall_Output^^.stdev[indek] := 0;			  	    Hall_Output^^.conc[indeK] := 0;			  	if (not is_batch) then			  	begin				   str := concat('We have a K factor for ',A^.Sym[Hall_Setup^^.Atomic_Number[indeK]],							  Hall_Setup^^.Siegbahn[indeK],',');				   putmessage(str,'but it is not in the fit results.','','');			    end;			  END;	{Else begin...}		end;	{ if (Hall_Setup^^.Atomic_Number[indeK] <> Bulk_Z...}       End;     { For indeK...}	   Hall_Output^^.Z_CORR := 1.0/(1.0 + Hall_Output^^.Z_CORR/Hall_Setup^^.Average_Z);		For index:= 1 to Number_of_Peaks do begin { correct the fit file concentration in wt fract}	 		  if conc[index] = 1.0 then conc[index] := conc[index - 1]		  {T only if line used for quant but not the 1st line which has the conc}		  else CONC[index]:= Hall_Output^^.Z_CORR * CONC[index];	{0.0 or a value}		  { for Simplex, only one line per family will have a non-zero value;		    for both, any line not in the quant will be zero.}		  end;		For indeK := 1 to Hall_Setup^^.Number_of_Peaks do 		if Hall_Setup^^.Std_File_Code[indek] <> 99 then begin { correct the mM/kg concentration}		  Hall_Output^^.conc[indek]:= Hall_Output^^.Z_CORR * Hall_Output^^.conc[indek];	{ zero for bulk line }		  Hall_Output^^.stdev[indek]:= Hall_Output^^.Z_CORR * Hall_Output^^.stdev[indek];	{ zero for bulk line }		end;      END;    { With Hall_Output^^,analysis... }    END;	{ Do_Hall_Quant }{$S Hall_2}    PROCEDURE Get_HallInfo;	VAR		used, lines_match : boolean;		index,index1,index2,errcode, refnum,fcnt : integer;		bcount	: longint;		test_str : string[4];		Read_Stuff : SimpS;        mytype                       : OsType;	    myprompt					 : str255;		str1,str2,str3,str4,str5,str6,str7,str8   : str255;		avgamps	: real;    BEGIN     { The main Hall dialog has check box options to do film correction and grid	   correction ... Here check boxes indicate to select data in results file to quant or other file;	   Call this procedure for each correction. Zero FlmCorr and Bulk Corr in main Do_Hall  }	found := false;	local := false;	fcnt:=0;	{ need read_stuff because cannot write over analysis results being quant'd}	B_count := sizeof(simplex_fit);	read_stuff:=SimpS(NewHandle(B_count));	MoveHHi(Handle(read_stuff));	HLock(Handle(read_stuff));		    REPEAT	{ until (found);  cancel in GetFileName also exits this procedure }	  IF (read_Hall_file) THEN BEGIN	{ get the required data from OTHER file }		If ( Hall_Str = 'film' ) then mytype := 'MCAf'	{ must be a spectrum file }		else mytype := 'MCAb';		Repeat	         myprompt := concat(' File for ',Hall_Str,' ? ');        		{GetFileName sets the Vol to that chosen in the file menu }        Until (GetFileName(The_File_Name, mytype, mytype, myprompt) = True) OR 			      (File_Cancel_Button = False);        IF (File_Cancel_Button = False) THEN		begin	{if using a setup file Hall_Setup^^.Number_of_peaks wil have been					 made to agree with analysis_result^^ when this routine is called}			H_UnLock_Dispose(Handle(read_stuff),'read_stuff xx');			Exit(Get_HallInfo);		end;	 END	{IF (read_Hall_file) then begin...}	 ELSE IF (quant_work and ( Hall_Str = 'film' )) THEN BEGIN {film spectrum in Work file}      		In_VolRefNum := Binary_VolNum_Read;       		The_File_Name := RdBinaryName;	 END	 ELSE BEGIN  { get the data from the results file you are quantitating...remember, even	 			   if doing work the quant is done AFTER the fit results are written}      		In_VolRefNum := MCA_Results_VolNum; 	{WD num}      		The_File_Name := MCA_ResultsName;	 END;     found := false; 	 used := false;     errCode := FSOpen_err(The_File_Name,In_VolRefNum, refnum,''); 	 IF ( Hall_Str = 'film' ) and ((read_Hall_file) or (Quant_work)) THEN	 BEGIN	   { read a spectrum file }		Hall_Setup^^.FilmCorr := zero;		   IF errCode <> NoErr THEN BEGIN			 putmessage(The_File_Name,'the file with the film spectrum failed to open.','','');			 Update_Full;		  			 Exit(Get_HallInfo);		   end			   else begin	{ errCode = NoErr...}			  errCode := SetFPos_err(refnum, fsFromStart,0,'');			  B_count := sizeof(Expt_Inforec);			  errcode := FSRead(refnum,B_count,@read_stuff^^.ExptStuff);			  B_count := sizeof(Plot_InfoRec);			  errcode := SetFPos_err(refnum,fsfromMark,B_count,'');			  index := read_stuff^^.ExptStuff.FirstSpec - 1;			  B_count := sizeof(Spectrum_Structure);			  bcount := read_stuff^^.ExptStuff.number_of_channels * 4;			  Repeat				errcode := FSRead(refnum,B_count,@read_stuff^^.SpectrumStuff);				errcode := FSRead(refnum,bcount,@col_1^);	{cnts}				index:=index+1;			    with read_stuff^^.SpectrumStuff. Spectrum_Info do begin		 	  	 test_str :=' ';				 test_str :=				   concat(Spectrum_class[1],Spectrum_class[2],Spectrum_class[3],Spectrum_class[4]);				 end;	{with...}			  Until (test_str = 'film') or (index = read_stuff^^.ExptStuff.LastSpect);			  errCode := FSClose(refnum);			  errCode := FlushVol(NIL, Binary_VolNum_Read);			  if (test_str = 'film') then with read_stuff^^,Exptstuff,SpectrumStuff,spectrum_info,Acq_info			  do begin			    avgamps := (end_faraday + begin_faraday)/2.0;			    If (Live_Time <= 0.0) or (avgamps <= 0.0)			    then begin			    	if answermessage('Either the livetime or Faraday current',			    			   'was not saved in the film Spectrum Header.',			    			   'If It`s OK I`ll go on with no film correction.',			    			   'If It`s NOT OK, CANCEL and edit the header.')			    	then Hall_Setup^^.FilmCorr := 0.0			    	else Exit(Get_HallInfo);			    end 	{If (Live_Time <= 0.0) or...}			    else begin					found := true;					index1 := rinttol((Analysis_result^^.Fit_params.Chosen_roi_lo * energy_slope + energy_intercept) / dE);					index2 := rinttol((Analysis_result^^.Fit_params.Chosen_roi_hi * energy_slope + energy_intercept) / dE);					for index := index1 to index2 do begin							Hall_Setup^^.FilmCorr := Hall_Setup^^.FilmCorr + col_1^[index];							end;					Hall_Setup^^.FilmCorr := Hall_Setup^^.FilmCorr/ ( Live_Time * avgamps *											 (index2 - index1 + 1)); { chosen background is normalized }					Hall_Setup^^.Filmfile := The_File_Name;				end;			  end	{if (test_str = 'film')...}			  else begin				  putmessage('There is no spectrum in the file with class set to "film".',				  'If the spectrum IS there, please set the class in the spectrum header.','If not, rethink the Hall setup.','');			  end;			  end;	{errCode <> NoErr...}			 END {if Hall_st = film...}	 ELSE BEGIN	{ the data must be in either the analysis results to quant or some other a.r.  }	  B_count := 1;	  errCode := FSRead(refnum, B_count,@is_batch);	  B_count := sizeof(simplex_fit);	  REPEAT { will read through the selected file until all required data are found or EOF }	   errCode := FSRead(refnum, B_count,@read_stuff^^);	   If (Errcode = Noerr) then	   begin 		 If ((read_stuff^^.Fit_params.Fit_Procedure = 'ML') and 		      ((Quant_work and Simplex_active) or (Analysis_result^^.Fit_params.Fit_Procedure = 'Sm') ) )			  then begin				putmessage('You are quantitating a Simplex fit; the file is an ML fit.','','','');				Errcode := EOFerr;				end		 Else if ((read_stuff^^.Fit_params.Fit_Procedure = 'Sm') and			   ((Quant_work and LLSQ_active) or (Analysis_result^^.Fit_params.Fit_Procedure = 'ML')))			  then begin 			  putmessage('You are quantitating an ML fit; the file is a Simplex fit.','Try another file.','','');			  Errcode := EOFerr;			  end		 Else If (( rinttol(read_stuff^^.Fit_params.Chosen_roi_lo)  <> 				   rinttol(Analysis_result^^.Fit_params.Chosen_roi_lo))				   or				 ( rinttol(read_stuff^^.Fit_params.Chosen_roi_Hi) <>				   rinttol(Analysis_result^^.Fit_params.Chosen_roi_hi)))		   then begin			  realtostring(read_stuff^^.Fit_params.Chosen_roi_lo,5,2,str1);			  realtostring(read_stuff^^.Fit_params.Chosen_roi_hi,5,2,str2);			  realtostring(Analysis_result^^.Fit_params.Chosen_roi_lo,5,2,str3);			  realtostring(Analysis_result^^.Fit_params.Chosen_roi_hi,5,2,str4);			  str1:=concat(str1,' and ',str2,' vs ',str3,' and ',str4);			  if (answermessage('Uh-Oh! The quant background region in the file is not the same as yours:', str1,			  ' If they`re very different your results will not be very accurate.',			  ' You Should pick another standard file, but If it`s OK, I`ll use this file.') ) then 			  			Errcode := Noerr;		   end;	   end;	{ If (Errcode = Noerr)...}	   	   If (Errcode = Noerr) then 	   WITH read_stuff^^,SpectrumStuff,Spectrum_Info,Acq_info,Fit_params,Fit_Result DO	   BEGIN		 if (this_is_a_standard) then test_str := 'stan'		 else test_str :=				 concat(Spectrum_class[1],Spectrum_class[2],Spectrum_class[3],Spectrum_class[4]);	     If (test_str = Hall_Str) then		 begin 	{if (test_str = Hall_Str)...}		   index := 0;			If ( Hall_Str = 'film' ) then			Begin		      avgamps := (end_faraday + begin_faraday)/2.0;		      If ((Live_Time <= 0.0) or ( avgamps <= 0.0))		      then begin			    	if answermessage('Either the livetime or Faraday current',			    			   'is zero in the filem correction information.',			    			   'If It`s OK I`ll go on with no film correction.',			    			   'If It`s NOT OK, I`ll quit so you can fix the problem.')			    	then Hall_Setup^^.FilmCorr := 0.0			    	else Exit(Get_HallInfo);		       end	{If (Live_Time <=...}		       else begin					  Hall_Setup^^.FilmCorr := Chosen_norm_bkg / (Live_Time * avgamps);					  found := true;					  Hall_Setup^^.Filmfile := The_File_Name;			   end;		    End	{If ( Hall_Str = 'film' ) then...}			Else IF ( Hall_Str = 'bulk' ) THEN	{ look through results for peaks til bulk info found }			Begin					  Hall_Setup^^.Bulk_Factor := zero;				  	  Repeat					   index := index + 1;					   if(Atomic_Number[index] = Hall_Setup^^.Bulk_Z) and					   (siegbahn[index][1] = Hall_Setup^^.Bulk_Line[1]) then					   begin						 Hall_Setup^^.Bulk_Factor := Hall_Setup^^.Bulk_Factor + Area[index];						 found := true;	{ only while reading the bulk family }					   end					   else found := false;	{ all the lines in the family have been found } 			          Until (index = Number_of_peaks) or				  		    ((not found) and (Hall_Setup^^.Bulk_Factor <> zero));					  if (Hall_Setup^^.Bulk_Factor <> zero) then begin				  	  	 Hall_Setup^^.Bulk_Factor := Chosen_norm_bkg/						 							(Hall_Setup^^.Bulk_Factor);				         Hall_Setup^^.bulkfile := The_File_Name;						 found:=true;					  end;			End	{ if (Hall_Str = 'bulk')...}		    Else If ( Hall_Str = 'stan' ) then			Begin			{ read one std analysis_result to read_stuff...does any line match a quant peak? Must 			  do a search because the order of pks in analysis_result may not match Hall setup order}			  str6:=' ';			  {compare each Hall_setup element to all lines in read_stuff...} 			  FOR index := 1 to Hall_Setup^^.Number_of_peaks do			  IF ( Hall_Setup^^.Std_File_Code[index] = 0) THEN BEGIN {no K factor yet}				index1 := 0;	{counts over lines in read_stuff...}				found := false;								if (Hall_Setup^^.Atomic_Number[index] = Hall_Setup^^.Bulk_Z) then begin				{ do not quant the bulk peak but it is one of the Hall_Setup^^.Number_of_peaks				  and must be accounted for in the following}				         beepbeep;						 Hall_Setup^^.K_Factor[index] := one;{otherwise, counted in next stds file...}						 Hall_Setup^^.Std_File_Code[index] := 99;					     stds_found := stds_found + 1; 				End	{...Hall_Setup^^.Bulk_Z)...}				Else Begin	{need std data...go thru all lines in std file read_stuff}				  if (Analysis_Result^^.Fit_params.Fit_Procedure = 'ML') then				  repeat { look through all the lines in one stds analysis result for the quant pk }					 index1 := index1 + 1;					 if (( Atomic_Number[index1] = Hall_Setup^^.Atomic_Number[index]) and						 ( siegbahn[index1] = Hall_Setup^^.siegbahn[index])) then					 begin				         lines_match := false;						 if (( ev_loLine[index1] = Hall_Setup^^.ev_loLine[index]) and						     ( ev_HiLine[index1] = Hall_Setup^^.ev_HiLine[index])) then					     begin {if ((Atomic_Number[index1]...}							  if (not used) then begin								fcnt:=fcnt+1;	{ counts the files used }								Hall_Setup^^.standard_files[fcnt] := The_File_Name;								used := true;	{set false when a new file is opened}							  end;							  lines_match := true;							  found:=true;							  stds_found := stds_found + 1;							  Hall_Setup^^.Std_File_Code[index] := fcnt;	{could be the same for all elements}							  if (local) then Hall_Setup^^.K_Factor[index] := Hall_Setup^^.K_Factor[index] +										  conc[index1] /( Peak_to_Local_Bkg[index1] * Average_Z) 							  else begin								  Hall_Setup^^.K_Factor[index] := Hall_Setup^^.K_Factor[index] +										  conc[index1] /(Peak_to_Chosen_Bkg[index1] * Average_Z);							  end;						end	{ if(( ev_loLine =...}					 end;	{if ((Atomic_Number[index1]...}				  until (found) or					    (index1 = Number_of_peaks)		{no more lines in the analysis_result}				  Else if (Analysis_Result^^.Fit_params.Fit_Procedure = 'Sm') then				  Begin {theZ starts out as Hall_Setup^^.Atomic_Number[1], zindex as 1,index1 as 0} 				   lines_match := true;				   index1 := index1 + 1;		           Repeat { look through all the lines in one stds analysis result for the Hall family }					 if (( Atomic_Number[index1] = Hall_Setup^^.Atomic_Number[index]) and						 (ev_loLine[index1] <= Hall_Setup^^.ev_loLine[index]) and						 (ev_hiLine[index1] >= Hall_Setup^^.ev_hiLine[index])) then					 begin					   found := true;					   if (not used) then begin						 fcnt:=fcnt+1;	{ counts the files used }						 Hall_Setup^^.standard_files[fcnt] := The_File_Name;						 used := true;	{set false when a new file is opened}					   end;					   stds_found := stds_found + 1;					   Hall_Setup^^.Std_File_Code[index] := fcnt;	{could be the same for all elements}					   {it's NEVER local...}					   IF (local) then Hall_Setup^^.K_Factor[index] :=								       conc[index1] /( Peak_to_Local_Bkg[index1] * Average_Z) 					   ELSE BEGIN	{...p/chosen B}						 index2 := index1;						 Repeat {reported simplex energy is calibrated...}						  if (Err_or_Energy[index1] * 1000 >= Hall_Setup^^.ev_loLine[index] - ExptStuff.dE) and							 (Err_or_Energy[index1] * 1000 <= Hall_Setup^^.ev_hiLine[index] + ExptStuff.dE) then						  begin							Hall_Setup^^.K_Factor[index] := Hall_Setup^^.K_Factor[index] + Peak_to_Chosen_Bkg[index1];						  end;						  index1 := index1 + 1;						 Until (index1 > Number_of_peaks) or 							   (ev_loLine[index1] <> ev_loLine[index2]) or							   (ev_hiLine[index1] <> ev_hiLine[index2]);						 Hall_Setup^^.K_Factor[index] :=  conc[index2] /(Hall_Setup^^.K_Factor[index] * Average_Z);					   END;	 {else begin}					 end	{ if (( Atomic_Number[index1] =...}					 else index1 := index1 + 1;{...to try next line in read_stuff}				   until (found) or					     (index1 > Number_of_peaks);				   {...Hall_setup line was found or no more lines in the analysis_result;				    compare next Hall_setup line to all lines in read_stuff }				  End;	{ If  (Analysis_Result^^.Fit_params.Fit_Procedure = 'Sm')...}				  If ( Hall_Setup^^.Std_File_Code[index] = 0) then				  begin {the k factor was not found among the read_stuff lines}				    str8:='';				    str8 := A^.Sym[Hall_Setup^^.Atomic_Number[index]];					If (not lines_match) then {...for ML only}					begin					  str6 := concat(str6,', ', str8);					  realtostring(Hall_Setup^^.ev_loLine[index],3,2,str7);					  realtostring(Hall_Setup^^.ev_hiLine[index],3,2,str5);					  str5 := concat('that includes the lines from ',str7,'ev to ',str5,'ev.');					  str7:= concat('The analysis requires a fit to a standard for ',str8);					  str6:=concat(str6,' ',str8);					  putmessage(str7,str5,					  			'The standard file has a fit, but for different lines.','');					end	{If (not lines_match)...}					else begin		  			  if answermessage('I don`t have a K factor for',str8,		  					   		   'If IT`S OK, I won`t quant this element,',							   		   'BUT the results may be QUITE inaccurate.')		  			  then begin					  	stds_found := stds_found + 1;	{don't skip all the eles with 0 K factors: get more stds}					    found:=true;						Hall_Setup^^.Std_File_Code[index] := 99; {make sure we don't ask about it again}					  end					  else str6:=concat(str6,' ',str8);					end;				  End;	{If ( Std_File_Code[index] = 0.0) then...}			     End;	{Else Begin...}			  			  END;	{ FOR index ...do IF ( Hall_Setup^^.Std_File_Code[index]... THEN BEGIN...}			  if (stds_found = Hall_Setup^^.Number_of_peaks) then found := true			  else found := false;			End;	{ Else If (Hall_Str = 'stan'...}		 end;  { if (test_str = Hall_Str)...}	   END; {(Errcode = Noerr) then With read_stuff... now go read the next analysis result from the file}	  UNTIL (found) or (Errcode = EOFerr);  {will read through the selected file...}	 END;	{Else begin	... reading a file of analysis results }	 errCode := FSClose(refnum);	 errCode := FlushVol(NIL, 0);	 If ( not found) then	 begin	  str1:='Please select another file. I need ';	  str2:='';	  if (hall_str = 'stan') then begin	  	str1:=concat(str1,'standards data for');		str2:=str6;	  end	  else if (hall_str = 'bulk') then str2 :=	  	concat('data for bulk line ',A^.Sym[Hall_Setup^^.Bulk_Z],Hall_Setup^^.Bulk_Line[1],'.')	  else if (hall_str = 'film') then str1 :=concat(str1,'film data.');	  	  putmessage(str1,str2,'','');	  read_Hall_file := true;	{ No matter what file we were reading if the data isn't there							we must specify another file to try. If some stds will be found in 							the fit results file to quantitate then Cancel from the file menu							when there are no more files to use. }	 end;	{If ( not found) then...}	UNTIL (found); 	{ WITH Hall_Output^^ do REPEAT...open files}    H_UnLock_Dispose(Handle(read_stuff),'read_stuff xx');  END;		{PROCEDURE Get_HallInfo;}  PROCEDURE Hall_Help;    VAR      tempRect                     : Rect;                  offset                       : integer;	  Left                         : integer;	  Top                          : integer;      n                            : integer;	  G_Help                       : DialogPtr;      itemHit                      : integer;      DType                         : Integer;      DItem                         : Handle;	  ExitDialog                    : Boolean; 	      CONST      G_Accept                      = 1;	  BEGIN                                              G_Help := GetNewDialog(433, NIL, POINTER( - 1));ShowWindow(G_Help);SelectWindow(G_Help);SetPort(G_Help);OutlineButton(G_Help, 1, 16); { outline the OK button }SetFont('Monaco', 9, []);offset := 12;Left := 5;Top := 15;		   n := 0;	  moveto(Left,Top);DrawString('The Hall type quantitation procedure is intended for spectra from thin specimens where some peak');	  n := n+1; moveto(Left,Top + n*offset);str := ' free region of the background provides a good measure of the mass thickness in the analytical volume.';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'This background region is usually chosen at the low energy end of the spectrum; it may require correction';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'for grid and film contributions. The average atomic number of the matrix in the analytical volume';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'is known approximately. This means the concentrations of the elements to be analyzed are low enough that';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'they do not appreciably effect the average atomic number. All elements not included in the estimate of';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'the matrix Z should be analyzed. The concentrations of the analyzed elements are reported for the "true"';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'composition of the analytical volume; the correction for the matrix average atomic number to true value';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'is reported. The Hall analysis may be run in two ways: it may be applied to a RESULTS file from a fitting';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'procedure. Or, a fitting procedure and Hall analysis may be set up for the WORK file; Hall is run when';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'the fitting is activated. There are some required PRELIMINARY STEPS. You must have a fit result from a ';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'statistically good SPECTRUM FROM A STANDARD for each element to be quantitated. BEFORE you run MLLSQ or';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'SIMPLEX on a standard spectrum, supply the composition of the standard and check THIS IS A STANDARD in ';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'the Spectrum Header. If no QUANT ROI is selected to measure background, a default region from 1.35 to ';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := '1.45 keV is used. Measured standard peak to background ratios are used to calculate the Hall K factors';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'that convert the P/B ratios from the unknown to concentrations. The fitting procedure for the unknown';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'spectra must be the same as for the standards. To correct background for support film, the specimen fit';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'results or spectrum file to quantitate may include a film, or a film spectrum file may be used. Be sure ';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'CLASS is set to "film" in Spectrum Header. To correct for a bulk contribution, a bulk spectrum must be';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'in the WORK file to quantitate, or a bulk spectrum fit result must be available. Set Spectrum Header';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'CLASS to "bulk" before fitting. You must include the bulk line in the fitting setup to quant a WORK file,';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'but no std is required. The bulk line closest to the chosen background region should be fit. ';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'Now, the dialog: As with most of the dialogs, clicking through the buttons in order is safe. ';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'SHOW A HALL FILE allows you to pick an old Hall results file to display. You can QUANTITATE a Fit Results';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'File (done when OK clicked), the spectrum in Work (OK then DO A FIT), or all the spectra in the Work File';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := '(OK then ANALYSIS: FIT ALL Work File SPECTRA). Check BULK and/or FILM and then supply the requested';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'information. Click STANDARDS to specify Fit Results Files with standards data. You may save/append and use';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'files of SETUP data (no Setup K factor, NO QUANT). If WORK or RESULTS is checked, OUTPUT OPTIONS allows';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'you only to name the binary results file which is always saved. To make text files';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'from a saved binary Hall file, enter the QUANT dialog and select only OUTPUT OPTIONS.';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'To make your choices active, click OK; to do nothing, CANCEL.  ';DrawString(str); n := n+1; moveto(Left,Top + n*offset); REPEAT  ModalDialog(NIL, itemHit);  GetDialogItem(G_Help, itemHit, DType, DItem, tempRect);  IF (itemHit = G_Accept) THEN	BEGIN	  ExitDialog := True;	END;UNTIL ExitDialog;		            DisposeDialog(G_Help);			BeginUpdate(BackPlane);			DrawAxesFull;			Update_Full;			EndUpdate(BackPlane);		    UpDate_SiLi_Window(SiLiWindow) ;END;                                              {End of Hall_Help procedure}	PROCEDURE D_DialHall;	const		I_Save_Setup = 3;		I_Use_Setup_File = 4;		I_Do_Accept = 1;		I_Exit = 2;		I_Do_Film_Correction = 5;		I_Do_Bulk_Correction = 6;		I_Read_File = 7;		I_Standards_included = 8;		I_Fit_Results = 9;		I_Work_Spectra = 10;		I_Quant = 11;		I_x12 = 12;		I_Get_AvgZ = 14;		I_Hall_Output = 15;		I_Show_Hall = 16;		I_Help      = 18;		I_Flowchart = 19;		I_Get_Stds  = 21;		I_AppendSetup = 22;		   var 		mytype : OsType;		myprompt : str255;		{bytecount,count	   		: Longint;}		errcode, refnum, setnum, setup_vol : integer;		use_setup_File, show_hall, save_setup,append_setup,		quant_fit, hall_accept, stds_zeroed, use_first : boolean;		ExitDialog, cancel_correction, no_LTAmp : boolean;		avgamps : real; 		 		GetSelection : DialogPtr;		tempRect : Rect;		DType : Integer;		Index,indek, numpks : Integer;		DItem : Handle;		CItem		 : controlhandle;		sTemp : Str255;		itemHit : Integer;		temp : Integer;		str,str1,str2,str3,str6   : str255; 			theEvent : EventRecord;		Hall_Spec : FSSpec;		AppendStuff : HallHdl;    PROCEDURE Refresh_Dialog;            BEGIN        SetPort(GetSelection);        GetDialogItem(GetSelection, I_Do_Accept, DType, DItem, tempRect);        PenSize(3, 3);        InsetRect(tempRect, - 4, - 4);        FrameRoundRect(tempRect, 16, 16);        PenSize(1, 1);      END;			PROCEDURE D_HallFileDial;	 {defines read_file}	const		I_OK = 1;		I_the_File_to_Quantitat = 2;		I__a_Fit_Results_File = 3;		I_x = 4;	{dialog instruction }		I_Element = 5;		I_Element_Text = 6;		I__a_Spectrum = 7;		I_Instruction = 8;		I_Cancel = 9;				    var 		ExitDialog : boolean; 		GetSelection : DialogPtr;		tempRect : Rect;		DType : Integer;		DItem : Handle;		CItem	 : controlhandle;		sTemp : Str255;		itemHit : Integer; 			    PROCEDURE Refresh_Dialog;	      	      BEGIN	        SetPort(GetSelection);	        GetDialogItem(GetSelection, I_OK, DType, DItem, tempRect);	        PenSize(3, 3);	        InsetRect(tempRect, - 4, - 4);	        FrameRoundRect(tempRect, 16, 16);	        PenSize(1, 1);	      END;   	 	Begin	{ D_HallFileDial; } 			GetSelection := GetNewDialog(729, nil,  Pointer(-1) );			ShowWindow(GetSelection);			SelectWindow(GetSelection);			SetPort(GetSelection);			 						Refresh_Dialog; 			ExitDialog:=FALSE;			if (Hall_Str = 'film') then begin			   HideDialogItem(GetSelection,I_Element);			   HideDialogItem(GetSelection,I_Element_Text);			   GetDialogItem(GetSelection, I__a_Fit_Results_File, DType, DItem, tempRect);			   CItem := controlhandle(DItem);			   HideControl(CItem);			   SetControlValue(CItem, 0);	{ turn the selection off }			   			   forecolor(redColor);			   textface([italic]);			   GetDialogItem(GetSelection,I_Instruction,DType,DItem,tempRect);{Get the item handle}			   stemp:='The film Spectrum Header or film Fit Result must have class set to "film".';			   SetDialogItemText(DItem,stemp);			   forecolor(blackColor);			   textface([]);			end			else if (Hall_Str = 'bulk') then begin 			   GetDialogItem(GetSelection,I__a_Spectrum,DType,DItem,tempRect);{Get the item handle}			   CItem := controlhandle(DItem); 			   HideControl(CItem);			   SetControlValue(CItem, 0);	{ turn the selection off }			   forecolor(redColor);			   textface([italic]);			   GetDialogItem(GetSelection,I_Instruction,DType,DItem,tempRect);{Get the item handle}			   stemp:='If you are doing the WORK spectrum file this line must be included in the LLSQ or Simplex setup, but no standard is required.';			   SetDialogItemText(DItem,stemp);			   textface([]);			   forecolor(blackColor);		    end;			repeat				ModalDialog(nil, itemHit);				GetDialogItem(GetSelection, itemHit, DType, DItem, tempRect);				CItem := controlhandle(DItem);				 				{Handle it real time}				if (ItemHit = I_Cancel) then cancel_correction := true;				if (ItemHit = I_OK) or (ItemHit = I_Cancel) then					ExitDialog:=TRUE;									if (ItemHit =I_the_File_to_Quantitat) or				   (ItemHit =I__a_Fit_Results_File) or (ItemHit =I__a_Spectrum) then{ radio button }				begin						GetDialogItem(GetSelection, I__a_Fit_Results_File, DType, DItem, tempRect);						SetControlValue(controlhandle(DItem), 0); { turn off the button }												GetDialogItem(GetSelection, I_the_File_to_Quantitat, DType, DItem, tempRect);						SetControlValue(controlhandle(DItem), 0); { turn off the button }												GetDialogItem(GetSelection, I__a_Spectrum, DType, DItem, tempRect);						SetControlValue(controlhandle(DItem), 0); { turn off the button }												SetControlValue(CItem, 1); { turn on the selected button }									    						if (ItemHit =I_the_File_to_Quantitat) then						begin						  if quant_fit then read_Hall_file := false						  else if (quant_work) then begin							if (MCA_Spectrum_Active = true) then read_Hall_file := false							else begin						        SetControlValue(CItem, 0); { turn off the button }								Putmessage('Uh-oh, there is no DTSA file active to read for the info!',											'Pick another option, or Cancel the Hall dialog and',											'open the DTSA file you want to quant.','');							end;	{else begin...}						  end;	{ else if (quant_work)...}						end	{if (ItemHit =I_the_File_to_Quantitat) then...}						else if (ItemHit =I__a_Fit_Results_File) then								read_Hall_file := true						else if (ItemHit =I__a_Spectrum) then								read_Hall_file := true				end;	{if (ItemHit =I_the_File_to_Quantitat) or...}			until ExitDialog;			if not (cancel_correction and (Hall_Str = 'bulk')) then begin			   GetDialogItem(GetSelection,I_Element,DType,DItem,tempRect);{Get the item handle}			   GetDialogItemText(DItem, sTemp);{Get the text entered}			   str := concat(stemp[1],stemp[2]);			   Hall_Setup^^.Bulk_Z := AtSymbol_to_Znum(str);			   IF ((ord(sTemp[3]) > 96) AND (ord(sTemp[3]) < 122))  THEN				   sTemp[3] := char(ord(sTemp[3]) - 32);	{ make it upper case }			   Hall_Setup^^.Bulk_Line := concat(stemp[3],'    ');			end;					tempRect := GetSelection^.portRect;		DisposeDialog(GetSelection);	    FillWhiteSpace(tempRect);		end;	{ procedure D_HallFileDial; }{$S Hall_3}      Procedure GetHallSetupInfo;		VAR 		index,indek		: integer;	BEGIN	  With Hall_Setup^^ do	  Begin	     use_first := true;		 number_of_peaks := 0;		 indek := 1;		 index := 1;	   { Hall_Setup^^.number_of_peaks should not include the derivatives if ML fit}		REPEAT	{Until index = analysis_result^^.Fit_Params.number_of_peaks;}		  str1:=('Uh-oh, my logic is wrong.');		  str := ('Fix me.');		  If ((Analysis_result^^.Fit_params.Fit_Procedure = 'Sm') and		      (analysis_result^^.Fit_Params.ref_index[index] >= 0)) or			 ((Analysis_result^^.Fit_params.Fit_Procedure = 'ML') and			  ( analysis_result^^.Fit_Params.ref_index[index] > 0 )) then		  Begin		   If Hall_Setup^^.number_of_peaks > 0 then		   With analysis_result^^ do		   Begin			 indek := 0;			 Repeat {go thru Hall stuff to see if element already accounted for...}			   indek := indek + 1;			   If Atomic_Number[indek] = Fit_Params.Atomic_Number[index]			   then begin				   str:=concat(a^.sym[Fit_Params.Atomic_Number[index]],Fit_Params.Siegbahn[index][1]);				   realtostring(Fit_Params.ev_loLine[index],4,2,str1);				   realtostring(Fit_Params.ev_hiLine[index],4,2,str2);				   str:= concat('and for ',str,' lines from ',str1,' to ',str2,' ev.');				   str1:=concat(a^.sym[Atomic_Number[indek]],Siegbahn[indek][1]);				   realtostring(ev_loLine[indek],4,2,str2);				   realtostring(ev_hiLine[indek],4,2,str3);				   str1 := concat('I have found fits for ',str1,' lines from ',str2,' to ',str3,' ev');				   use_first := answermessage(str1,str,											 'If IT`S OK, I`ll use the first set for the quant.',											 'If IT`s NOT OK, I`ll use the second set.');			   end;	{ If Atomic_Number[indek] = Fit_Params...}			 Until (indek = Hall_Setup^^.number_of_peaks) or				   (Atomic_Number[indek] = Fit_Params.Atomic_Number[index]);			 IF (Atomic_Number[indek] <> Fit_Params.Atomic_Number[index]) then				 indek := indek+1;		   End;	{ If number_of_peaks > 1...With analysis_result^^...}		   		   If (indek > Hall_Setup^^.number_of_peaks) or			  (not use_first)	{...not already accounted for or use the new lines}		   then begin			   Hall_Setup^^.K_Factor[indek] := 0.0;			   Hall_Setup^^.Std_File_Code[indek] := 0;			   Siegbahn[indek] := analysis_result^^.Fit_Params.Siegbahn[index];			   Atomic_Number[indek] := analysis_result^^.Fit_Params.Atomic_Number[index];			   ev_loLine[indek] := analysis_result^^.Fit_Params.ev_loLine[index];			   ev_hiLine[indek] := analysis_result^^.Fit_Params.ev_hiLine[index];			   If (indek > number_of_peaks) then number_of_peaks := indek;		   end;	{If (indek > number_of_peaks) or ...}		  		  End; {if (Analysis_result^^.Fit_params.Fit_Procedure = 'Sm')...}		   		  indek := index; {now use indek to hold index}		  With analysis_result^^,Fit_Params do		  Repeat{go thru anal res lines to next family}			  index := index + 1;		  Until (index > analysis_result^^.Fit_Params.number_of_peaks) or				(ev_loLine[indek] <> ev_loLine[index]) or				(ev_hiLine[indek] <> ev_hiLine[index]);		  {...index is now counter for next ele in anal res}				UNTIL (index > analysis_result^^.Fit_Params.number_of_peaks);	   	  End;	{ With Hall_Setup^^...}					END; {Procedure GetHallSetupInfo;...}		Procedure WritetoSetup;		Var		index, outnum, n : integer;		str,str1	: str255;		BEGIN	  errCode := FSOpen_err(Outname, setup_vol, outnum,'WritetoSetup: cannot open setup');	  B_count := Sizeof(Hall_Stuff); 	  IF errCode = NoErr THEN 	  BEGIN		 if append_setup then		 begin	{read data from setup file into AppendStuff}			 AppendStuff := HallHdl(NewHandle(sizeof(Hall_stuff)));			 HLock(Handle(AppendStuff));			 errCode := FSRead_err(outnum, B_count, @AppendStuff^^,'WritetoSetup:read @AppendStuff^^');			 			 setnum := 5;			 temp := 0;			 repeat			{find out how many Standard_files names have been stored}			  temp := temp + 1;			 until (temp = 5) or (AppendStuff^^.Standard_files[temp] = ' ');			 if AppendStuff^^.Standard_files[temp] = ' ' then setnum := temp - 1;						 {numpks := Hall_Setup^^.Number_of_Peaks;}	{...the new stuff}			 indek := AppendStuff^^.Number_of_Peaks;	{...the old stuff}			 numpks := indek;	{increment if adding, not replacing values}			 			 With  Hall_Setup^^ do for index := 1 to Number_of_Peaks do			 begin	{look for new stds data in old setup data}			   found := false;			   hall_accept := false;			   temp := 0;			   Repeat			   	temp := temp + 1;			   	if (AppendStuff^^.Atomic_Number[temp] = Atomic_Number[index]) and				   (AppendStuff^^.Siegbahn[temp] = Siegbahn[index])			   	then begin			   	  found := true;			   	  str := concat('The setup file has a K factor for ',a^.sym[Atomic_Number[index]],Siegbahn[index][1]); 			   	  hall_accept := answermessage(str,'If it`s OK I`ll replace it.','','');			   	end;			   Until (temp = indek) or found;			   if not found then begin			       numpks := numpks + 1;			       temp := numpks;	{...to add rather than replace values}			   end;			   if (not found) or (hall_accept) then	{add if not found, replace if hall_accept}			   begin {temp is new numpks if not found, or is cntr of set to replace}		        AppendStuff^^.Atomic_Number[temp] := Atomic_Number[index];		        AppendStuff^^. Siegbahn[temp] := Siegbahn[index];		        AppendStuff^^.ev_LoLine[temp] := ev_LoLine[index];		        AppendStuff^^.ev_HiLine[temp] := ev_HiLine[index];		        AppendStuff^^.K_Factor[temp] := K_Factor[index];		        {if we're using the new file at all need to inc setnum...}		        found := false;		        n := 0;		        Repeat		           n := n + 1;		           if AppendStuff^^.Standard_files[n] =		              Standard_files[Std_File_Code[index]] then		              found := true;		        Until (n = setnum) or found;		        If found then AppendStuff^^.Std_File_Code[temp] := n		        Else if setnum < 5 then		        begin		            setnum := setnum + 1;			        AppendStuff^^.Std_File_Code[temp] := setnum;			        AppendStuff^^.Standard_files[setnum] :=			              Standard_files[Std_File_Code[index]];	{fnamestr}			    end			    else begin			        AppendStuff^^.Std_File_Code[temp] := 5;			        AppendStuff^^.Standard_files[5] := 'Not stored.';	{fnamestr}			    end;			   end;	{if (not found) or (hall_accept)...} 		     end;	{With  Hall_Setup^^ do for index := 1 to Number_of_Peaks do...}		     AppendStuff^^.Number_of_Peaks := numpks;		 end;	{if append_setup...}	    	     errCode := SetEof(outnum,0);	{ in case using old filename}		 errCode := SetFPos_err(outnum, fsFromStart,0,'fsFromStart');		 if append_setup then		      errCode := FSWrite_err(outnum, B_count, @AppendStuff^^,'write @AppendStuff^^')		 else errCode := FSWrite_err(outnum, B_count, @Hall_Setup^^,'write @Hall_Setup^^');		 errCode := FSClose(outnum);		 errCode := FlushVol(NIL, setup_vol);		 H_UnLock_Dispose(Handle(AppendStuff),'dispose Hall AppendStuff Hdl');	  END	{IF errCode = NoErr...}	  ELSE		 putmessage('Uh-Oh! The file did not open to save setup.',					'After I`m done you can go back to the dialog, ',					'turn off QUANT WORK and QUANT FIT, ',					'select SAVE SETUP or APPEND SETUP and ACCEPT');	END; {Procedure WritetoSetup;}	BEGIN	{  main PROCEDURE D_DialHall; }	     		GetSelection := GetNewDialog(730, nil,  Pointer(-1) );			ShowWindow(GetSelection);			SelectWindow(GetSelection);			SetPort(GetSelection);			 			{Setup initial conditions}			Refresh_Dialog;			Use_Setup_File := false;			hall_accept := false;			show_hall := false;			show_one := false;			show_setup := false;			save_setup := false;			append_setup := false;			stds_zeroed :=  false;			ExitDialog := FALSE;			quant_work := false;			quant_fit := false;			Do_HallOutput := false;			Make_Hall := false;			no_LTAmp := false;		    Hall_Setup^^.get_stds := false;			  {The stds data MUST come from other fit results files			   for now. You cannot get_stds from the file to quant unless it is a fit result file			   and you specify it to read as one of the stds files}			IF Hall_active then begin			   GetDialogItem(GetSelection,I_Get_AvgZ,DType,DItem,tempRect);{Get the item handle}			   realtostring(Hall_Setup^^.Average_Z,4,2,stemp);			   SetDialogItemText(DItem, sTemp);{set the value read from file}			   			   if (Hall_setup^^.get_film) or				  (Hall_setup^^.FilmCorr <> 0.0)  then begin				 GetDialogItem(GetSelection,I_Do_Film_Correction,DType,DItem,tempRect);{Get the item handle}				 SetControlValue(controlhandle(DItem), 1);				 end;			   if (Hall_setup^^.do_bulk) then begin 				 GetDialogItem(GetSelection,I_Do_Bulk_Correction,DType,DItem,tempRect);{Get the item handle}				 SetControlValue(controlhandle(DItem), 1);				 end;			END;	{IF Hall_active then begin...}			REPEAT	{ 	until ExitDialog; }				ModalDialog(NewModalFilterProc(@DefaultFilter), itemHit);				GetDialogItem(GetSelection, itemHit, DType, DItem, tempRect);				CItem := controlhandle(DItem);								if (ItemHit =I_Save_Setup) then { immediate action button }				begin				   append_setup := false;	    		   Outname := 'Hall_SetupSav';   { the user's choice replaces this }				   if (CreateFile(Outname, 'Save Hall Setup File:') = True) OR								   (File_Cancel_Button = False) then;				   IF (File_Cancel_Button) THEN				   begin				   		  setup_vol := Out_VolRefNum;				          errCode := Create(Outname, setup_vol, 'DTSA', 'Hals');						  save_setup := true;				   end;			       Refresh_Dialog; 				end;	{if (ItemHit = I_Save_Setup)...}								If (ItemHit = I_AppendSetup) then				begin {this is so we can get a complete set of K factors into 				       one setup/k factor file}                  mytype := 'Hals';                  myprompt := 'Append Setup File:';                  REPEAT                  UNTIL (GetFileName(Outname, mytype, mytype, myprompt)) OR				        (File_Cancel_Button = FALSE);                  IF (File_Cancel_Button) THEN                  BEGIN					     setup_vol := in_volrefnum;					     append_setup := true;                  END;	{IF (File_Cancel_Button)...}			      Refresh_Dialog; 				end;	{ ItemHit = I_AppendSetup}				 								If (ItemHit =I_Hall_Output) then				begin				 IF (quant_Work or quant_fit) THEN { name the Hall binary File to be made }				 BEGIN	    		   Hall_name := Concat('Hall_',MCA_ResultsName);   { the user's choice replaces this }				   if (CreateFile(Hall_name, 'Name binary Hall File:') = True) OR								   (File_Cancel_Button = False) then;				   {CreateFile makes a FSSpec record and calls Get_WDInfo to define volume name in 				    OutVol_volname;volume ref number in OutVol_volnum;DirID in OutVol_DirID}				   IF (File_Cancel_Button) THEN				   begin				    Make_Hall := true;				    Hall_vol := Out_VolRefNum {...working directory refnum}						(*  My_File_Info[rindex].volname := myWDblock.ioNamePtr^;			 	My_File_Info[rindex].theDirID := myWDBlock.ioWDDirid; {dir id}				My_File_Info[rindex].volnum := myWDBlock.ioWDVRefNum;{always volume ref number}			*)	   end;	{IF (File_Cancel_Button)...}				 END	{If (quant_Work or...}				 ELSE BEGIN	{ can only do options after quant on old Hall file }				  Do_HallOutput := true;	{so correct text appears in D_Results_Options} 				  Binary_choice := false;   {so correct text appears in D_Results_Options}				  REPEAT	{...UNTIL (not Do_HallOutput);}					mytype := 'MCAH';					myprompt := 'Hall file for output?';					REPEAT					UNTIL (GetFileName(Hall_name, mytype, mytype, myprompt) = True) OR 						  (File_Cancel_Button = False);					{GetFileName makes a FSSpec using the working dir refnum and filename; calls					 Get_WDInfo to define volume name in InVol_volname; volume ref number in					 InVol_volnum; DirID in InVol_DirID}				   If (File_Cancel_Button) then				   Begin		 			Hall_vol := In_VolRefNum; {working dir refnum from GetFileName.}					Hall_Spec := In_Spec;					D_Results_Options;	{ in CurveFit: defines ascii file specs  }						If  Do_HallOutput Then					Begin {false if Cancel from D_Results_Options}					{ errCode := FSOpen_err(Hall_Name,Hall_Vol, FileRefNum,'');}					 errCode := FSpOpenDF(Hall_Spec,fsRdPerm,FileRefNum);					 if errcode <> noerr then 					 	errCode := FSOpen_err(Hall_Name,Hall_Vol, FileRefNum,'');					 if errcode = noerr then begin					   {read the Hall file only to get the MCA file info...}					   bytecount := sizeof(Hall_Stuff);					   errcode := FSRead(FileRefNum, bytecount, @Hall_Setup^^);					   bytecount := sizeof(Hall_OutStuff);					   errcode := FSRead(FileRefNum, bytecount, @Hall_Output^^);					   bytecount := sizeof(Hall_Stuff);					   errcode := SetFPos_err(FileRefNum,FSFromStart,bytecount,'');					   {put marker back to start of Hall_Output for reads in WriteFitResults}	   				   MCA_ResultsName := '';					   {size of Hall_Output^^.ResultsName < MCA_ResultsName...fields were						resultsname: String[61]; ResultsVNum: integer; are now 						resultsname: String[57],ResultsDirId:longint, ResultsVNum: integer}					    blockmove(@Hall_Output^^.ResultsName,@MCA_ResultsName,sizeof(Hall_Output^^.ResultsName));				 		{define the MCA info...}						MCA_ResultsDirID := Hall_Output^^.ResultsDirId;{probably junk for old Hall}		  				MCA_ResultsVNum := Hall_Output^^.ResultsVNum;{good number}				        MCA_Results_VolNum := Hall_Vol; {...for older file, a good guess??}				        MCAResult_Spec.ParID := MCA_ResultsDirID;				        MCAResult_Spec.VRefNum := MCA_ResultsVNum;				        MCAResult_Spec.name := MCA_ResultsName;						{MCA_Results_VolNum is always a WD number...ResultsVNum is not}						{If the dirid is a nonsense number or doesn't work then 						 Hall_Output^^.ResultsVNum is probably a WD number not a volume number.}					  Repeat					   {so first try WD = Hall_Vol num for old files. If it works					    then get the WDinfo so that HOpenDF can be used in WriteFitResults...}					   err := FSpOpenDF(MCAResult_Spec,fsRdPerm,Hold_RefNum);					   if err <> noerr then					     err := FSOpen(MCA_ResultsName,MCA_Results_VolNum, Hold_RefNum);					   if err <> noerr then					   begin	{try MCA_ResultsVNum as a WD...}					     err := FSOpen(MCA_ResultsName,MCA_ResultsVNum, Hold_RefNum);						 If err = noerr then MCA_Results_VolNum := MCA_ResultsVNum;					   end;					   					   if err <> noerr then {try vol num and dir id...}				         err := HOpenDF(MCA_ResultsVNum,MCA_ResultsDirID,MCA_ResultsName,FSRdPerm,Hold_RefNum);					   				   					   					   if err <> noerr then					   begin					       Do_HallOutput := false;						   if err = nsverr then						   begin							  str := concat('I need the fit results file ',MCA_ResultsName,'.');							  Do_HallOutput := answermessage(str,'It`s on some other volume. If it is a floppy,',									  'load it, then click IT`s OK.','Otherwise, click IT`s NOT OK.'); 							  if Do_HallOutput then							  repeat								  Do_HallOutput := GetNextEvent(diskMask, theEvent);							  until Do_HallOutput;						   end						   else if err = BdNamerr then putmessage('Something is wrong with the filename',MCA_ResultsName,'I can`t open it.','') 						   else if err = fnferr then putmessage('I can`t find the fit results file',MCA_ResultsName,' Please put it in the same folder as',Hall_name) 						   else begin							  putmessage('Err opening',MCA_ResultsName,'Please examine it and','if it`s OK, try again.');							  err := fnferr						   end;					   end	{ if err <> noerr...}					   else begin						 						 If ((Plain_Boolean) or (Spread_Boolean))						 then  begin						 	do_ascii := true;							{the Hall file is open at the start of Output data;							 the fit results file is identified but closed}							WriteFitResults; 	{make ascii files from old Hall only}                            do_ascii := false;						 end;						 						 Do_HallOutput := false;					   end;	{else begin...}				      Until (not Do_HallOutput); 				      err := FSClose(FileRefNum);	{...the Hall file}					  err := FlushVol(NIL, Hall_vol);					 end	{ if errcode = noerr...}					 else putmessage('There was an error opening the Hall file.','Try again.','','');					 Do_HallOutput := true;{so you can make more output...}					End;	{ If  Do_HallOutput...}				   End	{If (File_Cancel_Button)...}				   Else Do_HallOutput := false;				  UNTIL (not Do_HallOutput);		(*	        Do_HallOutput := true; *)	{...should in general be false.}					MCA_File_Boolean := False;					Plain_Boolean := false;					Spread_Boolean := false; 					Binary_Choice:=true;	{ this must be the default condition }				end;	{else begin	...}				 Refresh_Dialog; 		    end;	{if (ItemHit...}				 				 			 if (ItemHit =I_Show_Hall) then begin				mytype := 'MCAH';				myprompt := 'Get Hall File';				  Repeat		          Until (GetFileName(showname, mytype, mytype, myprompt)) or		                (File_Cancel_Button = False);		          IF (File_Cancel_Button) then		          begin						show_hall:=true;						show_vol:= In_VolRefNum;						show_one := false;						show_setup := false;						exitDialog := true; {...can't wait for an Accept because											 show_hall takes us to the main event loop}				  end;			end;	{ if (ItemHit =I_Show_Hall)...}			IF (ItemHit =I_Use_Setup_File) THEN			BEGIN  { immediate action button }			  If (quant_work or quant_fit) then		      Begin			        Use_setup_file := false;					mytype := 'Hals';					myprompt := 'Get Hall Setup File';					Repeat				    Until (GetFileName(Outname, mytype, mytype, myprompt) = True) OR 						  (File_Cancel_Button = False);					IF (File_Cancel_Button) THEN					BEGIN					    setup_vol := in_volrefnum;					    errcode := FSOpen_err(Outname,setup_vol,setNum,'');					    IF errCode = NoErr then begin						   errcode := SetFPos_err(setnum,fsFromstart,0,'');						   bytecount := sizeof(Hall_Stuff);						   errcode := FSRead(setNum,bytecount,@Hall_Setup^^);						   if ((errcode = noerr) or (errcode = eoferr)) then						   	Use_setup_file := true;						   errcode := FSClose(setNum);						   errcode := FlushVol(nil,setup_vol);				  		   If Use_setup_file = true then				  		   Begin						     GetDialogItem(GetSelection,I_Get_AvgZ,DType,DItem,tempRect);{Get the item handle}						     realtostring(Hall_Setup^^.Average_Z,4,2,stemp);						     SetDialogItemText(DItem, sTemp);{set the value read from file}						   						     if (Hall_setup^^.FilmCorr <> 0.0)  then begin							   GetDialogItem(GetSelection,I_Do_Film_Correction,DType,DItem,tempRect);{Get the item handle}							   SetControlValue(controlhandle(DItem), 1);							 end;						     if (Hall_setup^^.do_bulk) then begin 						       GetDialogItem(GetSelection,I_Do_Bulk_Correction,DType,DItem,tempRect);{Get the item handle}							   SetControlValue(controlhandle(DItem), 1);							 end; 						   {use the setup value unless the check box is unclicked and						   	then clicked on again:}							 Hall_setup^^.get_film := false;							 Hall_setup^^.get_grid := false;							 stds_zeroed := true;						  End;	{if Use_setup_file = true...}						END;	{ IF errCode = NoErr then...}					END;	{ IF (File_Cancel_Button...}			        Refresh_Dialog;			  end	{ if quant_work...}			  else putmessage('Please pick Quant Work or Quant Fit first.','','','');			END;	{ if (ItemHit =I_Use_Setup_File)...} 									if (ItemHit =I_Do_Accept) then {button}				begin				    if ((not quant_work) and (not quant_fit) and (not Show_Hall) and					    (not save_setup) and (not Do_HallOutput) and (not Append_setup)) then					begin					  Hall_accept := false;					  ExitDialog:=TRUE;					end					else begin					  Hall_accept := true;					  ExitDialog:=TRUE;					end;				end;								if (ItemHit =I_Exit) then				begin					ExitDialog:=TRUE;					Hall_accept := false;				end;								if (ItemHit =I_Help) then				begin					Hall_Help; 				end;								if (ItemHit =I_Flowchart) then				begin					Flow_Chart(440); 				 Refresh_Dialog; 				end;    			if (ItemHit =I_Do_Film_Correction) then				{checkbox...filedial either reads a  spectrumfile for the value or				 sets get_film true -> get the value from the file to quant}				begin				    cancel_correction := false;					temp := GetControlValue(CItem);					SetControlValue(CItem, (temp + 1) mod 2);					if (temp = 0) then					begin					     Hall_Setup^^.get_film := false;						 Hall_Str := 'film';						 D_HallFileDial;	{ defines boolean read_file }						 Refresh_Dialog;						 If cancel_correction then SetControlValue(CItem,0)						 else begin							 If ( read_Hall_file ) then Get_HallInfo { gets correction from spectrum file}				             else Hall_Setup^^.get_film := true;								 { If not read_file then doing work and data is in one of the files,								   find it and get correction when dialog input complete;								   or have data from the setup file. }						 end;					end;				end;								if (ItemHit = I_Do_Bulk_Correction) then				begin				    cancel_correction := false;				    Hall_Setup^^.get_grid := false;					temp := GetControlValue(CItem);					SetControlValue(CItem, (temp + 1) mod 2);					if (temp = 0) then					begin			             Hall_Setup^^.get_grid := false;						 Hall_Str := 'bulk';     					 D_HallFileDial;	{ defines boolean read_file }						 If cancel_correction then SetControlValue(CItem,0)						 else begin						    Hall_Setup^^.do_bulk := true;							If ( read_Hall_file ) then Get_HallInfo { returns grid correction factor}							else begin								 	if (quant_work) and (MCA_Spectrum_Active <> true) then									begin									   GetDialogItem(GetSelection, I_Do_Bulk_Correction, DType, DItem, tempRect);							           SetControlValue(controlhandle(DItem),0);								       Hall_Setup^^.do_bulk := false;									end								 	else Hall_Setup^^.get_grid := true;	{find a bulk spectrum in the quant file}						   end;	{else begin...}						 end;	{If cancel_correction...}						 { If not read_file then must be batch: data is in one of results/spectra.						   If spectrum, it will be found and fit, and the bulk info set.}				         Refresh_Dialog; 				    end;	{If (temp=0) then begin...}				end;								if (ItemHit = I_Get_Stds) then					begin					temp := GetControlValue(CItem);					SetControlValue(CItem, (temp + 1) mod 2);					if (temp = 0) then					begin					  if (stds_zeroed = false) then begin	{have not yet checked standards_included}					     stds_found := 0;					     for index := 1 to 5 do Hall_Setup^^.Standard_files[index] := ' ';					     for index:= 1 to MaxNumPks do					     begin							Hall_Setup^^.K_Factor[index] := zero;							Hall_Setup^^.Std_File_Code[index] := 0;					     end;					     stds_zeroed := true;					  end;	{if (stds_zeroed = false) ...}					  Hall_Str := 'stan';					  read_Hall_file := true;					  Get_HallInfo; { returns some or all k factors}					end;	{if (temp = 0)...}				    Refresh_Dialog;				end;	{ if (ItemHit = I_Get_Stds)...}												if (ItemHit =I_Work_Spectra) then	{ stds MUST be in results files or setup file }				begin		{ radios: if one turns on the other turns off }					for Index := I_Fit_Results  to I_Work_Spectra do					begin						GetDialogItem(GetSelection, Index, DType, DItem, tempRect);						SetControlValue(controlhandle(DItem), 0);	{ turn all buttons off }					end;	{for Index := I_Fit_Results...}										SetControlValue(CItem, 1);	{ turn the selection on }				    Quant_Work := true;	{we set this false below if something is wrong}		            quant_fit := false;				   IF ( not LLSQ_active) and (not Simplex_Active) then 				   begin						   putmessage(' Sorry. To quantitate Work Spectra',									  ' you must set up either ML or Simplex.','Either CANCEL or pick','Fit Result');						   Use_setup_file:=false;				           Quant_Work := false;	{we set this false below if something is wrong}						(* Hall_accept := false;						   exitDialog := true;	...out 9/30/96 *)				   end	{IF ( not LLSQ_active) and ...}			       else if (not MCA_OptionsBoolean) then				   begin						  temp:=0;						  if (CreateFile(OutName, 'Please name the Fit Results:') = True) OR 						  (File_Cancel_Button = False) then;						  If (File_Cancel_Button) then begin						        MCAResult_Spec := Out_spec;								MCA_Results_VolNum := Out_VolRefNum;								MCA_ResultsName := Outname;								MCA_ResultsDirID := MCAResult_Spec.parID;								MCA_ResultsVNum := MCAResult_Spec.VRefNum;								MCA_File_Boolean := false;{file will be made in MakeBinaryResults}								MCA_OptionsBoolean := true;{...didn't use D_Results_options}						  end;					end;	{if (not MCA_OptionsBoolean)...}										IF (ROI^^.Quant.Exists = False) THEN					   if ( Answermessage('You have not chosen a Quant background.',							  'You can EXIT, go to ROI and choose a Quant background;',							  ' or, if IT`S OK, I`ll use a region from 1.45 to 1.54 keV.',''))					   then with Plt_Spec[10]^^,Expt_Info do					   begin						   ROI^^.Quant.exists := true;						   ROI^^.Quant.Lo := rinttol((1450 * energy_slope + energy_intercept) / dE);						   ROI^^.Quant.Hi := rinttol((1540 * energy_slope + energy_intercept) / dE);						   Analysis_result^^.Fit_params.Chosen_roi_Lo:=1450;						   Analysis_result^^.Fit_params.Chosen_roi_Hi:=1540;					   end	{if ( Answermessage...with...}					   else begin						   Hall_Active := false;						   Use_setup_file:=false;						   Quant_Work := false;				           quant_fit := false;					   end;	{if ( Answermessage...else begin...}									       If quant_work then With Hall_Setup^^,					   Plt_Spec[10]^^, Expt_Info, SpectrumStuff, Spectrum_Info,Acq_Info					   Do begin { if use setup must not redefine Hall_Setup peak info}						   Analysis_result^^.Fit_params.Chosen_roi_Lo:=						   		(ROI^^.Quant.Lo * dE - energy_intercept)/energy_slope;						   Analysis_result^^.Fit_params.Chosen_roi_Hi:=						   		(ROI^^.Quant.Hi * dE - energy_intercept)/energy_slope;															GetHallSetupInfo;	{If you pick a setup file,							                     Hall_setup is redefined...}					   					   	   avgamps := (end_faraday + begin_faraday)/2.0;						   If ((Live_Time <= 0.0) or ( avgamps <= 0.0)) then no_LTAmp := true; 					   End;	{If quant_work then With Hall_Setup^^...}				     Refresh_Dialog; 				end;	{if (ItemHit =I_Work_Spectra)...}									{ radios: if one turns on the other turns off }				if (ItemHit =I_Fit_Results)  then	{ stds may be read from other files as well }				begin				   for Index:=I_Fit_Results  to I_Work_Spectra do					begin						GetDialogItem(GetSelection, Index, DType, DItem, tempRect);						SetControlValue(controlhandle(DItem), 0);	{ turn all buttons off }					end;				   SetControlValue(CItem, 1);	{ turn the selection on }					mytype := 'MCAb';					The_File_name := 'FileName';					myprompt := ' Fit Results File to quantitate? ';				   {GetFileName sets the Vol to that chosen in the file menu }				   Repeat				   Until (GetFileName(The_File_Name, mytype, mytype, myprompt) = True) OR 						 (File_Cancel_Button = False);				   IF (File_Cancel_Button) THEN 	{ a file was picked }				   begin					 MCAResult_Spec := In_Spec;					 MCA_Results_VolNum := In_volrefnum;	{WD for FSOpen_err below}					 MCA_ResultsName := The_File_Name;					 MCA_ResultsDirID := In_Spec.parID; {=>Hall_Output^^.ResultsDirId};					 MCA_ResultsVNum := In_Spec.VRefNum; {=>Hall_Output^^.ResultsVNum};					 MCA_File_Boolean:=true;					 { Get info for finding standards...using WD number here }					 errCode := FSOpen_err(MCA_ResultsName,MCA_Results_VolNum, refnum,'');					 errCode := SetFPos_err(refnum, fsFromStart,0,'');					 bytecount := 1;					 errCode := FSRead(refnum, bytecount, @is_batch);					 errcode := GetEOF(refnum,bytecount);					 if (bytecount >= 2 * sizeof(Simplex_fit) + 1) and (not is_batch) 				        then File_Cancel_Button := answermessage(' This is not a batch file.',								  ' ONLY if the all analysis results are for the same set of lines, will the quantitation work.',								  'If It`s OK, I`ll go on.','If It`s Not OK, pick another file or Cancel.');				   End;	{IF (File_Cancel_Button) ...}				   				   IF (File_Cancel_Button) THEN 	{ a good file was picked }				   begin					 bytecount := sizeof(Simplex_fit);					 err := FSRead(refnum, bytecount, @Analysis_Result^^);					 errcode := FSClose(refNum);					 errcode := FlushVol(nil,MCA_Results_VolNum);				     If (err = noerr) or (err = eoferr) then				     begin				      	quant_fit := true;				     	Quant_Work := false;						With Hall_Setup^^ do GetHallSetupInfo;						{...If you pick a setup file,Hall_setup is redefined.}				  					    With Analysis_Result^^.SpectrumStuff.Acq_Info					    Do Begin					   	   avgamps := (end_faraday + begin_faraday)/2.0;						   If ((Live_Time <= 0.0) or ( avgamps <= 0.0))						   then no_LTamp:= true; 					    End;	{With Hall_Setup^^...}				     end;	{If (err = noerr) or...}				  End 	{ IF (File_Cancel_Button)...}				  ELse IF (not File_Cancel_Button) then				  begin 				    SetControlValue(CItem, 0);	{ turn the selection back off }				    quant_fit := false;				  end;				Refresh_Dialog;			end;	{if (ItemHit = I_Fit_Results) ...}												if ((ItemHit = I_Use_Setup_File) and Use_Setup_File) then		    with analysis_result^^.Fit_Params do begin 			   IF ((Fit_Procedure = 'Sm') or Simplex_active) and (Hall_setup^^.Siegbahn[1][2] = ' ') then			   BEGIN 				    putmessage(' The Hall setup file is for an MLLSQ fit,',				    		   ' but the quant file fitting procedure is SIMPLEX.',							   ' Please choose a Hall setup file for a Simplex fit or',							   ' exit and setup an MLLSQ fit to the file. ');						   Use_Setup_File := false;					GetDialogItem(GetSelection,I_Do_Film_Correction,DType,DItem,tempRect);{Get the item handle}					 SetControlValue(controlhandle(DItem), 0);				    GetDialogItem(GetSelection,I_Do_Bulk_Correction,DType,DItem,tempRect);{Get the item handle}					 SetControlValue(controlhandle(DItem), 0);			   END	  		   ELSE  IF ((Fit_Procedure = 'ML') or LLSQ_active) and (Hall_setup^^.Siegbahn[1][2] <> ' ') then	  		   BEGIN 				    putmessage(' The Hall setup file is for a Simplex fit,',				               ' but the fitting procedure is MLLSQ.',							   ' Please choose a Hall setup file for an MLLSQ fit or',							   ' EXIT and setup a Simplex fit to the file. ');					Use_Setup_File := false;					GetDialogItem(GetSelection,I_Do_Film_Correction,DType,DItem,tempRect);{Get the item handle}					 SetControlValue(controlhandle(DItem), 0);				    GetDialogItem(GetSelection,I_Do_Bulk_Correction,DType,DItem,tempRect);{Get the item handle}					 SetControlValue(controlhandle(DItem), 0);			   END	{ELSE IF (Use_Setup_File)...}			   ELSE BEGIN				(*   index:=1;				   numpks := Hall_setup^^.number_of_peaks;	{this value comes from setup file}				   str6:=' ';				   Repeat	{is there a k_factor for each peak? Don't include derivatives. }					If ((Analysis_result^^.Fit_params.Fit_Procedure = 'Sm') and					    (analysis_result^^.Fit_Params.ref_index[index] >= 0 )) or					    (( analysis_result^^.Fit_Params.Siegbahn[index][4] <> 'D') and					     ( analysis_result^^.Fit_Params.ref_index[index] > 0 ))					then  begin						 indek:=0;					 stds_found:=0;					 repeat	{go thru setup data until match or no more data}						indek:=indek+1;					 until (indek = Hall_setup^^.number_of_peaks + 1) or						   ((Hall_setup^^.Atomic_Number[indek] = Atomic_Number[index]) or						    (Hall_setup^^.Siegbahn[indek][1] = Siegbahn[index][1]));					 if (indek = Hall_setup^^.number_of_peaks + 1) then					 begin				           numpks := numpks + 1;	{no setup data found}						   str6 := concat(str6,A^.Sym[analysis_result^^.Fit_Params.Atomic_Number[index]],' ',						   				  analysis_result^^.Fit_Params.Siegbahn[index]);				     	   Hall_setup^^.Siegbahn[numpks] := Siegbahn[index];					 	   Hall_setup^^.Atomic_Number[numpks] := Atomic_Number[index];				           Hall_setup^^.ev_loLine[numpks] := ev_loLine[index];						   Hall_setup^^.ev_hiLine[numpks] := ev_hiLine[index];						   Hall_setup^^.K_factor[numpks] := 0;	{no setup data found}					 	   stds_zeroed := true; { as if we read a stds file for the k factors }					 end	{ if (indek = Hall_setup^^.number_of_peaks + 1)...}					 else stds_found := stds_found + 1;					end;	{If( analysis_result^^.Fit_P... then begin...}					index := index + 1;				   Until (index = analysis_result^^.Fit_Params.number_of_peaks + 1);				   { have either found an entry in Hall_setup for each analysis_result peak, or added				     the line to Hall_setup with a zero k_factor to be supplied by READ STDS or				     to not quant. }				   if (str6 <> ' ') then begin				       putmessage('There is no data in the Hall setup file for',str6,							      ' Select STANDARDS to read other files with the missing data.',							      'Or I won`t quant those lines.');				   end	{ if (stds_found < Analysis_Result^^...}				   else Hall_Setup^^.get_stds := false;			       Refresh_Dialog;			 *)			  END;	{IF ((Fit_Procedure = 'Sm') or....END ELSE BEGIN...}			END; {if ((ItemHit = I_Use_Setup_File)...with...}						if (no_LTAmp = true) and			   (((ItemHit = I_Fit_Results) and quant_fit) or			    ((ItemHit = I_Work_Spectra) and quant_work)) then			begin			    str6 := 'is zero in the Work File.';			    if (quant_fit) then str6 := 'is zero in the Results File.';		    	if answermessage('Either the livetime or Faraday current',		    			         str6,		    			         'If It`s OK, I`ll go on with no film corrections.',		    			         'If It`s NOT OK, I`ll quit so you can fix the problem.')		    	then begin		    		Hall_Setup^^.FilmCorr := 0.0;		    		Hall_Setup^^.get_film := false;					GetDialogItem(GetSelection,I_Do_Film_Correction,DType,DItem,tempRect);					 CItem := Pointer(DItem); 					 HiliteControl(CItem, 255);						 SetControlValue(CItem, 0);		    	end		    	else ExitDialog := true;		   end;	{(no_LTAmp = true) and...}		UNTIL ExitDialog; 				IF (Hall_accept) then		BEGIN			if (quant_work or quant_fit) then 			BEGIN	{ do on exit from dialog }			   GetDialogItem(GetSelection,I_Get_AvgZ,DType,DItem,tempRect);{Get the item handle}			   GetDialogItemText(DItem, sTemp);{Get the text entered}			   Hall_Setup^^.Average_Z:=Mystr2num(stemp);			   			   GetDialogItem(GetSelection, I_Do_Film_Correction, DType, DItem, tempRect);			   temp := GetControlValue(controlhandle(DItem));			   if (temp = 0) then begin			        Hall_Setup^^.get_film := false;			   		Hall_Setup^^.Filmcorr := zero;				end;			   GetDialogItem(GetSelection, I_Do_Bulk_Correction, DType, DItem, tempRect);			   temp := GetControlValue(controlhandle(DItem));			   if (temp = 0) then begin					Hall_Setup^^.do_bulk := false;			   		Hall_Setup^^.Bulk_Factor := zero;					Hall_Setup^^.get_grid := false;			   end;				{ we either have a setup file value or get_grid is true }			 				Hall_active := true;			  				if Hall_Setup^^.get_film then {this is done after accept in case use_setup}				begin {otherwise we read a file above or have setup file value}				    read_Hall_File := false;					Hall_Str := 'film';					Get_HallInfo;	{ get film data from the results or work file to quant } 				end;							    if (Hall_Setup^^.get_stds) then begin					if (stds_zeroed = false) then begin	{ all stds are in the results file;					      if stds_zeroed is is true, some of them were found in the setupfile						  or some stds file so they shouldn't be zeroed }					   stds_found := 0;					   for index := 1 to 5 do Hall_Setup^^.Standard_files[index] := ' ';					   for index:= 1 to MaxNumPks do 										Hall_Setup^^.K_Factor[index] := zero;					   stds_zeroed := true;					end;					 Hall_Str := 'stan';					 read_Hall_file := false; { the file to use is the results file to quant }					 Get_HallInfo;            { looks for the other stds data in the results file}			    end;	{if (Hall_Setup^^.get_stds)...}			    if Hall_setup^^.get_grid then begin			   		If (Quant_work) then begin					  tempRect := GetSelection^.portRect;					  DisposeDialog(GetSelection);					  FillWhiteSpace(tempRect);					  mouse_active_window;					  exitDialog := false;	{ so we don't try to dispose of the dialog again below }					  FitBulk;	{ this writes to window via simplex or mlfit }					end					Else begin					   read_Hall_File := false;					   Hall_Str := 'bulk';					   Get_HallInfo;	{ get bulk data from the results file to quant }					end;			    end;	{if Hall_setup^^.get_grid...}				IF ( not Make_Hall) THEN				Begin				     if quant_work then Hall_vol := Binary_VolNum_Read					 else Hall_vol := MCA_Results_VolNum;					 if (Analysis_Result^^.Fit_params.Fit_Procedure = 'Sm') then 					 		Hall_name := 'Hall(Sim)_DefaultResults' 					 else Hall_name := 'Hall(ML)_DefaultResults'; 			    END;	{IF ( not Make_Hall)...}					errCode := Create(Hall_name, Hall_vol, 'DTSA', 'MCAH');				MakeHallFile;			 								If (Quant_fit) then				begin					Quant_the_Fit;	{MCA_ResultsName,MCA_Results_VolNum, the WD, are defined}					if (Plain_boolean) or (Spread_Boolean) 					{...these must be for fit results, not hall, file}					 then begin					  do_ascii := true;					  WriteFitResults;					  do_ascii:=false;					  MCA_File_Boolean := False;					  Plain_Boolean := false;					  Spread_Boolean := false; 					end;	{ if (Plain_boolean) ...}				  { Quantitating a fit results file which we have specified above. Have already					obtained film and grid corrections if required.}				End;	{ If (Quant_fit) then begin...}					    END; 	{if (quant_work or quant_fit)...}			     							If (save_setup) or (append_setup) then			begin			    show_one := false;			    Show_hall := false; 					WritetoSetup;				save_setup := false;				append_setup := false;			end;		        {this must be HERE!!! and NOT above!!!...}	        IF Quant_fit then begin						 show_vol := Hall_vol;						 showname := Hall_name;						 show_one := false;						 show_setup := false;						 Show_hall := true;	        end;				END;	{IF (Hall_Accept)...}		IF Show_hall THEN AsciiHallResults;	{calls ReviewFitResults which MUST										     be in MainEventLoop}			if ( ExitDialog ) then			 begin			{ ExitDialog is set false if Hall_setup^^.get_grid }				 tempRect := GetSelection^.portRect;				 DisposeDialog(GetSelection);				 FillWhiteSpace(tempRect);                 Mouse_Active_Window;			end;			 	end;	{ PROCEDURE D_DialHall; }	end.    								{End of unit}