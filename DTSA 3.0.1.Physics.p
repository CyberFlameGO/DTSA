(*{[j=30/55,:+,u+,d-,r+,o=120,k+,n+,#+,v+,q+,b+]}*){***********************************} UNIT Physics; {*********************************} {**********************************} INTERFACE {**********************************}  USES   QuickDraw, Types, OSUtils, ToolUtils, Timer, Errors, Menus, Files, Lists, Memory, Retrace, SegLoad, TextUtils, Dialogs,  Packages, Printing, fenv, fp {SANE}, Xray_Energies, Spectrum_Structures, Declarations, xray, INITIALIZE, Global_Functions;     PROCEDURE Thin_Film;  PROCEDURE Bulk;  PROCEDURE Add_Escape_Peaks; { Add escape peaks to what is in col1 }  FUNCTION Qk(E_o, Ek: real {double_t}): real {double_t}; { Eo in kV, Ek in eV }  FUNCTION Ql(E_o, El: real {double_t}): real {double_t}; { Eo in kV, El in eV }  FUNCTION Qm(E_o, Em: real {double_t}): real {double_t}; { Eo in kV, Em in eV }  FUNCTION WK(atno: Longint): real {double_t};  FUNCTION WL(atno: Longint): real {double_t};  FUNCTION WM(atno: Longint): real {double_t};  FUNCTION SAK(atno: Longint): real {double_t};  FUNCTION SAL(atno: Longint): real {double_t};  FUNCTION SAM(atno: Longint): real {double_t};  FUNCTION Backscatter(Ec: real): real;  FUNCTION Continuum_Backscatter(E: real {double_t}): real {double_t};  FUNCTION Integrate_Q_over_S(Level: integer): real {double_t};  PROCEDURE Q_Continuum_Thin(Z_in: integer);  FUNCTION J_Factor(Z: integer): real {double_t}; { J in units of keV }  FUNCTION Stopping_Power(E: real {double_t}): real {double_t}; { E in keV, S in units of keV }  PROCEDURE Detector_Efficiency(var theHdl:SiLi_RecHdl; var theboolean:boolean);  FUNCTION MassAbsCoeff(Energy: Real; absorberAtNo: integer): Real;  PROCEDURE rmczyfab(eq, zzr, atwt, e_beam: Real; VAR r_factor, s_factor, eta: real);IMPLEMENTATION{$S Physics}  VAR       counter                      : integer;      peak_label                    : Str_5;      str1,str2,str3                : str255;	  Numb_of_Elements	            : integer;	  XKF                           : real {double_t};	  cscTheta                      : Real;	  Valid_Peak                    : integer;	  fchi                          : Real;       Mu_over_Rho                   : Real;	      Term                          : Real;      Term1                         : Real;      sinPhi                        : Real;	        L_theGenRec					: SiLi_Rec;      K_Hold                        : integer;      L_Hold                        : integer;      M_Hold                        : integer; 	  theEdge						: real;	  Gen_K, Gen_L, Gen_M			: real;         { ALL indexing in PHYSICS is done over theGenRec^^.number_of_Channels NOT Maximum_channels.  If         theGenRec^^.number_of_Channels is <= maximum_channels this is ok } (* As far as possible use theGenRec values in these calculations just for nicety. The geom rec   is used as a structure to get values in and out of the geom dialogs. The specimen description   is in Plt_Spec[10], however, and I don't feel like maiing a new structure for them.  The   generated spectrum goes to Plt_Spec[10] anyway so it's ok to put the generation parameters   there when they are accepted in the dialogs. *)   PROCEDURE Remond (VAR Y: real; theFWHM, Centroid, Amplitude, Energy: real) ;        VAR      Term, HWHM, Lamda		: real;    BEGIN      Lamda := 12398.0 / Energy;      HWHM := theFWHM / 2;   { J := -8.7E-3*exp(-0.34*Lamda);         HWHMg := 8.06E-2*2*exp(-2.4*(J+Lamda)) ;    Ag := Amplitude*2930*exp(-3.6*Lamda);   }      Term := (Energy - Centroid) / HWHM;      Term := Term * Term;      Y := one_Coeff * Amplitude * exp( - ln2 * Term) + (1 - one_Coeff) * Amplitude * (1 / (1 + Term)) {+ Ag*exp(-ln2 *             (J/HWHMg * J/HWHMg)) } ;    END; {Remond}  FUNCTION MassAbsCoeff; { (energy : double_t; absorberAtNo : integer) : double_t; }{ This function requires the global variables A^.edge[ absorberAtNo ] etc ie the ten K thru NI  edge energies in eV and Atomic_Weight of the absorber for the given atomic number, z. Set  up the required globals by calling Get_Energies ( z : integer ) first. This algoritmn  is by Kurt Heinrich. Kurt only recommends it for about x-ray (not) beam energies from 500eV  to 20 keV.}    VAR      Z                             : integer;      nm, mu                        : Real;      bias                          : Real;      E                             : Real;      cc, az, c                     : Real;      f, c1, zz                     : Real;    BEGIN      IF Energy <= 10 THEN        BEGIN          MassAbsCoeff := 1E6;          exit(MassAbsCoeff);        END;      if (absorberAtNo<3) or 	     (absorberAtNo>95) {OR 		 (Energy > 100000)} then	  begin          MassAbsCoeff := 0.001;          exit(MassAbsCoeff);	  end;	  	        Z := absorberAtNo;      E := Energy;      IF E <= 1 THEN E := 1;      Mu_Choice := 1;      IF Mu_Choice = 1 THEN        BEGIN          bias := 0;          IF (E > A^.edge[1]) THEN          {** reg.1: above K edge **}            BEGIN              IF Z < 6 THEN {* R.1, Z<6 *}                BEGIN                  cc := 0.001 * (1.808599 * Z - 0.287536);                  az := ( - 14.15422 * Z + 155.6055) * Z + 24.4545;                  bias := 18.2 * Z - 103;                  nm := ( - 0.01273815 * Z + 0.02652873) * Z + 3.34745                END              ELSE {* R.1, Z>=6 *}                BEGIN                  cc := 1.0E-5 * (525.3 + 133.257 * Z - 7.5937 * Z * Z + 0.169357 * Z * Z * Z - 0.0013975 * Z * Z * Z *                        Z);                  az := (( - 0.152624 * Z + 6.52) * Z + 47) * Z;                  nm := 3.112 - 0.0121 * Z;		        if((E > A^.edge[1]) AND (Z >= 50)) then		        	az := (( - 0.015 * Z + 3.52) * Z + 47) * Z;		        if((E > A^.edge[1]) AND (Z >= 57)) then		        	cc := 1.0E-6 * (200.0 + 100.0 * Z - Z * Z);                END;            END          ELSE            IF (E > A^.edge[4]) THEN {** regs 2-4: below K, above L3 **}              BEGIN                c := 0.001 * ( - 0.0924 + 0.141478 * Z - 0.00524999 * Z * Z + 9.85296E-5 * Z * Z * Z);                c := c - 9.07306E-10 * Z * Z * Z * Z + 3.19245E-12 * Z * Z * Z * Z * Z;                cc := c;                az := ((( - 0.000116286 * Z + 0.01253775) * Z + 0.067429) * Z + 17.8096) * Z;                nm := ( - 4.982E-5 * Z + 0.001889) * Z + 2.7575;                IF (E < A^.edge[2]) AND (E > A^.edge[3]) THEN cc := c * 0.858;                IF E < A^.edge[3] THEN cc := c * (0.8933 - 0.00829 * Z + 6.38E-5 * Z * Z);              END            ELSE              IF (E < A^.edge[4]) AND (E > A^.edge[5]) THEN                BEGIN                  nm := ((4.4509E-6 * Z - 0.00108246) * Z + 0.084597) * Z + 0.5385;                  IF Z < 30 THEN c := (((0.072773258 * Z - 11.641145) * Z + 696.02789) * Z - 18517.159) * Z + 188975.7                  ELSE {Z>=30}                    c := (((0.001497763 * Z - 0.40585911) * Z + 40.424792) * Z - 1736.63566) * Z + 30039;                  cc := 1.0E-7 * c;                  az := ((( - 0.00018641019 * Z + 0.0263199611) * Z - 0.822863477) * Z + 10.2575657) * Z;                  IF Z < 61 THEN bias := ((( - 0.0001683474 * Z + 0.018972278) * Z - 0.536839169) * Z + 5.654) * Z                  ELSE bias := (((0.0031779619 * Z - 0.699473097) * Z + 51.114164) * Z - 1232.4022) * Z;                END              ELSE                IF (E >= A^.edge[9]) THEN {¥ rgs fr.M1 to M5}                  BEGIN                    az := (4.62 - 0.04 * Z) * Z;                    c := 1.0E-8 * ((( - 0.129086 * Z + 22.09365) * Z - 783.544) * Z + 7770.8);                    c := c * (((4.865E-6 * Z - 0.0006561) * Z + 0.0162) * Z + 1.406);                    cc := c * (( - 0.0001285 * Z + 0.01955) * Z + 0.584);                    bias := ((0.000378 * Z - 0.052) * Z + 2.51) * A^.edge[8];                    nm := 3 - 0.004 * Z;                    IF (E < A^.edge[6]) AND (E >= A^.edge[7]) THEN cc := c * (0.001366 * Z + 1.082);                    IF (E < A^.edge[7]) AND (E >= A^.edge[8]) THEN cc := 0.95 * c;                    IF (E < A^.edge[8]) AND (E >= A^.edge[9]) THEN cc := 0.8 * c * ((0.0005083 * Z - 0.06) * Z + 2.0553);                  END                ELSE                  IF (E < A^.edge[9]) THEN                    BEGIN                      cc := 1.08E-7 * ((( - 0.0669827 * Z + 17.07073) * Z - 1465.3) * Z + 43156);                      az := ((0.00539309 * Z - 0.61239) * Z + 19.64) * Z;                      bias := 4.5 * Z - 113;                      nm := 0.3736 + 0.02401 * Z                    END;          IF (E > A^.edge[10]) AND (E >= 10 {180} ) THEN            BEGIN              mu := cc * exp(nm * ln(12397 / E)) * Z * Z * Z * Z / Atomic_Weight;              mu := mu * (1 - exp((bias - E) / az));            END;          IF (E < A^.edge[10]) AND (E >= 10 {180} ) THEN {¥ DOUBTFUL RANGE between 0 eV and the N edge}            BEGIN              {cutoff := (0.252 * Z - 31.1812) * Z + 1042;}              IF { ( E < 1.1 * cutoff ) OR } (E <= 10 {180} ) THEN mu := 9000              ELSE                BEGIN                  mu := cc * exp(nm * ln(12397 / E)) * Z * Z * Z * Z / Atomic_Weight * (1 - exp((bias - A^.edge[10]) /                        az));                  mu := 1.02 * mu * (E - 10{cutoff}) / (A^.edge[10] - 10{cutoff});                END;            END;          IF E <= 10 THEN mu := 1E6;        END;      IF Mu_Choice = 2 THEN { Pee @ Poo }        BEGIN          f := 1;          IF E > A^.edge[1] THEN { >K }            BEGIN              c1 := 1.6397 - Z * (0.2498519 - Z * (0.02428704 - Z * (0.000577342 - Z * 5.26115E-6)));              c1 := - 3.452 + Z * c1;              nm := - 0.0204683 + Z * (0.00105863 + Z * ( - 3.7419E-5 + Z * (7.2045E-7 - 5.7357E-9 * Z)));              nm := 2.93083 + Z * nm;            END          ELSE            IF E > A^.edge[4] THEN { K - L3 }              BEGIN                IF Z < 29 THEN c := ((0.00050695 * Z + 0.006829) * Z - 0.09857) * Z + 0.29527                ELSE c := 3.61617 - Z * (0.415345 - Z * (0.008545 + Z * (0.0007518 - Z * 3.3515E-6)));                nm := Z * (0.000146512 + Z * ( - 3.5895E-6 + Z * (2.87323E-8 - 8.1863E-11 * Z)));                nm := 2.7377 + Z * ( - 0.0020643 + nm);                IF (E < A^.edge[2]) AND (E > A^.edge[3]) THEN                  BEGIN                    f := 0.972;                    IF Z < 30 THEN                      BEGIN                        zz := (1E-4 * Z) * Z;                        f := 0.945 - 40 * zz * zz * zz { L1-L2 } ; { OR + ?? }                      END;                  END;                IF E < A^.edge[3] THEN                  BEGIN                    f := 0.92;                    IF Z < 30 THEN                      BEGIN                        zz := (1E-4 * Z) * Z;                        f := 0.945 - 40 * zz * zz * zz { L2-L3 } ; { OR + ?? }                      END;                  END;              END            ELSE              IF E > A^.edge[9] THEN {L3-M5 }                BEGIN                  IF Z > 34 THEN c := - 47.9671 + Z * (3.062675 - Z * (0.0587633 - Z * (0.00048847)));                  nm := 2.6 * (1 - exp( - Z / 14));                  IF E < A^.edge[5] THEN f := 0.982 { M1-M2 } ;                  IF E < A^.edge[6] THEN f := 0.97 { M2-M3 } ;                  IF E < A^.edge[7] THEN f := 0.95 { M3-M4 } ;                  IF E < A^.edge[8] THEN f := 0.905 { M4-M5 } ;                END              ELSE { <M5 }                BEGIN                  c := 4.80914 - Z * (0.53271 - Z * (0.0104052));                  nm := 2.08;                END;          IF c < 0 THEN cc := 0.001;          mu := exp(f * ln(c * exp(nm * ln(12397 / E))));        END; { Else If Mu_Choice = 2...}		      IF mu <= 0.001 THEN mu:=0.001;      MassAbsCoeff := mu;    END; { Function MassAbsCoeff }  {=============================} FUNCTION Be_Mu(E: real {double_t}): real {double_t}; {=================}    VAR      Index                         : integer;    BEGIN      A^.edge[1] := 116.0;      FOR Index := 2 TO 17 DO        A^.edge[Index] := zero;      Atomic_Weight := 9.012;      Be_Mu := MassAbsCoeff(E, 4);    END; { Function Be_Mu }  {=============================} FUNCTION Au_Mu(E: real {double_t}): real {double_t}; {==================}VAR	   	   RlnE							 : real {double_t};    BEGIN      A^.edge[1] := 80713.0;      A^.edge[2] := 14353.0;      A^.edge[3] := 13733.0;      A^.edge[4] := 11919.0;      A^.edge[5] := 3425.0;      A^.edge[6] := 3148.0;      A^.edge[7] := 2743.0;      A^.edge[8] := 2291.0;      A^.edge[9] := 2206.0;      A^.edge[10] := 759.0;	  A^.edge[11] := 644.0;	  A^.edge[12] := 545.0;	  A^.edge[13] := 352.0;	  A^.edge[14] := 334.0;	  A^.edge[15] := 86.0;	  A^.edge[16] := 83.0;	  A^.edge[17] := 0.0;      Atomic_Weight := 197.09;	  if (E < A^.edge[2]) then      	Au_Mu := MassAbsCoeff(E, 79)	  else begin	  	RlnE := ln(E / 1000);	  	if (E < A^.edge[1]) then			Au_Mu := exp(12.132-2.594*RlnE)		else			Au_Mu := exp(13.014-2.4685*RlnE);	  end;    END; { Function Au_Mu }  {=============================} FUNCTION Ge_Mu(E: real {double_t}): real {double_t}; {==================}       VAR index                         : Integer;	   	   RlnE							 : real {double_t};    BEGIN      A^.edge[1] := 11103.0;      A^.edge[2] := 1414.2;      A^.edge[3] := 1247.7;      A^.edge[4] := 1216.6;      A^.edge[5] := 180.0;      A^.edge[6] := 127.9;      A^.edge[7] := 120.8;      FOR Index := 8 TO 17 DO        A^.edge[Index] := zero;      Atomic_Weight := 72.59;	  if (E < A^.edge[1]) then      	Ge_Mu := MassAbsCoeff(E, 32)	  else begin	    RlnE := ln(E / 1000);	  	Ge_Mu := exp( 6.5326118637 + 2.273551853 * RlnE - 1.5156689919 * RlnE * RlnE + 0.14894838345 * RlnE * RlnE * RlnE);	  end;    END; { Function Ge_Mu }  {=============================} FUNCTION B_Mu(E: real {double_t}): real {double_t}; {===================}       VAR index                         : Integer;    BEGIN      A^.edge[1] := 192.0;      FOR Index := 2 TO 17 DO        A^.edge[Index] := zero;      Atomic_Weight := 10.82;      B_Mu := MassAbsCoeff(E, 5);    END;  {=============================} FUNCTION N_Mu(E: real {double_t}): real {double_t}; {===================}        VAR index                         : Integer;    BEGIN      A^.edge[1] := 399.0;      FOR Index := 2 TO 17 DO        A^.edge[Index] := zero;      Atomic_Weight := 14.007;      N_Mu := MassAbsCoeff(E, 7);    END;  {=============================} FUNCTION Ice_Mu(E: real {double_t}): real {double_t}; {================}    VAR      Index                         : integer;    BEGIN      A^.edge[1] := 531.0;      FOR Index := 2 TO 17 DO        A^.edge[Index] := zero;      Atomic_Weight := 16.0;      Ice_Mu := MassAbsCoeff(E, 8);    END; { Function Ice_Mu }  {=============================} FUNCTION C_Mu(E: real {double_t}): real {double_t}; {==================}    VAR      Index                         : integer;    BEGIN      A^.edge[1] := 283.0;      FOR Index := 2 TO 17 DO        A^.edge[Index] := zero;      Atomic_Weight := 12.011;      C_Mu := MassAbsCoeff(E, 6);    END; { Function C_Mu }  {=============================} FUNCTION Al_Mu(E: real {double_t}): real {double_t}; {==================}    VAR      Index                         : integer;    BEGIN      A^.edge[1] := 1559.0;      A^.edge[2] := 87.0;      A^.edge[3] := 73.0;      A^.edge[4] := 72.0;      FOR Index := 5 TO 17 DO        A^.edge[Index] := zero;      Atomic_Weight := 26.98;      Al_Mu := MassAbsCoeff(E, 13);    END; { Function Al_Mu }  {=============================} FUNCTION Si_Mu(E: real {double_t}): real {double_t}; {==================}    VAR      Index                         : integer;    BEGIN      A^.edge[1] := 1838.0;      A^.edge[2] := 118.0;      A^.edge[3] := 99.0;      A^.edge[4] := 98.0;      FOR Index := 5 TO 17 DO        A^.edge[Index] := zero;      Atomic_Weight := 28.09;      Si_Mu := MassAbsCoeff(E, 14);    END; { Function Si_Mu } PROCEDURE Detector_Efficiency{(var theHdl:SiLi_RecHdl; var theboolean:boolean)};          VAR      k                             : integer; 	   PROCEDURE SiLi_Efficiency;	  		  VAR			k		                      : integer;			TAu                           : Real;			TSiDZ                         : Real;			TSiDET                        : Real;			TGeDZ                         : Real;			TGeDET                        : Real;			TBe                           : Real;			TCarbon                       : Real;			TIce                          : Real;			TAl                           : Real;			TBN                           : Real;			TSiN                          : Real;			T_Mylar                       : Real;			T_Moxtek                      : Real;			T_Paralene                    : Real;			T_Diamond                     : Real;			T_Quantum                     : Real;			Z_Au                          : Real;			Z_SiDZ                        : Real;			Z_Be                          : Real;			Z_Carbon                      : Real;			Z_Ice                         : Real;			Z_Al                          : Real;			Z_BN                          : Real;			Z_SiN                         : Real;			Z_Mylar                       : Real;			Z_Moxtek                      : Real;			Z_Paralene                    : Real;			Z_Diamond                     : Real;			Z_Quantum                     : Real;			Eff                           : Real;			E                             : Real;			Geom_Const                    : Real;	  		  BEGIN	   { If this is called from Generate then some value in theGenRec changed;		 if this is called from anywhere else its because a parameter in theGenRec was different		 from what was needed but theGenRec was made to equal the required values before the call }		  FOR k := 1 TO Maximum_Channels DO			Det_Effic_P^[k] := 0.0;		  Eff := zero;			{ the below converts needed terms to units of cm and corrects for the tilt of the detector.			  The detector tilt is 90 = no tilt, ie, a "normal" configuration }				WITH theHdl^^ DO				  BEGIN					Geom_Const := 1 / Sin(Detector_Tilt / 57.295779);					TSiDET := Detector_Thickness * 0.1 * Geom_Const;					TGeDET := Detector_Thickness * 0.1 * Geom_Const;					Geom_Const := 1E-4 * Geom_Const;					TAu := Au_Thickness * Geom_Const;					TBe := Be_Thickness * Geom_Const;					TSiDZ := Si_Thickness * Geom_Const;					TGeDZ := Si_Thickness * Geom_Const;					TCarbon := C_Thickness * Geom_Const;					TIce := Ice_Thickness * Geom_Const;					TAl := Al_Thickness * Geom_Const;					TBN := BN_Thickness * Geom_Const;					TSiN := SiN_Thickness * Geom_Const;					T_Mylar := Mylar * Geom_Const;					T_Moxtek := Moxtek * Geom_Const;					T_Paralene := Paralene * Geom_Const;					T_Diamond := Diamond * Geom_Const;					T_Quantum := Quantum * Geom_Const;				  END; { With...}	  				FOR k := 1 TO theHdl^^.Number_of_Channels DO { K LOOP (K*dE)=eV=E }				  BEGIN					SpinCursor;					E := k * theHdl^^.dE; { E in eV here }	  					IF E < 10.0 THEN					  Eff := zero {E IN eV }	  					ELSE					  BEGIN	  					IF theHdl^^.Detector.ID = 2 THEN              				BEGIN 								IF TGeDZ > 0.0 THEN Z_SiDZ := Ge_Mu(E) * 5.32 * TGeDZ								ELSE Z_SiDZ := 0.0;							END	  					ELSE              				BEGIN 								IF TSiDZ > 0.0 THEN Z_SiDZ := Si_Mu(E) * 2.33 * TSiDZ								ELSE Z_SiDZ := 0.0;							END;													IF TBe > 0.0 THEN Z_Be := Be_Mu(E) * 1.82 * TBe						ELSE Z_Be := 0.0;	  	  						IF TAu > 0.0 THEN Z_Au := Au_Mu(E) * 19.3 * TAu						ELSE Z_Au := 0.0;	  						IF TCarbon > 0.0 THEN Z_Carbon := C_Mu(E) * 2.22 * TCarbon		{¥¥Change C density from 1.0 to 2.22  11/25/96¥¥}						ELSE Z_Carbon := 0.0;	  						IF TIce > 0.0 THEN Z_Ice := Ice_Mu(E) * 0.917 * TIce						ELSE Z_Ice := 0.0;	  						IF TAl > 0.0 THEN Z_Al := Al_Mu(E) * 2.70 * TAl		{¥¥Change Al density from 2.39 to 2.70  11/25/96¥¥}						ELSE Z_Al := 0.0;	  						IF TBN > 0.0 THEN Z_BN := (B_Mu(E) * 0.435816 + N_Mu(E) * 0.564184) * 2.25 * TBN						ELSE Z_BN := 0.0;	  						IF TSiN > 0.0 THEN Z_SiN := (Si_Mu(E) * 0.60065 + N_Mu(E) * 0.39935) * 3.44 * TSiN						ELSE Z_SiN := 0.0;	  						IF T_Mylar > 0.0 THEN Z_Mylar := (C_Mu(E) * 0.625006 + Ice_Mu(E) * 0.333032) * 1.375 * T_Mylar						ELSE Z_Mylar := 0.0;	  						IF T_Moxtek > 0.0 THEN Z_Moxtek := (C_Mu(E) * 0.69387 + Ice_Mu(E) * 0.21007 + N_Mu(E) * 0.07356) * 1.42 * T_Moxtek {/ 0.75}	{11/22/96}						ELSE Z_Moxtek := 0.0;						{Moxtek AP1.3 is 0.3 um thick 75% to 80% transmission with 0.04um of Al}						{Moxtek AP1.7 is 0.6 um thick 75% to 80% transmission with ~0.06um of Al}	  						IF T_Paralene > 0.0 THEN Z_Paralene := (C_Mu(E) * 0.92257) * 1.11 * T_Paralene	{11/22/96}						ELSE Z_Paralene := 0.0;						{Paralene for the bolometer is 0.1 um thick with 0.14um of Al (there are 3 of these windows)}	  						IF T_Diamond > 0.0 THEN Z_Diamond := C_Mu(E) * 3.515 * T_Diamond						ELSE Z_Diamond := 0.0;	  						IF T_Quantum > 0.0 THEN Z_Quantum := (B_Mu(E) * 0.9 + N_Mu(E) * 0.1) * 1.4 * T_Quantum						ELSE Z_Quantum := 0.0;	  						Eff := exp( - Z_Be - Z_SiDZ - Z_Au - Z_Carbon - Z_Diamond - Z_Ice - Z_Al - Z_BN - Z_SiN - Z_Mylar -								   Z_Moxtek - Z_Paralene - Z_Quantum);					  END;	  			   { NIH TN UTW has 0.1 um of paralene, 0.0015 um of Al, and about 0.2 um of ice. Also a 90%				 transmission Ni grid to support the film, how shall we model that ???				 A diamond window is 0.38 um thick, has 201 angstroms Al coat on a grid with 72.72%				 transmission. Density of diamond to x-rays is 3.515. 		   Mylar comes in 1 and 6 um thicknesses.		   Super Quantum of Kevex is 0.25 um thick and density of 1.4 g/cc B=0.9, N=0.1 weight fr.		   Kevex Monograph 27 : 10 mm2 detector dead zone = 0.42um and 30 mm2 = 0.38 um }				IF theHdl^^.Detector.ID = 2 THEN					BEGIN 						IF E < 15000 THEN  Det_Effic_P^[k] := Eff * (1 - exp( - (Ge_Mu(E) * 5.32 * TGeDET)))						ELSE Det_Effic_P^[k] := Eff * (1 - exp( - 254740 * exp( - 2.9215 * ln(E / 1000)) * 5.32 * TGeDET));					END				ELSE					BEGIN 						IF E < 10000 THEN  Det_Effic_P^[k] := Eff * (1 - exp( - (Si_Mu(E) * 2.33 * TSiDET)))						ELSE Det_Effic_P^[k] := Eff * (1 - exp( - 33193 * exp( - 3.0584 * ln(E / 1000)) * 2.33 * TSiDET));					END;				(*if T_Moxtek > 0.0 THEN Det_Effic_P^[k] := Det_Effic_P^[k] * 0.75;*)			{ The 2nd transmission term is Chuck Fiori's fit to the Photoelectric cross section		   for Si from 2-300 keV. The fit is fairly good for this purpose from 2-200 keV with an acceptable		   deviation to 300 keV. It is used here for 15-200 keV }		   { The second ttransmission term is Bob Myklebust's fit to the Photoelectric cross section		   for Ge from 11.1-300 keV. 11.1 is the Ge K-edge. These values have been inserted above.}	  				  END; { END OF K LOOP }	  			Det_Effic_P^[1] := 1e-22;	  			theboolean := True;	  			ChangeCursor(ArrowC);	  END; { of proc SiLi_Efficiency }    BEGIN	{ PROCEDURE Detector_Efficiency(...); }	 PutBusyMessage('Busy calculating a detector response curve.',	               'Please wait....','','') ;       IF (WDS_active) THEN { we do not change theGenRec for WDS }        BEGIN		beepbeep;          FOR k := 1 TO Maximum_Channels {8192} DO            Det_Effic_P^[k] := 1.0;            theboolean := True;        END { if (WDS_active)...}      ELSE SiLi_Efficiency;      {¥¥¥¥STUPID!!! this compares the values NOT the variables!!@!!¥¥¥¥}      	{	IF theBoolean = SiLi_Response_Calculated then}	    IF BG_Active then			 BlockMove(@Det_Effic_P^, @Bkg_ResponseFnc^, Sizeof(Bkg_ResponseFnc^)) 		ELSE BlockMove(@Det_Effic_P^, @Gen_ResponseFnc^, Sizeof(Gen_ResponseFnc^));	  	   DisposeDialog(BusyMessage);    END; { Procedure Detector_Efficiency;}  FUNCTION Backscatter(Ec: real): real; {Ec in keV, and z, Bulk_kV are globals }        VAR      r_factor, s_factor, eta, z_r       : real;                      BEGIN   {   Backscatter := 1.0 - 8.1512E-3 * Z + 3.613E-5 * Z * Z + 9.582E-3 * Z *                       exp( - Bulk_kV / Ec) + 1.14E-3 * Bulk_kV;}      IF Ec >= Bulk_kV THEN Backscatter := zero      ELSE        BEGIN          z_r := Z;          rmczyfab(Ec, z_r, Atomic_Weight, Bulk_kV, r_factor, s_factor, eta);          Backscatter := - r_factor        END;    END;  FUNCTION Continuum_Backscatter(E: real {double_t}): real {double_t}; {E in keV, Bulk_kV,Z are globals }    VAR      A                             : real {double_t};      B                             : real {double_t};      c                             : real {double_t};      X                             : real {double_t};    BEGIN      X := E / Bulk_kV;      A := (1 - exp(0.361 * X * X + 0.288 * X - 0.619)) * 1E-4;      B := (1 - exp(0.153 * X * X + 2.04 * X - 2.17)) * 1E-2;      IF X < 0.7 THEN c := 1.003 + 0.0407 * X      ELSE c := 1.0 * 1.017;      Continuum_Backscatter := A * Z * Z - B * Z + c;      IF E >= Bulk_kV THEN Continuum_Backscatter := zero;    END;  FUNCTION J_Factor(Z: integer): real {double_t}; { in units of keV }    BEGIN      J_Factor := (9.76 * Z + 58.5 * exp( - 0.19 * ln(Z))) * 1.0E-3;    END;  FUNCTION Stopping_Power(E: real {double_t}): real {double_t}; { E in keV }    VAR      yj                            : real {double_t};      f_zovera                      : real {double_t};      d2, d3, p3                    : real {double_t};      vx, fv                        : real {double_t};    BEGIN      { Stopping_Power := - 7.85E4 * Z / (Atomic_Weight * E) * LN(1.166 * E / J_Factor(Z));}      { Bethe as modified by Pouchou}      yj := 0.001 * Z * (10.04 + 8.25 * exp( - Z / 11.22));      f_zovera := Z / Atomic_Weight;      d2 := 1.12E-5 * (1.35 - 0.45 * yj * yj);      d3 := 2.2E-6 / yj;      p3 := 0.25 * yj - 0.5;      vx := E / yj;      fv := 6.6E-6 * fast_power(vx, 0.78) + d2 * fast_power(vx, 0.1) + d3 * fast_power(vx, p3);      Stopping_Power := f_zovera / yj / fv * 1.037 {1.0E-4} ;    END;     {======================================================================================}  PROCEDURE rmczyfab(eq, zzr, atwt, e_beam: Real; VAR r_factor, s_factor, eta: real);{  This is a full integration method of computing the backscatter loss (R), the stopping   power (S) and the backscatter coefficient (eta). Eta uses Scott's method, S uses   Pouchou's method, and R uses the cross-section of Fabre and the energy distribution of   Czyzewski together with S and eta. }    TYPE      inarr                      = ARRAY [1..21] OF Real;    VAR      polyit, polyitE               : integer;      eta20                         : real {double_t};      hz20                          : real {double_t};      uk                            : real {double_t};      WKe                           : real {double_t};      yj                            : real {double_t};      g_1overeq                     : real {double_t};      f_zovera                      : real {double_t};      sss, ww                       : Real;      d2, d3, p3, k, p, s2          : real {double_t};      vx, fv, sst                   : real {double_t};      denom                         : real {double_t};    PROCEDURE romB(A, B: Real; VAR ans: Real); FORWARD;    PROCEDURE romW(A, B: Real; VAR ans: Real); FORWARD;    PROCEDURE romE(aE, bE: Real; VAR ans: Real); FORWARD;    {  Double integration  }    FUNCTION funt(w, E: Real): Real;     {  globals for integration  :  eta, yj, g_1overeq  }      VAR        X, detadw, funtr          	  : Real;        vxx, fvx, stx                 : Real;      BEGIN        vxx := E / yj;        fvx := 6.6E-6 * fast_power(vxx, 0.78) + d2 * fast_power(vxx, 0.1) + d3 * fast_power(vxx, p3);        stx := f_zovera / yj / fvx * 1.0E-4;        X := 1.0 - fast_power(w, k);        detadw := k * p * s2 * eta * fast_power(w, (k - 1)) / (fast_power(X, (1 + p)) * sqr(1 - s2 + s2 / fast_power(                  X, p)));        funtr := ln(g_1overeq * E) / (g_1overeq * E + 1.32) / stx * detadw;        funt := funtr;      END;    FUNCTION fund(yy: Real): Real; { Y1 }      VAR        E, fundr, wx                  : Real;      BEGIN        E := yy;        wx := ww;        fundr := funt(wx, E);        fund := fundr;      END;    FUNCTION X2(ee: Real): Real; { Y2 }     {  globals for integration  : e_beam = theGenRec^^.kV  }      VAR        w, x2r                        : Real;      BEGIN        w := ee;        x2r := w * e_beam; { *** needs beam voltage in kV *** }        X2 := x2r;      END;    FUNCTION funx(xx: Real): Real;     {  globals for integration  :  g_1overeq  }      VAR        x1, sa, temp_x2               : Real;      BEGIN        ww := xx;        x1 := 1.0 / g_1overeq - 0.001;        temp_x2 := X2(ww);        romE(x1, temp_x2, sa);        funx := sa;      END;    {  Single integration  }    FUNCTION funy(E: Real): Real; { funy }     {  globals for integration  : g_1overeq, f_zovera, yj  }      VAR        st, vxx, fvx, funcr           : Real;      BEGIN        vxx := E / yj;        fvx := 6.6E-6 * fast_power(vxx, 0.78) + d2 * fast_power(vxx, 0.1) + d3 * fast_power(vxx, p3);        st := f_zovera / yj / fvx * 1.0E-4;        funcr := ln(g_1overeq * E) / (g_1overeq * E + 1.32) / st;        funy := funcr;      END;    PROCEDURE trpzB(A, B: Real; VAR S: Real; n: integer);      VAR        J                             : integer;        X, numb, sum, delta              : Real;      BEGIN        IF (n = 1) THEN          BEGIN            S := 0.5 * (B - A) * (funy(A) + funy(B));            polyit := 1          END        ELSE          BEGIN            numb := polyit;            delta := (B - A) / numb;            X := A + 0.5 * delta;            sum := 0.0;            FOR J := 1 TO polyit DO              BEGIN                sum := sum + funy(X);                X := X + delta              END;            S := 0.5 * (S + (B - A) * sum / numb);            polyit := 2 * polyit          END      END;    PROCEDURE trpzW(A, B: Real; VAR S: Real; n: integer);      VAR        J                             : integer;        X, numb, sum, delta              : Real;      BEGIN        IF (n = 1) THEN          BEGIN            S := 0.5 * (B - A) * (funx(A) + funx(B));            polyit := 1          END        ELSE          BEGIN            numb := polyit;            delta := (B - A) / numb;            X := A + 0.5 * delta;            sum := 0.0;            FOR J := 1 TO polyit DO              BEGIN                sum := sum + funx(X);                X := X + delta              END;            S := 0.5 * (S + (B - A) * sum / numb);            polyit := 2 * polyit          END      END;    PROCEDURE trpzE(aE, bE: Real; VAR sE: Real; nE: integer);      VAR        J                             : integer;        X, numb, sum, delta              : Real;      BEGIN        IF (nE = 1) THEN          BEGIN            sE := 0.5 * (bE - aE) * (fund(aE) + fund(bE));            polyitE := 1          END        ELSE          BEGIN            numb := polyitE;            delta := (bE - aE) / numb;            X := aE + 0.5 * delta;            sum := 0.0;            FOR J := 1 TO polyitE DO              BEGIN                sum := sum + fund(X);                X := X + delta              END;            sE := 0.5 * (sE + (bE - aE) * sum / numb);            polyitE := 2 * polyitE          END;      END;    PROCEDURE polyintrp(x_arr, y_arr: inarr; n: integer; X: Real; VAR Y, dy: Real);      VAR        ns, mm, i                      		 : integer;        wt, k1, k2, diff, difer, dif_xarr     : Real;        g, h                          		 : inarr;      BEGIN        ns := 1;        difer := abs(X - x_arr[1]);        FOR i := 1 TO n DO          BEGIN            diff := abs(X - x_arr[i]);            IF (diff < difer) THEN              BEGIN                ns := i;                difer := diff              END;            g[i] := y_arr[i];            h[i] := y_arr[i]          END;        Y := y_arr[ns];        ns := ns - 1;        FOR mm := 1 TO n - 1 DO          BEGIN            FOR i := 1 TO n - mm DO              BEGIN                k2 := x_arr[i] - X;                k1 := x_arr[i + mm] - X;                wt := g[i + 1] - h[i];                dif_xarr := k2 - k1;                IF (dif_xarr = 0.0) THEN                  BEGIN                    Putmessage('Error in Polynomial interpolation', '', '', '');                  END;                dif_xarr := wt / dif_xarr;                h[i] := k1 * dif_xarr;                g[i] := k2 * dif_xarr              END;            IF ((2 * ns) < (n - mm)) THEN              BEGIN                dy := g[ns + 1]              END            ELSE              BEGIN                dy := h[ns];                ns := ns - 1              END;            Y := Y + dy          END      END;    PROCEDURE romB(A, B: Real; VAR ans: Real); { funy }      LABEL        99;      CONST        lim                           = 1.0E-3;        lmax                          = 20;        lmax1                         = 21;           (* lmax+1 *)        cnt                           = 5;      VAR        i, J                          : integer;        ret_ans                           : Real;        h, sB                         : ARRAY [1..lmax1] OF Real;        c, d                          : inarr;      BEGIN        h[1] := 1.0;        FOR J := 1 TO lmax DO          BEGIN            trpzB(A, B, sB[J], J);            IF (J >= cnt) THEN              BEGIN                FOR i := 1 TO cnt DO                  BEGIN                    c[i] := h[J - cnt + i];                    d[i] := sB[J - cnt + i]                  END;                polyintrp(c, d, cnt, 0.0, ans, ret_ans);                IF (abs(ret_ans) < lim * abs(ans)) THEN GOTO 99              END;            sB[J + 1] := sB[J];            h[J + 1] := 0.25 * h[J]          END;        Putmessage('Error in romB', '', '', '');        readln;      99:      END;    PROCEDURE romE(aE, bE: Real; VAR ans: Real);      LABEL        99;      CONST        lim                           = 1.0E-3;        lmax                          = 20;        lmax1                         = 21;           (* lmax+1 *)        cnt                             = 5;      VAR        i, J                          : integer;        ret_ans                           : Real;        h, sE                         : ARRAY [1..lmax1] OF Real;        c, d                          : inarr;      BEGIN        h[1] := 1.0;        FOR J := 1 TO lmax DO          BEGIN            trpzE(aE, bE, sE[J], J);            IF (J >= cnt) THEN              BEGIN                FOR i := 1 TO cnt DO                  BEGIN                    c[i] := h[J - cnt + i];                    d[i] := sE[J - cnt + i]                  END;                polyintrp(c, d, cnt, 0.0, ans, ret_ans);                IF (abs(ret_ans) < lim * abs(ans)) THEN GOTO 99              END;            sE[J + 1] := sE[J];            h[J + 1] := 0.25 * h[J]          END;        Putmessage('Error in romE', '', '', '');      99:      END;    PROCEDURE romW(A, B: Real; VAR ans: Real); { funx }      LABEL        99;      CONST        lim                           = 1.0E-3;        lmax                          = 20;        lmax1                         = 21;           (* lmax+1 *)        cnt                             = 5;      VAR        i, J                          : integer;        ret_ans                           : Real;        h, sW                         : ARRAY [1..lmax1] OF Real;        c, d                          : inarr;      BEGIN        h[1] := 1.0;        FOR J := 1 TO lmax DO          BEGIN            trpzW(A, B, sW[J], J);            IF (J >= cnt) THEN              BEGIN                FOR i := 1 TO cnt DO                  BEGIN                    c[i] := h[J - cnt + i];                    d[i] := sW[J - cnt + i]                  END;                polyintrp(c, d, cnt, 0.0, ans, ret_ans);                IF (abs(ret_ans) < lim * abs(ans)) THEN GOTO 99              END;            sW[J + 1] := sW[J];            h[J + 1] := 0.25 * h[J]          END;        Putmessage('Error in romW', '', '', '');      99:      END;    { *** needs atomic number zzr of matrix element *** }    { *** needs excitation potential eq of x-ray line *** }    BEGIN      eta20 := ( - 52.3791 + 150.48371 * zzr - 1.67373 * sqr(zzr) + 0.00716 * fast_power(zzr, 3)) / 1.0E4;      hz20 := ( - 1112.8 + 30.289 * zzr - 0.15498 * sqr(zzr)) / 1.0E4;      eta := eta20 * (1.0 + hz20 * ln(e_beam / 20.0));      p := Sin(Geom.Beam_Entry_Angle / 57.295779);      eta := 0.891 * fast_power(eta / 0.891, p);      yj := 0.001 * zzr * (10.04 + 8.25 * exp( - zzr / 11.22));      uk := e_beam / eq;      f_zovera := zzr / atwt;      g_1overeq := 1.0 / eq;      k := 1.6;      p := (0.8 + 2 * eta) * ln(1.0 / eta);      s2 := 0.1054 * (fast_power(2, p) - 1 + 1 / fast_power(2.25, p));      d2 := 1.12E-5 * (1.35 - 0.45 * yj * yj);      d3 := 2.2E-6 / yj;      p3 := 0.25 * yj - 0.5;      vx := e_beam / yj;      fv := 6.6E-6 * fast_power(vx, 0.78) + d2 * fast_power(vx, 0.1) + d3 * fast_power(vx, p3);      sst := f_zovera / yj / fv * 1.0E-4;      s_factor := sst;      {  denominator  }      romB(eq, e_beam, sss);      denom := sss;      {  numerator  }      WKe := eq / e_beam;      romW(WKe, 0.999, sss);      r_factor := 1.0 - sss / denom;    END; { of rmczyfab }  {==============================================================}   FUNCTION WK(atno: Longint): real {double_t};    VAR      temp                          : real {double_t};    BEGIN      IF (atno < 4) OR (atno > 95) THEN { atno out of range }        BEGIN          WK := zero;          exit(WK);        END;      temp := (0.015 + 0.0327 * atno - 6.4E-7 * atno * atno * atno); { K shell }      temp := temp * temp * temp * temp;      WK := temp / (1.0 + temp);    END; {of function WK}  FUNCTION WL(atno: Longint): real {double_t};    VAR      temp                          : real {double_t};    BEGIN      IF (atno < 16) OR (atno > 95) THEN {atno out of range}        BEGIN          WL := zero;          exit(WL);        END;      temp := ( - 0.11107 + 0.01368 * atno - 2.1772E-7 * atno * atno * atno); { L shell }      temp := temp * temp * temp * temp;      WL := temp / (1.0 + temp);    END; {of function WL}  FUNCTION WM(atno: Longint): real {double_t}; { From John Colby }    VAR      temp                          : real {double_t};    BEGIN      IF (atno < 35) OR (atno > 95) THEN {atno out of range}        BEGIN          WM := zero;          exit(WM);        END;      temp := ( - 0.00036 + 0.00386 * atno - 2.0101E-7 * atno * atno * atno); { M shell }      temp := temp * temp * temp * temp;      WM := temp / (1.0 + temp);    END; {of function WM}  FUNCTION SAK(atno: Longint): real {double_t};      {          purpose : accepts the atomic number of an element, & returns the                    value of g for that element.  SAK is a measure of the                    relative intensities of the Ka & Kb lines.                    SAK = iKa/(iKa+iKb).      }    BEGIN	  	  IF atno < 11 then SAK := 1.0	  ELSE SAK := 1.0 - Wt_Line[3];	      END; {of function SAK}  FUNCTION SAL(atno: Longint): real {double_t};      {          purpose : accepts the atomic number of an element, & returns the                    value of SAL for that element.  SAL is a measure of the                    relative intensities of the La vs all the L lines.      }    CONST      A                             = 2.4589396;      A1                            = - 0.37888109;      A2                            = 0.25433321E-1;      A3                            = - 0.86299095E-3;      A4                            = 0.16352545E-4;      A5                            = - 0.17584567E-6;      A6                            = 0.10044975E-8;      A7                            = - 0.23699964E-11;    BEGIN      SAL := A + A1 * atno + A2 * atno * atno + A3 * atno * atno * atno + A4 * atno * atno * atno * atno + A5 * atno *             atno * atno * atno * atno + A6 * atno * atno * atno * atno * atno * atno + A7 * atno * atno * atno * atno *             atno * atno * atno;    END; {of function SAL}  FUNCTION SAM(atno: Longint): real {double_t};      {          purpose : accepts the atomic number of an element, & returns the                    value of SAM for that element.  SAM is a measure of the                    relative intensities of the Ma vs all the M lines.      }    BEGIN      SAM := 0.65; { Perhaps Someday??}    END;  FUNCTION SigmaK(E_o: real {double_t}): real {double_t};           { From Ray Edgerton's EELS book, we do here the full integration of the differential        cross section }    CONST      R                             = 13.606;         {Rydberg energy}    VAR      ZS, RNK, E, B,                                  {Beta in radians}       T, GG, PO2, S, QAO21, PP2, LQAO21, QAO2M, LQAO2M, LQ2INC, LNQAO2, DSBYDE, GOSP, QAO2, Q, KH2, AKH, d, BP, c, Y,       AA, GOS, DELTA, SGINC, DSBDEP, Sigma, Ek, Einc: Real;      i, J, Imax                    : integer;      Flag1                         : Boolean;    BEGIN {SigmaK}      DSBDEP := zero;      IF Z = 1 { Z is a global that must be assigned before calling this function }         THEN        BEGIN          ZS := 1;          RNK := 1;        END      ELSE        BEGIN          ZS := Z - 0.3125;          RNK := 2;        END;      Imax := 40;	         Ek :=  A^.Edge[1];  { eV }	        Einc := Ek / 10.0;      E := A^.edge[1]; { A^.edge[1] (K edge) is a global that must be assigned before calling this function}      B := Pi; { Beta in radians}      T := 511060.0 * (1.0 - 1.0 / fast_power((1.0 + E_o / (511.06)), 2.0)) / 2.0;      GG := 1.0 + E_o / 511.06;      PO2 := T / R / (1.0 - 2.0 * T / 511060.0);      S := 0;      Sigma := 0;      FOR J := 1 TO 30 DO        BEGIN {for j}          QAO21 := fast_power(E, 2) / (4.0 * R * T) + fast_power(E, 3) / (8.0 * R * fast_power(T, 2) * fast_power(GG,                   3));          PP2 := PO2 - E / R * (GG - E / 1022120.0);          LQAO21 := ln(QAO21);          QAO2M := QAO21 + 4.0 * sqrt(PO2 * PP2) * fast_power(Sin(B / 2.0), 2);          LQAO2M := ln(QAO2M);          LQ2INC := (LQAO2M - LQAO21) / (Imax - 1);          LNQAO2 := LQAO21;          DSBYDE := zero;          GOSP := zero;          FOR i := 1 TO Imax DO {Integrate over all scattering angles}            BEGIN {for i}              QAO2 := exp(LNQAO2);              Q := QAO2 / (ZS * ZS);              KH2 := (E / (R * ZS * ZS)) - 1.0;              AKH := sqrt(abs(KH2));              Flag1 := True;              IF KH2 >= 0.0 THEN                BEGIN                  d := 1.0 - exp( - 2.0 * Pi / AKH);                  BP := ArcTan(2.0 * AKH / (Q - KH2 + 1.0));                  IF BP < 0.0 THEN BP := BP + Pi;                  c := exp(( - 2.0 / AKH) * BP);                  IF KH2 >= 0.0 THEN Flag1 := FALSE;                END;              IF Flag1 THEN                BEGIN                  d := 1.0;                  Y := - 1.0 / AKH * ln((Q + 1.0 - KH2 + (2.0 * AKH)) / (Q + 1.0 - KH2 - 2.0 * AKH));                  c := exp(Y);                END;              AA := fast_power((fast_power((Q - KH2 + 1.0), 2) + 4.0 * KH2), 3);              GOS := 128.0 * RNK * E / R / fast_power(ZS, 4) * c / d * (Q + KH2 / 3.0 + 1.0 / 3.0) / AA;              DSBYDE := DSBYDE + 3.5166E-16 * (R / T) * (1.0 / E) * (GOS + GOSP) * LQ2INC / 2.0;              IF i <= 1.0 THEN DSBYDE := zero;              LNQAO2 := LNQAO2 + LQ2INC;              GOSP := GOS;            END; {for i}          DELTA := E - Ek;          IF J <> 1 THEN            BEGIN              S := ln(DSBDEP / DSBYDE) / ln(E / (E - Einc));              SGINC := (E * DSBYDE - (E - Einc) * DSBDEP) / (1.0 - S);              Sigma := Sigma + SGINC;            END;          IF J >= 11 THEN            BEGIN              IF SGINC < (0.001 * Sigma) THEN                BEGIN                  SigmaK := Sigma;                  exit(SigmaK);                END;              Einc := Einc * 2.0;            END;          E := E + Einc;          IF E > 1000.0 * E_o THEN            BEGIN              SigmaK := Sigma;              exit(SigmaK);            END;          DSBDEP := DSBYDE;        END; {for j}    END; {SigmaK}	{$S Physics11}  FUNCTION SigmaL(E_o: real {double_t}): real {double_t};           { From Ray Edgerton's EELS book, we do here the full integration        of the differential cross section }    CONST      R                             = 13.606;    VAR      XU                            : ARRAY [1..18] OF Real;      IE3, IE1                      : ARRAY [1..18] OF integer;      KH2, LNQAO2, LQAO21, LQAO2M, LQ2INC, ZS, U, EL3, EL1, E, B, T, GG, PO2, S, QAO21, PP2, QAO2M, DSBYDE, GOSP,       QAO2, Q, AKH, d, BP, c, g, AA, RF, GOS, DELTA, SGINC, Einc, DSBDEP, Sigma: Real;      IZ, J, i, Imax                : integer;      Flag1                         : Boolean;    PROCEDURE Data;      BEGIN {Data}        XU[1] := 0.44;        XU[2] := 0.39;        XU[3] := 0.28;        XU[4] := 0.25;        XU[5] := 0.22;        XU[6] := 0.19;        XU[7] := 0.16;        XU[8] := 0.16;        XU[9] := 0.12;        XU[10] := 0.13;        XU[11] := 0.13;        XU[12] := 0.12;        XU[13] := 0.12;        XU[14] := 0.11;        XU[15] := 0.10;        XU[16] := 0.20;        XU[17] := 0.10;        XU[18] := 0.20;        IE3[1] := 73;        IE3[2] := 99;        IE3[3] := 135;        IE3[4] := 164;        IE3[5] := 200;        IE3[6] := 245;        IE3[7] := 294;        IE3[8] := 347;        IE3[9] := 402;        IE3[10] := 455;        IE3[11] := 513;        IE3[12] := 575;        IE3[13] := 641;        IE3[14] := 710;        IE3[15] := 779;        IE3[16] := 855;        IE3[17] := 931;        IE3[18] := 1021;        IE1[1] := 118;        IE1[2] := 149;        IE1[3] := 189;        IE1[4] := 229;        IE1[5] := 270;        IE1[6] := 320;        IE1[7] := 377;        IE1[8] := 438;        IE1[9] := 500;        IE1[10] := 564;        IE1[11] := 628;        IE1[12] := 695;        IE1[13] := 769;        IE1[14] := 846;        IE1[15] := 926;        IE1[16] := 1008;        IE1[17] := 1096;        IE1[18] := 1194;      END; {Data}    BEGIN {SigmaL}      Data;      Imax := 10;      Einc := 1.0 * 10.0;      ZS := Z - 0.35 * (8.0 - 1.0) - 1.7; {Is an error in this line?}      IZ := {trunc}(Z) - 12;      U := XU[IZ]; {Z must be in range of 13 ..30}      EL3 := IE3[IZ];      EL1 := IE1[IZ];      E := EL3;      B := Pi;      T := 511060.0 * (1.0 - (1.0 / fast_power((1.0 + (E_o / (511.06))), 2.0))) / 2.0;      GG := 1.0 + E_o / 511.06;      PO2 := T / R / (1.0 - 2.0 * T / 511060.0);      S := zero;      Sigma := zero;      FOR J := 1 TO 40 DO        BEGIN {for J}          QAO21 := fast_power(E, 2) / (4.0 * R * T) + fast_power(E, 3) / (8.0 * R * fast_power(T, 2) * fast_power(GG,                   3));          PP2 := PO2 - E / R * (GG - E / 1022120.0);          LQAO21 := ln(QAO21);          QAO2M := QAO21 + 4.0 * GG * GG * T / R * fast_power((Sin(B / 2.0)), 2);          LQAO2M := ln(QAO2M);          LQ2INC := (LQAO2M - LQAO21) / (Imax - 1);          LNQAO2 := LQAO21;          DSBYDE := zero;          GOSP := zero;          FOR i := 1 TO Imax DO {Integrate over all scattering angles}            BEGIN {for i}              QAO2 := exp(LNQAO2);              Q := QAO2 / (ZS * ZS);              KH2 := (E / (R * ZS * ZS)) - 0.25;              AKH := sqrt(abs(KH2));              Flag1 := True;              IF KH2 >= 0.0 THEN                BEGIN                  d := 1.0 - exp( - 2.0 * Pi / AKH);                  BP := ArcTan(AKH / (Q - KH2 + 0.25));                  IF BP < 0.0 THEN BP := BP + Pi;                  c := exp(( - 2.0 / AKH) * BP);                  IF KH2 >= 0.0 THEN Flag1 := FALSE;                END;              IF Flag1 THEN                BEGIN                  d := 1.0;                  c := exp(( - 1.0 / AKH) * ln((Q + 0.25 - KH2 + AKH) / (Q + 0.25 - KH2 - AKH)));                END;              IF (E - EL1) > 0 THEN                BEGIN                  g := fast_power(Q, 3) - (5.0 / 3.0 * KH2 + 11.0 / 12.0) * fast_power(Q, 2) + (KH2 * KH2 / 3.0 + 1.5 *                       KH2 + 65.0 / 48.0) * Q + fast_power(KH2, 3) / 3.0 + 0.75 * KH2 * KH2 + 23.0 / 48.0 * KH2 + 5.0 /                       64.0;                  AA := fast_power((fast_power((Q - KH2 + 0.25), 2) + KH2), 4);                END              ELSE                BEGIN                  g := 2.25 * fast_power(Q, 4) - (0.75 + 3.0 * KH2) * fast_power(Q, 3) + (0.59375 - 0.75 * KH2 - 0.5 *                       KH2 * KH2) * Q * Q + (0.11146 + 0.85417 * KH2 + 1.8833 * KH2 * KH2 + fast_power(KH2, 3)) * Q +                       0.0035807 + KH2 / 21.333 + KH2 * KH2 / 4.5714 + fast_power(KH2, 3) / 2.4 + fast_power(KH2, 4) /                       4;                  AA := fast_power((fast_power((Q - KH2 + 0.25), 2) + KH2), 5);                END;              RF := fast_power(((E + 0.1 - EL3) / 1.8 / Z / Z), U);              IF (abs(IZ - 11) <= 5) THEN IF (J <= 3) THEN RF := 1.0;              GOS := 32.0 * g * c / AA / d * E / R / fast_power(ZS, 4) * RF;              DSBYDE := DSBYDE + 3.5166E-16 * (R / T) * (1.0 / E) * (GOS + GOSP) * LQ2INC / 2.0;              IF i <= 1 THEN DSBYDE := zero;              LNQAO2 := LNQAO2 + LQ2INC;              GOSP := GOS;            END; {for i}          DELTA := E - EL3;          IF J <> 1 THEN            BEGIN              S := ln(DSBDEP / DSBYDE) / ln(E / (E - Einc));              SGINC := (E * DSBYDE - (E - Einc) * DSBDEP) / (1.0 - S);              Sigma := Sigma + SGINC;              SigmaL := Sigma;            END;          IF J >= 11 THEN Einc := Einc * 2.0;          E := E + Einc;          IF E > T THEN            BEGIN              SigmaL := Sigma;              exit(SigmaL);            END;          DSBDEP := DSBYDE;        END; {for J}    END; {SigmaL} (* edge no.  electrons/shell         1   2  2   2  3   2  4   4  5   2  6   2  7   4  8   4  9   6   1,   4,    9,  1,    4,   4,    4,   3,   3,     3,    2,    2,    2,   9,   8,   7,      6  Ka,  La1,  Ma,  Kb,  La2,  Ll,  Lb2,  Lb1,  Lg1,  Ln,  Lb3,  Lg3,  Lb4,  Mz,  Mb,  Mg,   M2N4*){$S Physics5}  FUNCTION Qk(E_o, Ek: real {double_t}): real {double_t}; { E_o in kV, Ek in eV }                    { Z is used below and in SigmaK and is a global defined and gotten                                               in Get_Energies( of an atomic number ) }    VAR      Ak, Bk, Bt, UZ, h, BZ         : real {double_t};      temp, Term1, Term2, Term3, Term4, Term5, Term6, SIGGT, SIGLT, PIE4, ALGZ, BKAY, DKAY: real {double_t};	  RI, RI1, RI2, RT, RT1, RT2, RF: real {double_t};	  Rbet0,Rbet,F1,F2,F3,F4,F5		: real {double_t};      NZ, indx                      : integer;      A1, mm						: array [1..3] of real;    BEGIN      IF Ek <= 0.0 THEN Ek := 1.0; { Paranoia }      IF E_o <= 0.0 THEN E_o := 1.0; { Paranoia }      Ek := Ek / 1000.0; { Convert Ek to units of keV }      IF ((E_o <= Ek) OR (Z < 4) OR (Z > 95)) THEN        BEGIN          Qk := zero;          exit(Qk);        END;	  UZ := E_o / Ek;	        IF ((Running_Thin_Mode) AND (Thin_K_Xsect = 3)) THEN        BEGIN {¥¥¥ Schreiber/Wimms ¥¥¥}          { ULTRAMICROSCOPY 6(1981) PP 323-334. ENERGIES ARE IN kV. }          PIE4 := 6.4924E-20;          ALGZ := ln(Z);          BKAY := 0.661;          IF (Z <= 30.0) THEN BKAY := 8.874 - 8.158 * ALGZ + 2.9055 * ALGZ * ALGZ - 0.35778 * ALGZ * ALGZ * ALGZ;          DKAY := 1.0667 - 0.00476 * Z;          temp := PIE4 * 2 * BKAY * ln(UZ) / (Ek * Ek * fast_power(UZ, DKAY));        END;      IF ((Running_Thin_Mode) AND (Thin_K_Xsect = 4)) OR ((Running_Bulk_Mode) AND (Bulk_K_Xsect = 12)) THEN        BEGIN {¥¥¥ Mott-Massey ¥¥¥}          temp := 6.51E-20 * 2 * 0.35 / (Ek * E_o) * ln(2.42 * UZ);        END;      IF ((Running_Thin_Mode) AND (Thin_K_Xsect = 5)) OR ((Running_Bulk_Mode) AND (Bulk_K_Xsect = 11)) THEN        BEGIN {¥¥¥ Kolbensvedt, Relativistic form ¥¥¥}          E_o := E_o / 511.0;          Ek := Ek / 511.0;          Term1 := (0.275 / Ek) * (E_o + 1.0) * (E_o + 1.0) / (E_o * (E_o + 2.0));          Term2 := ln((1.19 * E_o * (E_o + 2.0)) / Ek);          Term3 := E_o * (E_o + 2.0) / ((E_o + 1.0) * (E_o + 1.0));          SIGGT := Term1 * (Term2 - Term3);          Term4 := (0.99 / Ek) * (E_o + 1.0) * (E_o + 1.0) / (E_o * (E_o + 2.0));          Term5 := E_o * E_o / (2.0 * (E_o + 1.0) * (E_o + 1.0));          Term6 := (2 * E_o + 1.0) / ((E_o + 1.0) * (E_o + 1.0)) * ln(UZ);          SIGLT := Term4 * (1.0 - (1.0 / UZ) * (1.0 - Term5 + Term6));          temp := (SIGLT + SIGGT) * 1.0E-24;        END;      IF ((Running_Thin_Mode) AND (Thin_K_Xsect = 6)) THEN        BEGIN {¥¥¥ Bethe/Fermi (Zaluzek) ¥¥¥}          Ak := 6.4924E-20;          Bk := 0.35;          NZ := 2;          Bt := 1.0 - ((1.0 / (1.0 + E_o / 511.0)) * (1.0 / (1.0 + E_o / 511.0)));          h := (1.0 - exp( - Ek / 2.0));          BZ := (5.0 * h / UZ) * (1.0 - exp( - (1250.0 / Ek) / (UZ * UZ)));          temp := Ak * Bk * NZ * (ln(4.0 * E_o / (BZ * Ek)) - ln(1.0 - Bt) - Bt) / (Ek * E_o);        END;      IF ((Running_Thin_Mode) AND (Thin_K_Xsect = 7)) OR ((Running_Bulk_Mode) AND (Bulk_K_Xsect = 9)) THEN        BEGIN {¥¥¥ Fabre ¥¥¥}          temp := 6.51E-20 * 2 * ln(UZ) / (Ek * Ek * 1.18 * (UZ + 1.32));        END;      IF ((Running_Thin_Mode) AND (Thin_K_Xsect = 8)) OR ((Running_Bulk_Mode) AND (Bulk_K_Xsect = 8)) THEN        BEGIN {¥¥¥ Ray Edgertons SigmaK ¥¥¥}          temp := SigmaK(E_o);        END;      IF ((Running_Thin_Mode) AND (Thin_K_Xsect = 10)) OR ((Running_Bulk_Mode) AND (Bulk_K_Xsect = 6)) THEN        BEGIN {¥¥¥ Green-Cosslett ¥¥¥}          temp := 6.51E-20 * 2 * 0.61 / (Ek * E_o) * ln(UZ);        END;      IF ((Running_Thin_Mode) AND (Thin_K_Xsect = 11)) OR ((Running_Bulk_Mode) AND (Bulk_K_Xsect = 5)) THEN        BEGIN {¥¥¥ Worthington-Tomlin ¥¥¥}          temp := 6.51E-20 * 2 * 0.35 / (UZ * Ek * Ek) * ln((4 * UZ) / (1.65 + 2.35  * exp(1.0 - UZ)));        END;      IF ((Running_Thin_Mode) AND (Thin_K_Xsect = 9)) OR ((Running_Bulk_Mode) AND (Bulk_K_Xsect = 7)) THEN        BEGIN {¥¥¥ Lotz ¥¥¥}          temp := 5.00E-20 * 2 * ln(UZ) * (1.0 - 0.75 * exp(-0.5 * (UZ - 1.0))) / (UZ * Ek * Ek);        END;      IF ((Running_Thin_Mode) AND (Thin_K_Xsect = 14)) OR ((Running_Bulk_Mode) AND (Bulk_K_Xsect = 2)) THEN        BEGIN {¥¥¥ Drawin ¥¥¥}          temp := 4.32E-20 * 2 * (UZ - 1.0) * ln(1.25 * UZ) / (UZ * UZ * Ek * Ek);        END;      IF ((Running_Thin_Mode) AND (Thin_K_Xsect = 12)) OR ((Running_Bulk_Mode) AND (Bulk_K_Xsect = 4)) THEN        BEGIN {¥¥¥ Gryzinski ¥¥¥}		  Term2 := SQRT((UZ - 1.0) / (UZ + 1.0));		  Term3 := Term2 * Term2 * Term2;		  Term1 := (1.0 / UZ) * Term3 * (1.0 + (2.0 / 3.0) * (1.0 - 1.0 / (2.0 * UZ)) * ln(2.7 + SQRT(UZ - 1)));          temp := 6.51E-20 * 2 * Term1 / ( Ek * Ek);        END;      IF ((Running_Thin_Mode) AND (Thin_K_Xsect = 2)) OR ((Running_Bulk_Mode) AND (Bulk_K_Xsect = 10)) THEN        BEGIN {¥¥¥ Casnati ¥¥¥}          F2 := -1.736 / UZ + 0.317 / (UZ * UZ);		  Term1 := 10.57 * exp(F2);	{CF}		  Term2 := -0.0318 + 0.316 / UZ - 0.1135 / (UZ * UZ);		{CD}		  RI := Ek / 511;		  RT := E_o / 511;		  RI1 := 1 + RI;		  RT1 := 1 + RT;		  RI2 := 2 + RI;		  RT2 := 2 + RT;		  Term3 := ((RT + RI) * RT2 * RI1 * RI1) / (RT * RT2 * RI1 * RI1 + RI * RI2);		  Term5 := fast_power(Term3,1.5);		  F1 := Ek / 0.013606;		  Term4 := fast_power(F1,Term2);	{CP^CD}		  RF := (RI2 / RT2) * (RT1 / RI1) * (RT1 / RI1) * Term5;          temp := 5.18E-21 * 2 * RF * Term4 * Term1 * ln(UZ) / (UZ * Ek * Ek);        END;      IF ((Running_Thin_Mode) AND (Thin_K_Xsect = 13)) OR ((Running_Bulk_Mode) AND (Bulk_K_Xsect = 3)) THEN        BEGIN {¥¥¥ Brown-Gilfritch ¥¥¥}          temp := 6.51E-20 * 2 * (0.52 + 0.0029 * Z) / (Ek * E_o) * ln(UZ);          { This was algebraically manipulated by Powell from       7.92E-20*(0.85+0.0047*Z)/(Ek*E_o)*ln(E_o/Ek) }        END;      IF ((Running_Thin_Mode) AND (Thin_K_Xsect = 15)) OR ((Running_Bulk_Mode) AND (Bulk_K_Xsect = 13)) THEN        BEGIN {¥¥¥ Jakoby ¥¥¥}		  RI := Ek / 511;		  RT := E_o / 511;		  Rbet0 := 1.0 - 1.0/((1 + RI) * (1 + RI));          Rbet := 1.0 - 1.0/((1 + RT) * (1 + RT));          F1 := 2.549E-22/(Ek*Rbet);          F2 := ln(Rbet/(1 - Rbet)) - Rbet;          F3 := 1.0 - Rbet0/Rbet;          F4 := ln(1.0/Rbet0);          F5 := Rbet0/Rbet;          Term1 := 5.14 * fast_power(Z,-0.48);          Term2 := 5.76 - 0.04 * Z;          Term3 := 0.72 + 0.039 * Z - 0.0006 * Z * Z;          temp := Term1 * F1 * (F2 + Term2 * F3 + F4 * fast_power(F5,Term3));		END;	IF ((Running_Bulk_Mode) AND (Bulk_K_Xsect = 14)) THEN		BEGIN {¥¥¥ Pouchou & Pichoir ¥¥¥}			Term1 := 0.86 + 0.12 * exp(-(Z / 5) * (Z / 5));			temp := 6.51E-20 * 2 * exp(1) * Term1 / fast_power(UZ,Term1) * ln(UZ) / ( Ek * Ek);		END;			IF ((Running_Bulk_Mode) AND (Bulk_K_Xsect = 15)) THEN		BEGIN {¥¥¥ Pouchou ¥¥¥}			A1[1] := 1.0;			A1[2] := 0.1;			A1[3] := 1.5;			mm[1] := 0.86 + 0.12 * exp(-(Z / 5) * (Z / 5));			mm[2] := 5.0;			mm[3] := 30.0;			temp := 0.0;			Term2 := 1.4E-20 * 2 * exp(1) * mm[1] * ln(UZ) / ( Ek * Ek);			FOR indx := 1 TO 3 DO begin				temp := temp + Term2 * A1[indx] / fast_power(UZ,mm[indx]);			end;		END;	      { Some last minute paranoia }      Qk := temp;      IF Running_Thin_Mode THEN Qk := Thin_K_ScaleFactor * temp;      IF Running_Bulk_Mode THEN Qk := Bulk_K_ScaleFactor * temp;    END;  FUNCTION Ql(E_o, El: real {double_t}): real {double_t}; { E_o in kV, El in eV }    VAR      temp, Ak, Bk, Bt, UZ, h, BZ   : real {double_t};	  RI, RI1, RI2, RT, RT1, RT2, RF: real {double_t};	  Rbet0,Rbet,F1,F2,F3,F4,F5		: real {double_t};	  Term2, Term3, Term4, Term5	: real {double_t};      NZ                            : integer;    BEGIN      IF El <= 0.0 THEN El := 1.0; { Paranoia }      IF E_o <= 0.0 THEN E_o := 1.0; { Paranoia }      El := El / 1000.0;      IF ((E_o <= El) OR (Z < 16) OR (Z > 95)) THEN        BEGIN          Ql := zero;          exit(Ql);        END;      UZ := E_o / El;            IF ((Running_Thin_Mode) AND (Thin_L_Xsect = 7)) THEN        BEGIN {¥¥¥ Schreiber-Wimms ¥¥¥}          temp := 6.51E-20 * 4 * (0.2704 + 0.007256 * ln(Z) * ln(Z) * ln(Z)) / (El * E_o) * ln(1.0 * UZ);        END;      IF ((Running_Thin_Mode) AND (Thin_L_Xsect = 8)) THEN        BEGIN {¥¥¥ Bethe/Fermi (Zaluzek) ¥¥¥}          Ak := 6.4924E-20;          Bk := 0.25;          NZ := 8; { should not this be 4, the number of electrons in the ¥sub¥ shell, Damn Nestor's parameterization }          Bt := 1.0 - ((1.0 / (1.0 + E_o / 511.0)) * (1.0 / (1.0 + E_o / 511.0)));          h := (1.0 - exp( - El / 2.0));          BZ := (5.0 * h / UZ) * (1.0 - exp( - (1250.0 / El) / (UZ * UZ)));          temp := Ak * Bk * NZ * (ln(4.0 * E_o / (BZ * El)) - ln(1.0 - Bt) - Bt) / (El * E_o);        END;      IF ((Running_Thin_Mode) AND (Thin_L_Xsect = 9)) OR ((Running_Bulk_Mode) AND (Bulk_L_Xsect = 5)) THEN        BEGIN {¥¥¥ Brown-Powell ¥¥¥}          temp := 6.51E-20 * 4 * (0.44 + 0.0020 * Z) / (El * E_o) * ln(UZ);        END;      IF ((Running_Bulk_Mode) AND (Bulk_L_Xsect = 6)) THEN        BEGIN {¥¥¥ Fiori/Myklebust ¥¥¥}          { Basic Bethe, sub shell has 4 electrons }         { temp := (6.51E-20 * 4)*(1.08263+0.0320451*E_o-4.3197E-4*E_o*E_o-0.0538427*El+6.41132E-3*El*El)       / (El * E_o) * LN(E_o / El);}          temp := (6.51E-20 * 4) * 1.41 / (El * E_o) * ln(UZ);        END;      IF ((Running_Thin_Mode) AND (Thin_L_Xsect = 6)) THEN        BEGIN {¥¥¥ Bethe-Fiori ¥¥¥}          { Basic Bethe, sub shell has 4 electrons }          temp := (6.51E-20 * 4) * 2.22 / (El * E_o) * ln(UZ);        END;      IF ((Running_Thin_Mode) AND (Thin_L_Xsect = 10)) OR ((Running_Bulk_Mode) AND (Bulk_L_Xsect = 4)) THEN        BEGIN {¥¥¥ Bethe-Powell ¥¥¥}	{*** Uo must be greater than 1.67 or you get negative peaks ***}		  if (E_o / El < 1.67) then begin			temp := 0.0;		  end		  else            temp := 6.51E-20 * 4 * 0.75 / (El * E_o) * ln(0.6 * UZ);        END;      IF ((Running_Thin_Mode) AND (Thin_L_Xsect = 11)) OR ((Running_Bulk_Mode) AND (Bulk_L_Xsect = 3)) THEN        BEGIN {¥¥¥ Ray Edgerton's SIGMA L ¥¥¥}          IF (Z < 13) OR (Z > 30) THEN            BEGIN              temp := 0.0;              Putmessage('Sigma L is only valid between Z=13 to Z=30', '', '', '');            END          ELSE temp := SigmaL(E_o);        END;      IF ((Running_Thin_Mode) AND (Thin_L_Xsect = 12)) {OR ((Running_Bulk_Mode) AND (Bulk_L_Xsect = 2))} THEN        BEGIN {¥¥¥ Mott-Massey ¥¥¥}          temp := 6.51E-20 * 4 * 0.25 / (El * E_o) * ln(2.42 * UZ);        END;      IF ((Running_Thin_Mode) AND (Thin_L_Xsect = 5)) OR ((Running_Bulk_Mode) AND (Bulk_L_Xsect = 7)) THEN        BEGIN {¥¥¥ Casnati ¥¥¥}          F2 := -1.736 / UZ + 0.317 / (UZ * UZ);		  Term1 := 10.57 * exp(F2);	{CF}		  Term2 := -0.0318 + 0.316 / UZ - 0.1135 / (UZ * UZ);		{CD}		  RI := El / 511;		  RT := E_o / 511;		  RI1 := 1 + RI;		  RT1 := 1 + RT;		  RI2 := 2 + RI;		  RT2 := 2 + RT;		  Term3 := ((RT + RI) * RT2 * RI1 * RI1) / (RT * RT2 * RI1 * RI1 + RI * RI2);		  Term5 := fast_power(Term3,1.5);		  F1 := El / 0.013606;		  Term4 := fast_power(F1,Term2);	{CP^CD}		  RF := (RI2 / RT2) * (RT1 / RI1) * (RT1 / RI1) * Term5;          temp := 5.18E-21 * 4 * RF * Term4 * Term1 * ln(UZ) / (UZ * El * El);        END;	IF ((Running_Bulk_Mode) AND (Bulk_L_Xsect = 8)) THEN		BEGIN	{¥¥¥ Pouchou & Pichoir ¥¥¥}			Term1 := 0.82;			temp := 6.51E-20 * 4 * exp(1) * Term1 / fast_power(UZ,Term1) * ln(UZ) / ( El * El);				END;			IF ((Running_Bulk_Mode) AND (Bulk_L_Xsect = 9)) THEN		BEGIN	{¥¥¥ Pouchou ¥¥¥}			Term1 := 0.82;			temp := 1.2E-20 * 4 * exp(1) * Term1 * ln(UZ) / fast_power(UZ,Term1) / ( El * El);				END;	IF ((Running_Bulk_Mode) AND (Bulk_L_Xsect = 10)) THEN		BEGIN	{¥¥¥ Jakoby ¥¥¥}		  RI := El / 511;		  RT := E_o / 511;		  Rbet0 := 1.0 - 1.0/((1 + RI) * (1 + RI));          Rbet := 1.0 - 1.0/((1 + RT) * (1 + RT));          F1 := 2.549E-22/(El*Rbet);          F2 := ln(Rbet/(1 - Rbet)) - Rbet;          F3 := 1.0 - Rbet0/Rbet;          F4 := ln(1.0/Rbet0);          F5 := Rbet0/Rbet;          Term1 := 5.14 * fast_power(Z,-0.48);          Term2 := 5.76 - 0.04 * Z;          Term3 := 0.72 + 0.039 * Z - 0.0006 * Z * Z;          temp := Term1 * F1 * (F2 + Term2 * F3 + F4 * fast_power(F5,Term3));				END;	IF ((Running_Bulk_Mode) AND (Bulk_L_Xsect = 11)) THEN		BEGIN	{¥¥¥ Green_Cosslett ¥¥¥}			temp := 6.51E-20 * 4 * 0.61 / (El * E_o) * ln(UZ);		END;      { Some last minute paranoia }      Ql := temp;      IF Running_Thin_Mode THEN Ql := Thin_L_ScaleFactor * temp;      IF Running_Bulk_Mode THEN Ql := Bulk_L_ScaleFactor * temp;    END;  FUNCTION Qm(E_o, Em: real {double_t}): real {double_t}; { E_o in kV, Em in eV }    VAR	  RI, RI1, RI2, RT, RT1, RT2, RF: real {double_t};	  Rbet0,Rbet,F1,F2,F3,F4,F5		: real {double_t};	  Term2, Term3, Term4, Term5	: real {double_t};      temp, UZ                		: real {double_t};    BEGIN      IF Em <= 0.0 THEN Em := 1; { Paranoia }      IF E_o <= 0.0 THEN E_o := 1; { Paranoia }      Em := Em / 1000.0;      IF ((E_o <= Em) OR (Z < 35) OR (Z > 95)) THEN        BEGIN          Qm := zero;          exit(Qm);        END;	  UZ := E_o / Em;      IF ((Running_Thin_Mode) AND (Thin_M_Xsect = 7)) OR ((Running_Bulk_Mode) AND (Bulk_M_Xsect = 2)) THEN        BEGIN {¥¥¥ Bethe-Fiori ¥¥¥}          temp := (6.51E-20 * 6) * 15 / (Em * E_o) * ln(UZ);          { Basic Bethe, sub shell has 6 electrons }        END;      IF ((Running_Thin_Mode) AND (Thin_M_Xsect = 6)) OR ((Running_Bulk_Mode) AND (Bulk_M_Xsect = 3)) THEN        BEGIN {¥¥¥ Bethe ¥¥¥}          temp := (6.51E-20 * 6) / (Em * E_o) * ln(UZ);          { Basic Bethe, sub shell has 6 electrons }        END;      IF ((Running_Thin_Mode) AND (Thin_M_Xsect = 5)) THEN        BEGIN {¥¥¥ Schreiber-Wimms ¥¥¥}          temp := 6.51E-20 * 6 * (11.335 - 2.428 * ln(Z)) / (Em * E_o) * ln(1.0 * UZ);        END;      IF ((Running_Thin_Mode) AND (Thin_M_Xsect = 4)) OR ((Running_Bulk_Mode) AND (Bulk_M_Xsect = 4)) THEN        BEGIN {¥¥¥ Casnati ¥¥¥}          F2 := -1.736 / UZ + 0.317 / (UZ * UZ);		  Term1 := 10.57 * exp(F2);	{CF}		  Term2 := -0.0318 + 0.316 / UZ - 0.1135 / (UZ * UZ);		{CD}		  RI := Em / 511;		  RT := E_o / 511;		  RI1 := 1 + RI;		  RT1 := 1 + RT;		  RI2 := 2 + RI;		  RT2 := 2 + RT;		  Term3 := ((RT + RI) * RT2 * RI1 * RI1) / (RT * RT2 * RI1 * RI1 + RI * RI2);		  Term5 := fast_power(Term3,1.5);		  F1 := Em / 0.013606;		  Term4 := fast_power(F1,Term2);	{CP^CD}		  RF := (RI2 / RT2) * (RT1 / RI1) * (RT1 / RI1) * Term5;          temp := 5.18E-21 * 6 * RF * Term4 * Term1 * ln(UZ) / (UZ * Em * Em);        END;	IF ((Running_Bulk_Mode) AND (Bulk_M_Xsect = 5)) THEN		BEGIN	{¥¥¥ Pouchou_Pichoir ¥¥¥}			Term1 := 0.78;			temp := 6.51E-20 * 6 * exp(1) * Term1 / fast_power(UZ,Term1) * ln(UZ) / ( Em * Em);						END;	IF ((Running_Bulk_Mode) AND (Bulk_M_Xsect = 6)) THEN		BEGIN	{¥¥¥ Pouchou ¥¥¥}			Term1 := 0.78;			temp := 1.2E-20 * 4 * exp(1) * Term1 * ln(UZ) / fast_power(UZ,Term1) / ( Em * Em);		END;	IF ((Running_Bulk_Mode) AND (Bulk_M_Xsect = 7)) THEN		BEGIN	{¥¥¥ Rez ¥¥¥}			temp := 6.51E-20 * 6 * 1.224 / (Em * E_o) * ln(0.702 * UZ) / UZ;		END;	IF ((Running_Bulk_Mode) AND (Bulk_M_Xsect = 8)) THEN		BEGIN	{¥¥¥ Gryzinski ¥¥¥}		  Term2 := SQRT((UZ - 1.0) / (UZ + 1.0));		  Term3 := Term2 * Term2 * Term2;		  Term1 := (1.0 / UZ) * Term3 * (1.0 + (2.0 / 3.0) * (1.0 - 1.0 / (2.0 * UZ)) * ln(2.7 + SQRT(UZ - 1)));          temp := 6.51E-20 * 6 * Term1 / ( Em * Em);				END;	IF ((Running_Bulk_Mode) AND (Bulk_M_Xsect = 9)) THEN		BEGIN	{¥¥¥ Fabre ¥¥¥}			temp := 6.51E-20 * 6 * ln(UZ) / (Em * Em * 1.18 * (UZ + 1.32));		END;      { Some last minute paranoia }      Qm := temp;      IF Running_Thin_Mode THEN Qm := Thin_M_ScaleFactor * temp;      IF Running_Bulk_Mode THEN Qm := Bulk_M_ScaleFactor * temp;    END;  FUNCTION Modified_Bethe_Heitler(Echar: real {double_t}): real {double_t};    VAR      dK                            : real {double_t};      tZ                            : real {double_t};      eZ                            : real {double_t};      ezSQ                          : real {double_t};      pzSQ                          : real {double_t};      pZ                            : real {double_t};      Xkay                          : real {double_t};      Efin                          : real {double_t};      Theta_t                       : real {double_t};      t_Angle                       : real {double_t};      SinTH                         : real {double_t};      SNSQTH                        : real {double_t};      COSTH                         : real {double_t};      eeZ                           : real {double_t};      EfinSQ                        : real {double_t};      PfinSQ                        : real {double_t};      Pfin                          : real {double_t};      XkSQ                          : real {double_t};      delZ                          : real {double_t};      ppZ                           : real {double_t};      eeZ1                          : real {double_t};      Alpha                         : real {double_t};      ALSQ                          : real {double_t};      QSQ                           : real {double_t};      Epsi                          : real {double_t};      BIGQ                          : real {double_t};      delZSQ                        : real {double_t};      PSQD2                         : real {double_t};      PSQD4                         : real {double_t};      Q2D2                          : real {double_t};      PSQD                          : real {double_t};      Ater                          : real {double_t};      Bter                          : real {double_t};      Cter                          : real {double_t};      Dter                          : real {double_t};      Fter                          : real {double_t};      Eter                          : real {double_t};      Gter                          : real {double_t};      Hter                          : real {double_t};      FGter                         : real {double_t};      EPter                         : real {double_t};      X2KAY                         : real {double_t};      SUMter                        : real {double_t};      EQter                         : real {double_t};      BLNUM                         : real {double_t};      bigL                          : real {double_t};      PZ2A2                         : real {double_t};      BLDNM                         : real {double_t};      EPSIQN                        : real {double_t};      EPSIQD                        : real {double_t};      brac                          : real {double_t};      stuff                         : real {double_t};      PI2Z                          : real {double_t};      betaZ                         : real {double_t};      beta                          : real {double_t};      ELX0                          : real {double_t};      EpSIQ                         : real {double_t};      ELX                           : real {double_t};      Elwert                        : real {double_t};    BEGIN      { independent stuff ¥¥¥¥move this out of the fn maybe by a boolean at call time}      (*   t_Angle := 90.0 + theGenRec^^.Take_Off_Angle;*)      t_Angle := 90.0 + theGenRec^^.Elevation;      Theta_t := t_Angle / 57.295779;      SinTH := Sin(Theta_t);      SNSQTH := SinTH * SinTH;      COSTH := COS(Theta_t);      dK := 0.001 * theGenRec^^.dE / 511.0;      tZ := Thin_KV / 511.0; {electron kinetic energy in units of mc**2 = 511Kev}      eZ := tZ + 1.0; {Total electron energy}      ezSQ := eZ * eZ;      pzSQ := ezSQ - 1.0; {incident electron momentum**2}      pZ := sqrt(pzSQ);      delZ := eZ - pZ * COSTH;      delZSQ := delZ * delZ;      PSQD2 := pzSQ * delZSQ;      PSQD4 := PSQD2 * delZSQ;      PSQD := pzSQ * delZ;      Ater := 8.0 * SNSQTH * (2.0 * ezSQ + 1.0) / PSQD4;      betaZ := pZ / eZ;      { Z dependent stuff ¥¥¥¥move this out of the fn perhaps by a boolean at call time}      Alpha := 108.0 / (exp((1.0 / 3.0) * ln(Z))); { Z is the global atomic # from get_Energies}      ALSQ := Alpha * Alpha;      PZ2A2 := pzSQ / ALSQ;      PI2Z := - 2.0 * Pi * Z / 137.0;      ELX0 := exp(PI2Z / betaZ);      { Energy dependent stuff }      IF Echar < 0.05 THEN Echar := 0.05; { to "flat top" the cont. dist. at low E}      Xkay := Echar / 511.0; {Photon energy in M0*C**2 units}      Efin := eZ - Xkay; {Final electron total energy}      eeZ := Efin * eZ;      EfinSQ := Efin * Efin;      PfinSQ := Efin * Efin - 1.0; {Final total electron momentum}      Pfin := sqrt(PfinSQ);      XkSQ := Xkay * Xkay;      ppZ := pZ * Pfin;      eeZ1 := eeZ - 1.0;      QSQ := pzSQ + XkSQ - 2.0 * pZ * Xkay * COSTH;      Q2D2 := QSQ * delZSQ;      Epsi := ln((Efin + Pfin) / (Efin - Pfin));      BIGQ := sqrt(QSQ);      Bter := 2.0 * (5.0 * ezSQ + 2.0 * eeZ + 3.0) / PSQD2;      Cter := 2.0 * (pzSQ - XkSQ) / Q2D2;      Dter := 4.0 * Efin / PSQD;      Eter := 4.0 * eZ * SNSQTH * (3.0 * Xkay - pzSQ * Efin) / PSQD4;      Fter := 4.0 * ezSQ * (ezSQ + EfinSQ);      Gter := 2.0 - 2.0 * (7.0 * ezSQ - 3.0 * Efin * eeZ + EfinSQ);      FGter := (Fter + Gter) / PSQD2;      X2KAY := 2 * Xkay;      Hter := X2KAY * (ezSQ + eeZ - 1.0) / PSQD;      BLNUM := (eeZ - 1.0 + ppZ) * (eeZ - 1.0 + ppZ);      BLDNM := XkSQ + PZ2A2 / delZSQ;      bigL := ln(BLNUM / BLDNM);      SUMter := bigL * (Eter + FGter + Hter) / ppZ;      EPter := 4.0 * Epsi / (Pfin * delZ);      EPSIQN := (BIGQ + Pfin) * (BIGQ + Pfin) * (BIGQ + Pfin) * (BIGQ + Pfin);      EPSIQD := 4.0 * (XkSQ * delZSQ + PZ2A2);      EpSIQ := 0.5 * ln(EPSIQN / EPSIQD);      EQter := EpSIQ * (4.0 / delZSQ - 6.0 * Xkay / delZ - X2KAY * (pzSQ - XkSQ) / (QSQ * delZ)) / (Pfin * BIGQ);      brac := Ater - Bter - Cter + Dter + SUMter - EPter + EQter;      stuff := Z * Z {* Domega} * 2.3096054E-29 * dK * Pfin / (Xkay * pZ);            { Note: Brem radiation is into a unit steradian and not 4*pi as is characteristic,       so we get (DOMEGA/4*pi) * (4*pi) = DOMEGA }      beta := Pfin / Efin;      ELX := exp(PI2Z / beta);      Elwert := betaZ * (1.0 - ELX0) / (beta * (1.0 - ELX));      { 2.3096054E-29=r0*r0/8*PI*137 where r0=2.82E-13 cm is the classical electron radius.}      Modified_Bethe_Heitler := stuff * brac * Elwert;    END; { FUNCTION Modified_Bethe_Heitler }  FUNCTION Marshall_Hall(KEV: real {double_t}): real {double_t};    VAR      J, E, E_o                      : real {double_t};    BEGIN      J := J_Factor(Z) * 1000.0;      E := KEV * 1000.0;      E_o := Thin_KV * 1000.0;      Marshall_Hall := 3.65E-23 * Z * Z / (E_o * E) * ln(1.166 * E_o / J) * theGenRec^^.dE;    END; { Marshall_Hall }  FUNCTION Kirkpatrick_Weidmann(KEV: real {double_t}): real {double_t};    VAR      E0, E, ZC, Y3, Y2, Y1, YH, yj, YK, A, B, AA, BB, Bt, THETA, c, S, U, YF, XF: real {double_t};    BEGIN      E0 := 1000.0 * Thin_KV;      E := 1000.0 * KEV;      ZC := E0 / (300.0 * Z * Z);      U := E / E0;      Y3 := - 0.00259 + 0.00776 / (ZC + 0.116);      Y2 := 0.067 + 0.023 / (ZC + 0.75);      Y1 := 0.22 * (1.0 - 0.39 * exp( - 26.9 * ZC));      YH := ( - 0.214 * Y1 + 1.21 * Y2 - Y3) / (1.43 * Y1 - 2.43 * Y2 + Y3);      yj := (1.0 + 2.0 * YH) * Y2 - 2.0 * (1.0 + YH) * Y3;      YK := (1.0 + YH) * (Y3 + yj);      A := exp( - 0.223 * ZC) - exp( - 57.0 * ZC);      B := exp( - 0.0828 * ZC) - exp( - 84.9 * ZC);      AA := 1.47 * B - 0.507 * A - 0.833;      BB := 1.70 * B - 1.09 * A - 0.627;      Bt := (1.0 / (E0 / 5.11E05 + 1.0));      Bt := sqrt(1.0 - Bt * Bt);      (* THETA := (90.0 + theGenRec^^.Take_Off_Angle) / 57.295779; *) {THETA := ANGLE/57.295779}      THETA := 90.0 + theGenRec^^.Elevation;      c := COS(THETA);      Y3 := (1.0 - Bt * c);      Y3 := Y3 * Y3;      S := Sin(THETA);      S := S * S / Y3;      c := 1.0 + (1 + c * c) / Y3;      Y1 := (U - 0.135);      YF := ( - yj + YK / (U + YH)) / ZC;      XF := (0.252 + AA * Y1 - BB * Y1 * Y1) / ZC;      Kirkpatrick_Weidmann := 1.5091E-24 * (XF * S + YF * c) * theGenRec^^.dE / E;    END; {Kirkpatrick_Weidmann}  PROCEDURE Q_Continuum_Thin(Z_in: integer);                 { Enter 0 for Z_in if the inputs are to come from the thin input window,                   ie, a multi- element specimen, otherwise, a legitamate atomic number will                   load the Bkg_P^[K] array with the continuum for that single element}    VAR      Concentration                 : Real;      k, nn, Chan          			: integer;      counter                       : integer;      templo, temphi            	: integer;      Numb_of_Elements            	: integer;      Q_Continuum                   : Real;      E_keV                         : Real;    BEGIN      IF ((Z_in < 3) AND (Z_in <> 0)) OR (Z_in > 95) THEN        BEGIN          Putmessage('An invalid atomic number was supplied to the thin film continuum procedure', '', '', '');          exit(Q_Continuum_Thin);        END      ELSE IF Z_in = 0 THEN        BEGIN              temphi := theGenRec^^.Number_of_Channels;              templo := 1;          Numb_of_Elements := 0;          FOR k := 1 TO 15 {10} DO            IF (A^.Thin_Concentration[k] <> 0.0) AND (A^.Thin_At_Num[k] <> 0) THEN			Numb_of_Elements := Numb_of_Elements + 1;        END      ELSE        BEGIN          Numb_of_Elements := 1;          Concentration := 1.0;          Get_Energies(Z_in);        END;                             { Clear the global continuum spectrum }      For nn := 1 to Maximum_Channels do Bkg_P^[nn] := 0.0;	        FOR counter := 1 TO Numb_of_Elements DO        BEGIN { Numb_of_Elements loop }          IF Z_in = 0 THEN            BEGIN			  Get_Energies(A^.Thin_At_Num[counter]);              temphi := theGenRec^^.Number_of_Channels;              templo := 1;            END          ELSE            BEGIN              IF K_Peak_2_Bkg THEN temphi := rinttol(eV_Line[1] / theGenRec^^.dE);              IF L_Peak_2_Bkg THEN temphi := rinttol(eV_Line[42] / theGenRec^^.dE);              IF M_Peak_2_Bkg THEN temphi := rinttol(eV_Line[72] / theGenRec^^.dE);              templo := temphi;            END;          FOR Chan := temphi DOWNTO templo DO            BEGIN              SpinCursor;              E_keV := Chan * theGenRec^^.dE * 0.001;              Q_Continuum := 0.0;              IF Thin_CONT_Xsect = 7 THEN Q_Continuum := Modified_Bethe_Heitler(E_keV)              ELSE IF Thin_CONT_Xsect = 5 THEN Q_Continuum := Kirkpatrick_Weidmann(E_keV)              ELSE IF Thin_CONT_Xsect = 4 THEN Q_Continuum := Marshall_Hall(E_keV);              IF Z_in = 0 THEN Concentration := A^.Thin_Concentration[counter];              Bkg_P^[Chan] := Bkg_P^[Chan] + Concentration * Thin_CONT_ScaleFactor * Q_Continuum /                                       Atomic_Weight;              IF E_keV >= Thin_KV THEN Bkg_P^[Chan] := zero;              IF Bkg_P^[Chan] <= 0.0 THEN Bkg_P^[Chan] := zero;            END; { End of loop (1..theGenRec^^.number_of_Channels) to generate the Qz*dE for a single Z thin specimen }        END; { of all the elements loop }    END; { Procedure Q_Continuum_Thin }     PROCEDURE Romberg(LowerLimit, UpperLimit, Tolerance: real {double_t}; MaxIter: integer; VAR Integral:                    real {double_t}; VAR Iter: integer; VAR Error: byte);    TYPE      vecSize                       = ARRAY [0..50] OF real {double_t};    VAR      Spacing                       : real {double_t};       { Spacing between points }      NewEstimate, OldEstimate      : vecSize;        { Iteration variables }      TwoToTheIterMinus2            : integer;    FUNCTION UserFunction(E: real {double_t}): real {double_t}; { E in keV here }      VAR        temp                          : real {double_t};      BEGIN        { shell selected by global "shell" }{  A^.edge[] is a global quantity which must be defined by a call to "get_Energies" first.   In the below, E is in keV and A^.edge[] is in eV }        IF shell = 1 THEN temp := Qk(E, A^.edge[1]) / Stopping_Power(E);        IF shell = 2 THEN temp := Ql(E, A^.edge[4]) / Stopping_Power(E);        IF shell = 3 THEN temp := Qm(E, A^.edge[9]) / Stopping_Power(E);        UserFunction := temp;      END;    PROCEDURE TestAndInitialize(LowerLimit, UpperLimit, Tolerance: real {double_t}; MaxIter: integer; VAR                                 Iter: integer; VAR Spacing: real {double_t}; VAR OldEstimate: vecSize; VAR                                 TwoToTheIterMinus2: integer; VAR Error: byte);      BEGIN        Error := 0;        IF Tolerance <= 0 THEN Error := 1;        IF MaxIter <= 0 THEN Error := 2;        IF Error = 0 THEN          BEGIN            Spacing := UpperLimit - LowerLimit;            OldEstimate[1] := Spacing * (UserFunction(LowerLimit) + UserFunction(UpperLimit)) / 2;            Iter := 1;            TwoToTheIterMinus2 := 1;          END;      END; { procedure TestAndInitialize }    PROCEDURE Trapezoid(TwoToTheIterMinus2: integer; LowerLimit, Spacing, Old_Estimate: real {double_t};                        VAR New_Estimate: real {double_t});      VAR        sum                           : real {double_t};        Dummy                         : integer;      BEGIN        sum := 0;        FOR Dummy := 1 TO TwoToTheIterMinus2 DO          sum := sum + UserFunction(LowerLimit + (Dummy - 0.5) * Spacing);        New_Estimate := 0.5 * (Old_Estimate + Spacing * sum);      END; { procedure Trapezoid }    PROCEDURE Extrapolate(Iter: integer; OldEstimate: vecSize; VAR NewEstimate: vecSize);      VAR        Extrap                        : integer;        FourToTheExtrapMinus1         : real {double_t};      BEGIN        FourToTheExtrapMinus1 := 1;        FOR Extrap := 2 TO Iter DO          BEGIN            FourToTheExtrapMinus1 := FourToTheExtrapMinus1 * 4;            NewEstimate[Extrap] := (FourToTheExtrapMinus1 * NewEstimate[Extrap - 1] - OldEstimate[Extrap - 1]) / (                                   FourToTheExtrapMinus1 - 1);          END;      END; { procedure Extrapolate }    BEGIN { procedure Romberg }      TestAndInitialize(LowerLimit, UpperLimit, Tolerance, MaxIter, Iter, Spacing, OldEstimate, TwoToTheIterMinus2,                        Error);      IF Error = 0 THEN        BEGIN          REPEAT            SpinCursor;            Iter := Succ(Iter);            Trapezoid(TwoToTheIterMinus2, LowerLimit, Spacing, OldEstimate[1], NewEstimate[1]);            TwoToTheIterMinus2 := TwoToTheIterMinus2 * 2;            Extrapolate(Iter, OldEstimate, NewEstimate);            Spacing := Spacing / 2;            OldEstimate := NewEstimate;          UNTIL { The fractional difference between }          { iterations is within Tolerance    }           (abs(NewEstimate[Iter - 1] - NewEstimate[Iter]) <= abs(Tolerance * NewEstimate[Iter])) OR (Iter >= MaxIter);          IF Iter >= MaxIter THEN Error := 3;          Integral := NewEstimate[Iter];        END;      ChangeCursor(ArrowC);    END; { procedure Romberg }  FUNCTION Integrate_Q_over_S(Level: integer): real {double_t};    VAR      Ec, Integral                  : real {double_t};      Iter                          : integer;      Error                         : byte;      { Bulk_kV and A^.edge[] are global quantities. A^.edge[] must be defined by a call to      "get_Energies" first }    BEGIN      Integral := zero;      IF Level = 1 THEN Ec := A^.edge[1] / 1000.0; { K }      IF Level = 2 THEN Ec := A^.edge[4] / 1000.0; { L }      IF Level = 3 THEN Ec := A^.edge[9] / 1000.0; { M }      shell := Level; { Set the global "Shell" }      Romberg(Bulk_kV, {LowerLimit both Bulk_kV, Ec in keV here }              Ec, {UpperLimit}              1E-6 {Tolerance} , 500 {MaxIter} , Integral, Iter, Error);      Integrate_Q_over_S := Integral;    END;  PROCEDURE Add_Escape_Peaks; { Add escape peaks to what is in col1 }    VAR      nn, ndown, ndown1, ndown2, ndown3		: integer;      E, M, B, Re, ESCMAG, costrm   : Real;    BEGIN      IF theGenRec^^.Detector.Spec = EDS THEN        BEGIN		    IF theGenRec^^.Detector.ID = 2 THEN	{Ge Detector}            BEGIN                costrm := COS((90 - theGenRec^^.Detector_Tilt) / 57.295779);                M := 0.01517 * costrm - 0.000803; { Peter Statham's equation }                B := 0.0455 * costrm + 0.01238;                ndown := rinttol(9885.0 / theGenRec^^.dE);	{ Ge K-alpha}			    ndown1 := rinttol(10980.0 / theGenRec^^.dE);	{ Ge K-beta}			    ndown2 := rinttol(1188.0 / theGenRec^^.dE);	{ Ge L-alpha1}			    ndown3 := rinttol(1218.0 / theGenRec^^.dE);	{ Ge L-beta1}				                FOR nn := rinttol(1217 / theGenRec^^.dE) TO theGenRec^^.Number_of_Channels DO { Add Escape events }                  BEGIN                    E := nn * theGenRec^^.dE;                    E := E * 0.001; { ch energy in keV }                    Re := 0.0202 / (1 + (M * E + B) * E * E);                    ESCMAG := Re * Col_1^[nn]/(Re+1);	{Col_1 here has the true intensity}					  Col_1^[nn - ndown2] := Col_1^[nn - ndown2] + ESCMAG;	{L-alpha1}					  IF (nn > rinttol(1248 / Plt_spec[10]^^.Expt_Info.dE)) then 						Col_1^[nn - ndown3] := Col_1^[nn - ndown3] + ESCMAG;	{L-beta1}					  IF (nn > rinttol(11103 / Plt_spec[10]^^.Expt_Info.dE)) then begin						Col_1^[nn - ndown] := Col_1^[nn - ndown] + ESCMAG;	{K-alpha}						Col_1^[nn - ndown1] := Col_1^[nn - ndown1] + ESCMAG;	{K-beta}					  end;					Col_1^[nn] := Col_1^[nn] - ESCMAG;                  END		    END 			ELSE BEGIN	{theGenRec^^.Detector.ID = 1}              costrm := COS((90 - theGenRec^^.Detector_Tilt) / 57.295779);              M := 0.01517 * costrm - 0.000803; { Peter Statham's equation }              B := 0.0455 * costrm + 0.01238;              ndown := rinttol(1740.0 / theGenRec^^.dE);              FOR nn := rinttol(1840 / theGenRec^^.dE) TO theGenRec^^.Number_of_Channels DO { Add Escape events }                BEGIN	{...the last (1840-1740)/dE + 1 chs don't get any addition of counts}                  E := nn * theGenRec^^.dE;                  E := E * 0.001; { ch energy in keV }                  Re := 0.0202 / (1 + (M * E + B) * E * E);                  ESCMAG := Re * Col_1^[nn]/(1 + Re);				  Col_1^[nn] := Col_1^[nn] - ESCMAG;	{11/23/93}                  Col_1^[nn - ndown] := Col_1^[nn - ndown] + ESCMAG;                END;           END;        END { IF theGenRec^^.Detector.Spec = EDS...}      ELSE        IF theGenRec^^.Detector.Spec = WDS THEN          BEGIN          END;    END;{$S Physics21}  {[f-]}  {*****************************} PROCEDURE Thin_Film; {*****************************}{[f+]}        VAR      K_Hold                        : integer;      L_Hold                        : integer;      M_Hold                        : integer;      J, k, nn						: integer;      E, YE, YE_SiLi                : Real;      i                             : integer;      counter                       : integer;      JJ                            : integer;	  En_Lim						: real;      SIGSQ                         : Real;      DELESQ                        : Real;      theConst                      : Real;      aConst                        : Real;      SigConst                      : Real;      ZConst                        : Real;      Mu_over_Rho                   : Real;      Intensity,Intensity_x         : Real;      Rho_T                         : Real;      cscTheta                      : Real;      Num_SubLayers                 : integer;      Av_At_Number                  : Real;      T_Calc, theAngle              : real {double_t};	  L_theGenRec					: SiLi_Rec;	      PROCEDURE Thin_Dependent_Peak_Gen(Pk_eV, Pk_Wt: Real; ParantLine: integer);		VAR			theWeight	: real {double_t};			theYield	: real {double_t};			QS_index	: integer;			theScale	: real {double_t};			      BEGIN	    if Valid_Peak > 750 then		  begin		    Putmessage('WARNING, you have 750 peaks and are trying for more',			           'and I cant do what you want. Are you sure you need this many?',					   '',''); 		    exit(Thin_Dependent_Peak_Gen);		  end;		  		IF Pk_eV < 50 THEN 		  begin 		    exit(Thin_Dependent_Peak_Gen);		  end;           (*IF Pk_eV >= Thin_KV * 1000 THEN Pk_Wt := 0.0;*)         IF theEdge >= Thin_KV * 1000 THEN exit(Thin_Dependent_Peak_Gen);{Pk_Wt := 0.0;	}	{¥¥¥The edge voltage, NOT the peak¥¥¥}        Valid_Peak := Valid_Peak + 1;        Line_Energy^[Valid_Peak] := Pk_eV;		if ParantLine <> 0 then       		Generated^[Valid_Peak] := Pk_Wt * Generated^[ParantLine]		else			BEGIN			  if peak_label[1] = 'K' then			   begin			    theWeight := SAK(A^.Thin_At_Num[counter]);				theYield := WK(A^.Thin_At_Num[counter]);				QS_index := 1;				theScale := Qk(Thin_KV, theEdge);			   end;			  if peak_label[1] = 'L' then			   begin			    theWeight := SAL(A^.Thin_At_Num[counter]);			    theYield := WL(A^.Thin_At_Num[counter]);				QS_index := 2;				theScale := Ql(Thin_KV, theEdge);			   end;			  if peak_label[1] = 'M' then			   begin			    theWeight := SAM(A^.Thin_At_Num[counter]);				theYield := WM(A^.Thin_At_Num[counter]);				QS_index := 3;				theScale := Qm(Thin_KV, theEdge);			   end;		                 Generated^[Valid_Peak] := Pk_Wt * theScale * theYield *			  							theWeight * ZConst;			END;      END; { Procedure Thin_Dependent_Peak_Gen; }    BEGIN { Procedure Thin_Film }      PutBusyMessage('Busy calculating a first principles thin target spectrum.',	               'Please wait......','','') ;  	  	if (BG_Active) then	    L_theGenRec := theBGRec^^	else	    L_theGenRec := theGenRec^^;      Av_At_Number := zero;      Numb_of_Elements := 0;      FOR k := 1 TO 15 DO	  IF (A^.Thin_Concentration[k] <> 0.0) AND (A^.Thin_At_Num[k] <> 0) THEN	  begin		Numb_of_Elements := Numb_of_Elements + 1;		Av_At_Number := A^.Thin_Concentration[k] * A^.Thin_At_Num[k] + Av_At_Number;	  end;        cscTheta := 1 / Sin(L_theGenRec.Take_Off_Angle / 57.295779);      FOR k := 1 TO 750 DO {!!!Would 750 be enough if we had 15 HEAVY elements???}         BEGIN          Line_Energy^[k] := zero;          Generated^[k] := zero;          Inside_Detector^[k] := zero;          InFront_Detector^[k] := zero;        END;      FOR k := 1 TO Maximum_Channels DO        BEGIN		   Gen_P^[k] := 0.0;		   Ob_Pks_P^[k] := 0.0;		   mu_rho_P^[k] := 0.0;		   f_chi_P^[k] := 0.0;	{Use this for emitted peaks}		   Col_1^[k] := 0.0;		   Col_2^[k] := 0.0;		   Col_3^[k] := 0.0;		   Col_4^[k] := 0.0;		   Col_5^[k] := 0.0;		   Col_6^[k] := 0.0;		  { Plt_spec[7]^^.s[k] := 0.0;		   Plt_spec[8]^^.s[k] := 0.0; }       END;    			En_Lim := L_theGenRec.Number_of_Channels * L_theGenRec.dE;      Domega := L_theGenRec.Detector_Area / (L_theGenRec.Spec_Detector_Distance * L_theGenRec.Spec_Detector_Distance);      theAngle := ArcTan(sqrt(sqr(tan(Geom.X_Tilt_angle / 57.295779)) + sqr(tan(Geom.Y_Tilt_angle / 57.295779))));      T_Calc := Specimen_Thickness / COS(theAngle); {the thickness the beam sees because of tilts}      Rho_T := Thin_Density * Specimen_Thickness;	  Num_SubLayers := rinttol(Specimen_Thickness/0.0000010);  {cm/100 in cm}      Thin_Physics_Constant := 6.023E23 * Thin_Density * { gms/cc }                               Faraday_Current * 6.24196E9 * { current in nA * 6.24196e9 is Ne }                               T_Calc * Live_Time;      theConst := Domega * Thin_Physics_Constant;      aConst := theConst / Pi4;      Q_Continuum_Thin(0);	{ produces Bkg_P^ }     {comes back as (Qz*dE/Atomic_Weight), per unit Steradian into the take-off angle specified,      weighted for all the elements in the thin specimen, in the array ¥¥ Bkg_P^[k] ¥¥ .      The 0 in the argument is to signal that the procedure should use the	  concentrations etc from the thin input window}    { Now scale Bkg_P^[k] to be the radiation about to enter the detector.	  This form will be the same as the characteristic radiation which is calculated next.	  Note: Brem radiation is that into a unit steradian and not over 4*pi as is the	  characteristic, so we get (DOMEGA/4*pi) * (4*pi) = DOMEGA }	  FOR i := 1 TO L_theGenRec.Number_of_Channels DO        BEGIN		  {Plt_Spec[8]^^.S[i] := Bkg_P^[i];}           Bkg_P^[i] := Bkg_P^[i] * theConst;{gen contin * theConst = gencont}           Col_3^[i] := Bkg_P^[i] * Det_Effic_P^[i]; {gencont*deteff}         END;      BlockMove(@Bkg_P^, @Col_2^, Sizeof(Col_2^)); {gencont}      BlockMove(@Col_3^, @Bkg_P^, Sizeof(Bkg_P^)); {gencont*deteff}       {continuum scaled to in front of detector but no specimen absorption} { Col2 and 3 are to be used below to add the delta functions onto, here we stuffed   them with what they need. The received-in-detector continuum goes in the temporary   holding vector Col_3^[], and Col2^^.S[] gets what is arriving at the detector   just before the window materials. }             SigSqMn := (L_theGenRec.Si_Resolution * L_theGenRec.Si_Resolution) * aSigConst;	  	  if WDS_Active then      	SigSqMn := (L_theGenRec.WDS_Resolution * L_theGenRec.WDS_Resolution) * aSigConst; 	  (*Valid_Peak := 0;*)		 FOR counter := 1 TO Numb_of_Elements DO      BEGIN { Numb_of_Elements loop }          SpinCursor;          Get_Energies(A^.Thin_At_Num[counter]); { get atomic weight, atomic rho, line energies etc.¥¥ Z is defined here ¥¥ }          ZConst := aConst * A^.Thin_Concentration[counter] / Atomic_Weight;          K_Hold := 0;          L_Hold := 0;          M_Hold := 0;		  Valid_Peak := 0;			FOR k := 1 to 100 do begin			  Line_Energy^[k] := 0.0;			  Generated^[k] := 0.0;			  Inside_Detector^[k] := 0.0;			  InFront_Detector^[k] := 0.0;			END;          IF (eV_Line[1] > 51) AND (eV_Line[1] < En_Lim) THEN            BEGIN              Valid_Peak := Valid_Peak + 1;              Line_Energy^[Valid_Peak] := eV_Line[1];              Generated^[Valid_Peak] := (Wt_Line[1] / (Wt_Line[1] + Wt_Line[2])) * Qk(Thin_KV, A^.edge[1]) * WK(Z) * SAK(Z) * ZConst;									                 {ZConst:=(Domega*Thin_Physics_Constant/Pi4)*(A^.Thin_Concentration[Counter]/Atomic_Weight)}			 K_Hold := Valid_Peak;	{IF (eV_KA1 > 51)...}            END;          IF (eV_Line[2] > 51) AND (eV_Line[2] < En_Lim) THEN            BEGIN              Valid_Peak := Valid_Peak + 1;              Line_Energy^[Valid_Peak] := eV_Line[2];              Generated^[Valid_Peak] := Wt_Line[2] * Generated^[K_Hold];            END;          IF (eV_Line[3] > 1.0) AND (eV_Line[3] < En_Lim) THEN            BEGIN              Valid_Peak := Valid_Peak + 1;              Line_Energy^[Valid_Peak] := eV_Line[3];              Generated^[Valid_Peak] := (Generated^[K_Hold] + Generated^[Valid_Peak - 1]) * 			                            Wt_Line[3] / (1 - Wt_Line[3]);              {Weight_KB1 * Generated^[K_Hold] * (Weight_KA1 + Weight_KA2) / (1 - Weight_KB1);}			END;						peak_label := 'K';			theEdge := A^.edge[1];         IF (eV_Line[42] > 51) AND (eV_Line[42] < En_Lim) AND (A^.Thin_At_Num[counter] >= 16) THEN            BEGIN              Valid_Peak := Valid_Peak + 1;              Line_Energy^[Valid_Peak] := eV_Line[42];              Generated^[Valid_Peak] := Wt_Line[42] * Ql(Thin_KV, A^.edge[4]) *			  							WL(A^.Thin_At_Num[counter]) * SAL(A^.Thin_At_Num[counter]) * ZConst;            {ZConst:=(Domega*Thin_Physics_Constant/Pi4)*            (A^.Thin_Concentration[Counter]/Atomic_Weight)}			  L_Hold := Valid_Peak;            END;				peak_label := 'L';		theEdge := A^.edge[4];		FOR i := 43 to 49 do begin          IF (eV_Line[i] > 1.0) AND (eV_Line[i] < En_Lim) THEN            Thin_Dependent_Peak_Gen(eV_Line[i], Wt_Line[i], L_Hold);				end;		theEdge := A^.edge[3];				          IF (eV_Line[24] > 1.0) AND (eV_Line[24] < En_Lim) THEN            Thin_Dependent_Peak_Gen(eV_Line[24], Wt_Line[24], L_Hold);				FOR i := 29 to 35 do begin          IF (eV_Line[i] > 1.0) AND (eV_Line[i] < En_Lim) THEN            Thin_Dependent_Peak_Gen(eV_Line[i], Wt_Line[i], L_Hold);				end;		theEdge := A^.edge[2];		FOR i := 11 to 18 do begin          IF (eV_Line[i] > 1.0) AND (eV_Line[i] < En_Lim) THEN            Thin_Dependent_Peak_Gen(eV_Line[i], Wt_Line[i], L_Hold);				end;          IF (eV_Line[144] > 1.0) AND (eV_Line[144] < En_Lim) THEN	{¥¥5/16/99 LG2¥¥}            Thin_Dependent_Peak_Gen(eV_Line[144], Wt_Line[144], L_Hold);				          IF (eV_Line[72] > 51) AND (eV_Line[72] < En_Lim) AND (Z >= 35) THEN		              BEGIN              Valid_Peak := Valid_Peak + 1;              Line_Energy^[Valid_Peak] := (eV_Line[72] + eV_Line[73])/2;              Generated^[Valid_Peak] := (Wt_Line[72] + Wt_Line[73])/2 * Qm(Thin_KV, A^.edge[9]) *              							 WM(A^.Thin_At_Num[counter]) * SAM(                                       A^.Thin_At_Num[counter]) * ZConst; {ZConst:=(Domega * Thin_Physics_Constant / Pi4) *                                                                        (A^.Thin_Concentration[Counter] / Atomic_Weight)}			  M_Hold := Valid_Peak;            END		  ELSE M_Hold := 0;		  		  peak_label := 'M';		  theEdge := A^.edge[9];          IF (eV_Line[74] > 1.0) AND (eV_Line[74] < En_Lim) THEN            Thin_Dependent_Peak_Gen(eV_Line[74], Wt_Line[74], M_Hold);		  theEdge := A^.edge[8];		  FOR i := 69 to 70 do begin	          IF (eV_Line[i] > 1.0) AND (eV_Line[i] < En_Lim) THEN	            Thin_Dependent_Peak_Gen(eV_Line[i], Wt_Line[i], M_Hold);			END;					  theEdge := A^.edge[7];		  FOR i := 61 to 66 do begin	          IF (eV_Line[i] > 1.0) AND (eV_Line[i] < En_Lim) THEN	            Thin_Dependent_Peak_Gen(eV_Line[i], Wt_Line[i], M_Hold);			END;		  		  theEdge := A^.edge[6];		  FOR i := 55 to 58 do begin	          IF (eV_Line[i] > 1.0) AND (eV_Line[i] < En_Lim) THEN	            Thin_Dependent_Peak_Gen(eV_Line[i], Wt_Line[i], M_Hold);			END;		  theEdge := A^.edge[5];		  FOR i := 53 to 54 do begin	          IF (eV_Line[i] > 1.0) AND (eV_Line[i] < En_Lim) THEN	            Thin_Dependent_Peak_Gen(eV_Line[i], Wt_Line[i], M_Hold);			END;		 if (counter = 1) then begin		 { Num_SubLayers := 50;....see above near Rho_T :=...changed 5/12/95}         		  FOR J := 1 TO L_theGenRec.Number_of_Channels DO            BEGIN			  SpinCursor;			  Mu_over_Rho := 0.0; { At each channel get the mass absorption coefficient }			  			  FOR nn := 1 TO Numb_of_Elements DO			  BEGIN				  Get_Energies(A^.Thin_At_Num[nn]); { get edge energies etc. }				  Mu_over_Rho := MassAbsCoeff(J * L_theGenRec.dE, A^.Thin_At_Num[nn]) * A^.Thin_Concentration[nn] +				  			     Mu_over_Rho;			  END;			  			  mu_rho_P^[J] := Mu_over_Rho;	{Mass absorption coef. at channel J}			  Intensity := Col_2^[J] / Num_SubLayers;	{generated BG/num_SubLayers}			  Intensity_x := Col_3^[J] / Num_SubLayers;	{(generated BG * det eff)/num_SubLayers}			  Col_4^[J] := 0.0;			  Col_6^[J] := 0.0;			  FOR nn := 1 TO Num_SubLayers DO { Divide film into Num_SubLayers and do Beers Law}				BEGIN												   				  Col_4^[J] := Col_4^[J] + Intensity * exp( - Mu_over_Rho * Rho_T / Num_SubLayers * (nn - 0.5) *												   cscTheta);{just outside specimen - no peaks}				  Col_6^[J] := Col_6^[J] + Intensity_x * exp( - Mu_over_Rho * Rho_T / Num_SubLayers * (nn - 0.5) *												   cscTheta);{inside detector - no peaks}				END;			END; { of j loop }									DisposeDialog(BusyMessage);			BlockMove(@Col_6^, @Col_1^, Sizeof(Col_6^));{(gencont+deltas)*DetEff*mu}			Convolve_Col1;	{contains the convolved continuum after all absorptions}			BlockMove(@Col_1^, @Col_5^, Sizeof(Col_1^));{convolved continuum}				BlockMove(@Col_1^, @Col_3^, Sizeof(Col_1^));{convolved continuum}			  PutBusyMessage('Busy calculating a first principles thin target spectrum.',		   'Please wait......','','') ;		   		  end;	{if (counter = 1) then }			FOR JJ := 1 to Valid_Peak DO	{ valid_peak includes all peaks for each Z}			BEGIN			  k := rinttol(Line_Energy^[JJ] / L_theGenRec.dE);	{Channel no. of peak JJ}			  Intensity := Generated^[JJ] / Num_SubLayers;	{generated Peak/num_SubLayers}			  Inside_Detector^[JJ] := 0.0;			  InFront_Detector^[JJ] := 0.0;				  FOR nn := 1 TO Num_SubLayers DO { Divide film into Num_SubLayers and do Beers Law}			  BEGIN				  InFront_Detector^[JJ] := InFront_Detector^[JJ] + Intensity * exp( - mu_rho_P^[k] * Rho_T / Num_SubLayers * (nn - 0.5) *												   cscTheta);{just outside specimen - peaks only}			  END;			  Inside_Detector^[JJ] := InFront_Detector^[JJ] * Det_Effic_P^[k];			  			END;		  E := 0.0;          FOR J := 1 TO L_theGenRec.Number_of_Channels DO            BEGIN			  SpinCursor;              E := E + L_theGenRec.dE;              FOR JJ := 1 TO Valid_Peak DO                BEGIN                  IF WDS_active THEN SIGSQ := SigSqMn                  ELSE IF Ge_Active THEN SIGSQ := theSigConst * (Line_Energy^[JJ] - 5895.0) + SigSqMn                  ELSE SIGSQ := theSigConst * (Line_Energy^[JJ] - 5895.0) + SigSqMn;                  DELESQ := (E - Line_Energy^[JJ]) * (E - Line_Energy^[JJ]);                  SigConst := L_theGenRec.dE / sqrt(PI2 * SIGSQ) * exp( - 0.5 * DELESQ / SIGSQ);                  YE := Generated^[JJ] * SigConst;                  YE_SiLi := Inside_Detector^[JJ] * SigConst;{deltas*det eff*sigconst}          { We need the term "dE/sqrt(pi2*SIGSQ)" to distribute the number of generated counts            over the channels of the whole peak, rather than put them all in the peak channel }                  Gen_P^[J] := Gen_P^[J] + YE;                  (*IF Gen_P^[J] <= 0.0 THEN Gen_P^[J] := 0.0;*) { Paranoia }                  				  Ob_Pks_P^[J] := Ob_Pks_P^[J] + YE_SiLi;{deltas*det eff*sigconst}                 (* IF Ob_Pks_P^[J] <= 0.0 THEN Ob_Pks_P^[J] := 0.0; *){ Paranoia }                  { Now do the delta functions and put onto the continuum }                  IF (Line_Energy^[JJ] >= E - L_theGenRec.dE) AND (Line_Energy^[JJ] < E) THEN                    BEGIN                      Col_2^[J] := Col_2^[J] + Generated^[JJ];{cont.+ deltas}					  Col_4^[J] := Col_4^[J] + InFront_Detector^[JJ]; {(cont.+ deltas) * absorb}                      Col_6^[J] := Col_6^[J] + Inside_Detector^[JJ];{(cont*det eff+ deltas*det eff) * absorb}                    END;                END; { of jj = valid_peak loop }				(*Col_1^[J] := Col_1^[J] + Ob_Pks_P^[J];*)				            END; { of J = chn loop }				 END;	{FOR counter := 1 TO Numb_of_Elements... }	 	 FOR J := 1 TO L_theGenRec.Number_of_Channels DO	 	Col_3^[J] := Col_3^[J] + Ob_Pks_P^[J];	  DisposeDialog(BusyMessage);	  BlockMove(@Col_3^, @Col_1^, Sizeof(Col_3^));      IF NOT WDS_active THEN Add_Escape_Peaks; 	{...to Col_1 always:  now also reduces the peak intensity }	  BlockMove(@Col_1^, @Composite_P^, Sizeof(Col_1^));	  BlockMove(@Col_6^, @Col_3^, Sizeof(Col_6^));	{inside det.}	  	  BlockMove(@Ob_Pks_P^, @Col_1^, Sizeof(Ob_Pks_P^));      Add_Escape_Peaks;	{...to Col_1 always:  now also reduces the peak intensity }	  BlockMove(@Col_1^, @Ob_Pks_P^, Sizeof(Col_1^));{correct observed peak distribution}		END; { of proc Thin_Film }     PROCEDURE fluorescence;      TYPE        varray                        = ARRAY [1..15] OF real {double_t};        marray                        = ARRAY [1..15, 1..15] OF real {double_t};      VAR        eq                            : real {double_t};        E_fline                       : real {double_t};        U                             : real {double_t};        p                             : varray;        R1                            : varray;        OM                            : varray;        AA                            : varray;        X                             : varray;        AC                            : varray;        Fluor_AC                      : marray;        LI                            : integer;        KEY                           : ARRAY [1..15] OF integer;        Index                         : integer;        index2                        : integer;        index3                        : integer;        k2                            : integer;        co                            : real {double_t};        kf, fswt                      : integer;        kkf                           : integer;        OM1                           : real {double_t};        as                            : real {double_t};        XU                            : real {double_t};        nu                            : real {double_t};        xuv                           : real {double_t};        at, E_line                    : real {double_t};        E165, E_edge                  : real {double_t};              BEGIN          Get_Energies(A^.Bulk_At_Num[counter]);        AA[counter] := Atomic_Weight;  {  This will either be called from the KA1 calculation or the LA1 calculation.     The code will be set for the appropriate line so Siegbahn is not needed. }        {  peak_label := Siegbahn[counter]; }        IF peak_label[1] = 'K' THEN          BEGIN            LI := 1;            E_fline := eV_Line[1] / 1000.0; { K line }            eq := A^.edge[1] / 1000.0; { K edge }          END        ELSE          IF peak_label[1] = 'L' THEN            BEGIN              LI := 2;              E_fline := eV_Line[42] / 1000.0; { L line }              eq := A^.edge[4] / 1000.0; { L edge }            END          ELSE            IF peak_label[1] = 'M' THEN              BEGIN                LI := 3;                E_fline := (eV_Line[72] + eV_Line[73])/2 / 1000.0; { M line }                eq := A^.edge[9] / 1000.0; { M edge }              END;        U := Bulk_kV / eq;        E165 := fast_power(Bulk_kV, 1.65);        FOR Index := 1 TO Numb_of_Elements DO          BEGIN            SpinCursor;            KEY[Index] := 0;            Get_Energies(A^.Bulk_At_Num[Index]);            AA[Index] := Atomic_Weight;            AC[Index] := MassAbsCoeff(E_fline * 1000.0, A^.Bulk_At_Num[Index]);          END; { index }        { find characteristic fluorescence }        CASE LI OF          1:            BEGIN              co := 5.0;              kkf := 0;            END;          2:            BEGIN              co := 3.5;              kkf := 1;            END;          3:            BEGIN              co := 3.5;              kkf := 2;            END;          END; { case }        FOR Index := 1 TO Numb_of_Elements DO {begin checking for fluorescence}          BEGIN            fswt := 0;            IF A^.Bulk_At_Num[counter] <> A^.Bulk_At_Num[Index] THEN {skip if same element}              FOR kf := 1 TO 2 DO {1 for K lines, 2 for L lines}                BEGIN                  k2 := kf * kf;					E_edge := 0.0;					E_line := 0.0;                                 IF ((kf = 1) AND (A^.Bulk_At_Num[Index] > 2)) THEN                    BEGIN                      E_edge := K_ABS_Handle^^.Data[A^.Bulk_At_Num[Index]].value / 1000.0;                      E_line := KA1_Handle^^.Data[A^.Bulk_At_Num[Index]].Lamda / 1000.0;                    END;                  IF ((kf = 2) AND (fswt = 0) AND (A^.Bulk_At_Num[index] > 19)) THEN                    BEGIN                      E_edge := LIII_ABS_Handle^^.Data[A^.Bulk_At_Num[Index]].value / 1000.0;                      E_line := LA1_Handle^^.Data[A^.Bulk_At_Num[Index]].Lamda / 1000.0;                    END;                  IF (1.022 * E_edge < Bulk_kV) AND (E_line > eq) AND (E_line <= eq + co) THEN                    BEGIN                      {putmessage('A fluorescence was detected.','','','');}                      fswt := 1;                      IF (KEY[Index] = 0) THEN                        BEGIN                          KEY[Index] := kf + 2 * kkf;                          X[Index] := Bulk_kV / E_edge;                          FOR index2 := 1 TO Numb_of_Elements DO                            BEGIN                              Get_Energies(A^.Bulk_At_Num[index2]);                              Fluor_AC[index2, Index] := MassAbsCoeff(E_line * 1000.0, A^.Bulk_At_Num[index2]);        {writeln(f,' fl absorb is Fluor_AC[index2,                index] ',Fluor_AC[index2, index],' index ',index,' index2 ',index2);}                            END;                        END;                    END;                END; { FOR kf := 1 TO 2 DO }          END; { FOR index := 1 TO Numb_of_Elements DO }        FOR Index := 1 TO Numb_of_Elements DO          BEGIN            IF (KEY[Index] > 0) THEN              BEGIN                p[Index] := 1.0;                R1[Index] := 0.88;                kf := KEY[Index];                IF (odd(kf)) THEN kkf := 1                ELSE kkf := 2;                CASE kkf OF                  1:                    BEGIN                      OM1 := 0.015 + 0.0327 * A^.Bulk_At_Num[Index] - 6.4E-7 * fast_power(A^.Bulk_At_Num[Index], 3);                      OM1 := fast_power(OM1, 4);                      OM[Index] := OM1 / (1 + OM1);                      IF (kf > 1) THEN                        IF (kf <> 5) THEN                          BEGIN                            p[Index] := 0.24;                            R1[Index] := 0.75;                          END                        ELSE                          BEGIN                            p[Index] := 0.02;                            R1[Index] := 0.5;                          END;                    END; { case 1:}                  2:                    BEGIN                      OM[Index] := exp(2.946 * ln(A^.Bulk_At_Num[Index]) - 13.94);                      IF (kf = 2) THEN p[Index] := 4.2;                      IF (kf = 4) THEN R1[Index] := 0.75;                      IF (kf = 6) THEN                        BEGIN                          p[Index] := 0.02;                          R1[Index] := 0.5;                        END;                    END; { case 2:}                  END; { Case }              END; { end if ( key[index1,index] > 0 )... }          END; { end index }        as := zero;        FOR Index := 1 TO Numb_of_Elements DO          BEGIN            SpinCursor;            {  writeln(f, ' elem ',A^.Bulk_At_Num[index],' conc is ',A^.Bulk_Concentration[index]);  }            as := as + A^.Bulk_Concentration[Index] * AC[Index];          END;        XKF := zero;        FOR Index := 1 TO Numb_of_Elements DO          BEGIN            IF (KEY[Index] > 0) THEN              BEGIN                SpinCursor;      {  FOR index3 := 1 TO Numb_of_Elements DO writeln(f,'mu/rho Fl ',index3,' ',                         index,' ',Fluor_AC[index3, index]);}                at := zero;                FOR index3 := 1 TO Numb_of_Elements DO                  at := at + A^.Bulk_Concentration[index3] * Fluor_AC[index3, Index];                XU := cscTheta * as / at;                nu := (3.33E5 / (E165 - fast_power(eq, 1.65))) / at;                xuv := Ln(XU+1) / XU + Ln(nu+1) / nu;                            {  writeln(f, 'at= ', at, ' xu= ', xu, ' nu= ', nu, ' xuv= ', xuv);                              writeln(f, 'P= ', P[index], ' Omega= ', OM[index], ' R1= ',          R1[index]);  }                XKF := XKF + A^.Bulk_Concentration[Index] * p[Index] * OM[Index] / 2 * R1[Index] * fast_power(((X[                       Index] - 1) / (U - 1)), 1.67) * AA[counter] / AA[Index] * Fluor_AC[counter, Index] / at * xuv;              END;          END; { FOR index := 1 TO Numb_of_Elements DO }        XKF := XKF + 1.0;      END; { Procedure fluorescence }	  {$S Physics6}      {=======================}FUNCTION fChiChar(VPLine: Real): Real; {========================}      VAR        kk                            : integer;        { ¥¥¥Begin fChi expression for characteristic radiation }      BEGIN        Mu_over_Rho := 0.0;		IF VPLine < 50 THEN 		  begin		    fChiChar := 0.0;		    exit(fChiChar);		  end;        FOR kk := 1 TO Numb_of_Elements DO          BEGIN            Get_Energies(A^.Bulk_At_Num[kk]);            { get edge energies etc. for fchi calculation at this line energy }            Mu_over_Rho := MassAbsCoeff(VPLine, A^.Bulk_At_Num[kk]) * A^.Bulk_Concentration[kk] + Mu_over_Rho;          END;        Get_Energies(A^.Bulk_At_Num[counter]); { restore the necessary stuff for element "counter"}        Term := 1.2E-6 * (Term1 - exp(1.65 * ln(VPLine * 0.001)));        fChiChar := 1 / ((1 + Term * Mu_over_Rho * cscTheta * sinPhi) * (1 + Term * Mu_over_Rho * cscTheta * sinPhi));      END;    { ¥¥¥End fChi expression for characteristic radiation }    PROCEDURE Bulk_Dependent_Peak_Gen(Pk_eV, Pk_Wt: Real; ParantLine: integer);		VAR			theWeight	: real {double_t};			theYield	: real {double_t};			QS_index	: integer;      BEGIN	    	    if Valid_Peak > 750 then		  begin		    Putmessage('WARNING, you have 750 peaks and are trying for more',			           'and I cant do what you want. Are you sure you need this many?',					   '',''); 		    exit(Bulk_Dependent_Peak_Gen);		  end;		  		IF Pk_eV < 50 THEN 		  begin 		    exit(Bulk_Dependent_Peak_Gen);		  end;          (*IF Pk_eV >= Bulk_kV * 1000 THEN Pk_Wt := 0.0;*)		IF theEdge >= Bulk_kV * 1000 THEN exit(Bulk_Dependent_Peak_Gen);{Pk_Wt := 0.0;}		{¥¥¥This should be checked against the edge voltage, NOT the peak¥¥¥}        Valid_Peak := Valid_Peak + 1;        Line_Energy^[Valid_Peak] := Pk_eV;        fchi := fChiChar(Line_Energy^[Valid_Peak]);				if ParantLine <> 0 then        	Generated^[Valid_Peak] := Pk_Wt * Generated^[ParantLine]		else					BEGIN			  if peak_label[1] = 'K' then			   begin			    theWeight := SAK(A^.Bulk_At_Num[counter]);				theYield := WK(A^.Bulk_At_Num[counter]);				QS_index := 1;			   end;			  if peak_label[1] = 'L' then			   begin			    theWeight := SAL(A^.Bulk_At_Num[counter]);				theYield := WL(A^.Bulk_At_Num[counter]);				QS_index := 2;			   end;			  if peak_label[1] = 'M' then			   begin			    theWeight := SAM(A^.Bulk_At_Num[counter]);				theYield := WM(A^.Bulk_At_Num[counter]);				QS_index := 3;			   end;			Generated^[Valid_Peak] := Pk_Wt * Integrate_Q_over_S(QS_index) * Backscatter(theEdge / 1000.0) *										theYield * theWeight * Bulk_Physics_Constant;			END;			InFront_Detector^[Valid_Peak] := Generated^[Valid_Peak] * fchi;			InFront_Detector_Fluor^[Valid_Peak] := InFront_Detector^[Valid_Peak] * XKF;			Inside_Detector^[Valid_Peak] := InFront_Detector_Fluor^[Valid_Peak] * 		                           Det_Effic_P^[rinttol(Line_Energy^[Valid_Peak] / L_theGenRec.dE)];      END; { Procedure Bulk_Peak_Gen; }	 PROCEDURE Load_WDS_K;	 	VAR			En_Lim			: real;			i				: integer;	 begin	 	En_Lim := L_theGenRec.Number_of_Channels * L_theGenRec.dE;		FOR i := 4 to 7 do begin		    IF (eV_Line[i] > 1.0) AND (eV_Line[i] < En_Lim) THEN            Bulk_Dependent_Peak_Gen(eV_Line[i], Wt_Line[i], K_Hold);         end;		FOR i := 77 to 100 do begin		    IF (eV_Line[i] > 1.0) AND (eV_Line[i] < En_Lim) THEN            Bulk_Dependent_Peak_Gen(eV_Line[i], Wt_Line[i], K_Hold);         end;	end;{ wds active...}		 PROCEDURE Load_WDS_L;	 	VAR			En_Lim			: real;			i				: integer;	 begin	 	En_Lim := L_theGenRec.Number_of_Channels * L_theGenRec.dE;		 theEdge := A^.edge[4];		FOR i := 101 to 127 do begin		    IF (eV_Line[i] > 1.0) AND (eV_Line[i] < En_Lim) THEN            Bulk_Dependent_Peak_Gen(eV_Line[i], Wt_Line[i], L_Hold);         end;		 theEdge := A^.edge[3];		FOR i := 128 to 132 do begin		    IF (eV_Line[i] > 1.0) AND (eV_Line[i] < En_Lim) THEN            Bulk_Dependent_Peak_Gen(eV_Line[i], Wt_Line[i], L_Hold);         end;		 theEdge := A^.edge[2];		FOR i := 133 to 135 do begin		    IF (eV_Line[i] > 1.0) AND (eV_Line[i] < En_Lim) THEN            Bulk_Dependent_Peak_Gen(eV_Line[i], Wt_Line[i], L_Hold);         end;        end; {wds...}{$S Physics13}  (*{[f-]}*)  {**********************************} PROCEDURE Bulk; {***********************************}(*{[f+]}*)    VAR      {Eo                            : Real;}      J, k, kk                      : integer;	  indexer                       : integer;      nn                            : integer;      {Ele1_lstK,Ele2_1stK,Ele2_lstK : integer;}	  loc_chan						: integer;	  En_Lim						: real;      B, M                          : Real;      La                            : Real;      Lb, MN                        : Real;      E, YE, YE_delta               : Real;       JJ                            : integer;      SIGSQ, DELESQ                 : Real;      Av_At_Number                  : Real;            Term3                         : Real;       w                             : Real;      YE_SiLi, YE_SiLi_delta        : Real;       arg, dele                     : Real;    {=============================}             BEGIN { ¥¥¥¥¥¥¥¥¥¥¥ Procedure Bulk; ¥¥¥¥¥¥¥¥¥¥¥¥¥¥ }      PutBusyMessage('Busy calculating a first principles bulk target spectrum.',	               'Please wait......','','') ;	 { the functions mostly use L_theGenRec but Plt_Spec[10] has the same values if coming from   GENERATE so they may be ok unless in background subt some params have been changed   from Plt_Spec[10] values to get a better result}	 	if (BG_Active) then  L_theGenRec := theBGRec^^ else L_theGenRec := theGenRec^^;		      FOR k := 1 TO 750 DO        BEGIN          Line_Energy^[k] := 0.0;          Generated^[k] := 0.0;          Inside_Detector^[k] := 0.0;          InFront_Detector_Fluor^[k] := 0.0;        END;       FOR k := 1 TO Maximum_Channels DO        BEGIN		   Gen_P^[k] := 0.0;		   Ob_Pks_P^[k] := 0.0;		   mu_rho_P^[k] := 0.0;		   Col_1^[k] := 0.0;		   Col_2^[k] := 0.0;		   Col_3^[k] := 0.0;		   Col_4^[k] := 0.0;		   Col_5^[k] := 0.0;		   Col_6^[k] := 0.0;		  { plt_spec[7]^^.s[k] := 0.0;		   plt_spec[8]^^.s[k] := 0.0; }       END;      Eo := Bulk_kV;      Av_At_Number := 0.0;      Numb_of_Elements := 0;      FOR k := 1 TO 15 DO          IF (A^.Bulk_Concentration[k] > 0.0) AND (A^.Bulk_At_Num[k] > 0) THEN		  begin			Numb_of_Elements := Numb_of_Elements + 1;			Av_At_Number := A^.Bulk_Concentration[k] * A^.Bulk_At_Num[k] + Av_At_Number;		  end;      Term1 := exp(1.65 * ln(Eo));      M := 0.00599 * Eo + 1.05;      B := - 0.0322 * Eo + 5.8;      Term3 := {5.53E-9} 6.748E-9 * exp(B);          { Multiply Smalls equation by a scaling factor to Kramers constant. This is Chuck's 		           kludge of Small's equation, which needs to make absolute. }			        (*!!!!!! do not change L_theGenRec to Plt_Spec[10] because of background subtraction *)      Domega := L_theGenRec.Detector_Area / (L_theGenRec.Spec_Detector_Distance * L_theGenRec.Spec_Detector_Distance);      IF L_theGenRec.Take_Off_Angle <= 0.0 THEN        BEGIN          Putmessage(' The Take off angle cannot be zero or negative! ',                     'DTSA will set it to 1 degree to prevent division by zero in the f( Chi) calculation.',                     'However, garbage in here is assuredly garbage out squared', '');          L_theGenRec.Take_Off_Angle := 1.0;        END;      cscTheta := 1 / Sin(L_theGenRec.Take_Off_Angle / 57.295779);      sinPhi := Sin(Geom.Beam_Entry_Angle / 57.295779);     { For nn := 1 to Maximum_Channels do Col_1^[nn] := 0.0;}      {¥¥¥¥¥¥}      FOR k := 1 TO L_theGenRec.Number_of_Channels DO { MAIN K LOOP (K*dE*0.001)=keV}        BEGIN {This part calculates the Bulk Continuum at each channel for each element}          SpinCursor;          E := k * L_theGenRec.dE * 0.001;          IF k <= 5 THEN E := 0.050;          IF Bulk_CONT_Xsect = 4 THEN { Small's equation }            Bkg_P^[k] := Term3 * 			                      exp(M * ln(Av_At_Number * 								  (Eo / E - 1))) * 								  L_theGenRec.dE * 								  0.001;          IF Bulk_CONT_Xsect = 5 THEN { Kramer's equation }            Bkg_P^[k] := 2.6E-6 * 			                      Av_At_Number * 								  (Eo / E - 1) * 								  L_theGenRec.dE * 								  0.001;          IF Bulk_CONT_Xsect = 6 THEN { Lifshins quadratic }            BEGIN              La := 1;              Lb := 4E-2; { CFs temporary diddle }              Bkg_P^[k] := 2.08E-6 * 			                        Av_At_Number * 									(La * (Eo - E) / E + Lb * 									((Eo - E) * 									(Eo - E) / (E * E))) *                                    L_theGenRec.dE * 									0.001;            END; { if Lifshin...}          IF Bulk_CONT_Xsect = 8 THEN { Rao-Sahib, Wittry, Chuck scaled this using K's constant}            Bkg_P^[k] := 3.198E-6 * 			                      Av_At_Number * 								  (Eo - E) / exp(1.21 * ln(E)) * 								  L_theGenRec.dE * 								  0.001;          IF E >= Eo THEN Bkg_P^[k] := 0.0;          Mu_over_Rho := 0.0;		            FOR kk := 1 TO Numb_of_Elements DO            BEGIN              Get_Energies(A^.Bulk_At_Num[kk]); { get edge energies etc. }              Mu_over_Rho := MassAbsCoeff(k * L_theGenRec.dE, A^.Bulk_At_Num[kk]) * 			                 A^.Bulk_Concentration[kk] + Mu_over_Rho;            END;          { Begin fChi expression for the continuum }		            Term := 1.2E-6 * (Term1 - exp(1.65 * ln(E)));          fchi := 1 / ((1 + Term * Mu_over_Rho * cscTheta * sinPhi) * 		               (1 + Term * Mu_over_Rho * cscTheta * sinPhi));          w := 1.15 - 0.15 * fchi; { Myklebust's anisotropy correction }          Col_6^[k] := fchi *                            w * 						   Continuum_Backscatter(E) * 						   Bkg_P^[k] * 						   Bulk_CONT_ScaleFactor * 						   Faraday_Current *                           6.24196E9 * 						   Live_Time * 						   Domega / Pi4; { Col[6] is now background in front of detector }						             Col_5^[k] := Col_6^[k];          Col_1^[k] := Det_Effic_P^[k] * Col_6^[k];          IF Col_1^[k] <= 0.0 THEN Col_1^[k] := 0.0; { Paranoia }          { The received-in-detector continuum is now in the temporary holding vector Col_1^[K] }          f_chi_P^[k] := fchi;          mu_rho_P^[k] := Mu_over_Rho;          {¥¥¥¥¥¥¥}        END; { End of Bulk Continuum main K loop } { Col2 and 3 are to be used below to add the delta functions onto, here we stuff them with  what they need. The received-in-detector continuum goes in the temporary holding vector  Col_1^[].      Col_2^[] gets what is arriving at the detector just before the  window materials with specimen effects. }  		En_Lim := L_theGenRec.Number_of_Channels * L_theGenRec.dE;		      FOR nn := 1 TO L_theGenRec.Number_of_Channels DO        BEGIN          Col_2^[nn] := Bkg_P^[nn] * 		                    Faraday_Current * 							6.24196E9 * 							Live_Time * 							Domega / Pi4;          Col_3^[nn] := Col_1^[nn];          Col_4^[nn] := Col_1^[nn];        END;      FOR indexer := 1 TO Numb_of_Elements DO      BEGIN { Numb_of_Elements loop }		  counter := indexer;		  {Xray_Data_Request set T in Physics_windows...}		{putmessage('in Physics, Get_Energies','','','');}          Get_Energies(A^.Bulk_At_Num[counter]);          Bulk_Physics_Constant := A^.Bulk_Concentration[counter] / Atomic_Weight * 		                           6.023E23 * 								   Faraday_Current * 6.24196E9                                   * Domega / Pi4 * 								   Live_Time;          { ¥¥¥¥¥ Now do the peaks ¥¥¥¥¥ }          K_Hold := 0;          L_Hold := 0;          M_Hold := 0;		Valid_Peak := 0;		            Z := A^.Bulk_At_Num[counter]; { Z is a Global used in the characteristic cross sections }           IF (eV_Line[1] > 52) AND (eV_Line[1] < En_Lim) THEN           BEGIN          	  Valid_Peak := Valid_Peak + 1;              Line_Energy^[Valid_Peak] := eV_Line[1];			  loc_chan := rinttol(Line_Energy^[Valid_Peak] / L_theGenRec.dE);              peak_label := 'K    ';               fluorescence;			   Get_Energies(A^.Bulk_At_Num[counter]);               fchi := fChiChar(Line_Energy^[Valid_Peak]);               Generated^[Valid_Peak] := Bulk_Physics_Constant * 			                           Integrate_Q_over_S(1) * 									   Wt_Line[1] / (Wt_Line[1] + Wt_Line[2]) * 									   Backscatter(A^.edge[1] / 1000.0) * 									   WK(A^.Bulk_At_Num[counter]) * 									   SAK(A^.Bulk_At_Num[counter]);   { ¥¥ dont use a putmessage around here since it generates an update, which calls update_Full,     which calls markers, which calls get_Energies, which will cause you to sully your pants}              InFront_Detector^[Valid_Peak] := Generated^[Valid_Peak] * fchi;              InFront_Detector_Fluor^[Valid_Peak] := InFront_Detector^[Valid_Peak] * XKF;              Inside_Detector^[Valid_Peak] := InFront_Detector_Fluor^[Valid_Peak] * Det_Effic_P^[loc_chan];              K_Hold := Valid_Peak;            END;	{IF (eV_KA1 > 52)...}          IF (eV_Line[2] > 52) AND (eV_Line[2] < En_Lim)  THEN            BEGIN              Valid_Peak := Valid_Peak + 1;              Line_Energy^[Valid_Peak] := eV_Line[2];			  loc_chan := rinttol(Line_Energy^[Valid_Peak] / L_theGenRec.dE);              fchi := fChiChar(Line_Energy^[Valid_Peak]);              Generated^[Valid_Peak] := Wt_Line[2] * Generated^[K_Hold];              InFront_Detector^[Valid_Peak] := Generated^[Valid_Peak] * fchi;              InFront_Detector_Fluor^[Valid_Peak] := InFront_Detector^[Valid_Peak] * XKF;              Inside_Detector^[Valid_Peak] := InFront_Detector_Fluor^[Valid_Peak] * Det_Effic_P^[loc_chan];            END;          IF (eV_Line[3] > 1.0) AND (eV_Line[3] < En_Lim)  THEN            BEGIN { Weight_KB1 is the weight of B/ sum(K) }              Valid_Peak := Valid_Peak + 1;              Line_Energy^[Valid_Peak] := eV_Line[3];			  loc_chan := rinttol(Line_Energy^[Valid_Peak] / L_theGenRec.dE);              fchi := fChiChar(Line_Energy^[Valid_Peak]);              Generated^[Valid_Peak] := (Generated^[K_Hold] + Generated^[Valid_Peak - 1]) * 			                            Wt_Line[3] / (1 - Wt_Line[3]);              { Weight_KB1 * (1 + Weight_KA2) / (1 - Weight_KB1) }              InFront_Detector^[Valid_Peak] := Generated^[Valid_Peak] * fchi;              InFront_Detector_Fluor^[Valid_Peak] := InFront_Detector^[Valid_Peak] * XKF;              Inside_Detector^[Valid_Peak] := InFront_Detector_Fluor^[Valid_Peak] * Det_Effic_P^[loc_chan];            END;			peak_label := 'K    ';			theEdge := A^.edge[1];     {if WDS_Active then} Load_WDS_K;					(* if indexer = 2 then ele2_LstK := valid_peak		 else if indexer = 1 then ele1_LstK := valid_peak;*)	    	            IF (eV_Line[42] > 52) AND (eV_Line[42] < En_Lim) AND		   (A^.Bulk_At_Num[counter] >= 16) THEN            BEGIN              Valid_Peak := Valid_Peak + 1;              Line_Energy^[Valid_Peak] := eV_Line[42];			                peak_label := 'L    ';               fluorescence;			   Get_Energies(A^.Bulk_At_Num[counter]);			   loc_chan := rinttol(Line_Energy^[Valid_Peak] / L_theGenRec.dE);               fchi := fChiChar(Line_Energy^[Valid_Peak]);			                 Generated^[Valid_Peak] := Wt_Line[42] * Integrate_Q_over_S(2) * Backscatter(A^.edge[4] / 1000.0) * WL(                                       A^.Bulk_At_Num[counter]) * SAL(A^.Bulk_At_Num[counter]) * Bulk_Physics_Constant;               InFront_Detector^[Valid_Peak] := Generated^[Valid_Peak] * fchi;              InFront_Detector_Fluor^[Valid_Peak] := InFront_Detector^[Valid_Peak] * XKF;              Inside_Detector^[Valid_Peak] := InFront_Detector_Fluor^[Valid_Peak] * Det_Effic_P^[loc_chan];              L_Hold := Valid_Peak;			 END		  ELSE L_Hold := 0;         peak_label := 'L    '; 		 theEdge := A^.edge[4];		 For k := 37 to 41 do begin          IF (eV_Line[k] > 1.0) AND (eV_Line[k] < En_Lim) THEN            Bulk_Dependent_Peak_Gen(eV_Line[k], Wt_Line[k], L_Hold);         End;         		 For k := 43 to 52 do begin          IF (eV_Line[k] > 1.0) AND (eV_Line[k] < En_Lim) THEN            Bulk_Dependent_Peak_Gen(eV_Line[k], Wt_Line[k], L_Hold); 		 End; 		       		 theEdge := A^.edge[3];		 For k := 21 to 36 do begin          IF (eV_Line[k] > 1.0) AND (eV_Line[k] < En_Lim) THEN            Bulk_Dependent_Peak_Gen(eV_Line[k], Wt_Line[k], L_Hold); 		 End;      		 theEdge := A^.edge[2];		 For k := 8 to 20 do begin          IF (eV_Line[k] > 1.0) AND (eV_Line[k] < En_Lim) THEN            Bulk_Dependent_Peak_Gen(eV_Line[k], Wt_Line[k], L_Hold); 		 End;          IF (eV_Line[144] > 1.0) AND (eV_Line[144] < En_Lim) THEN	{¥¥5/16/99 LG2¥¥}            Bulk_Dependent_Peak_Gen(eV_Line[144], Wt_Line[144], L_Hold);		{if WDS_Active then} Load_WDS_L;			(*END;*)	{IF (eV_LA1 > 52) AND (eV_LA1 < En_Lim)}	 									          IF (eV_Line[72] > 52.0) AND 		     (eV_Line[72] < En_Lim) AND 			 (Z >= 35) THEN			 		(*IF (A^.Bulk_At_Num[counter] >= 35) THEN*)            BEGIN             Valid_Peak := Valid_Peak + 1;              Line_Energy^[Valid_Peak] := (eV_Line[72] + eV_Line[73])/2;			  loc_chan := rinttol(Line_Energy^[Valid_Peak] / L_theGenRec.dE);			                peak_label := 'M    ';  				                fluorescence; 		 	  Get_Energies(A^.Bulk_At_Num[counter]);	                 fchi := fChiChar(Line_Energy^[Valid_Peak]);              Generated^[Valid_Peak] := (Wt_Line[72] + Wt_Line[73])/2 * Integrate_Q_over_S(3) *              						 Backscatter(A^.edge[9] / 1000.0) * WM(                                       A^.Bulk_At_Num[counter]) * SAM(A^.Bulk_At_Num[counter]) * Bulk_Physics_Constant;              InFront_Detector^[Valid_Peak] := Generated^[Valid_Peak] * fchi;              InFront_Detector_Fluor^[Valid_Peak] := InFront_Detector^[Valid_Peak] * XKF;              Inside_Detector^[Valid_Peak] := InFront_Detector_Fluor^[Valid_Peak] * Det_Effic_P^[loc_chan];											          M_Hold := Valid_Peak;		 END		ELSE M_Hold := 0;		          peak_label := 'M';		 theEdge := A^.edge[9];			k := 71;          IF (eV_Line[k] > 1.0) AND (eV_Line[k] < En_Lim) THEN            Bulk_Dependent_Peak_Gen(eV_Line[k], Wt_Line[k], M_Hold);			k := 74;          IF (eV_Line[k] > 1.0) AND (eV_Line[k] < En_Lim) THEN            Bulk_Dependent_Peak_Gen(eV_Line[k], Wt_Line[k], M_Hold);      		 theEdge := A^.edge[8];		 For k := 67 to 70 do begin          IF (eV_Line[k] > 1.0) AND (eV_Line[k] < En_Lim) THEN            Bulk_Dependent_Peak_Gen(eV_Line[k], Wt_Line[k], M_Hold); 		 End;		 theEdge := A^.edge[7];		 For k := 59 to 66 do begin          IF (eV_Line[k] > 1.0) AND (eV_Line[k] < En_Lim) THEN            Bulk_Dependent_Peak_Gen(eV_Line[k], Wt_Line[k], M_Hold); 		 End;      		 theEdge := A^.edge[6];		 For k := 55 to 58 do begin          IF (eV_Line[k] > 1.0) AND (eV_Line[k] < En_Lim) THEN            Bulk_Dependent_Peak_Gen(eV_Line[k], Wt_Line[k], M_Hold); 		 End;					 theEdge := A^.edge[5];		 	k := 53;          IF (eV_Line[k] > 1.0) AND (eV_Line[k] < En_Lim) THEN            Bulk_Dependent_Peak_Gen(eV_Line[k], Wt_Line[k], M_Hold);		 	k := 54;          IF (eV_Line[k] > 1.0) AND (eV_Line[k] < En_Lim) THEN            Bulk_Dependent_Peak_Gen(eV_Line[k], Wt_Line[k], M_Hold);     if WDS_Active then	 begin		 theEdge := A^.edge[9];		 For k := 136 to 139 do begin          IF (eV_Line[k] > 1.0) AND (eV_Line[k] < En_Lim) THEN            Bulk_Dependent_Peak_Gen(eV_Line[k], Wt_Line[k], M_Hold); 		 End;		 theEdge := A^.edge[8];		 For k := 140 to 142 do begin          IF (eV_Line[k] > 1.0) AND (eV_Line[k] < En_Lim) THEN            Bulk_Dependent_Peak_Gen(eV_Line[k], Wt_Line[k], M_Hold); 		 End;		 theEdge := A^.edge[7];		 	k := 143;          IF (eV_Line[k] > 1.0) AND (eV_Line[k] < En_Lim) THEN            Bulk_Dependent_Peak_Gen(eV_Line[k], Wt_Line[k], M_Hold);			   		end;{ if wds...}   	(*END;*)	{IF (eV_MA1_2 > 52) AND 		     (eV_MA1_2 < En_Lim) AND 			 (Z >= 57)}			 			           MN := L_theGenRec.Si_Resolution * L_theGenRec.Si_Resolution;		             FOR J := 1 TO L_theGenRec.Number_of_Channels DO            BEGIN              SpinCursor;              E := J * L_theGenRec.dE;              FOR JJ := 1 TO Valid_Peak DO                BEGIN                  IF Si_Active THEN SIGSQ := (2.5 * (Line_Energy^[JJ] - 5895.0) + MN) * aSigConst;                  IF Ge_Active THEN SIGSQ := (2.5 * (Line_Energy^[JJ] - 5895.0) + MN) * aSigConst;                  IF WDS_active THEN SIGSQ := L_theGenRec.WDS_Resolution * L_theGenRec.WDS_Resolution * aSigConst;				  IF L_theGenRec.Si_Resolution < 125.0 then SIGSQ := MN * aSigConst;                  dele := (E - Line_Energy^[JJ]);                  DELESQ := dele * dele;                  arg := - (0.5 / SIGSQ);                  YE := Generated^[JJ] * L_theGenRec.dE / sqrt(PI2 * SIGSQ) * exp( - 0.5 * DELESQ / SIGSQ);                  IF WDS_active THEN                    BEGIN                      Remond(YE_SiLi, 					         L_theGenRec.WDS_Resolution, 							 Line_Energy^[JJ], 							 L_theGenRec.dE / sqrt(PI2 * SIGSQ) * Inside_Detector^[JJ], 							 E);                    END                  ELSE                    YE_SiLi := Inside_Detector^[JJ] * L_theGenRec.dE / sqrt(PI2 * SIGSQ) * exp( - 0.5 * DELESQ / SIGSQ); { We need the term "dE/sqrt( pi2*SIGSQ)" to distribute the number of generated  counts over the channels of the whole peak, rather than put them all in the peak channel }                  Gen_P^[J] := Gen_P^[J] + YE; { does NOT have fluorescence }                  Ob_Pks_P^[J] := Ob_Pks_P^[J] + YE_SiLi; { does have fluorescence }                  { Now do the delta functions and put onto the continuum }                  IF (Line_Energy^[JJ] >= E - L_theGenRec.dE) AND (Line_Energy^[JJ] < E) THEN                    BEGIN                      YE_delta := Generated^[JJ]; { Fluor No }                      YE_SiLi_delta := Inside_Detector^[JJ]; { Fluor Yes }                      Col_2^[J] := Col_2^[J] + YE_delta; { gen. scaled for before det. Fluor No}                      Col_3^[J] := Col_3^[J] + YE_SiLi_delta; { Inside detector. Fluor Yes }					  Col_5^[J] := Col_5^[J] + InFront_Detector^[JJ]; { Fluor No, continuum added above }                      Col_6^[J] := Col_6^[J] + InFront_Detector_Fluor^[JJ]; { Before detector. Fluor Yes }                    END;                END; { JJ := 1 TO Valid_Peak... }            END; { J := 1 TO L_theGenRec.Number_of_Channels... }        END;	{ FOR indexer := 1 TO Numb_of_Elements...}      { The received-in-detector continuum is in the temporary holding vector Col_1^[] }       DisposeDialog(BusyMessage);       	  Convolve_Col1;      FOR nn := 1 TO L_theGenRec.Number_of_Channels DO        BEGIN          Col_1^[nn] := Col_1^[nn] + Ob_Pks_P^[nn];        END;	  IF NOT WDS_active THEN Add_Escape_Peaks;       BlockMove(@Col_1^, @Composite_P^, Sizeof(Composite_P^));	 	 IF NOT WDS_active THEN BEGIN	  {do escapes on Ob_Pks_P so that the amplitude is correct...}      BlockMove(@Ob_Pks_P^, @Col_1^, Sizeof(Col_1^));	   Add_Escape_Peaks;       BlockMove(@Col_1^, @Ob_Pks_P^, Sizeof(Ob_Pks_P^));     END;		END; { of proc Bulk }END. { of UNIT Physics }  