UNIT PGT_4_Plug;INTERFACEUSES	Types, QuickDraw, Memory, fp, StandardFile, GestaltEqu, Errors, Files,	TextUtils, {PascalA4,} FilePlugIns;const		__procinfo : longint = $3F80;{$Main}PROCEDURE	ENTRYPOINT(message:Integer; VAR InPtr:IOPlugPtr; VAR theResult:OSerr);IMPLEMENTATION{$IFC NOT POWERPC}uses PascalA4;{$ENDC}PROCEDURE PGT_System_4(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);FORWARD;PROCEDURE DoAbout(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);FORWARD;PROCEDURE DoOpen(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);FORWARD;PROCEDURE DoWrite(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);FORWARD;FUNCTION	Str2Num(s: Str255): Real;FORWARD;PROCEDURE 	ENTRYPOINT{(message:Integer; VAR InPtr:IOPlugPtr; VAR theResult:OSErr)};		{ Main dispatching routine.  Initializes and sets up the global variables,	}		{		and performs the operation specified by the message. 				}VAR	firstTime	: BOOLEAN;	OldA4		: Longint;BEGIN{$IFC NOT POWERPC}	oldA4 := SetCurrentA4();	RememberA4();{$ENDC}	theResult:=noErr;	firstTime:=(InPtr=NIL);					{ See if this is the first time called }	IF firstTime THEN BEGIN						{ If so, allocate and initialize a data area }		InPtr:= IOPlugPtr(NewPtrClear(sizeof(IOPlug)));		IF (InPtr=NIL) THEN BEGIN			debugstr('memFullErr');			theResult:=memFullErr;{$IFC NOT POWERPC}	oldA4 := SetA4(oldA4);{$ENDC}			EXIT(ENTRYPOINT);		END;				END;		CASE message OF					{ Perform the requested operation }		fileAbout		:DoAbout(InPtr, theResult);		ImpFile			:PGT_System_4(InPtr, theResult);		ExpFile			:DoWrite(InPtr, theResult);		OpenInPlug		:DoOpen(InPtr, theResult);		OpenExPlug		:DoOpen(InPtr, theResult);		END; {CASE messaage}		{$IFC NOT POWERPC}	oldA4 := SetA4(oldA4);{$ENDC}END;PROCEDURE DoAbout(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);	Begin	End;	PROCEDURE DoOpen(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);	Begin		InPtr^.PlugInName:='PGT System 4';		{Debugstr('Inside of PGT_System_4 - Do Open');}		theResult := noErr;	End;	PROCEDURE DoWrite(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);	Begin	End;  PROCEDURE PGT_System_4(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);        CONST      tSerial_BufferSize            = 100000; {Never more than a single spectrum, 8192 chans ┼ 80K}    TYPE      tPAC256Buffer                 = PACKED ARRAY [1..tSerial_BufferSize] OF signedbyte;      tPAC256BufPtr                 = ^tPAC256Buffer;	  TByte                         = PACKED ARRAY [1..1] OF byte;    VAR      index, nn, jj, kk             : integer;      FileSize                      : longint;      theRefnum                     : integer;      tipBufPtr                     : tPAC256BufPtr;      indexL                        : longint;      strLength                     : TByte;      bytecount                     : longint;      str, str1, str2               : str255;      Car_Ret                       : Boolean;      START_EV                      : Real;	  END_EV                        : Real;	  errCode                       : OSErr;	      LABEL      100;    BEGIN		theRefnum := InPtr^.Rd_Refnum;		{Debugstr('Inside of ReadTracorFile');}		InPtr^.Specimen_Comment_Field := '';		  errCode := GetEOF(theRefnum, FileSize);      tipBufPtr := tPAC256BufPtr(NewPtr(sizeof(tPAC256Buffer)));      IF tipBufPtr = NIL THEN        BEGIN          exit(PGT_System_4);        END;      IF FSRead(theRefnum, FileSize, Pointer(tipBufPtr)) <> NoErr THEN        BEGIN		  theResult := badFileFormat;		  DisposePtr(Ptr(tipBufPtr));          exit(PGT_System_4);        END;      Car_Ret := false;        indexL := 0;        strLength[1] := 25;        BlockMove(@strLength, @str[0], 1);        FOR nn := 1 TO 200 DO { move into the buffer up to 200 characters until the string "----- SPECTRUM DATA -----" found}          BEGIN            indexL := indexL + 1;            BlockMove(@tipBufPtr^[indexL], @str[1], strLength[1]);            IF str = '----- SPECTRUM DATA -----' THEN              BEGIN                indexL := 1;  {reset to the beginning}                GOTO 100;              END;          END;        theResult := badFileFormat;        DisposePtr(Ptr(tipBufPtr));        exit(PGT_System_4);      100:        REPEAT          indexL := indexL + 1;        UNTIL (tipBufPtr^[indexL] <> 13)  AND  {CR}		      (tipBufPtr^[indexL] <> 10)  AND  {LF}			  (tipBufPtr^[indexL] <> $20) AND  {SPACE}			  (tipBufPtr^[indexL] <> $09);     {TAB}		        jj := 0;        REPEAT          jj := jj + 1;        UNTIL tipBufPtr^[indexL + jj] = 13; {measure the length of rest of the line }        strLength[1] := jj;        BlockMove(@strLength, @str[0], 1);        BlockMove(@tipBufPtr^[indexL], @str[1], strLength[1]);        InPtr^.Specimen_Comment_Field := str;				START_EV   := 0.0;		END_EV     := 20000.0;         strLength[1] := 8;        BlockMove(@strLength, @str[0], 1);        REPEAT          BlockMove(@tipBufPtr^[indexL], @str[1], strLength[1]);          indexL := indexL + 1;        UNTIL str = 'START EV';        indexL := indexL + strLength[1];                 WHILE ((tipBufPtr^[indexL] = $20) OR (tipBufPtr^[indexL] = $09)) DO          indexL := indexL + 1; { jump over a run of spaces }        str := '';        WHILE NOT ((tipBufPtr^[indexL] = $20) OR (tipBufPtr^[indexL] = $09)) DO          BEGIN            str := CONCAT(str, chr(tipBufPtr^[indexL]));            indexL := indexL + 1;          END; { While }        IF (LENGTH(str) > 0) THEN START_EV := str2num(str);        strLength[1] := 6;        BlockMove(@strLength, @str[0], 1);        REPEAT          BlockMove(@tipBufPtr^[indexL], @str[1], strLength[1]);          indexL := indexL + 1;        UNTIL str = 'END EV';        indexL := indexL + strLength[1];                 WHILE ((tipBufPtr^[indexL] = $20) OR (tipBufPtr^[indexL] = $09)) DO          indexL := indexL + 1; { jump over a run of spaces }        str := '';        WHILE NOT ((tipBufPtr^[indexL] = $20) OR (tipBufPtr^[indexL] = $09)) DO          BEGIN            str := CONCAT(str, chr(tipBufPtr^[indexL]));            indexL := indexL + 1;          END; { While }        IF (LENGTH(str) > 0) THEN END_EV := str2num(str);         strLength[1] := 10;        BlockMove(@strLength, @str[0], 1);        REPEAT          BlockMove(@tipBufPtr^[indexL], @str[1], strLength[1]);          indexL := indexL + 1;        UNTIL str = 'EV/CHANNEL';        indexL := indexL + strLength[1];        WHILE ((tipBufPtr^[indexL] = $20) OR (tipBufPtr^[indexL] = $09)) DO          indexL := indexL + 1; { jump over a run of spaces }        str := '';        WHILE NOT ((tipBufPtr^[indexL] = $20) OR (tipBufPtr^[indexL] = $09)) DO          BEGIN            str := CONCAT(str, chr(tipBufPtr^[indexL]));            indexL := indexL + 1;          END; { While }        IF (LENGTH(str) > 0) THEN InPtr^.dE := str2num(str);         InPtr^.Number_of_Channels := rinttol((END_EV-START_EV)/InPtr^.dE);        strLength[1] := 25;        BlockMove(@strLength, @str[0], 1);        FOR nn := 1 TO 200 DO { move into the buffer up to 200 characters until the string "----- SPECTRUM DATA -----" found}          BEGIN            indexL := indexL + 1;            BlockMove(@tipBufPtr^[indexL], @str[1], strLength[1]);            IF str = '----- SPECTRUM DATA -----' THEN			BEGIN					   REPEAT				 indexL := indexL + 1;			   UNTIL tipBufPtr^[indexL] = 13;			   indexL := indexL + 1;			   IF (tipBufPtr^[indexL] = 10) THEN indexL := indexL + 1; {skip a LF}			   indexL := indexL + 17; {skip over the 1st 2 columns}			   leave;			END;		  END;				        jj := 1; { jj will be the channel number }        REPEAT {еееее This REPEAT part reads in the spectrum еееее}          str := ''; {еееее This fragment reads a channel еееее}          WHILE ((tipBufPtr^[indexL] = $20 {sp} ) OR (tipBufPtr^[indexL] = $09 {tab} )) DO            indexL := indexL + 1; { jump over a run of spaces/tabs }          WHILE ((tipBufPtr^[indexL] <> $20 {sp} ) AND (tipBufPtr^[indexL] <> $09 {tab} )) AND (tipBufPtr^[indexL] <> $0D {cr} ) DO            BEGIN              str := CONCAT(str, chr(tipBufPtr^[indexL]));              indexL := indexL + 1;              IF tipBufPtr^[indexL] = $0D {cr} THEN Car_Ret := true;            END; { While }          IF LENGTH(str) > 0 THEN            BEGIN              InPtr^.Spec_cts[jj] := str2num(str);              jj := jj + 1;            END;          indexL := indexL + 1;          IF tipBufPtr^[indexL] = $0D {cr} THEN Car_Ret := true;          IF Car_Ret THEN            BEGIN			  indexL := indexL + 1;			  IF (tipBufPtr^[indexL] = 10) THEN indexL := indexL + 1; {skip a LF}			  indexL := indexL + 17; {skip over the 1st 2 columns}              Car_Ret := false;            END;            IF indexL > FileSize THEN 			  begin				DisposePtr(Ptr(tipBufPtr));				theResult := badFileFormat;				exit(PGT_System_4);			  end;        UNTIL jj >= InPtr^.Number_of_Channels; {еееее}		InPtr^.LastChannel := InPtr^.Number_of_Channels;       	DisposePtr(Ptr(tipBufPtr));		theResult := noErr;    END; { Procedure PGT_System_4 }{*****************************************************************************}FUNCTION Str2Num(s: Str255): Real;   { Pascal implementation of Str2Num (fp.p: Str2Dec, Dec2Str) }VAR	aDecimal		: Decimal;	aCStr			: ConstCStringPtr;	anIndex			: Integer;	aValidPrefix	: Integer; { ignore }BEGIN	aCStr := P2CStr(@s);	anIndex := 0;	str2dec( aCStr, anIndex, aDecimal, aValidPrefix );	Str2Num := dec2num( aDecimal );END;END.