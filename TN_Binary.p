UNIT TN_Binary_Plug;INTERFACEUSES	Types, QuickDraw, Memory, fp, StandardFile, GestaltEqu, Errors, Files,	{PascalA4,} FilePlugIns;const		__procinfo : longint = $3F80;{$Main}PROCEDURE	ENTRYPOINT(message:Integer; VAR InPtr:IOPlugPtr; VAR theResult:OSerr);IMPLEMENTATION{$IFC NOT POWERPC}uses PascalA4;{$ENDC}PROCEDURE ReadTracorFile(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);FORWARD;PROCEDURE DoAbout(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);FORWARD;PROCEDURE DoOpen(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);FORWARD;PROCEDURE DoWrite(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);FORWARD;PROCEDURE 	ENTRYPOINT{(message:Integer; VAR InPtr:IOPlugPtr; VAR theResult:OSErr)};		{ Main dispatching routine.  Initializes and sets up the global variables,	}		{		and performs the operation specified by the message. 				}VAR	firstTime	: BOOLEAN;	OldA4		: Longint;BEGIN{$IFC NOT POWERPC}	oldA4 := SetCurrentA4();	RememberA4();{$ENDC}	theResult:=noErr;	firstTime:=(InPtr=NIL);					{ See if this is the first time called }	IF firstTime THEN BEGIN						{ If so, allocate and initialize a data area }		InPtr:= IOPlugPtr(NewPtrClear(sizeof(IOPlug)));		IF (InPtr=NIL) THEN BEGIN			debugstr('memFullErr');			theResult:=memFullErr;{$IFC NOT POWERPC}	oldA4 := SetA4(oldA4);{$ENDC}			EXIT(ENTRYPOINT);		END;				END;		CASE message OF					{ Perform the requested operation }		fileAbout		:DoAbout(InPtr, theResult);		ImpFile			:ReadTracorFile(InPtr, theResult);		ExpFile			:DoWrite(InPtr, theResult);		OpenInPlug		:DoOpen(InPtr, theResult);		OpenExPlug		:DoOpen(InPtr, theResult);		END; {CASE message}		{$IFC NOT POWERPC}	oldA4 := SetA4(oldA4);{$ENDC}END;PROCEDURE DoAbout(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);	Begin	End;	PROCEDURE DoOpen(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);	Begin		InPtr^.PlugInName:='TN 5500 Binary';		{Debugstr('Inside of ReadTracorFile - Do Open');}		theResult := noErr;	End;	PROCEDURE DoWrite(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);	Begin	End;  PROCEDURE ReadTracorFile(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);	TYPE		Data_Array                    = ARRAY [1..8200] OF real;		Data_TypePtr                  = ^Data_Array;		TypeBlock                     = PACKED ARRAY [0..511] OF byte;		SmallArray                    = ARRAY [0..255] OF real;		SmallIntArray                 = ARRAY [0..255] OF integer;    VAR      nn, fref, Itemp, index        : integer;      FirstBlockInteger             : SmallIntArray;      FirstBlock, FirstBlockSwapped : TypeBlock;      AnotherBlock, AnotherBlockSwapped: TypeBlock;      AnotherBlockInteger           : SmallIntArray;      AnotherBlockReal              : SmallArray;      NumBlocks, NBlock             : integer;      NumberofChannels              : longint;      numbytes                      : longint;      BlockPtr                      : Ptr;      increm, increm2, wheretoput, putbytes: integer;      dummy                         : str255;      LabelArray                    : PACKED ARRAY [1..40] OF char;      num_digits, wds_byt           : signedbyte;      units_label                   : PACKED ARRAY [1..4] OF char;      TestErr, kk, refnum           : integer;	  Spectrum						: Data_TypePtr;  PROCEDURE BlockSwap(InBlock: TypeBlock; VAR OutBlock: TypeBlock);    VAR      i, ii                         : integer;    BEGIN      FOR i := 0 TO 511 DO        BEGIN          OutBlock[i] := 0;        END;      FOR i := 0 TO 255 DO        BEGIN          ii := 2 * i;          OutBlock[ii + 1] := InBlock[ii];          OutBlock[ii] := InBlock[ii + 1];        END;    END;    BEGIN		refnum := InPtr^.Rd_Refnum;		{Debugstr('Inside of ReadTracorFile');}		InPtr^.Specimen_Comment_Field := '';	      Spectrum := Data_TypePtr(NewPtr(sizeof(Data_Array)));      BlockPtr := @FirstBlock;      numbytes := 512;      TestErr := FSRead(refnum, numbytes, BlockPtr);      IF TestErr <> noErr THEN begin	  	DisposePtr(Ptr(Spectrum));	  	(*numToString(TestErr, dummy);	  	dummy := concat('Error is = ',dummy);		Debugstr(dummy);*)				theResult := badFileFormat;	  	exit(ReadTracorFile);	  end;      BlockSwap(FirstBlock, FirstBlockSwapped);      BlockMove(@FirstBlockSwapped, @FirstBlockInteger, numbytes);      NumBlocks := 256 - BAND(FirstBlockInteger[56], 255);      NBlock := trunc(NumBlocks / 3);      NumberofChannels := 512 * NBlock;      InPtr^.Number_of_Channels := NumberofChannels;	  	(*numToString(NumberofChannels, dummy);	  	dummy := concat('num of channels = ',dummy);		Debugstr(dummy);*)      BlockPtr := @AnotherBlock;      FOR increm := 1 TO (NBlock * 2) DO { number of blocks of words }        BEGIN          wheretoput := 256 * (increm - 1) + 1;          TestErr := FSRead(refnum, numbytes, BlockPtr);          BlockSwap(AnotherBlock, AnotherBlockSwapped);          BlockMove(@AnotherBlockSwapped, @AnotherBlockInteger, numbytes);          FOR increm2 := 0 TO 255 DO            BEGIN              IF (AnotherBlockInteger[increm2] < 0) THEN AnotherBlockReal[increm2] := 65536 + AnotherBlockInteger[increm2]              ELSE AnotherBlockReal[increm2] := AnotherBlockInteger[increm2];            END;          BlockMove(@AnotherBlockReal, @Spectrum^[wheretoput], sizeof(AnotherBlockReal));        END;      FOR increm := 1 TO NBlock DO        BEGIN          putbytes := 512 * (increm - 1) + 1;          TestErr := FSRead(refnum, numbytes, BlockPtr);          FOR increm2 := 0 TO 511 DO            BEGIN              IF (AnotherBlock[increm2] < 0) THEN Itemp := AnotherBlock[increm2] + 256              ELSE Itemp := AnotherBlock[increm2];              wheretoput := putbytes + increm2;              Spectrum^[wheretoput] := Spectrum^[wheretoput] + 65536 * Itemp;            END;        END;      FOR increm2 := 1 TO NumberofChannels DO        InPtr^.Spec_cts[increm2] := Spectrum^[increm2];      InPtr^.Live_Time := FirstBlockInteger[156];      InPtr^.dE := BAND(FirstBlockInteger[157], 3);      InPtr^.dE := 10 * Exp(Ln(2) * InPtr^.dE);      InPtr^.Specimen_Comment_Field := '';      BlockMove(@FirstBlock[2], @LabelArray[1], 40);      FOR increm := 1 TO 40 DO        InPtr^.Specimen_Comment_Field := CONCAT(InPtr^.Specimen_Comment_Field, LabelArray[increm]);      IF BAND(FirstBlockInteger[56], 1024) < 1 THEN { 20 or 40 byte label test }        delete(InPtr^.Specimen_Comment_Field, 21, 20);      BlockMove(@FirstBlock[36], @wds_byt, 1);      IF (wds_byt = 0) THEN        BEGIN          InPtr^.Spectrum_Type := 'WDS ';          (*WDS_Active := true;          Si_Active := false;*)        END      ELSE        BEGIN          InPtr^.Spectrum_Type := 'EDS ';          (*WDS_Active := false;          Si_Active := true;*)        END;      IF (wds_byt = 0) THEN        BEGIN          BlockMove(@FirstBlockInteger[19], @increm, 2); { Units/channel }          BlockMove(@FirstBlockInteger[20], @increm2, 2); { Starting value }          BlockMove(@FirstBlock[42], @units_label, 4);          BlockMove(@FirstBlock[37], @num_digits, 1);          InPtr^.FirstValue := increm2;          InPtr^.EndValue := increm2 + NumberofChannels * increm;          FOR index := 1 TO num_digits DO            BEGIN              InPtr^.FirstValue := InPtr^.FirstValue / 10;              InPtr^.EndValue := InPtr^.EndValue / 10;            END;          InPtr^.LastChannel := NumberofChannels;        END;      DisposePtr(Ptr(Spectrum));	  theResult := noErr;    END;END.