UNIT ND_ASCII_Plug;INTERFACEUSES	Types, QuickDraw, Memory, fp, StandardFile, GestaltEqu, Errors, Files,	TextUtils, {PascalA4,} FilePlugIns;const		__procinfo : longint = $3F80;{$Main}PROCEDURE	ENTRYPOINT(message:Integer; VAR InPtr:IOPlugPtr; VAR theResult:OSerr);IMPLEMENTATION{$IFC NOT POWERPC}uses PascalA4;{$ENDC}PROCEDURE Read_a_Nuclear_Data_File(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);FORWARD;PROCEDURE DoAbout(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);FORWARD;PROCEDURE DoOpen(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);FORWARD;PROCEDURE DoWrite(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);FORWARD;FUNCTION	Str2Num(s: Str255): Real;FORWARD;PROCEDURE 	ENTRYPOINT{(message:Integer; VAR InPtr:IOPlugPtr; VAR theResult:OSErr)};		{ Main dispatching routine.  Initializes and sets up the global variables,	}		{		and performs the operation specified by the message. 				}VAR	firstTime	: BOOLEAN;	OldA4		: Longint;BEGIN{$IFC NOT POWERPC}	oldA4 := SetCurrentA4();	RememberA4();{$ENDC}	theResult:=noErr;	firstTime:=(InPtr=NIL);					{ See if this is the first time called }	IF firstTime THEN BEGIN						{ If so, allocate and initialize a data area }		InPtr:= IOPlugPtr(NewPtrClear(sizeof(IOPlug)));		IF (InPtr=NIL) THEN BEGIN			debugstr('memFullErr');			theResult:=memFullErr;{$IFC NOT POWERPC}	oldA4 := SetA4(oldA4);{$ENDC}			EXIT(ENTRYPOINT);		END;				END;		CASE message OF					{ Perform the requested operation }		fileAbout		:DoAbout(InPtr, theResult);		ImpFile			:Read_a_Nuclear_Data_File(InPtr, theResult);		ExpFile			:DoWrite(InPtr, theResult);		OpenInPlug		:DoOpen(InPtr, theResult);		OpenExPlug		:DoOpen(InPtr, theResult);		END; {CASE message}		{$IFC NOT POWERPC}	oldA4 := SetA4(oldA4);{$ENDC}END;PROCEDURE DoAbout(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);	Begin	End;	PROCEDURE DoOpen(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);	Begin		InPtr^.PlugInName:='Nuc Data ASCII';		{Debugstr('Inside of ND_ASCII - Do Open');}		theResult := noErr;	End;	PROCEDURE DoWrite(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);	Begin	End;  FUNCTION NDDateStr2Real(thestr: str255): real;        VAR      theLint, theSecs              : longint;      Index, max                    : integer;      str8,str2                     : str255;	  days, hours, minutes			: longint;	  seconds						: real;{1} BEGIN      Index := 1;      str8 := '';	  max := Length(thestr);		days := 0;		REPEAT		  if (ord(thestr[Index]) < 58) or (ord(thestr[Index]) > 47)			  then str8 := CONCAT(str8, thestr[Index]);		  Index := Index + 1;		UNTIL ( index > max) or (ord(thestr[Index]) = 58);		StringToNum(str8, theLint);		hours := theLint;		{3} 	if index < max then begin		  {index was not a number so increment it again if < max}		  str8 := '';		  Index := Index + 1;		  REPEAT			if (ord(thestr[Index]) < 58) or (ord(thestr[Index]) > 47)				then str8 := CONCAT(str8, thestr[Index]);			Index := Index + 1;		  UNTIL ( index > max) or (ord(thestr[Index]) = 58);		  StringToNum(str8, theLint);		  minutes := theLint;		  {4}	      if index < max then begin			{index was not a number so increment it again if < max}			str8 := '';			Index := Index + 1;			REPEAT			  if (ord(thestr[Index]) < 58) or (ord(thestr[Index]) >= 46)				  then str8 := CONCAT(str8, thestr[Index]);			  Index := Index + 1;			UNTIL ( index > max) or (ord(thestr[Index]) < 46) or (ord(thestr[Index]) > 57);			Seconds := Str2Num(str8);{4} 	  END;	{index < max...){3}     END;	{index < max...){2}   {END;}	{index < max...}	NDDateStr2Real := ((((days*24) + hours)*60 + minutes)*60) + seconds;{1} END; {Function NDDateStr2Real(thestr: str255): real;}  PROCEDURE Read_a_Nuclear_Data_File(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);      CONST      tBufferSize            = 100000; {Never more than a single spectrum, 8192 chans Å 80K}    TYPE      tBuffer                 = PACKED ARRAY [1..tBufferSize] OF signedbyte;      tBufPtr                 = ^tBuffer;	  TByte                   = PACKED ARRAY [1..1] OF byte;    VAR      index, nn, jj, kk             : integer;      err                           : integer;      refnum                        : integer;      FileSize                      : longint;      tipBufPtr                     : tBufPtr;      indexL                        : longint;      {counter                       : integer;}      strLength                     : TByte;      bytecount                     : longint;      str, str1, str2               : str255;      theWhere                      : Point;      theReply                      : SFReply;      finished                      : Boolean;      Car_Ret                       : Boolean;	  IValue						: longint;	  RValue                        : real;        LABEL      100;  	BEGIN		refnum := InPtr^.Rd_Refnum;		{Debugstr('Inside of ND_ASCII_Files - Read_a_Nuclear_Data_File');}		InPtr^.Specimen_Comment_Field := '';						nn := 0;		err := GetEOF(refnum, FileSize);		tipBufPtr := tBufPtr(NewPtr(sizeof(tBuffer)));		err := FSRead(refnum, FileSize, Pointer(tipBufPtr));		theResult := err;        Car_Ret := false;        indexL := 0;        strLength[1] := 4;        BlockMove(@strLength, @str[0], 1);        FOR nn := 1 TO 100 DO { move into the buffer up to 100 characters until the string "***N" found, and register from this}          BEGIN            indexL := indexL + 1;            BlockMove(@tipBufPtr^[indexL], @str[1], strLength[1]);            IF str = '***N' THEN              BEGIN                indexL := indexL + 4; {skip over the ***}                GOTO 100;              END;          END;        DisposePtr(Ptr(tipBufPtr));		theResult := badFileFormat;        exit(Read_a_Nuclear_Data_File);      100:        jj := 0;        REPEAT          jj := jj + 1;        UNTIL tipBufPtr^[indexL + jj] = 13; {measure the length of rest of the line }        strLength[1] := jj - 1;        BlockMove(@strLength, @str[0], 1);        BlockMove(@tipBufPtr^[indexL], @str[1], strLength[1]);        InPtr^.Specimen_Comment_Field := str;        indexL := indexL - 5; { back up a bit for safety }        REPEAT          indexL := indexL + 1;        UNTIL tipBufPtr^[indexL] = 13;        indexL := indexL + 1;        IF (tipBufPtr^[indexL] = 10) THEN indexL := indexL + 1; {skip a LF}        strLength[1] := 20;        BlockMove(@strLength, @str[0], 1);        REPEAT          BlockMove(@tipBufPtr^[indexL], @str[1], strLength[1]);          indexL := indexL + 1;        UNTIL str = 'Number of Channels =';        indexL := indexL + strLength[1];        WHILE ((tipBufPtr^[indexL] = $20) OR (tipBufPtr^[indexL] = $09)) DO          indexL := indexL + 1; { jump over a run of spaces }        str := '';        WHILE NOT ((tipBufPtr^[indexL] = $20) OR (tipBufPtr^[indexL] = $09)) DO          BEGIN            str := CONCAT(str, chr(tipBufPtr^[indexL]));            indexL := indexL + 1;          END; { While }        IF (LENGTH(str) > 0) THEN InPtr^.Number_of_Channels := rinttol(str2num(str));        IF InPtr^.Number_of_Channels <= 0 THEN          BEGIN			DisposePtr(Ptr(tipBufPtr));			theResult := badFileFormat;            exit(Read_a_Nuclear_Data_File);          END;		  		{¥¥¥Can read in the ND date here¥¥¥}		{example:  Start time = 14-OCT-1994 09:24:03.76}		        strLength[1] := 12;        BlockMove(@strLength, @str[0], 1);        REPEAT          BlockMove(@tipBufPtr^[indexL], @str[1], strLength[1]);          indexL := indexL + 1;        UNTIL str = 'real time =0';        indexL := indexL + strLength[1];        WHILE ((tipBufPtr^[indexL] = $20) OR (tipBufPtr^[indexL] = $09)) DO          indexL := indexL + 1; { jump over a run of spaces }        str := '';        WHILE NOT ((tipBufPtr^[indexL] = $20) OR (tipBufPtr^[indexL] = $09)) DO          BEGIN            str := CONCAT(str, chr(tipBufPtr^[indexL]));            indexL := indexL + 1;          END; { While }        IF (LENGTH(str) > 0) THEN InPtr^.Real_Time := NDDateStr2Real(str);        IF InPtr^.Real_Time <= 0 THEN          BEGIN			DisposePtr(Ptr(tipBufPtr));			theResult := badFileFormat;            exit(Read_a_Nuclear_Data_File);          END;        strLength[1] := 12;        BlockMove(@strLength, @str[0], 1);        REPEAT          BlockMove(@tipBufPtr^[indexL], @str[1], strLength[1]);          indexL := indexL + 1;        UNTIL str = 'live time =0';        indexL := indexL + strLength[1];        WHILE ((tipBufPtr^[indexL] = $20) OR (tipBufPtr^[indexL] = $09)) DO          indexL := indexL + 1; { jump over a run of spaces }        str := '';        WHILE NOT ((tipBufPtr^[indexL] = $20) OR (tipBufPtr^[indexL] = $09) OR					(tipBufPtr^[indexL] = $0D) OR (tipBufPtr^[indexL] = $0A)) DO          BEGIN            str := CONCAT(str, chr(tipBufPtr^[indexL]));            indexL := indexL + 1;          END; { While }        IF (LENGTH(str) > 0) THEN InPtr^.Live_Time := NDDateStr2Real(str);        IF InPtr^.Live_Time <= 0 THEN          BEGIN			DisposePtr(Ptr(tipBufPtr));			theResult := badFileFormat;            exit(Read_a_Nuclear_Data_File);          END;        strLength[1] := 8;        BlockMove(@strLength, @str[0], 1);        REPEAT          BlockMove(@tipBufPtr^[indexL], @str[1], strLength[1]);          indexL := indexL + 1;        UNTIL str = 'Offset =';        indexL := indexL + strLength[1];        WHILE ((tipBufPtr^[indexL] = $20) OR (tipBufPtr^[indexL] = $09)) DO          indexL := indexL + 1; { jump over a run of spaces }        str := '';        WHILE NOT ((tipBufPtr^[indexL] = $20) OR (tipBufPtr^[indexL] = $09)) DO          BEGIN            str := CONCAT(str, chr(tipBufPtr^[indexL]));            indexL := indexL + 1;          END; { While }		  {***** this statement is bad *****}        IF ((LENGTH(str) > 0) {AND (counter = 0)}) THEN 		begin			RValue := str2num(str);			RValue := RValue * 100000.0;			IValue := rinttol(RValue);  {keep all of Offset}		end;        strLength[1] := 7;        BlockMove(@strLength, @str[0], 1);        REPEAT          BlockMove(@tipBufPtr^[indexL], @str[1], strLength[1]);          indexL := indexL + 1;        UNTIL str = 'Slope =';        indexL := indexL + strLength[1];        WHILE ((tipBufPtr^[indexL] = $20) OR (tipBufPtr^[indexL] = $09)) DO          indexL := indexL + 1; { jump over a run of spaces }        str := '';        WHILE NOT ((tipBufPtr^[indexL] = $20) OR (tipBufPtr^[indexL] = $09)) DO          BEGIN            str := CONCAT(str, chr(tipBufPtr^[indexL]));            indexL := indexL + 1;            IF indexL > FileSize THEN 			  begin			    exit(Read_a_Nuclear_Data_File);				theResult := badFileFormat;				DisposePtr(Ptr(tipBufPtr));			  end;          END; { While }		  		  begin			IF (LENGTH(str) > 0) THEN RValue := str2num(str);	{ Slope }			{"calibrating" a Nuc. Data spectrum must be done a little differently since		they only pass a calibration equation. }				InPtr^.Energy_Slope := 1.0;			InPtr^.Energy_Intercept := 0.0;			InPtr^.dE := RValue * 1000.0;	{ This takes care of the slope }			IValue := - rinttol(IValue/InPtr^.dE/100);	{ Intercept }			InPtr^.NDoffset := IValue;			{Numtostring(IValue, str1);			Debugstr(str1);}			{putmessage('Offset value in channels is ',str1,' Slope is ',str);}		  end;		          strLength[1] := 7;        BlockMove(@strLength, @str[0], 1);        REPEAT          BlockMove(@tipBufPtr^[indexL], @str[1], strLength[1]);          indexL := indexL + 1;        UNTIL str = 'Title =';        indexL := indexL + strLength[1];		        strLength[1] := 9;        BlockMove(@strLength, @str[0], 1);        REPEAT          BlockMove(@tipBufPtr^[indexL], @str[1], strLength[1]);          indexL := indexL + 1;        UNTIL str = 'Voltage =';        indexL := indexL + strLength[1];        WHILE ((tipBufPtr^[indexL] = $20) OR (tipBufPtr^[indexL] = $09)) DO          indexL := indexL + 1; { jump over a run of spaces }        str := '';        WHILE NOT ((tipBufPtr^[indexL] = $20) OR (tipBufPtr^[indexL] = $09)) DO          BEGIN            str := CONCAT(str, chr(tipBufPtr^[indexL]));            indexL := indexL + 1;          END; { While }        IF (LENGTH(str) > 0) THEN InPtr^.kV := str2num(str);        jj := 0;        REPEAT          jj := jj + 1;        UNTIL tipBufPtr^[indexL + jj] = 13; {measure the length of rest of the line }        strLength[1] := jj - 1;        BlockMove(@strLength, @str[0], 1);        BlockMove(@tipBufPtr^[indexL], @str[1], strLength[1]);        strLength[1] := 2; {¥¥¥¥¥¥Jump to the beginning of the spectrum}        BlockMove(@strLength, @str[0], 1);        REPEAT          BlockMove(@tipBufPtr^[indexL], @str[1], strLength[1]);          indexL := indexL + 1;        UNTIL str = '1:';        indexL := indexL + strLength[1] + 1;        jj := 1; { jj will be the channel number }        REPEAT {¥¥¥¥¥ This REPEAT part reads in the spectrum ¥¥¥¥¥}          str := ''; {¥¥¥¥¥ This fragment reads a channel ¥¥¥¥¥}          WHILE ((tipBufPtr^[indexL] = $20 {sp} ) OR (tipBufPtr^[indexL] = $09 {tab} )) DO            indexL := indexL + 1; { jump over a run of spaces/tabs }          WHILE ((tipBufPtr^[indexL] <> $20 {sp} ) AND (tipBufPtr^[indexL] <> $09 {tab} )) AND (tipBufPtr^[indexL] <> $0D {cr} ) DO            BEGIN              str := CONCAT(str, chr(tipBufPtr^[indexL]));              indexL := indexL + 1;              IF tipBufPtr^[indexL] = $0D {cr} THEN Car_Ret := true;            END; { While }          IF LENGTH(str) > 0 THEN            BEGIN              InPtr^.Spec_cts[jj] := str2num(str);              jj := jj + 1;            END;          indexL := indexL + 1;          IF tipBufPtr^[indexL] = $0D {cr} THEN Car_Ret := true;          IF Car_Ret THEN            BEGIN              strLength[1] := 1; {¥¥¥¥¥¥Jump to the next line and move past ":"}              BlockMove(@strLength, @str[0], 1);              REPEAT                BlockMove(@tipBufPtr^[indexL], @str[1], strLength[1]);                indexL := indexL + 1;              UNTIL str = ':';              indexL := indexL + 2;              Car_Ret := false;            END;            IF indexL > FileSize THEN 			  begin				DisposePtr(Ptr(tipBufPtr));				theResult := badFileFormat;				exit(Read_a_Nuclear_Data_File);			  end;        UNTIL jj >= InPtr^.Number_of_Channels; {¥¥¥¥¥}		DisposePtr(Ptr(tipBufPtr));		InPtr^.LastChannel := InPtr^.Number_of_Channels;		theResult := noErr;	  	END;	{ Read_a_Nuclear_Data_File }{*****************************************************************************}FUNCTION Str2Num(s: Str255): Real;   { Pascal implementation of Str2Num (fp.p: Str2Dec, Dec2Str) }VAR	aDecimal		: Decimal;	aCStr			: ConstCStringPtr;	anIndex			: Integer;	aValidPrefix	: Integer; { ignore }BEGIN	aCStr := P2CStr(@s);	anIndex := 0;	str2dec( aCStr, anIndex, aDecimal, aValidPrefix );	Str2Num := dec2num( aDecimal );END;END.