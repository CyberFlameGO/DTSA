UNIT wPGT_Prism_Plug;INTERFACEUSES	Types, QuickDraw, Memory, fp, StandardFile, GestaltEqu, Errors, Files,	TextUtils, {PascalA4,} FilePlugIns;const		__procinfo : longint = $3F80;{$Main}PROCEDURE	ENTRYPOINT(message:Integer; VAR InPtr:IOPlugPtr; VAR theResult:OSerr);IMPLEMENTATION{$IFC NOT POWERPC}uses PascalA4;{$ENDC}PROCEDURE wPGT_Prism(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);FORWARD;PROCEDURE DoAbout(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);FORWARD;PROCEDURE DoOpen(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);FORWARD;PROCEDURE DoRead(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);FORWARD;{FUNCTION	Str2Num(s: Str255): Real;FORWARD;}PROCEDURE 	ENTRYPOINT{(message:Integer; VAR InPtr:IOPlugPtr; VAR theResult:OSErr)};		{ Main dispatching routine.  Initializes and sets up the global variables,	}		{		and performs the operation specified by the message. 				}VAR	firstTime	: BOOLEAN;	OldA4		: Longint;BEGIN{$IFC NOT POWERPC}	oldA4 := SetCurrentA4();	RememberA4();{$ENDC}	theResult:=noErr;	firstTime:=(InPtr=NIL);					{ See if this is the first time called }	IF firstTime THEN BEGIN						{ If so, allocate and initialize a data area }		InPtr:= IOPlugPtr(NewPtrClear(sizeof(IOPlug)));		IF (InPtr=NIL) THEN BEGIN			debugstr('memFullErr');			theResult:=memFullErr;{$IFC NOT POWERPC}	oldA4 := SetA4(oldA4);{$ENDC}			EXIT(ENTRYPOINT);		END;				END;		CASE message OF					{ Perform the requested operation }		fileAbout		:DoAbout(InPtr, theResult);		ImpFile			:DoRead(InPtr, theResult);		ExpFile			:wPGT_Prism(InPtr, theResult);		OpenInPlug		:DoOpen(InPtr, theResult);		OpenExPlug		:DoOpen(InPtr, theResult);		END; {CASE message}		{$IFC NOT POWERPC}	oldA4 := SetA4(oldA4);{$ENDC}END;PROCEDURE DoAbout(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);	Begin	End;	PROCEDURE DoOpen(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);	Begin		InPtr^.PlugInName:='Write PGT Prism';		{Debugstr('Inside of wMSA_Format_R - Do Open');}		theResult := noErr;	End;	PROCEDURE DoRead(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);	Begin	End;PROCEDURE wPGT_Prism(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);          VAR      index, nn, jj, kk             : integer;      FileSize                      : longint;      Refnum                     	: integer;      indexL, posit                 : longint;      bytecount                     : longint;      str, str1, str2               : str255;	  num_channels					: real;	  err	                        : OSErr;	  IValue						: longint;	  Version, Rvalue, columns      : real;  	BEGIN		Refnum := InPtr^.rd_refNum;		{Debugstr('Inside of MSA_Format');}		str := 'number of channels:     1920';		str := StringOf(str, {InPtr^.Number_of_Channels,}chr(13),chr(13));		IValue := length(str);		err := FSWrite(Refnum,IValue,@str[1]);							str := 'label: ';		str := CONCAT(str,InPtr^.Specimen_Comment_Field,chr(13));		IValue := length(str);		err := FSWrite(Refnum,IValue,@str[1]);				str := 'ev per channel:   ';		str := StringOf(str, InPtr^.dE,chr(13),chr(13));		IValue := length(str);		err := FSWrite(Refnum,IValue,@str[1]);				str := concat('start ev:    0.000',chr(13),chr(13));		IValue := length(str);		err := FSWrite(Refnum,IValue,@str[1]);				str := 'end ev: ';		str := StringOf(str,round(InPtr^.kV)*1000:9:3,chr(13),chr(13));		IValue := length(str);		err := FSWrite(Refnum,IValue,@str[1]);				str := 'live time: ';		str := StringOf(str,InPtr^.Live_Time:7:3,chr(13),chr(13));		IValue := length(str);		err := FSWrite(Refnum,IValue,@str[1]);				str := concat('background subtracted: not subtracted',chr(13),chr(13));		IValue := length(str);		err := FSWrite(Refnum,IValue,@str[1]);				str := concat('number of elements:        0',chr(13),chr(13));		IValue := length(str);		err := FSWrite(Refnum,IValue,@str[1]);				str := concat('element list: ',chr(13),chr(13));		IValue := length(str);		err := FSWrite(Refnum,IValue,@str[1]);				str := 'probe current:   ';		str := StringOf(str,InPtr^.Begin_Faraday:6:3,chr(13),chr(13));		IValue := length(str);		err := FSWrite(Refnum,IValue,@str[1]);				str := 'accelerating voltage:  ';		str := StringOf(str,InPtr^.kV:6:3,chr(13),chr(13));		IValue := length(str);		err := FSWrite(Refnum,IValue,@str[1]);				str := 'real time:  ';		str := StringOf(str,InPtr^.Real_Time:6:3,chr(13),chr(13));		IValue := length(str);		err := FSWrite(Refnum,IValue,@str[1]);				str := concat('dead time percent:    5.213',chr(13),chr(13));		IValue := length(str);		err := FSWrite(Refnum,IValue,@str[1]);				str := 'takeoff angle:   ';		str := StringOf(str,InPtr^.D_Elevation:6:3,chr(13),chr(13));		IValue := length(str);		err := FSWrite(Refnum,IValue,@str[1]);				str := 'tilt angle:   ';		str := StringOf(str,InPtr^.X_Tilt:6:3,chr(13),chr(13));		IValue := length(str);		err := FSWrite(Refnum,IValue,@str[1]);				str := concat('microscope: Microscope',chr(13),chr(13));		IValue := length(str);		err := FSWrite(Refnum,IValue,@str[1]);				str := concat('detector: PGT PRISM',chr(13),chr(13));		IValue := length(str);		err := FSWrite(Refnum,IValue,@str[1]);				str := concat('modified: original',chr(13),chr(13));		IValue := length(str);		err := FSWrite(Refnum,IValue,@str[1]);				str := concat('low end corrected: uncorrected',chr(13),chr(13));		IValue := length(str);		err := FSWrite(Refnum,IValue,@str[1]);				str := concat('detector type: silicon',chr(13),chr(13));		IValue := length(str);		err := FSWrite(Refnum,IValue,@str[1]);				str := concat('front end electronics: digital',chr(13),chr(13));		IValue := length(str);		err := FSWrite(Refnum,IValue,@str[1]);				str := concat('(digital) collection mode:   quant',chr(13),chr(13));		IValue := length(str);		err := FSWrite(Refnum,IValue,@str[1]);				str := concat('origin of data: collected data',chr(13),chr(13));		IValue := length(str);		err := FSWrite(Refnum,IValue,@str[1]);				str := concat('system standard counts:    0.000',chr(13),chr(13));		IValue := length(str);		err := FSWrite(Refnum,IValue,@str[1]);				str := concat('scaling factor:    0.000',chr(13),chr(13));		IValue := length(str);		err := FSWrite(Refnum,IValue,@str[1]);				str := concat('resolution:    0.000',chr(13),chr(13));		IValue := length(str);		err := FSWrite(Refnum,IValue,@str[1]);				str := concat('number of quant elements:        0',chr(13));		str1 := concat(str,chr(13),'No quant data available for this spectrum.',chr(13),chr(13));		IValue := length(str);		err := FSWrite(Refnum,IValue,@str[1]);				str := concat('date collected: Tue Jan 17 14:58:44 1995',chr(13),chr(13));		IValue := length(str);		err := FSWrite(Refnum,IValue,@str[1]);				str := concat('density:    0.000',chr(13),chr(13));		IValue := length(str);		err := FSWrite(Refnum,IValue,@str[1]);				str := concat('thickness:    0.000',chr(13),chr(13));		IValue := length(str);		err := FSWrite(Refnum,IValue,@str[1]);				str := concat('axis label: Energy (keV)',chr(13),chr(13));		IValue := length(str);		err := FSWrite(Refnum,IValue,@str[1]);				str := concat('detector window: not available',chr(13),chr(13));		IValue := length(str);		err := FSWrite(Refnum,IValue,@str[1]);				str := 'channel counts:';		str := CONCAT(str,chr(13));		IValue := length(str);		err := FSWrite(Refnum,IValue,@str[1]);		{ееееееееееееееее}          jj := 1; { jj will be the channel number }          num_channels := InPtr^.Number_of_Channels;          REPEAT {еееее This part writes the spectrum еееее}            str := '';          	  str := StringOf(round(InPtr^.Spec_cts[jj]), chr(13));          	  jj := jj + 1;			IValue := length(str);			err := FSWrite(Refnum,IValue,@str[1]);          UNTIL (jj > num_channels); {еееее This part read in the spectrum еееее}      END; { PGT Format }END.