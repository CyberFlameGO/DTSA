{[j=30/55,:+,u+,r+,o=120,k+,n+,#+,v+,q+,b+]}{[f-]}{*********************************} UNIT CliffLor ;{*********************************}{**********************************} INTERFACE {**********************************} USES  QuickDraw, QuickdrawText, Types, OSUtils, ToolUtils, Timer, Errors, Menus, Files, Lists, Memory, Dialogs, Events,  TextUtils, Packages, Printing, StandardFile, fenv, fp, SegLoad, Retrace, Spectrum_Structures, Controls, Windows,   Finder, Declarations, INITIALIZE, Xray_Energies, Global_Functions, Utilities, SANDIA,  CurveFit, Simplexer,  Linear_Least_Squares, Physics, xray;{[f+]}(* Notes to me:	C-L is good if x-ray absorption < 3% relative.	Proc should include tests to see if thin film criteria hold: 1)the absorption	correction factor should be >0.97 and <1.03. 2) the ratio of flouresence I /	primary intensity <= 5%.*) 	PROCEDURE D_DialCL;	PROCEDURE Do_CL_Quant;    PROCEDURE WriteToCL;	{called after any fit if Cl_Active}    PROCEDURE CLKFile;	{show contents of K factor file}	        PROCEDURE CLResults(only_one:boolean);	{called in menus and in DoAFit in SiLiWin}    PROCEDURE CLKfact;    PROCEDURE CLHelp;	PROCEDURE CLOutput;	{******************************} IMPLEMENTATION {**********************************}(* From Base_stuff...			Report_oxides	: boolean;			Ox_by_Stoic		: boolean;*)	(*	CL_OutPut^^ has to include structures for CL_BaseStuff and CL_LineStuff so that    any active ..._Stuff for quant is not destroyed if the user looks at the results	of an old quant.*)	TYPE		KFile_rec = record			Kfitproc	: string[2];			Kkv			: real;	  		KDetector	: Detector_Rec;		end;		KExptPtr	= ^KFile_rec;		KExptHdl	= ^KExptPtr;				ZInfo_rec = record		    K			:	real;	{k ratio:for a_info, kab; for b info, kbZ; b is z or Z}			Z			:	integer;			line		:	STRING[1];			loline_ev	:	real; 			hiLine_ev	:	real; 			fit_roi_lo	:	real; {in ev}			Fit_roi_hi	:	real;		end;				KFact_rec = record		  KaZ							: real;	(* running avg of(Ka/Kb)/(Kb/KZ) *)		  avg							: boolean;		  NuminAvg						: integer;		  Ksum							: real; (* ·(Ka/Kb)/(Kb/KZ);for Z, ·wtf/cnts per amp-sec *)		  Ksqsm							: real; (* ·[(Ka/Kb)/(Kb/KZ)**2] *)		  vari							: real;	{ of KaZ}		  SpecFilename					: str_25; {useful for one value or batch only}		  RefFileName                   : fnamestr;{useful for one value or batch only}		  {the quant info in x_info is there for code convenience}		  a_info                 		: ZInfo_rec;{K is Kab where b is z or Z(then K=KaZ)}		  b_info                 		: ZInfo_rec;{K is KbZ for element b where b is z or Z}		  counts						: real; {per amp sec}		  wtf						    : real; { could be different for each val in the avg}		end;		KFactPtr	= ^KFact_rec;		KFactHdl	= ^KFactPtr;		VAR		aKsum							: array [1..maxnumpks] of real {double_t};		aKsqsm							: array [1..maxnumpks] of real {double_t};		acntsum							: array [1..maxnumpks] of real;		alist                           : LinFitIntArray;		covar		                    : LinFitCovArray;		solution         			    : LinFitExtArray;		New_Setup : ARRAY [1..MaxNumPks] OF ClHdl; {50 hdls for 26 byte recs}		new_base : ClBsHdl;		kbase	 	: real;		Kfile_Data	: KExptHdl;		Ka_data, Kb_data, KZ_Data  : KFactHdl;	    showname	:fnamestr;		show_vol,Valid_peak, FilesUsed	:integer;        errcode		:integer;		found, show_one : boolean;		{quant_work was made a global for ZAF}		bytecount		: Longint;			List_Z_CL                : ListHandle;		CellRect, ListRect: Rect;		dataBounds : Rect;		cSize : Point;		theCell,newCell: cell;   		Procedure Refresh_CLDialog;		    const				I_OK = 1;			var 				otherRect:Rect;				DType: integer;				DItem : Handle;			begin 				SetPort(CLPicker);				GetDialogItem(CLPicker,I_OK,DType,DItem,otherRect);				PenSize(3, 3);				InsetRect(otherRect, -4, -4);				FrameRoundRect(otherRect, 16, 16); 				PenSize(1, 1);                				InsetRect(CellRect, - 1, - 1);				FrameRect(CellRect);                InsetRect(CellRect, 1, 1);		   end; 	{procedure Refresh_Dialog;...}	PROCEDURE CLoutput;	VAR		mytype : OsType;		myprompt : str255;		bytecount   		: Longint;		err,errcode	 : integer;		theEvent : EventRecord;		Cl_Spec : FSSpec;	BEGIN	{PROCEDURE CLoutput;...called in Menus only}	   Do_CLOutput := true;	{...global for D_Results_Options} 	   binary_choice := FALSE; { ...global so 'name the DTSA file' is not active}	   REPEAT	{...UNTIL (not Do_CLOutput);}		 mytype := 'MCAo';		 myprompt := 'CL file for output?';		 REPEAT		 UNTIL (GetFileName(Hall_name, mytype, mytype, myprompt) = True) OR 					 (File_Cancel_Button = False);		 If (File_Cancel_Button) then		 Begin		   Hall_vol := In_VolRefNum; {working dir refnum}		   Cl_Spec := In_Spec;{In_Spec from GetFileName: primarily to get cl file		   				         creation date in WriteFitResults}		   D_Results_Options;	{ in CurveFit; defines Hall_name and Hall_vol  }			   If  Do_CLOutput {false if we Cancel from D_Results_Options} Then		   Begin			errCode := FSpOpenDF(CL_Spec,fsRdPerm, FileRefNum);if errcode <> noerr then putmessage('The CL binary file failed to open.','','','');			if errcode <> noerr then 			   errCode := FSOpen_err(Hall_Name,Hall_Vol, FileRefNum,'');			if errcode = noerr then			begin			  if (CL_Output = NIL) then			  begin				ReserveMem(sizeof(CL_outstuff));				if MemError = memFullErr then Bag_the_Program;				CL_Output := CLOutHdl(NewHandle(sizeof(CL_outstuff)));				HLock(Handle(CL_Output));			  end;			  bytecount := sizeof(CL_BaseStuff);			  errcode := FSRead(FileRefNum, bytecount, @CL_Output^^);			  bytecount := CL_Output^^.BaseInfo.number_of_peaks * sizeof(CL_LineStuff);			  {...LineInfo for the base or Ox if by stoic is never in binary}			  errcode := FSRead(FileRefNum, bytecount, @CL_Output^^.LineInfo);			  MCA_ResultsName := '';			  {CL_Output^^.ResultsName = 57 bytes; MCA_ResultsName = 63...}			  bytecount:= sizeof(fnamestr);{63 bytes: integer,String[57],longint}			  errcode := FSRead(FileRefNum,bytecount,@CL_Output^^.ResultsVNum);			  {...previous also gets CL_Output^^.ResultsName and DirId}			  MCA_ResultsName := '';			  blockmove(@CL_Output^^.ResultsName,@MCA_ResultsName,sizeof(CL_Output^^.ResultsName));			  MCA_ResultsDirID := CL_Output^^.ResultsDirId;			  MCA_ResultsVNum := CL_Output^^.ResultsVNum;			  MCA_Results_VolNum := Hall_Vol;	{good guess; there is no cl_vol, we use Hall_vol}			  {for the open call...}			  blockmove(@CL_Output^^.ResultsName,@MCAResult_Spec.Name,sizeof(CL_Output^^.ResultsName));			  MCAResult_Spec.parID := CL_Output^^.ResultsDirId;			  MCAResult_Spec.VrefNum := CL_Output^^.ResultsVNum;			  Repeat			  			   err := FSOpen(MCA_ResultsName,MCA_Results_VolNum, Hold_RefNum);			   if err <> noerr then			   begin	{try MCA_ResultsVNum as a WD...}			     err := FSOpen(MCA_ResultsName,MCA_ResultsVNum, Hold_RefNum);				 If err = noerr then MCA_Results_VolNum := MCA_ResultsVNum;			   end;			   if err <> noerr then err := FSpOpenDF(MCAResult_Spec,fsRdPerm, Hold_RefNum);			{	err := HOpenDF(MCA_ResultsVNum,MCA_ResultsDirID,MCA_ResultsName,FSRdPerm,Hold_RefNum);}(*if err = noerr then putmessage('HOpenDF worked for MCA_Results',MCA_ResultsName,'leave it open for WriteFitResults','')else putmessage('HOpenDF FAILED for MCA_Results','','','');*)				if err <> noerr then				begin					if err = nsverr then					begin					   str := concat('I need the fit results file ',MCA_ResultsName,'.');					   Do_CLOutput := answermessage(str,'It`s on some other volume. If it is a floppy,',							   'load it, then click IT`s OK.','Otherwise, click IT`s NOT OK.'); 					   if Do_CLOutput then					   repeat						   Do_CLOutput := GetNextEvent(diskMask, theEvent);					   until Do_CLOutput;					end					else if err = BdNamerr then putmessage('Something is wrong with the filename',MCA_ResultsName,'I can`t open it.','') 					else if err = fnferr then putmessage('Have you deleted or moved the fit results file',MCA_ResultsName,'Please put it in the same folder with ', Hall_name) 					else					begin					   putmessage('Err opening',MCA_ResultsName,'Please examine it and','if it`s OK, try again.');					   err := fnferr					end;				end	{ if err <> noerr...}				else				begin	(*  putmessage('opened',MCA_ResultsName,'now close it to reopen in  WriteFitResults','');*)	(*12/1/95			  err := FSClose(Hold_RefNum);*)	{...close fit file so WriteFitResults can open it}				  If ((Plain_Boolean) or (Spread_Boolean))					then begin					  do_ascii := true;					  WriteFitResults; 	{make ascii files from old CL only}					  do_ascii := false;					end;				end;	{else...}			  Until  (err = fnferr) or (err = noerr) or (not Do_CLOutput); 			  err := FSClose(FileRefNum);	{...the CL file}			  err := FlushVol(NIL, Hall_vol);		   end	{ if errcode = noerr...}		   else putmessage('There was an error opening the CL file.','Try again.','','');		   		   if (CL_Output <> NIL) then	{this if test has correct boolean}			 H_UnLock_Dispose(Handle(CL_Output),'CL_Output xx');	       		  End;	{ If  Do_CLOutput...}	     End	{If (File_Cancel_Button)...}	     Else Do_CLOutput := false;       UNTIL (not Do_CLOutput);	 	 MCA_File_Boolean := False;	 Plain_Boolean := false;	 Spread_Boolean := false; 	 Binary_Choice := true;	{ this must be the default condition }    				 	END;	{PROCEDURE CLOutput}        PROCEDURE CLHelp;    VAR      tempRect                     : Rect;                  offset                       : integer;	  Left                         : integer;	  Top                          : integer;      n                            : integer;	  G_Help                       : DialogPtr;      itemHit                      : integer;      DType                         : Integer;      DItem                         : Handle;	  ExitDialog                    : Boolean; 	      CONST      G_Accept                      = 1;	  BEGIN                                             G_Help := GetNewDialog(433, NIL, POINTER( - 1));ShowWindow(G_Help);SelectWindow(G_Help);SetPort(G_Help);OutlineButton(G_Help, 1, 16); { outline the OK button }SetFont('Monaco', 9, []);offset := 12;Left := 5;Top := 15;		   n := 0;	  moveto(Left,Top);str := 'The CL type quantitation procedure is designed for thin specimens for which absorption and fluorescence ';DrawString(str);	  n := n+1; moveto(Left,Top + n*offset);str := 'are negligible. For each element the specimen thickness at which absorption becomes >= 3% relative';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'is reported by the quantitation procedure. A K factor,the factor that scales the ratio of concentration';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'of element A to concentration of element B to the ratio of peak area of element A to peak area of';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'element B, is required for each element in the unknown. K factors cannot be entered by hand. To make ';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'K factors you must acquire statistically good spectra from standards and produce a Fit Results file';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'with peak areas obtained by either Simplex or LLSQ fitting. K factors are calculated from the values';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'in the fit results. The fit results file may have the fit to only one spectrum, fits to n similar ';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'spectra (batch fit), or fits to a number of different spectra (Do A Fit,Add a Fit). The routine';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'for caculating K factors will average values. All K factors for a set of conditions (element B, kV,';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'detector and fitting procedure) may be stored in one K factor file. K factors may be used to quantitate';  DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'only spectra that satisfy the same conditions. With LLSQ fitting the lines used to calculate a K factor';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'and those fit for the unknown must be the same. With Simplex fitting the lines used to calculate a';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'K factor must be among those fit for the unknown. The program should flag any discrepencies. Remember to';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'check the standard box in the composition dialog of the spectrum header before fitting a std spectrum.';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'Currently a K factor is not calculated by interpolation. However you may obtain a K factor by fitting ';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'a generated spectrum. First acquire spectra with good statistics with families of lines close to those ';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'for the element family requiring a K factor. If you are able to supply detector parameters, etc. which';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'allow you to generate spectra that match the acquired data, use those parameters to generate a standard';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'spectrum for the element requiring a K factor. Proceed as if the spectrum were acquired. ';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'You can perform a CL quant procedure on either a file of Simplex or MLLSQ fitting results, the spectrum';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'displayed in WORK, or the file of spectra from which WORK was read. To perform a CL quant, select Quant';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'from the CL Menu.(You selected Help from that menu to get here.) For Quant instructions select Help.';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'To examine a saved binary file of CL quantitation results, select Show Quant Results from the CL Menu. ';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'This function makes an Ascii file with the name (binary file)_Ascii and displays the data.';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'You can make other ASCii files with information from binary CL files: select Ascii Output from the';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'CL Menu. The file selection dialog is displayed listing only binary CL files; select one.';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'Pick the output files you want to make from the next dialog. The files are made when you';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'click OK. Pick another binary file or Cancel the file selection dialog.';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'The Ascii files can be opened from the appropriate applications. ';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := ' ';DrawString(str); n := n+1; moveto(Left,Top + n*offset); REPEAT  ModalDialog(NIL, itemHit);  GetDialogItem(G_Help, itemHit, DType, DItem, tempRect);  IF (itemHit = G_Accept) THEN	BEGIN	  ExitDialog := True;	END;UNTIL ExitDialog;		            DisposeDialog(G_Help);			BeginUpdate(BackPlane);			DrawAxesFull;			Update_Full;			EndUpdate(BackPlane);		    UpDate_SiLi_Window(SiLiWindow) ;		END;     {End of CLHelp procedure}	 Function myFilter(theDialog:DialogPtr;	 					var theEvent:EventRecord; var itemHit:integer): boolean;			{ ¥¥¥¥¥  Do NOT put this function into the calling procedure, 					 or the address will get trashed when needed ¥¥¥¥¥¥ }										var				DataLen: Integer;				thePt: point;				list_str : string[2];		begin	{ Function myFilter }		dataLen := 2;		list_str := '12';		myFilter := FALSE;{...tells  ModalDialog to actually handle the event}			if (theEvent.what = MouseDown) then    {Only do on a mouse click}			begin				thePt := theEvent.where;     {Get the point where the mouse was clicked}				GlobalToLocal(thePt);	{makes thePt have graph port coords where										 CLPicker defines the graph port}				if PtInRect(thePt, ListRect) then				begin				   DoubleClick := LClick(thePt, theEvent.modifiers, List_Z_CL);				  {was it in the cell part of item 5?...if so, return 11 as item_hit so				   if the elevator bar was hit no ¥ is added anywhere.}				   if PtInRect(thePt, CellRect) then				   begin					  List_Z_CL^^.lastClick := LLastClick(List_Z_CL);					  	{...gets coords of last cell clicked}					  LGetCell(@list_str[1], dataLen, List_Z_CL^^.lastClick, List_Z_CL);					  {StringToNum(list_str, numpk);					   ItemHit := integer(numpk + 10);}	{10 items showing in dialog list}					  ItemHit := 11;	{10 items in dialog list}					  myFilter := TRUE;				   end;	{ if PtInRect(thePt, CellRect)...}					{ else ItemHit := 5;} 					{myFilter := TRUE;}				end;   {End of PtInRect}			end;	{if (theEvent.what = MouseDown)...}		end;	{Function myFilter;}       PROCEDURE CLKFile;	{Called from Menus...shows K file contents}		  const			   I_OK = 1;			   I_Cancel = 2;			   I_FileTxt = 3;			   I_ZText = 4;			   I_List = 5; 			   I_DeleteK = 6;			   I_Ascii = 7;	  VAR        K_Name, KPlainName:fnamestr;        fndrInfo             : FInfo;		mytype : OsType;		myprompt,str1,str2,str,sTemp : str255;		errcode,copynum, k_num, K_VolNum : integer;		bytecount	   		: Longint;		DType, strlen : Integer;		itemHit,rcount,temp, ndelete, lastcell : integer;		rdcount : Longint;		DItem : Handle;		CItem : controlhandle;        pkdchars:packed array [1..255] of char;		ExitDialog, Cancel, make_Ascii : boolean;	BEGIN	   make_Ascii := false;	   ndelete := 0;	   mytype := 'MCAK';	   The_File_name := 'K Filename';	   myprompt := 'K factor file to show? ';		  {GetFileName sets the Vol to that chosen in the file menu }	   Repeat	   Until (GetFileName(The_File_Name, mytype, mytype, myprompt) = True) OR 			 (File_Cancel_Button = False);	   IF (File_Cancel_Button) THEN 	{ a file was picked }		begin		 K_VolNum := In_volrefnum;		 K_name := The_File_Name;		 errCode := FSOpen(K_name,K_VolNum,k_num);		 if errcode = noerr then		 begin		   Kfile_Data:=KExptHdl(NewHandle(sizeof(KFile_rec)));		   MoveHHi(Handle(Kfile_Data));		   HLock(Handle(Kfile_Data));			   		   Ka_data := KFactHdl(NewHandle(sizeof(KFact_rec)));		   MoveHHi(Handle(Ka_data));		   HLock(Handle(Ka_data));				CLPicker := GetNewDialog(1943, nil,  Pointer(-1) );			ShowWindow(CLPicker);	{makes it visible}			SelectWindow(CLPicker); {makes it the active window & front window, hilights}			SetPort(CLPicker);		{makes this the port for drawing}					   bytecount := sizeof(KFile_rec);		   err := FSRead(k_num, bytecount, @Kfile_Data^^);{expt stuff}		   str := ' ';		   if Kfile_Data^^.Kfitproc = 'ML' then str := ' ML ' else str := ' Simplex ';		   if Kfile_Data^^.KDetector.spec = EELS then str1 := 'EELS'		   else if Kfile_Data^^.KDetector.spec = WDS then str1 := 'WDS'		   else  str1 := 'EDS';		   numtostring(Kfile_Data^^.KDetector.ID,str2);		   str := concat(K_name,': K factors to quant',str,'fit results; data from ',str1,' detector #',str2);		   realtostring(Kfile_Data^^.Kkv,4,1,str1);		   str1 := concat(' acquired at ',str1,' KV.');		   sTemp := CONCAT(str, str1);		  { textface([italic]);}		   GetDialogItem(CLPicker, I_FileTxt, DType, DItem, tempRect); {Get the item handle}		   SetDialogItemText(DItem, sTemp);		   		   bytecount := sizeof(KFact_rec);		   err := FSRead(k_num, bytecount, @Ka_data^^);{first rec is base element Z}		   str := ' ';		   realtostring(Ka_data^^.a_info.loline_ev,4,1,str1);		   realtostring(Ka_data^^.a_info.hiLine_ev,4,1,str2);		   str := concat('K factors are relative to ',a^.sym[Ka_data^^.a_info.Z],Ka_data^^.a_info.Line,', lines from ',str1,' ev to ',str2,' ev;');		   sTemp := str;		   GetDialogItem(CLPicker, I_ZText, DType, DItem, tempRect); {Get the item handle}		   SetDialogItemText(DItem, sTemp);		  { textface([]);}						GetDialogItem(CLPicker,I_List,DType,DItem,ListRect);			CellRect := ListRect;			{...this ListRect is the rect that includes the list AND scroll bars}			{make CellRect, the RView, exclude the scroll bars};			CellRect.Right := CellRect.Right -15;				        Refresh_CLDialog;						SetRect(dataBounds, 0, 0, 1, 0);{the bounds allocated are col0,row0 to col1,row0:											 rect:left,top,right,bottom}  			cSize.h := CellRect.Right - CellRect.Left;			cSize.v := 16;			List_Z_CL:=  LNew(CellRect,dataBounds,cSize,0,CLPicker,TRUE,FALSE,FALSE,TRUE);						List_Z_CL^^.selFlags := lOnlyOne + lNoNilHilite;			LSetDrawingMode(false, List_Z_CL);			newCell.v := 0; {row}			newCell.h := 0; {col}			rcount := -1;			bytecount := sizeof(KFact_rec);			REPEAT			  err := FSRead(k_num, bytecount, @Ka_data^^);{first rec is base element}			  If (err = noerr) then			  begin				str := ' ';				realtostring(Ka_data^^.a_info.loline_ev,4,0,str1);				realtostring(Ka_data^^.a_info.hiLine_ev,4,0,str2);				str := concat(a^.sym[Ka_data^^.a_info.Z],Ka_data^^.a_info.Line,', lines from ',str1,' ev to ',str2,' ev: ');				realtostring(Ka_data^^.KaZ,4,3,str1);				realtostring(sqrt(Ka_data^^.vari),5,4,str2);							str := concat(str,str1,'±',str2);				rcount := LAddRow(1, rcount+1, List_Z_CL);	 				LSetCell(@Str[1], length(Str),newCell,List_Z_CL);				LDraw(newCell, List_Z_CL);				newCell.v := newCell.v + 1;	{next cell}			  end;			UNTIL (err = EOFErr);		    err := FSClose(k_num);						ChangeCursor(ArrowC);			lastcell := rcount;		    LAutoScroll(List_Z_CL);			LSetDrawingMode(TRUE, List_Z_CL);			thecell.v := 0;			LUpdate(CLPicker^.visRgn,List_Z_CL);	{should redraw everything}						ExitDialog := FALSE;			itemhit:=0;			Cancel := False;	{¥¥¥¥¥}	REPEAT	{ UNTIL (ExitDialog)}				  ModalDialog(NewModalFilterProc(@myFilter),itemHit);			  			  IF (ItemHit = I_Cancel) then {don't delete anything}			  begin			  	cancel := TRUE;				ExitDialog := TRUE;			  end;			  			  IF (ItemHit = I_OK) then			  BEGIN					ExitDialog := TRUE; {delete the ¥ entries}			  END;			  			  			  IF (ItemHit = I_Ascii) then			  BEGIN					GetDialogItem(CLPicker, I_Ascii, DType, DItem, tempRect); 					CItem := ControlHandle(DItem); 					temp := GetControlValue(CItem); 					SetControlValue(CItem, (temp + 1) MOD 2);   			  END;			  IF (ItemHit = 11) THEN			  BEGIN			   str  := '';			   str1  := '';			   strlen := 255;			   LGetCell(@pkdchars,strlen,List_Z_CL^^.lastClick,List_Z_CL);			   {selectedCell := List_Z_CL^^.lastClick;}				  if (pkdchars[strlen] = '¥') then				  begin {Single click...turn off}					 strlen := strlen - 1; {if there was ¥ it is gone}					 ndelete := ndelete - 1;					 {write pkdchars back with out any ¥...}					  LSetCell(@pkdchars,strlen,List_Z_CL^^.lastClick,List_Z_CL);				  end				  else begin	{new choice...turn on the choice}					str1 := '¥';					ndelete := ndelete + 1;					LAddToCell(@str1[1],length(str1),List_Z_CL^^.lastClick,List_Z_CL);					LUpdate(CLPicker^.visRgn,List_Z_CL);	{should redraw everything}				  end;			  				  Refresh_CLDialog;			   LUpdate(CLPicker^.visRgn,List_Z_CL);	{should redraw everything} 			   END;	{IF (ItemHit = 11)...}			   			  IF (ItemHit = I_List) THEN {in elevator bar only}			  BEGIN			   LUpdate(CLPicker^.visRgn,List_Z_CL);	{should redraw everything}			  END;	{ ELSE BEGIN...}				   UNTIL ExitDialog;		   		   IF Cancel then (*putmessage('cancel','','','')*)		   ELSE BEGIN	{ OK Exit}		   	 GetDialogItem(CLPicker, I_Ascii, DType, DItem, tempRect); 			 CItem := ControlHandle(DItem); 			 temp := GetControlValue(CItem); 			 IF (temp = 1) then make_Ascii := true;		     If (make_Ascii or (ndelete > 0)) then begin			   err := FSOpen(K_name,K_VolNum,k_num);			   bytecount := sizeof(KFile_rec);			   err := FSRead(k_num, bytecount, @Kfile_Data^^);			   bytecount := sizeof(KFact_rec);			   err := FSRead(k_num, bytecount, @Ka_data^^);			   			   If (make_Ascii) then begin {write file and Z data to ascii}					KPlainName := concat(K_name,'_ASCii');					Rewrite(Plain, KPlainName);	{ plain:text}					Rewrite(Plain);							fndrInfo.fdcreator := 'MSWD';					fndrInfo.fdtype := 'TEXT';					fndrInfo.fdFlags := 0 {100};                        					errCode := setfinfo(KPlainName, 0, fndrInfo);					 Str := CONCAT('           Cliff-Lorimer K factor file: ', K_name);					 writeln(Plain, Str);					 str := ' ';					 writeln(Plain, Str);					 if Kfile_Data^^.Kfitproc = 'ML' then str := ' ML ' else str := ' Simplex ';					 if Kfile_Data^^.KDetector.spec = EELS then str1 := 'EELS'					 else if Kfile_Data^^.KDetector.spec = WDS then str1 := 'WDS'					 else  str1 := 'EDS';					 str := concat(' K factors to quant',str,'fit results from ',str1,' detector #');					 numtostring(Kfile_Data^^.KDetector.ID,str1);					 str := concat(str,str1,' at ');					 realtostring(Kfile_Data^^.Kkv,4,1,str1);					 str := concat(str,str1,' KV. ');					 writeln(Plain, Str);					 str := ' ';					 realtostring(Ka_data^^.a_info.loline_ev,4,0,str1);					 realtostring(Ka_data^^.a_info.hiLine_ev,4,0,str2);					 str := concat(' K factors are relative to ',a^.sym[Ka_data^^.a_info.Z],Ka_data^^.a_info.Line,' lines from ',str1,' ev to ',str2,' ev.');					 writeln(Plain, Str);					 str1 := '';					 writeln(Plain, Str);					 str := '   Z      low line ev      high line ev    # averaged     KaZ     std dev ';  					 writeln(Plain, Str);					 str := '';					 {If no ks are deleted then write the Ascii...}					 If (ndelete = 0) then					 begin					   Repeat						   err := FSRead(k_num, bytecount, @Ka_data^^);						   if err = noerr then						   begin							 str := '  ';					         write(Plain, Str);							 with Ka_data^^,a_info do							  writeln(Plain, a^.sym[Z]:2,Line,loline_ev:14:1,hiLine_ev:18:1,NuminAvg:14,KaZ:14:4,sqrt(vari):10:4);				           end;					   Until (err = EOFErr); 					   errCode := FSClose(k_num);			   		 End;	{If (ndelete = 0)...write the Ascii...}			   End;	{If Make_ascii...}			   			   {if there are Ks to delete find them, delete them, write Ascii..}			   If (ndelete > 0) then			   begin				rdcount := 0; {...gets increased at end of REPEAT}				The_File_Name := concat(K_name,'_copy');				err := create(The_File_Name,K_VolNum, 'DTSA', 'MCAK');				err := FSOpen(The_File_Name,K_VolNum,copynum);				{copy the file and base data...}				bytecount := sizeof(KFile_rec);				err := FSWrite(copynum, bytecount, @Kfile_Data^^);				bytecount :=sizeof(KFact_rec);				err := FSWrite(copynum, bytecount, @Ka_data^^);{Z data}				{copy all data not marked for delete...}				theCell.v := -1;				REPEAT		{ UNTIL theCell.v > lastcell;}				{read thru all cells looking for ¥'s. Delete the marked data...}				  theCell.v := theCell.v + 1;	{next cell}				  err := FSRead(k_num, bytecount, @Ka_data^^);				  strlen := 255;				  LGetCell(@pkdchars,strlen,theCell,List_Z_CL);{returns true strlen}				  IF (pkdchars[strlen] <> '¥') then 					err := FSWrite(copynum, bytecount, @Ka_data^^);					if Make_ascii then					begin					  str := '  ';					  write(Plain, Str);					  with Ka_data^^,a_info do					   writeln(Plain, a^.sym[Z]:2,Line,loline_ev:14:1,hiLine_ev:16:1,NuminAvg:14,KaZ:12:4,sqrt(vari):10:4);					end;	{if Make_ascii then...}				UNTIL (theCell.v = lastcell){ or (err = eoferr)};			    err := FSClose(k_num);				err := FSDelete(K_name,K_VolNum);				err := FSClose(copyNum);				err := Rename(The_File_Name,K_VolNum,K_name);               End;	 {If ndelete > 0 then begin...}			   if Make_ascii then Close(Plain);			 End;		{If (make_Ascii or (ndelete > 0)...}			   END;		{If Cancel...ELSE BEGIN...}			   LDispose(List_Z_CL);		   CellRect := CLPicker^.portRect;		   DisposeDialog(CLPicker);		   FillWhiteSpace(CellRect);		   H_UnLock_Dispose(Handle(Kfile_Data),'Kfile_Data xx');		   H_UnLock_Dispose(Handle(Ka_data),'Ka_data xx');		 End	{if errcode = noerr...}		 Else putmessage('Sorry,',K_name,'failed to open.','');	  end;	{ IF (File_Cancel_Button)...}	END;	{    PROCEDURE CLKFile;	}    		PROCEDURE CLKfact;			  const		I_Ok = 1;		I_Cancel = 2;		I_Fit_File = 4;		I_New_File = 5;		I_Old_File = 6;		I_Manual = 8;		  VAR        Results_Name,K_Name	:fnamestr;		Read_Stuff : SimpS;	{handle}		mytype : OsType;		myprompt : str255;		bytecount,count,size	   		: Longint;		errcode,refnum,krefnum, znum, K_VolNum, Results_VolNum : integer;		only_one, doAvg, replace, append : boolean;		ExitDialog, OldFile, goodfile, is_std : boolean;		ka:array[1..10] of integer;		selectedCell: cell;		 		GetSelection : DialogPtr;		tempRect : Rect;		DType,itemHit,knum : Integer;		numpk : longint;		DItem : Handle;		CItem : controlhandle;					    PROCEDURE Refresh_Dialog;            BEGIN        SetPort(GetSelection);        GetDialogItem(GetSelection, I_OK, DType, DItem, tempRect);        PenSize(3, 3);        InsetRect(tempRect, - 4, - 4);        FrameRoundRect(tempRect, 16, 16);        PenSize(1, 1);      END;		PROCEDURE D_CL_Picker;		  const			   I_OK = 1;			   I_Cancel = 2;			   I_List = 5; 			   I_OldZ = 6;			   I_Warn = 7;		       I_Avg = 8;			   I_Next = 9;		  var 				ExitDialog, Next , Cancel,baseOK : boolean; 							jj,kk, DType, strlen : Integer;				itemHit,rcount,temp, nresult, lastcell, zresult,zcell,Rzcell,nextR : integer;				rdcount : Longint;				DItem : Handle;				err  : OSErr;				str,str1,str2,str4,str5   : str255;				pkdchars:packed array [1..255] of char;				basenum	: integer;				thearea : real;								ItemRect : rect;				KLorM	:	STRING[1];				strz	: fnamestr;	Procedure Avg_batch;	{for getting average values from ALL results in batch file							 for appending to old K file or starting a new one}	var		jj,rcount, nresult : integer;		str, str2   : str255;		ampsec :	 real;				BEGIN	{ Procedure Avg_batch;}		{ Have znum data from zresult. Get the Z data and elements data from ALL results in		  the file except zresult...Get_Kata will get elements data data from zresult}		 nresult := 0; { in the calling unit have read z result but it may not be		 the 1st result in the file...OOPS! as currently implemented it is always the first		 result because we only show 1st result from a batch file...this is ok tho'}			  bytecount:=sizeof(simplex_fit) ;			  errCode := FSOpen(Results_Name,Results_VolNum, refnum);			  IF errcode = noerr THEN			  BEGIN			    REPEAT {nresult may not = 0...}				  nresult := nresult + 1; {counts # of results...must inc before next <>}				  if (nresult <> zresult) then {...Get_Kata gets data from zresult...WHY? Because				  								already have znum data from zresult}				  begin					rdcount := 1 + (nresult-1) * bytecount; {rdcount changes below}					err := setfpos(refnum,fsFromStart,rdcount);					err := FSRead(RefNum, bytecount, @read_stuff^^);					If err = noerr then					Begin	{get the base element z Kb_data stuff from result...z may be same as Z}					 {for new file at this point Ka_data^^.NuminAvg <> Kb_data^^.NuminAvg					   cause Kb_data is for Z and we already have values for that}					 Kb_data^^.NuminAvg := Kb_data^^.NuminAvg + 1;					 Ka_data^^.NuminAvg := Ka_data^^.NuminAvg + 1;				         if (read_stuff^^.Fit_Params.Fit_Procedure = 'ML') then						Kb_Data^^.counts := read_stuff^^.Fit_Result.area[basenum]					  else					  begin	{if (read_stuff^^.Fit_Params.Fit_Procedure = 'Sm')...}						jj := basenum;						Kb_Data^^.counts := 0.0;						while ((jj<= read_stuff^^.Fit_Params.Number_of_peaks) and							   (read_stuff^^.Fit_Params.ev_LoLine[jj] =								read_stuff^^.Fit_Params.ev_LoLine[basenum]) and							   (read_stuff^^.Fit_Params.ev_HiLine[jj] = 								read_stuff^^.Fit_Params.ev_HiLine[basenum])) do						begin						  Kb_Data^^.counts := Kb_Data^^.counts + read_stuff^^.Fit_Result.area[jj];						  jj:=jj+1;						end;					  end;	{if (read_stuff^^.Fit_Params.Fit_Procedure = 'Sm')...}					 {get the denominator in the K ratios from this result...we also need the KaZ for					 Kb_Data: KaZ is 1 if Kb_data is Z data.}					 Kb_data^^.a_info.K := read_stuff^^.Fit_Result.conc[basenum]/Kb_Data^^.counts;					 Ka_data^^.b_info := Kb_data^^.a_info;  {...to get the value with counts, not					   									      counts per amp-sec}					 {get counts per sec per amp to report average count...specs may have different times					  and currents...in Ka_data^^.b_info.count and K...}					 With read_stuff^^,SpectrumStuff.Acq_info do					    ampsec := Live_time * (Begin_faraday + End_Faraday)/2;					 {get counts per amp-sec...}					 Kb_Data^^.counts := Kb_Data^^.counts/ampsec;					 Kb_data^^.a_info.K := read_stuff^^.Fit_Result.conc[basenum]/Kb_Data^^.counts;	    			 aKsum[basenum] := aKsum[basenum] + Kb_Data^^.a_info.K;	{..cnts per sec-amp}							 aKsqsm[basenum] := aKsqsm[basenum] + Kb_Data^^.a_info.K * Kb_Data^^.a_info.K;			         acntsum[basenum] := acntsum[basenum] + Kb_Data^^.counts;					 {... Kb_Data^^.a_info.K used below is for this result only}					 					 {if basenum = znum, Kb_Data^^.KaZ => 1.0 in calling routine}					 {¥¥¥¥if basenum <> znum then Kb_Data^^.KaZ comes from the K file}				     {when the averaging is finished we set Ka_Data^^.b_info to the				      averaged Kb_Data^^.a_info to write to the K file...why?? Maybe we won't.}				  {get the other element stuff...}					For jj := 1 to knum do					if ka[jj] <> basenum then{...to be sure ka[jj] never equals basenum}					Begin					 Ka_data^^.counts := 0.0;					 rcount := ka[jj];					 repeat					   if read_stuff^^.Fit_Params.Siegbahn[rcount][4] <> 'D' then					   begin						 Ka_data^^.counts := Ka_data^^.counts + read_stuff^^.Fit_Result.area[rcount];					   end;					   rcount := rcount + 1;					 until ((rcount > read_stuff^^.Fit_Params.Number_of_peaks) or							(read_stuff^^.Fit_Params.ev_LoLine[rcount] <>							 read_stuff^^.Fit_Params.ev_LoLine[ka[jj]]) or							(read_stuff^^.Fit_Params.ev_HiLine[rcount] <>							 read_stuff^^.Fit_Params.ev_HiLine[ka[jj]]));					 {the 2 values for this result...}					 Ka_data^^.a_info.K := read_stuff^^.Fit_Result.conc[ka[jj]]/Ka_data^^.counts;					 {calculate here only for convenience in next two running sums...}					 Ka_data^^.KaZ := (Ka_data^^.a_info.K/Ka_data^^.b_info.K);					 {...* Kb_data^^.KaZ below or in Get_Kdata not here}					 aKsum[ka[jj]] := aKsum[ka[jj]] + Ka_data^^.KaZ;					 aKsqsm[ka[jj]] := aKsqsm[ka[jj]] + Ka_data^^.KaZ * Ka_data^^.KaZ;					 With read_stuff^^,SpectrumStuff.Acq_info do					     Ka_Data^^.counts := Ka_Data^^.counts/ampsec;					 acntsum[ka[jj]] := acntsum[ka[jj]] + Ka_Data^^.counts;  					End;	{for jj...}				   End 	{ if err = noerr...}				   Else if err <> eoferr then begin				    numtostring(nresult,str);				   	Putmessage('Other than EOFerr reading', Results_Name,'at result #',str);				   End; 	{Else begin...}				  end;	{if nresult <> zresult then begin...}				UNTIL err = eoferr;	{if is_batch and doavg repeat...}			 END	{IF errcode = noerr...}			 ELSE putmessage('Err opening results file',Results_Name,'','');						IF ErrCode = noerr then			Begin		{Now calculate the stats for avg base data. If Base data is is Z data		 the aksum[znum], etc have values from all results inc zresult and		 all Kb_data is written to the Zdata part of K file; otherwise only Ka_Data^^.b_info =		 Kb_Data^^.b_info is written as part of Ka_data^^...		 the calling routine takes care of this. aKsum and acntsum are of vals 		 normalized by time and avg current.}			  Kb_Data^^.a_info.K := aKsum[basenum]/Kb_Data^^.NuminAvg;{...cnts per amp-sec}			  Kb_Data^^.Ksum := aKsum[basenum];	{...cnts per amp-sec}			realtostring(Kb_Data^^.a_info.K,5,2,str2);	str2 := concat('end of avg_batch, for basenum, Kb_Data^^.a_info.K is ',str2);	realtostring(aKsqsm[basenum],5,2,str);			  Kb_Data^^.Ksqsm := aKsqsm[basenum];			  Kb_Data^^.counts := acntsum[basenum]/Kb_Data^^.NuminAvg;	{...per amp-sec}			  Kb_Data^^.vari := aKsqsm[basenum]/Kb_Data^^.NuminAvg -			                    aKsum[basenum] * aKsum[basenum]/(Kb_Data^^.NuminAvg * Kb_Data^^.NuminAvg);			  Kb_data^^.wtf := read_stuff^^.Fit_Result.conc[basenum];			 errCode := FSClose(krefnum);			End; {if errCode = noerr...}        END; {procedure avg_batch;}		Procedure Get_Kdata(this_knum	: integer);		{From the basenum result or selected result this procedure gets the info to write	 to the K file for each K factor to be calculated from the result and calculates the	 KaZ values for that result.  Before calling Get_Kdata, must read the analysis result	 into read_stuff^^ and get Kb_data.a_info.K = wtf/counts for the result basenum.	 This can be done with Get_Kdata.	 To get base data with Get_Kdata initialize the vars:	 		knum=1, ka[1] = basenum THEN basenum = 0, Oldfile = false, append = false.	 If an old K factor file was opened, routine will check if there is a K factor in the file	 as each selected KaZ is calculated. It will avg or replace the old value, as directed.	 Otherwise it will append each new KaZ.	 if no Avg_batch, zero the running sum values before calling this. }	VAR			kk,jj,index	:integer;			ampsec : real;			st_len : integer;					Begin 			  if doavg then Ka_data^^.avg := true			  else Ka_data^^.avg := false;			  kk := 0;			  if is_batch then Ka_data^^.NuminAvg := Ka_data^^.NuminAvg + 1			  else Ka_data^^.NuminAvg :=1;		 FOR jj := 1 to this_knum do		 BEGIN{here only if found...}			  {this_knum is the number of k factors to make; ka[jj] is the # of the 1st pk			   in the result for the jjth k factor...}			  			  If ka[jj] <> basenum then	{...have data for basenum from old Kfile or from get_Kdata			  							 if new Kfile. Now get Z, line,LoLine_ev etc			  							 for each ka, calculate KaZ and write data to Kfile}			  Begin			    {before we got here we put base info into KZ_Data in case below we write on				 kb_data^^ when testing an old file for a duplicate Kfactor...} 			    Kb_data^^ := KZ_data^^;{...wtf/counts comes from this result}				repeat {find which roi}				 kk := kk + 1;				until (kk = read_stuff^^.Fit_Params.Number_of_windows) or 					  (ka[jj] < read_stuff^^.Fit_Params.First_in_Roi[kk + 1]);				Ka_data^^.vari := 0.0;				{here if ka[jj] <> basenum...}		{If it is_batch then we are here to get the data from the zresult and		 add it to data from averaging all the other results. We then check if data is in the K file		 for the element and average this batch average with those values. We increment and decrement		 Ka_data^^.NuminAvg so it is correct for eack this_knum.		 If it's not batch then we calc Ka_data for this this_knum only. Then we see if there is data		 in the k file for the element and average this new value in with it or replace it so		 Ka_data^^.NuminAvg is either 1 or Kb_data^^.NuminAvg + 1.}		 			st_len := length(read_stuff^^.ExptStuff.MCA_Filename);		 	Ka_data^^.SpecFilename := copy(read_stuff^^.ExptStuff.MCA_Filename,1,st_len);		 			 		{BlockMove(@read_stuff^^.ExptStuff.MCA_Filename,@Ka_data^^.SpecFilename,sizeof(read_stuff^^.ExptStuff.MCA_Filename));}{¥ROI^^.Quant.Lo := round((ML_Setup^^.BkgLo * energy_slope + energy_intercept) / dE);}{¥ML_Setup^^.BkgLo := (ROI^^.Quant.Lo * dE - energy_intercept)/energy_slope;}				{the energy values in fit files are all true line energies from the table;				 ROI energies in fit files are calculated using energy slope and intercept...				 they are the true energies of the end points}				Ka_data^^.a_info.Fit_Roi_Lo := read_stuff^^.Fit_Params.Fitting_Roi_Lo[kk];				Ka_data^^.a_info.Fit_Roi_Hi := read_stuff^^.Fit_Params.Fitting_Roi_Hi[kk];				kk := kk-1; {...so we test the next ka[jj] against the same window}				Ka_data^^.a_info.LoLine_ev := read_stuff^^.Fit_Params.ev_LoLine[ka[jj]];				Ka_data^^.a_info.HiLine_ev := read_stuff^^.Fit_Params.ev_HiLine[ka[jj]];				Ka_data^^.a_info.Z := read_stuff^^.Fit_Params.Atomic_Number[ka[jj]];				Ka_data^^.a_info.line := read_stuff^^.Fit_Params.Siegbahn[ka[jj]][1];				Ka_data^^.wtf := read_stuff^^.Fit_Result.conc[ka[jj]];				Ka_data^^.counts := 0.0;				if read_stuff^^.Fit_Params.fit_procedure ='ML' then				begin				  index := read_stuff^^.Fit_Params.Ref_Index[ka[jj]];				  Ka_data^^.RefFileName := read_stuff^^.Fit_Params.Ref_FileName[index];				  Ka_data^^.counts := read_stuff^^.Fit_Result.area[ka[jj]];				end				else	{if read_stuff^^.Fit_Params.fit_procedure ='Sm'...}				begin				  strz := 'No ref file';				  st_len := length(strz);				  Ka_data^^.RefFileName := copy(strz,1,st_len);				  				  {BlockMove(@strz,@Ka_data^^.RefFileName,sizeof(strz));}				  rcount := ka[jj];				  while ((rcount <= read_stuff^^.Fit_Params.Number_of_peaks) and					     (read_stuff^^.Fit_Params.ev_LoLine[rcount] =						  Ka_data^^.a_info.LoLine_ev) and					     (read_stuff^^.Fit_Params.ev_HiLine[rcount] =						  Ka_data^^.a_info.HiLine_ev)) do				  begin					 Ka_Data^^.counts := Ka_Data^^.counts + read_stuff^^.Fit_Result.area[rcount];					 rcount := rcount + 1;				  end; {while...}				end; {if read_stuff^^.Fit_Params.fit_procedure ='Sm)...}				{the Kb_data^^ for the result is defined by the calling code...}				Ka_data^^.a_info.K := Ka_data^^.wtf / Ka_Data^^.counts;				Ka_data^^.b_info.K := Kb_data^^.a_info.K;{...data from this result for basenum}				Ka_data^^.KaZ := (Ka_data^^.a_info.K/Ka_data^^.b_info.K) * Kb_data^^.KaZ;				{...secs and amps factor out unless for Z where Ka_data^^.b_info.K = 1}				{...* Kb_data^^.KaZ is done below; Kb_data^^.KaZ is 1 if for Z, else from Kfile} 								With read_stuff^^,SpectrumStuff.Acq_info do					     ampsec := Live_time * (Begin_faraday + End_Faraday)/2;				Ka_Data^^.counts := Ka_Data^^.counts/ampsec;											acntsum[ka[jj]] := acntsum[ka[jj]] + Ka_data^^.counts; {counts per amp-sec}			 { For Z data, the · values need to have time and current factored out...			   because Kb_data^^.K is 1 if ka[jj] = znum, a special case,			   Ka_data^^.KaZ is only wtf/counts...thus the sums into Avg_Batch will be ok}				If ka[jj] = znum then begin					Ka_data^^.KaZ := Ka_data^^.KaZ * ampsec;				end;								{unless this is Get_kdata for batch file the ·'s are the values and				 NuminAvg = 1...}				aKsum[ka[jj]] := aKsum[ka[jj]] + Ka_data^^.KaZ;{...forZ this is wtf/counts}				aKsqsm[ka[jj]] := aKsqsm[ka[jj]] + Ka_data^^.KaZ * Ka_data^^.KaZ;			   			   Ka_data^^.KaZ := aKsum[ka[jj]]/Ka_data^^.NuminAvg; {avg val for vari not file}				Ka_data^^.Ksum := aKsum[ka[jj]]; {for Z: ·wtf/counts per amp-sec}				Ka_data^^.Ksqsm := aKsqsm[ka[jj]];				If (Ka_data^^.NuminAvg = 1) then Ka_data^^.vari := 0.0				else Ka_data^^.vari := aKsqsm[ka[jj]]/Ka_data^^.NuminAvg - 								       (aKsum[ka[jj]]/Ka_data^^.NuminAvg) * aKsum[ka[jj]]/Ka_data^^.NuminAvg;				{ka[1]<>znum...this is always true except if we are making a new file. Then				 we set Ka[1] equal to znum before we call this proc and we don't want to do the next}				 				 If (Oldfile or ((ka[1]<>znum) and (not is_batch))) then					 {is an entry in the file for this K factor?...}				 begin             		append := true;{???in case no avg or replace???}					{includes the value for Kb_Data^^.a_info.K from this result...}					Ka_data^^.b_info.K := aKsum[basenum]/Kb_data^^.NuminAvg;{...amp-sec}   						   bytecount := sizeof(KFile_rec);						   count := sizeof(KFact_rec);   				{Future change: Call a dialog that shows the two sets of data for the line				  and get an avg, replace or keep decision, then do it...}						 REPEAT						     replace := false;							 Ka_data^^.avg := false;							 bytecount := bytecount + count;							 errCode := FSOpen(K_Name,K_VolNum,krefnum);							 {skip past the file and base info}							 errCode := SetFPos(krefnum, FSFromStart,bytecount);							 err := FSRead(krefNum, count, @Kb_data^^);							 errCode := FSClose(krefnum);						    IF err = noerr then							BEGIN							 if (Ka_data^^.a_info.Z = Kb_data^^.a_info.Z) and								(Ka_data^^.a_info.line = Kb_data^^.a_info.line) then							 begin							 str := concat(A^.Sym[Ka_data^^.a_info.Z],' ',Ka_data^^.a_info.line);							 str := concat('The K factor file already has a K factor for ',str,'.');							   if  ((Kfile_Data^^.Kfitproc = 'Sm') and							        (Ka_data^^.a_info.LoLine_ev = Kb_data^^.a_info.LoLine_ev) and								    (Ka_data^^.a_info.HiLine_ev = Kb_data^^.a_info.HiLine_ev)) then 							   begin							   	   realtostring(Kb_data^^.a_info.LoLine_ev,4,0,str1);								   realtostring(Kb_data^^.a_info.HiLine_ev,4,0,str2);								   if Kb_data^^.avg then begin									  numtostring(Kb_data^^.NuminAvg,str4);									  str4 :=concat('. K factor is avg of ',str4,' values.');								   end								   else begin									  realtostring(Kb_data^^.counts,5,1,str4);									  str4:= concat(', ',str4,' counts.');								   end;								   str1:=concat('lines from ',str1,'ev to ',str2,'ev',str4);							  			   					   if answermessage(str,str1,'If IT`S OK I`ll average the values.',													     'If IT`S NOT OK,I`ll replace the old value.')								   then begin									   Ka_data^^.avg := true;	{new avg}									   replace := true;			{and replace old avg}								   end								   else begin								        if doavg then Ka_data^^.avg := true								        else Ka_data^^.avg := false; {no avg}										replace := true;		{replace old value}			  				       end;							   end	{if  ((Kfile_Data^^.Kfitproc = 'Sm')...}							   else							   if ((Kfile_Data^^.Kfitproc = 'ML') and							       (Ka_data^^.a_info.LoLine_ev = Kb_data^^.a_info.LoLine_ev) and								   (Ka_data^^.a_info.HiLine_ev = Kb_data^^.a_info.HiLine_ev)) then							   begin								 realtostring(Kb_data^^.a_info.LoLine_ev,4,0,str1);								 realtostring(Kb_data^^.a_info.HiLine_ev,4,0,str2);								 if Kb_data^^.avg then begin									numtostring(Kb_data^^.NuminAvg,str4);									str4 :=concat('. K factor is avg of ',str4,' values.');								 end								 else begin									realtostring(Kb_data^^.counts,5,1,str4);									str4:= concat(', ',str4,' counts.');								 end;								 str1:=concat('Rois may be different but lines from ',str1,'ev to ',str2,'ev',str4);(* changed as above 9/18/95 *)    if answermessage(str,str1,												 		'If IT`S OK, I`ll average the values.',														'If IT`S NOT OK, I`ll replace the old value.')								  then begin									Ka_data^^.avg := true;	{new avg}									replace := false;								  end								  else begin								    if (doavg) then Ka_data^^.avg := true 									else Ka_data^^.avg := false;									replace := true;								  end;								   Refresh_CLDialog;								   LAutoScroll(List_Z_CL);								   LUpdate(CLPicker^.visRgn,List_Z_CL);	{should redraw everything}							   end; {if ((Kfile_Data^^.Kfitproc = 'ML')...}							 end;	{ if (Ka_data^^.a_info.Z =...}						str := concat(A^.Sym[Ka_data^^.a_info.Z],' ',Ka_data^^.a_info.line);		                  								   if replace then {overwrite with avg or new data...}						   begin	{Kb_data holds values from K file, Ka_data from result}							If Ka_data^^.avg then {Make Ka_data new avg values...}							begin			 							 Ka_data^^.NuminAvg := Kb_data^^.NuminAvg + Ka_data^^.NuminAvg;							 Ka_data^^.Ksum := Kb_data^^.Ksum + Ka_data^^.Ksum;							 {KaZ is the mean K factor...}							 Ka_data^^.KaZ := Ka_data^^.Ksum/Ka_data^^.NuminAvg;							 Ka_data^^.Ksqsm := Kb_data^^.Ksqsm + Ka_data^^.Ksqsm;							 Ka_data^^.vari := Ka_data^^.Ksqsm/Ka_data^^.NuminAvg -							 				   Ka_data^^.Ksum/Ka_data^^.NuminAvg * Ka_data^^.Ksum/Ka_data^^.NuminAvg;							end; {If Ka_data^^.avg...if no avg then write new Ka_data over old values}							{write the Ka_data...}							errCode := FSOpen(K_Name,K_VolNum,krefnum);							errCode := SetFPos(krefnum, FSFromstart,bytecount);							errCode := FSWrite(krefNum, count, @Ka_data^^);							errCode := FSClose(krefnum);						    append := false;							{so NuminAvg is correct for nex ka[jj]...}							If Ka_data^^.avg then Ka_data^^.NuminAvg :=												  Ka_data^^.NuminAvg - Kb_data^^.NuminAvg;						   end;	{if replace then...}					   END; 	{IF err = noerr...}					UNTIL (err = EOFerr);				  End; 	{if Oldfile...}				  If  append then 				  begin {append new data...}					  errCode := FSOpen(K_Name,K_VolNum,krefnum);					  bytecount := 0;					  errCode := setFPos(krefnum,FSFromLEOF,bytecount);					  bytecount := sizeof(KFact_rec);					  errCode := FSWrite(krefNum, bytecount, @Ka_data^^);					  errCode := FSClose(krefnum);				 end;	{ If  append...}			 End;	{if ka[jj] <> basenum then Begin...}		  END;	{FOR jj := 1 to this_knum do BEGIN...}	End;	{Procedure Get_Kdata;}						BEGIN	{PROCEDURE D_CL_Picker;}					CLPicker := GetNewDialog(1940, nil,  Pointer(-1) );				ShowWindow(CLPicker);	{makes it visible}				SelectWindow(CLPicker); {makes it the active window & front window, hilights}				SetPort(CLPicker);		{makes this the port for drawing}								if (oldfile) then begin					GetDialogItem(CLPicker,I_OldZ,DType,DItem,ItemRect);					str := 'The file normalizing Z family is marked by ¥¥¥';				    SetDialogItemText(DItem,str);				end				else begin					GetDialogItem(CLPicker,I_Warn,DType,DItem,ItemRect);				    SetDialogItemText(DItem,'');					GetDialogItem(CLPicker,I_OldZ,DType,DItem,ItemRect);				    SetDialogItemText(DItem,'¥¥¥¥');				end;								GetDialogItem(CLPicker,I_List,DType,DItem,ListRect);				CellRect := ListRect;				{...this ListRect is the rect that includes the list AND scroll bars}				{make CellRect, the RView, exclude the scroll bars};				CellRect.Right := CellRect.Right -15;								Refresh_CLDialog;  			    SetRect(dataBounds, 0, 0, 1, 0);{the bounds allocated are col0,row0 to col1,row0:				   								 rect:left,top,right,bottom}				cSize.h := CellRect.Right - CellRect.Left;				cSize.v := 16;				List_Z_CL:=  LNew(CellRect,dataBounds,cSize,0,CLPicker,TRUE,FALSE,FALSE,TRUE);								List_Z_CL^^.selFlags := lOnlyOne + lNoNilHilite;				LSetDrawingMode(false, List_Z_CL);												{if results is a batch fit then NEXT disappears and AVG is locked on.				 if results has one only fit result NEXT and AVG disappear.} 				GetDialogItem(CLPicker,I_Avg,DType,DItem,ItemRect);				CItem := ControlHandle(DItem);				If (is_batch) then SetControlValue(CItem, 1)				else SetControlValue(CItem, 0);				if (only_one) then HideControl(CItem); 									GetDialogItem(CLPicker,I_Next,DType,DItem,ItemRect);				CItem := ControlHandle(DItem);				If (is_batch or only_one) then HideControl(CItem);		newCell.v := 0; {row}		newCell.h := 0; {col}		rcount := -1;		baseOK := False;		znum := 0;		basenum := 0;		nresult := 0;		zresult := 0;		Zcell := 0;		Rzcell := 0;		selectedCell := newCell;				REPEAT	{UNTIL ExitDialog...steps through sets of results in a file}		{read one anal result and put the useful stuff in the list...the number		 that appears in the list is the position of the line in the anal result so		 numbers of derivatives do not appear and list numbers will not be consecutive}		  bytecount:=sizeof(simplex_fit) ;		  rdcount := 1 + nresult * bytecount; {rdcount changes below}		  errCode := FSOpen(Results_Name,Results_VolNum, refnum);		  err := setfpos(refnum,fsFromStart,rdcount);	      err := FSRead(RefNum, bytecount, @read_stuff^^);		  errCode := FSClose(refnum);		  nresult := nresult + 1; {counts # of results read...not changed below this pt}		  		  if (count <= rdcount + bytecount) then  {count, eof position defined in CLKfact...}		  begin {turn off next if at eof}				  GetDialogItem(CLPicker,I_Next,DType,DItem,ItemRect);				  HideControl(ControlHandle(DItem));		  end;	{ if (count...}		  rcount := LAddRow(1, rcount+1, List_Z_CL);		  str1:=copy(read_stuff^^.SpectrumStuff.Spectrum_Info.Spectrum_Comment_Field,1,25);		  numtostring(nresult,str);		  str1 := concat('Result',str,' ',str1);		  LSetSelect(false, selectedCell, List_Z_CL);		  LSetCell(@Str1[1], length(Str1),newCell,List_Z_CL);		  LSetSelect(true, newCell, List_Z_CL);	{highlights...}		  selectedCell := newCell;		  LDraw(newCell, List_Z_CL);		  newCell.v := newCell.v + 1;	{next cell}	      WITH read_stuff^^,Fit_params,Fit_Result DO	      begin			if (read_stuff^^.Fit_Params.Fit_Procedure = 'ML') then			begin			 For jj := 1 to Number_of_peaks  do			 begin	{the rows add at the bottom...}				if Siegbahn[jj][4] <> 'D' then begin					SpinCursor;              					str1:='';					 Numtostring(jj,str1);					{¥¥¥if you change < 2 in next line change str := '12' below...}					 while (length(str1) < 2) do str1:=concat('0',str1);					 str1 := CONCAT(str1,':',A^.Sym[Atomic_number[jj]]);					 if (length(str1) < 6) then str1:=concat(str1,' ',Siegbahn[jj][1])					 else str1:=concat(str1,Siegbahn[jj][1]);					 if ref_index[jj] < 1 then str := concat(str1,' not fit.')					 else begin						realToString(ev_LoLine[jj],4,1, str4);						realToString(ev_HiLine[jj],4,1, str5);						Str := CONCAT(str1,str4,'-',str5,'ev ');						str1 := str;						realToString(area[jj],5,1, str4);						realToString(conc[jj],4,3,str5);						Str := CONCAT(str,str4,'cnts ',str5,'wtf');						if (oldfile) or (znum > 0) then { KZ_Data is defined }						begin							KLorM := Siegbahn[jj][1];						  if (KZ_Data^^.a_info.Z = Atomic_number[jj]) and							 (KZ_Data^^.a_info.line = KLorM) then						  begin							 If ((KZ_Data^^.a_info.loline_ev = ev_LoLine[jj]) and								 (KZ_Data^^.a_info.hiline_ev = ev_HiLine[jj])) then							 begin								Str := CONCAT(str,'¥¥¥');								baseOK := true;								if ((is_batch and (znum = 0)) or only_one) then znum := jj;							 end;		{if (KZ_Data^^.a_number ...}						  end;	{if (KZ_Data^^.a_info.Z =...}						end;		{ if oldfile...}					  end;	{if ref_index[jj] < 1...else...}					  rcount := LAddRow(1, rcount+1, List_Z_CL);	   					  LSetCell(@Str[1], length(Str),newCell,List_Z_CL);				      LDraw(newCell, List_Z_CL);					  newCell.v := newCell.v + 1;	{next cell}				   end;	{ if Siegbahn[jj][4]...}			 end; { for jj := ...}		    End	{ if (Fit_Procedure = 'ML')...}		    Else	if (Fit_Procedure = 'Sm') then		    Begin		     jj := 1;		     Repeat			   SpinCursor;              			   str1:='';				str:='';				str4:='';				str5:='';				Numtostring(jj,str1);				while (length(str1) < 2) do str1:=concat('0',str1);								Str1 := CONCAT(str1,': ',A^.Sym[Atomic_number[jj]],Siegbahn[jj][1]);  				if (length(str1) < 6) then str1:=concat(str1,' ');				kk := jj; {kk holds 1st pk #...}				thearea := 0.0;				KLorM := Siegbahn[kk][1];				if  (oldfile or (znum > 0)) and				    (KZ_Data^^.a_info.Z = Atomic_number[kk]) and					(KZ_Data^^.a_info.line = KLorM) then				begin				   if (KZ_Data^^.a_info.LoLine_ev >= ev_LoLine[kk]) and					  (KZ_Data^^.a_info.HiLine_ev <= ev_HiLine[kk]) then				   begin					  repeat					   if (KZ_Data^^.a_info.LoLine_ev >= ev_LoLine[jj]) and						  (KZ_Data^^.a_info.HiLine_ev <= ev_HiLine[jj]) then						  thearea := thearea + area[jj]; 					   jj := jj + 1;					  until (jj = Number_of_peaks + 1) or							(ev_LoLine[jj] <> ev_LoLine[kk]) or 							(ev_HiLine[jj] <> ev_HiLine[kk]);	{jj is now number of next peak}					  Str := '¥¥¥';					  baseOK := true;					  if ((is_batch and (znum = 0)) or only_one) then znum := kk;					  	{...otherwise znum may be a different kk for each result}				   end	{if (KZ_Data^^.a_info.LoLine_ev...}				   else Str := ' ';				end	{if  (oldfile or (znum > 0)) and...}				else repeat 				 thearea := thearea + area[jj]; 				 jj := jj + 1;				until (jj = Number_of_peaks + 1) or					  (ev_LoLine[jj] <> ev_LoLine[kk]) or 					  (ev_HiLine[jj] <> ev_HiLine[kk]);	{jj is now number of next peak}								if (ref_index[kk] = -1) then					str := concat( str1,' not fit.')				else begin					realToString(ev_LoLine[kk],4,0, str4);					realToString(ev_HiLine[kk],4,0, str5);					Str1 := CONCAT(str1,' lines ',str4,'-',str5,'ev ');					realToString(thearea,5,1, str4);					realToString(conc[kk],4,3, str5);					Str := CONCAT(str1,str4,' cnts ',str5,' wtf',str);			    end; {if ref_index = -1...else...}				rcount := LAddRow(1, rcount+1, List_Z_CL);	 				LSetCell(@Str[1], length(Str), newCell,List_Z_CL);				LDraw(newCell, List_Z_CL);				newCell.v := newCell.v + 1;	{next cell}			 Until jj = Number_of_peaks + 1;		  End;	{ Else	if (Fit_Procedure = 'Sm')...}				 ChangeCursor(ArrowC);		End;	{With...}			lastcell := rcount;		    LAutoScroll(List_Z_CL);			LSetDrawingMode(TRUE, List_Z_CL);			thecell.v := 0;			LUpdate(CLPicker^.visRgn,List_Z_CL);	{should redraw everything}			ExitDialog:=FALSE;			itemhit:=0;			Next := False;			Cancel := False;	{¥¥¥¥¥}	REPEAT	{ UNTIL (ExitDialog or Next);...}				  ModalDialog(NewModalFilterProc(@myFilter),itemHit);			(*  LUpdate(CLPicker^.visRgn,List_Z_CL);*)	{should redraw everything}			  			  IF (ItemHit = I_Cancel) then 			  begin			  	cancel := TRUE;				ExitDialog := TRUE;			  end;			  			  IF (ItemHit = I_OK) then			  BEGIN			    if baseOK then begin					ExitDialog := TRUE;				end				else begin				  if oldfile then				  begin					  ExitDialog := answermessage('You didn`t double click anything. If IT`S OK,',								 'I`ll try to find an element z as in KaZ=(Ka/Kz)*(Kz/KZ)',								 'among selections for each result. If IT`S NOT OK,',								 'please indicate z in each result with ¥¥.'); 				  end				  else putmessage('You didn`t indicate a  base element Z by ¥¥¥ so',								  'Z in KaZ = ka/kZ is not defined. Please select',								  'your choice for Z; I`ll try to find an intermediate z ',								  'in any result that does not have Z data.');			      Refresh_CLDialog;		          LAutoScroll(List_Z_CL);				  LUpdate(CLPicker^.visRgn,List_Z_CL);	{should redraw everything}				end;			  END;			  			  IF (ItemHit = I_Next) then			  BEGIN			    Next := TRUE;			  END;			  			  IF (ItemHit = I_Avg) THEN BEGIN				if (not is_batch) then				begin				  GetDialogItem(CLPicker, itemHit, DType, DItem, tempRect);				  CItem := ControlHandle(DItem);				  temp := GetControlValue(CItem); 				  SetControlValue(CItem, (temp + 1) MOD 2);				  if temp = 1 then doAvg := false				  else doAvg := true;				end;			  END;			  			  {ELSE BEGIN}			   IF (ItemHit = 11) THEN			   BEGIN			    str  := '';			    str1  := '';				strlen := 255;			  	LGetCell(@pkdchars,strlen,List_Z_CL^^.lastClick,List_Z_CL);				selectedCell := List_Z_CL^^.lastClick;				if (pkdchars[1] <> 'R') then				   begin				   if doubleclick then				   begin					 if (pkdchars[strlen] = '¥') then str1 := '¥'					 else str1 := '¥¥';					 baseOK := true;					  {if it's an old file or znum picked, then cell must be a basenum choice...					   put ¥¥ else must be picking Z so put ¥¥¥}					 IF (Oldfile or (Znum > 0)) then LAddToCell(@str1[1],length(str1),selectedCell,List_Z_CL)					 ELSE BEGIN {new k file, no znum picked, this is it...make ¥¥¥}					  str1 := concat(str1,'¥');					  LAddToCell(@str1[1],length(str1),selectedCell,List_Z_CL);			          LUpdate(CLPicker^.visRgn,List_Z_CL);	{should redraw everything}					  {Now get Z data...}					  temp := 2;					  str:='12';	{this makes the length of str = 2 otherwise it's undefined									  and doesn't get a value from the LGetCell}					  LGetCell(@str[1],temp,selectedCell,List_Z_CL);					  StringToNum(str, numpk);					  znum := integer(numpk);					  {znum is the line...but from what result?}					  theCell.v := selectedCell.v;					  Zcell := selectedCell.v;					  zresult := 0;	{...in case we've changed the ¥¥¥}					  Repeat {in what result is ¥¥¥ ?...}						strlen := 255;						theCell.v := theCell.v - 1; {go backwards counting "R"}						LGetCell(@pkdchars,strlen,theCell,List_Z_CL);{returns true strlen}						if pkdchars[1] = 'R' then begin							zresult := zresult + 1;							if zresult = 1 then Rzcell := theCell.v;						end;					  Until (theCell.v = 0); 										  rdcount := 1 + (zresult - 1) * sizeof(simplex_fit);					  errCode := FSOpen(Results_Name,Results_VolNum, refnum);					  err := setfpos(refnum,fsFromStart,rdcount);					  bytecount := sizeof(simplex_fit); 					  err := FSRead(RefNum, bytecount, @read_stuff^^);					  errCode := FSClose(refnum);	                  {read_stuff^^ has info for all the lines in all the windows but 					   the line we want is znum...}					  Kfile_Data^^.Kfitproc := read_stuff^^.Fit_Params.fit_procedure;					  Kfile_Data^^.Kkv := read_stuff^^.ExptStuff.kV;					  Kfile_Data^^.KDetector := read_stuff^^.ExptStuff.Detector;					  {the next three lines are so we can use Get_Kdata}					  basenum := 0; {so ka[jj] <> basenum in Get_Kdata}					  ka[1] := znum; {haven't yet otherwise defined the set of ka}					  KZ_data^^.KaZ := 1; {(kZ/kZ)/(kZ/kZ)}					  KZ_data^^.a_info.K := 1; {kZ/kZ}					  KZ_data^^.vari := 0.0;					  aKsum[znum] := 0;					  aKsqsm[znum] := 0;					  acntsum[znum] := 0;					  KZ_data^^.NuminAvg := 0;					  Ka_data^^.NuminAvg := 0;					  append := false; {...Don't write to file yet in case we change the Z}					  {Kb_data^^ := KZ_data^^ in Get_Kdata}					  knum := 1;					  Get_Kdata(knum); {we are here only if new file and for a Znum}					  KZ_Data^^:= Ka_data^^;					  KZ_Data^^.KaZ := 1;{otherwise it would = conc/wtf}					  KZ_Data^^.b_info := KZ_Data^^.a_info;					 END;	{if (not oldfile)...}				   end	{ if doubleclick, new k file and znum = 0...this is Z }				   else if (pkdchars[strlen] = '¥') then				   begin {Single click...should we turn something off?}					 if (not oldfile) {can turn anything off...} 					 or (oldfile and (pkdchars[strlen-2] <> '¥')) then					 {can't turn off ¥¥¥ in old file: it's code set only.}					 begin					   strlen := strlen - 1;					   {check for ¥¥...}					   if (pkdchars[strlen] = '¥') then strlen := strlen - 1;					   {check for ¥¥¥, turn off in a new file only}					   if (pkdchars[strlen] = '¥') then {now at original strlen-2}					   begin					   		strlen := strlen - 1; {if there were ¥¥¥ they are gone}							znum := 0;			  { new K file only...deselected the Z}							theCell.v := 1;							Repeat {removes all ¥¥¥...}							  strlen := 255;							  LGetCell(@pkdchars,strlen,theCell,List_Z_CL);{returns true strlen}							  if (pkdchars[strlen-2] = '¥') then							  begin							   strlen := strlen - 3;							   LSetCell(@pkdchars,strlen,theCell,List_Z_CL);							  end;							  theCell.v := theCell.v + 1;							Until (theCell.v > lastcell); 						end                	   {write pkdchars back with out any ¥...}					   Else LSetCell(@pkdchars,strlen,List_Z_CL^^.lastClick,List_Z_CL);				   	 end;				   end				   else begin	{new choice...turn on the choice}					 str1 := '¥';					 LAddToCell(@str1[1],length(str1),List_Z_CL^^.lastClick,List_Z_CL);			         LUpdate(CLPicker^.visRgn,List_Z_CL);	{should redraw everything}				   end;			   				   Refresh_CLDialog;				End;	{ if (pkdchars[1] <> 'R')...}			    LUpdate(CLPicker^.visRgn,List_Z_CL);	{should redraw everything} 			   END;	{IF (ItemHit = 11)...}			   			  IF (ItemHit = I_List) THEN {in elevator bar only}			  BEGIN			   LUpdate(CLPicker^.visRgn,List_Z_CL);	{should redraw everything}			  END;	{ ELSE BEGIN...}			  	 UNTIL (ExitDialog or Next);			  { if Next, read next result and add to list...}	   UNTIL ExitDialog;	   If Cancel then (* putmessage('cancel','','','') *)	   Else	   Begin	     if is_batch then doAvg := true		 else if only_one then doAvg := false	     else begin		   GetDialogItem(CLPicker, I_Avg, DType, DItem, tempRect);		   temp := GetControlValue(ControlHandle(DItem)); 		   if temp = 1 then doAvg := true		   else doAvg := false;		 end;		 		{If starting a new file need to get all the k factor data from the result		 with  Z¥¥¥ chosen. This is because there may be a result in a non-batch file		 which has no info on Z so that an intermediate z must be set...need to know what's		 possible.		 For old or new k file, at this point we have KZ data defined: we either read		 it from oldfile or got it¥¥¥ from the results file via Get_Kdata into		 Ka_data then copied to KZ_data. If a new K file then write the base element		 Z data to the file and copy that to Kb_data for Get_Kdata on the Z result}		 		 { znum > 0 only if newfile, or if oldfile and is_batch		  or only_one and base Z in file}		 IF (znum > 0) then		 IF ((not oldfile) or 		     (oldfile and (is_batch or only_one)))		 THEN		 BEGIN		  {read cells for zresult to get lines to make Ks...we have Zdata info from		   old Kfile with values in running sums set to 0.0; for old and new file we		   read it from zresult: defined for new file, 1 for old. Avg_Batch gets ka		   and z data from all results and adds to running sums. Get_Kdata }			 theCell.h := 0;			 theCell.v := Rzcell + 1;{...the 1st cell for the result with ¥¥¥}			 bytecount := sizeof(simplex_fit);			 			 kk := 0;{here, not in loop,  because cells/pks come in order in Rois which come in order} 			 knum := 0;			 REPEAT	{get the set of pk nums to make k's for...}				strlen := 255;				LGetCell(@pkdchars,strlen,theCell,List_Z_CL);{returns true strlen}				IF (pkdchars[1] = 'R') then nextR := theCell.v				ELSE IF (pkdchars[strlen] = '¥') and 				        (pkdchars[strlen-2] <> '¥') then {¥ or ¥¥, but not ¥¥¥}				BEGIN				   temp := 2;				   str:='12';				   LGetCell(@str[1],temp,theCell,List_Z_CL);				   StringToNum(str, numpk);				   jj := integer(numpk);				   knum := knum + 1;				   ka[knum]:= jj;{...making the set of pk #s in result to use in k factors}				END;	{if (pkdchars[strlen] = '¥') and...}				theCell.v := theCell.v + 1;				{if 'R', 'R' is in theCell.v not theCell.v + 1...}			 UNTIL (pkdchars[1] = 'R') or (theCell.v > lastcell);			 if (theCell.v > lastcell) then nextR := lastcell + 1;	{must be defined}			 			 (*if (pkdchars[1] = 'R') then nextR := theCell.v - 1			 else nextR := lastcell + 1;	{must be defined}*)		   						Kb_data^^ := KZ_data^^; {thus Kb_data^^.NuminAvg = 1 for new file}						If (oldfile) then	 {if oldfile we have no data for any result...						 		  if new file we have data for Z only from Zresult}			begin				zresult := 1; {just to give a value for avg_batch}				aKsum[znum] := 0.0;				aKsqsm[znum] := 0.0;				acntsum[znum] := 0.0;			    Kb_data^^.NuminAvg := 0;			end;						 Ka_data^^.NuminAvg := 0; {...the z or Z result Ks are made in Get_Kdata below}			 basenum := znum;   						For jj := 1 to knum do			Begin			   aKsum[ka[jj]] := 0.0;			   aKsqsm[ka[jj]] := 0.0;			   acntsum[ka[jj]] := 0.0;			End;			{The preceeding three were evaluated in Get_Kdata above at ¥¥¥ for a new			 file;			 not used for old file since Z data only used in denom of K ratios.}		   		   IF (is_batch) then		   BEGIN 		    Avg_batch; { gets aksum,aksumsq and acntsum for each K ratio to make			            from all results except zresult; get_Kdata below does that.						aksum,aksumsq and acntsum[znum] have values from ALL results}		   END;				{if new kfile is_batch, running sums now include data from ALL results...get_Kdata call	 for zresult at user¥¥¥ got 1st vals;if old file we don't use Kb_Data^^ for anything}	     		 If not oldfile then		 begin		 {write the KZ data to new K file...}		    KZ_Data^^ := Kb_Data^^; {Kb_Data^^.KaZ comes from the File KZ_Data if old file}			KZ_Data^^.KaZ := 1.0;			 errCode := FSOpen(K_Name,K_VolNum,krefnum);			 bytecount := sizeof(KFile_rec);			 errCode := FSWrite(krefNum, bytecount, @Kfile_Data^^);		 	 bytecount := sizeof(KFact_rec);			 errCode := FSWrite(krefNum, bytecount, @KZ_Data^^); 			 errCode := FSClose(krefnum);	     end;	{ If not oldfile ...}						{Get data from zresult...			 read the zresult data into read_stuff^^...if old file zresult was set to one 1}			 			 rdcount := 1 + (zresult - 1) * sizeof(simplex_fit);			 errCode := FSOpen(Results_Name,Results_VolNum, refnum);			 err := setfpos(refnum,fsFromStart,rdcount);			 bytecount := sizeof(simplex_fit); 			 err := FSRead(RefNum, bytecount, @read_stuff^^);			 errCode := FSClose(refnum);			 			 basenum := znum;			 append := true;			 {Remember Kb_data in this part of code is for element Z only so Kb_data^^.KaZ := 1			  Kb_data^^.a_info.K must come from each result so ...}			 if (read_stuff^^.Fit_Params.Fit_Procedure = 'ML') then				Kb_Data^^.counts := read_stuff^^.Fit_Result.area[basenum]			  else			  begin	{if (read_stuff^^.Fit_Params.Fit_Procedure = 'Sm')...}				jj := basenum;				Kb_Data^^.counts := 0.0;				while ((jj<= read_stuff^^.Fit_Params.Number_of_peaks) and					   (read_stuff^^.Fit_Params.ev_LoLine[jj] =						KZ_Data^^.a_info.LoLine_ev) and					   (read_stuff^^.Fit_Params.ev_HiLine[jj] = 						KZ_Data^^.a_info.HiLine_ev)) do				begin				  Kb_Data^^.counts := Kb_Data^^.counts + read_stuff^^.Fit_Result.area[jj];				  jj:=jj+1;				end;			  end;	{if (read_stuff^^.Fit_Params.Fit_Procedure = 'Sm')...}			 {get the denominator in the K ratios from this result...we also need the KaZ for			  Kb_Data: KaZ is 1 if Kb_data is for Z.}			 Kb_data^^.a_info.K := read_stuff^^.Fit_Result.conc[basenum]/Kb_Data^^.counts;			 Kb_data^^.KaZ := 1.0;			 			 if Oldfile then {znum info from this result...add into kb_data stats}			 begin			   Kb_data^^.NuminAvg := Kb_data^^.NuminAvg + 1;			   With read_stuff^^,SpectrumStuff.Acq_info do				aKsum[basenum] := aKsum[basenum] +								  Kb_Data^^.a_info.K * Live_time * (Begin_faraday + End_Faraday)/2;	{..cnts per sec-amp}					 {the Kb_data is for Z so K is just conc/counts which must be normalized to make a			  sensible avg}			 end;	{if Oldfile ...}			 			 KZ_Data^^ := Kb_Data^^;{...so we don't lose the result Kb_Data^^ in Get_Kdata}			 Get_Kdata(knum); {adds K ratio values from  result to running sums and writes			 			 the Ka_data to Kfile. We are currently writing over the Kb_data we need for						 the next ka[jj] if ka[jj-1] has a kfactor in the file.}			 errCode := FSOpen(K_Name,K_VolNum,krefnum);			 bytecount := sizeof(KFile_rec);			 errCode := FSRead(krefNum, bytecount, @Kfile_Data^^);		 	 bytecount := sizeof(KFact_rec);			 errCode := FSRead(krefNum, bytecount, @KZ_Data^^); 			 errCode := FSClose(krefnum);		END;	{ If (not oldfile) and znum > 0 or				     (oldfile and (znum > 0) and (is_batch or only_one))..}		{If old K file, the code marked the Base element Z in each result otherwise		 the user marked ¥¥ an intermediate element  z. KZ data has been read in.		 We now have to find the Z or z in each result...use the same test to find		 a local Z or z Base...		 If oldfile then zresult =??? 0 from above.}			{At this point	 ¥ we have the KZ data for the base element Z no matter if it's an old	   or new K file...if new we have all the data from the zresult, if old from the K file.	 ¥ If it's a new K file... we also have other element data from the result with the KZ 	   base element. If it's also a batch result file all the results are the same so we	   called Avg_batch to read all the other results and calc avg vales. So we are finished	   with this results file.	   If results aren't batch next read cells to determine what to use from each result.	 ¥ If it's an old K file, the code  marked¥¥¥ any cell with the base Z element.	   Any result without base element data must have an intermediate element	   marked¥¥ by the user, or the code tries to find an element to use. We go through all	   cells... }	   	  IF (znum <= 1) or ((not is_batch) and (not only_one))  then 	  BEGIN	{ if oldfile we have Z data only, get the rest if there are cells with ¥				must define znum for each result}		 bytecount := sizeof(simplex_fit);		 {Define the the 1st result and 1st cell to read...we have the zdata from an		  old file or we have it from the zresult} 		 if zresult = 1 then {making a new K file and first result had Z data}		 begin			nresult := 2;			rdcount := 1 + bytecount; {bytes from start of results file}			theCell.v := nextR + 1;{...the one after nextR}		 end		 else begin {old K file, or zresult was not the 1st result}			  nresult := 1;			  rdcount := 1; {...gets increased at end of REPEAT}			  theCell.v := 1;		 end;		 errCode := FSOpen(Results_Name,Results_VolNum, refnum);		 err := setfpos(refnum,fsFromStart,rdcount);		 err := FSRead(RefNum, bytecount, @read_stuff^^);		 errCode := FSClose(refnum);		   thecell.h := 0;		   knum := 0;	{counts ks for each result}		   basenum := 0; {¥¥ means intermediate base: we have to check the K file for						  the lines to see if basenum can be an intermediate z}		   znum := 0; {must get znum for each result...}		   		   IF (theCell.v <= lastcell) {lastcell was defined when we wrote the list}		   then		   REPEAT		{ UNTIL theCell.v > lastcell...}			 {read thru all cells looking for ¥'s. Z data is already known so calculate 			 the k factors and write data to k file EACH TIME THE END OF A RESULT is found.}			   			   strlen := 255;			   LGetCell(@pkdchars,strlen,theCell,List_Z_CL);{returns true strlen}			    temp := 2;				str:='12';				LGetCell(@str[1],temp,theCell,List_Z_CL);				StringToNum(str, numpk);				jj := integer(numpk);				{if old k file, code marked all Z with ¥¥¥, if Z present}				{if lines match the Z Base have local Base, znum is defined}				IF  (pkdchars[strlen - 2] = '¥') or				   ((Kfile_Data^^.Kfitproc = 'ML') and				    (KZ_Data^^.a_info.LoLine_ev = read_stuff^^.Fit_Params.ev_LoLine[jj]) and				    (KZ_Data^^.a_info.HiLine_ev = read_stuff^^.Fit_Params.ev_HiLine[jj])) or				   ((Kfile_Data^^.Kfitproc = 'Sm') and 					(KZ_Data^^.a_info.HiLine_ev <= read_stuff^^.Fit_Params.ev_HiLine[jj]) and				    (KZ_Data^^.a_info.LoLine_ev >= read_stuff^^.Fit_Params.ev_LoLine[jj]))			    then				begin	{lines match the base element for the file...}						znum := jj; { a local Z...could be any cell, might have a ¥¥ base num too}					found := true; {found lines for Z}					Kb_data^^ := KZ_Data^^;				end				ELSE IF (pkdchars[strlen - 1] = '¥') then {¥¥}				begin	{ an intermediate base; there may be a znum in the result too}					basenum := jj;{z}				end				ELSE IF (pkdchars[strlen] = '¥') then 				BEGIN	{make a k factor for this element}					knum := knum + 1;					ka[knum]:= jj;	{number in result of peak to use for k factor}			    END;			   			IF (pkdchars[1] = 'R') or (theCell.v = lastcell) then			BEGIN {finished cells for the result or no more cells: we know the znum			       pk # of a Z line or basenum pk # of a z line, and lines to make				   K factors for; get data from result}			  IF (znum > 0) then {have match to file base element} 			  BEGIN			   if (basenum > 0) then	{convert any intermediate base to a knum}			   begin { IF (znum > 0)...}				 knum := knum + 1;				 ka[knum]:= basenum;	{number in result of peak to use for k factor}			   end;			   basenum := znum;{basenum, not znum, is the index used below}			   found := true;			  END;	{ IF (znum > 0)...}				 			  IF (knum > 0 ) then {converted a basenum or picked some eles...}			  BEGIN				With read_stuff^^,ExptStuff,Fit_Result,Fit_Params do				Begin{if found is T: result had znum, or if znum=0 then result had intermediate base z data...the K file data for base z is in Ka_data^^. Get Z or z data from result into Kb_data...}				 IF (znum = 0) then {no Z data found among cells...}				 BEGIN { get data for an intermediate base...}				   if (basenum = 0) then {no intermediate base picked...} 				   begin {...does any line have a k factor in the file?}					  jj := 0;					  kk := 0;					  temp := knum; {...the # of els to make k factors}				   end				   else begin {make sure chosen basenum IS in the k factor file...}					  jj := knum; {knum is the number of k factors to make}					  kk := knum;					  ka[knum+1] := basenum; {ka[knum] is the line # of the knumth k factor}					  temp := knum + 1;				   end;{...have not changed knum, look in K_Name for only one jj: jj = knum+1}				   				   {Open the K file and look for the basenum or each line...}				   errCode := FSOpen(K_Name,K_VolNum,krefnum);				   bytecount := sizeof(KFile_rec);				   errCode := FSRead(krefNum, bytecount, @Kfile_Data^^);				   count := sizeof(KFact_rec);				   errCode := FSRead(krefNum, count, @KZ_data^^);				   errCode := FSClose(krefnum);				   {there is no Z in the result: read Z data from the K file,					find the intermediate base z or some line to be z...}				   REPEAT{go through K file...find a z}					bytecount := bytecount + count;					errCode := FSOpen(K_Name,K_VolNum,krefnum);					errCode := SetFPos(krefnum, FSFromStart,bytecount);					err:= FSRead(krefNum, count, @Ka_data^^);					errCode := FSClose(krefnum);					IF err = noerr then 					BEGIN				 {compare each ka[jj] result data or the kk result data to K factor data}					 jj := kk; { kk = 0 or knum, number of families picked to make k factors}					 REPEAT	{no Z: does z or, if no z, a knum that can be z have data							  in the the K file?}					   jj:=jj+1; {1st jj is 1 if no basenum: compare all ka[jj] to K data;								  jj is knum+1 otherwise: ka[knum+1] is basenum, pk# of int'med base z}					   KLorM := read_stuff^^.Fit_Params.Siegbahn[ka[jj]][1];		  					   if (Ka_data^^.a_info.Z = read_stuff^^.Fit_Params.Atomic_number[ka[jj]]) and						  (Ka_data^^.a_info.line = KLorM) then					   begin {then line ka[jj] might be good intermediate z...}						 str:= concat('The fit file and K file have data for ',a^.Sym[Ka_data^^.a_info.Z ],Ka_data^^.a_info.line,'.');						 {the energies, ROI and line, in the fit files are all true energies...}						 if (((Ka_data^^.a_info.Fit_Roi_Lo = read_stuff^^.Fit_Params.Fitting_Roi_Lo[ka[jj]]) and							  (Ka_data^^.a_info.Fit_Roi_Hi = read_stuff^^.Fit_Params.Fitting_Roi_Hi[ka[jj]])) or							 ((Kfile_Data^^.Kfitproc = 'Sm') and							  (Ka_data^^.a_info.LoLine_ev >= read_stuff^^.Fit_Params.ev_LoLine[ka[jj]]) and							  (Ka_data^^.a_info.HiLine_ev <= read_stuff^^.Fit_Params.ev_HiLine[ka[jj]])))						 then if answermessage(str,'If IT`S OK I`ll use this as z data to calculate Kaz in KaZ=Kaz/KzZ.',											  'If IT`S NOT OK,I`ll see if some other choice from the result',											  'can be used as z.') then  found := true						 else						 if ((Kfile_Data^^.Kfitproc = 'ML') and							 (Ka_data^^.a_info.LoLine_ev = read_stuff^^.Fit_Params.ev_LoLine[ka[jj]]) and							 (Ka_data^^.a_info.HiLine_ev = read_stuff^^.Fit_Params.ev_HiLine[ka[jj]])) then							 if answermessage(str,'The lines fit are the same but the fitting rois are not.',												'This will affect each KaZ obtained from Kaz/KzZ for the result.',												'If IT`S OK I`ll use this as z data to calculate Kaz anyway.')							 then  found := true						 else						 if answermessage(str,										 'However, the lines fit are not the same.', 										 'This will affect each KaZ obtained from Kaz/KzZ for the result.',										 'If IT`S OK I`ll use the z element data to calculate Kaz anyway.')						 then found := true;					   end;	{ if ((Ka_data^^.a_info.Z =...}					 UNTIL ((found) or (jj = temp));{temp and jj = basenum, or 													 temp = # of families to make k factors}					 if found then					 begin					     Kb_data^^ := Ka_data^^;{¥¥¥ MUST keep this line}					  numtostring(ka[jj],str1);					 end					 else					 (* putmessage('compared all ka to kfile entry for',str4,'did not find match','next entry')*);					END;	{ IF err = noerr...}				  UNTIL ((found)  or (err = EOFerr)); {..end of K file data}				 END;	{IF ((znum = 0)) ...}				 If (not found)				 then putmessage('Sorry, I can`t make k factors for anything from this result.',								 'I could not find any data in the K factor file',								 'to define a z for this result as in KaZ = Kaz/KzZ.',								 'Try again after more data goes into the K factor file.')				 Else {If  found...get base element z data from result into Kb_data^^...}				 Begin				 {if there was no znum and no basenum, but a line ka[jj] was found in the				  k factor file, make it the basenum...otherwise we have a basenum = znum or basenum}				  				  if (basenum = 0) then basenum := ka[jj];{  }			      {in either case, the current read_stuff has the data for this ka... }				  kk := 0;				  repeat					 kk := kk + 1;				  until ((kk = read_stuff^^.Fit_Params.Number_of_Windows) or						 (basenum< First_in_Roi[kk + 1])); {...basenum is in window kk}	   					 Kb_data^^.vari := 0.0;					 Kb_data^^.avg := false;					 BlockMove(@read_stuff^^.ExptStuff.MCA_Filename,@Kb_data^^.SpecFilename,sizeof(read_stuff^^.ExptStuff.MCA_Filename));					 Kb_data^^.counts := 0.0;					 if Kfile_Data^^.Kfitproc ='ML' then					 begin						 Kb_data^^.counts := area[basenum];						 temp := read_stuff^^.Fit_Params.Ref_Index[basenum];						 BlockMove(@read_stuff^^.Fit_Params.Ref_FileName[temp],@Kb_data^^.RefFileName,sizeof(read_stuff^^.Fit_Params.Ref_FileName[temp]));					 end					 else begin	{Simplex fit}					  strz := 'No ref file';					  Kb_data^^.RefFileName := strz;					  {BlockMove(@strz,@Kb_data^^.RefFileName,sizeof(strz));}					   jj := basenum;					   repeat 						  if ((read_stuff^^.Fit_Result.err_or_energy[jj]*1000 >= Kb_data^^.a_info.fit_roi_lo) and							  (read_stuff^^.Fit_Result.err_or_energy[jj]*1000 <= Kb_data^^.a_info.Fit_roi_hi))						  then						  Kb_data^^.counts := Kb_data^^.counts + read_stuff^^.Fit_Result.area[jj];						  jj:=jj+1;					   until ((jj > Number_of_peaks) or							  (read_stuff^^.Fit_Params.ev_LoLine[jj] <>							   read_stuff^^.Fit_Params.ev_LoLine[basenum]));					  end;	{else begin...}					  Kb_data^^.a_info.Fit_Roi_Lo := read_stuff^^.Fit_Params.Fitting_Roi_Lo[kk];					  Kb_data^^.a_info.Fit_Roi_Hi := read_stuff^^.Fit_Params.Fitting_Roi_Hi[kk];					  Kb_data^^.a_info.Z := read_stuff^^.Fit_Params.Atomic_Number[basenum];					  Kb_data^^.a_info.K := read_stuff^^.Fit_Result.conc[basenum]/Kb_data^^.counts;					  {if Kb_data is for a znum then Kb_data^^.KaZ = 1.					   if Kb_data is for a basenum then Kb_data^^.KaZ = is K factor from file.}					  Kb_data^^.wtf := read_stuff^^.Fit_Result.conc[basenum];					  {...so Kb_data^^ has either Z info or z info...					   now get ka[knum] data...for Kaz or KaZ}					   KZ_data^^ := Kb_data^^;					   For jj := 1 to knum do					   Begin						  aKsum[ka[jj]] := 0.0;						  aKsqsm[ka[jj]] := 0.0;						  acntsum[ka[jj]] := 0.0;					   End;					   Ka_data^^.NuminAvg := 0;					   Get_Kdata(knum); {			}					   errCode := FSOpen(K_Name,K_VolNum,krefnum);					   size := sizeof(KFile_rec);					   errCode := FSRead(krefNum,size , @Kfile_Data^^);					   size := sizeof(KFact_rec);					   errCode := FSRead(krefNum, size, @KZ_Data^^); 					   errCode := FSClose(krefnum);				 End;	{if found...}				End;	{With...}			  END; {IF knum > 0...}				 			 IF (theCell.v < lastcell) or (is_batch)			 THEN BEGIN{lastcell was defined when we wrote the list}				 {read the result for the next set of cells...}					 knum := 0;					 if nresult + 1 = zresult then nresult := nresult + 1; {got this data}					 rdcount := 1 + nresult * sizeof(simplex_fit);{setfpos to end of nresult}					 nresult := nresult + 1;	{result# for next set of cells}					 numtostring(nresult,str1);					 basenum := 0;					 znum:=0;					 errCode := FSOpen(Results_Name,Results_VolNum, refnum);					 err := setfpos(refnum,fsFromStart,rdcount);					 bytecount := sizeof(simplex_fit); 					 err := FSRead(RefNum, bytecount, @read_stuff^^);					 errCode := FSClose(refnum);			  END;	{ IF (theCell.v < lastcell) or...}			 END;	{ IF (pkdchars[1] = 'R' or theCell.v = lastcell)...}			   			   if theCell.v = Rzcell then theCell.v := nextR + 1 {skip all these cells} 			   else theCell.v := theCell.v + 1; 					   UNTIL (theCell.v > lastcell) or (err = eoferr);		END;	{IF (not oldfile) and (is_batch and doavg)...ELSE BEGIN...}			  End;	{If (not Cancel)...}			  LDispose(List_Z_CL);						 CellRect := CLPicker^.portRect;				 DisposeDialog(CLPicker);				 FillWhiteSpace(CellRect);                 Mouse_Active_Window;		End;	{procedure D_CL_Picker...}		Procedure D_ManualEntry;		const		I_OK = 1;		I_Cancel = 2;		I_Accept = 3;		   var 		mytype : OsType;		myprompt : str255;		bytecount   		: Longint;		errcode, refnum, setnum, setup_vol : integer;		use_setup_File, show_CL, save_setup, found,		quant_fit, CL_accept, stds_zeroed, cancel, stoich, reportOxides, No_valences : boolean;		ExitDialog : boolean;		relerror	: real;		setup_name : fnamestr;		 		GetSelection : DialogPtr;		tempRect : Rect;		DType : Integer;		Index, fcnt : Integer;		DItem : Handle;		CItem	 : controlhandle;		sTemp : Str255;		itemHit : Integer;		temp : Integer;	BEGIN	{ PROCEDURE D_ManualEntry; }     		GetSelection := GetNewDialog(133, nil,  Pointer(-1) );			ShowWindow(GetSelection);			SelectWindow(GetSelection);			SetPort(GetSelection);			 			End;			BEGIN {procedure CLKfact}		bytecount := sizeof(simplex_fit);		read_stuff := SimpS(NewHandle(bytecount));		MoveHHi(Handle(read_stuff));		HLock(Handle(read_stuff));						bytecount := sizeof(KFile_rec);		Kfile_Data:=KExptHdl(NewHandle(bytecount));		MoveHHi(Handle(Kfile_Data));		HLock(Handle(Kfile_Data));					Ka_data := KFactHdl(NewHandle(sizeof(KFact_rec)));		MoveHHi(Handle(Ka_data));		HLock(Handle(Ka_data));			KZ_Data := KFactHdl(NewHandle(sizeof(KFact_rec)));		MoveHHi(Handle(KZ_Data));		HLock(Handle(KZ_Data));			Kb_data := KFactHdl(NewHandle(sizeof(KFact_rec)));		MoveHHi(Handle(Kb_data));		HLock(Handle(Kb_data));			GetSelection := GetNewDialog(134, nil,  Pointer(-1) );{this is a dialogptr,-1=>frontwindow}		ShowWindow(GetSelection);	{makes it visible}		SelectWindow(GetSelection); {makes it the active window & front window, hilights}		SetPort(GetSelection);		          GetDialogItem(GetSelection, I_Fit_File, DType, DItem, tempRect);          HiliteControl(ControlHandle(DItem), 255);          GetDialogItem(GetSelection, I_Manual, DType, DItem, tempRect);          {HiliteControl(ControlHandle(DItem), 255);}          CItem := ControlHandle(DItem);		  HideControl(CItem);		ExitDialog := false;		K_VolNum := 1000;		K_Name := '';	    knum := 0;		oldfile := false;		doavg := false;		only_one := true;		REPEAT						ModalDialog(NewModalFilterProc(@DefaultFilter), itemHit);				GetDialogItem(GetSelection, itemHit, DType, DItem, tempRect);				CItem := ControlHandle(DItem);								if (ItemHit =I_Ok) then ExitDialog := true;								if (ItemHit =I_Cancel) then ExitDialog := true; 								if (ItemHit =I_Manual) then 				begin					D_ManualEntry;				end;				if (ItemHit =I_Fit_File) then 				begin				 Repeat	{ Until (goodfile or (not File_Cancel_Button)) ;}				   mytype := 'MCAb';				   The_File_name := 'FileName';				   myprompt := ' Fit Results File to use? ';					  {GetFileName sets the Vol to that chosen in the file menu }				   Repeat				   Until (GetFileName(The_File_Name, mytype, mytype, myprompt) = True) OR 						 (File_Cancel_Button = False);				   IF (File_Cancel_Button) THEN 	{ a file was picked }					begin					 Results_VolNum := In_volrefnum;					 Results_Name := The_File_Name;					 { Get info for finding standards }					 errCode := FSOpen(Results_Name,Results_VolNum, refnum);					 errCode := SetFPos(refnum, fsFromStart,0);					 bytecount := 1;					 errCode := FSRead(refnum, bytecount, @is_batch);					 bytecount := sizeof(simplex_fit);					 errCode := FSRead(refnum, bytecount, @read_stuff^^);					 errCode := getfpos(refnum,bytecount);					 errCode := getEOF(refnum,count); 					 errCode := FSClose(refnum);					 if (count <= bytecount) then					 		only_one := true else only_one := false;			{¥¥¥}    is_std := read_stuff^^.SpectrumStuff.Spectrum_Info.This_is_a_Standard;			         If not is_std then					 Begin					  	if answermessage('The Standard Box in Spectrum Composition was not checked.',					 				     'If you are sure the composition is correct and It`s OK,',									     'I`ll proceed.','Otherwise pick another Fit File.') 					    then is_std := true;				  					 End;	{If not read_stuff^^...This_is_a_Standard}					 If (is_std = true) and 					    ((read_stuff^^.SpectrumStuff.Spectrum_Info.Number_of_Elements <= 0) or						 (read_stuff^^.SpectrumStuff.Spectrum_Info.Element_Info[1].Weight_fraction <= 0))					 Then Begin					      is_std := false;						  Putmessage('There doesn`t seem to be any composition information in the Fit Results.',									 'Please check this information (File: Fit Files: Show Contents).','','');					 End;										  				 IF is_std Then				 BEGIN					 If oldfile then					 Begin					 	if ((read_stuff^^.Fit_Params.Fit_Procedure = Kfile_Data^^.Kfitproc) and						    (read_stuff^^.ExptStuff.kv < (Kfile_Data^^.Kkv + 0.01*Kfile_Data^^.Kkv)) and						    (read_stuff^^.ExptStuff.kv > (Kfile_Data^^.Kkv - 0.01*Kfile_Data^^.Kkv)) and							(read_stuff^^.ExptStuff.detector.spec = Kfile_Data^^.KDetector.spec) and							(read_stuff^^.ExptStuff.detector.ID = Kfile_Data^^.KDetector.ID))							 then D_CL_Picker						else begin						  if (read_stuff^^.Fit_Params.Fit_Procedure <> Kfile_Data^^.Kfitproc) then						  	  str:='Uh-Oh! The fit procedure is different'						  else if (read_stuff^^.ExptStuff.kv <> Kfile_Data^^.Kkv) then						  	  str:='Uh-Oh! The kV is more than 1% different from the kV'						  else if (read_stuff^^.ExptStuff.detector.spec <> Kfile_Data^^.KDetector.spec) then							  str:='Excuse me, but that fit is for a different spectroscopy than'						  else if (read_stuff^^.ExptStuff.detector.ID <> Kfile_Data^^.KDetector.ID) then							  str:='Uh-Oh! that fit is for a detector different from the one';						 putmessage( str,									'in the K factor file you are appending.',									'Please select another results file,',							 		'or close the current K factor file and open another.');					 	end;	{else begin...}					 End	{if oldfile then...}					 Else D_CL_Picker;					 goodfile := true;				 END;	{IF is_std...}				 Refresh_Dialog;				end;	{IF (File_Cancel_Button)...}			  Until (goodfile or (not File_Cancel_Button)) ;							 End;	{if (ItemHit...}								if (ItemHit =I_Old_File) then 				begin				   mytype := 'MCAK';				   The_File_name := 'FileName';				   myprompt := 'K factor file to append? ';					  {GetFileName sets the Vol to that chosen in the file menu }				   Repeat				   Until (GetFileName(The_File_Name, mytype, mytype, myprompt) = True) OR 						 (File_Cancel_Button = False);				   Refresh_Dialog;				   IF (File_Cancel_Button) THEN 	{ a file was picked }					begin					 K_VolNum := In_volrefnum;					 K_Name := The_File_Name;		             errCode := FSOpen(K_Name,K_VolNum,krefnum);					 bytecount := sizeof(KFile_rec);	      			 err := FSRead(krefNum, bytecount, @Kfile_Data^^);{expt stuff}					 bytecount := sizeof(KFact_rec);	      			 err := FSRead(krefNum, bytecount, @KZ_data^^);{first rec is base element}		             errCode := FSClose(krefnum);					 knum := 0;					 oldfile := true;					 GetDialogItem(GetSelection, I_Fit_File, DType, DItem, tempRect);					 HiliteControl(ControlHandle(DItem), 0);					 GetDialogItem(GetSelection, I_Manual, DType, DItem, tempRect);					 HiliteControl(ControlHandle(DItem), 0);					 Refresh_Dialog;				  end;	{ IF (File_Cancel_Button)...}			    end;				if (ItemHit =I_New_File) then 				 begin	    		   K_Name := 'K_File';   { the user's choice replaces this }				   if (CreateFile(K_Name, 'Name new K file:') = True) OR								   (File_Cancel_Button = False) then;				   Refresh_Dialog;				   IF (File_Cancel_Button) THEN				   begin				    K_VolNum := Out_VolRefNum;				    errCode := Create(K_Name, K_VolNum, 'DTSA', 'MCAK');							bytecount := 0;							errCode := FSOpen(K_Name,K_VolNum,krefnum);							errCode := SetEOF(krefnum,bytecount);							errCode := FSClose(krefnum);					knum := 0;	(*  9/96	    putmessage('The first fit data you select MUST be data for Z,',							   'as in KaZ = Ka/KZ. Double click it, please.',							   'If any subsequent result used has no Z data,',							   'I`ll try to find a z, as in KaZ  = Kaz/KzZ.');	*)					GetDialogItem(GetSelection, I_Fit_File, DType, DItem, tempRect);					HiliteControl(ControlHandle(DItem), 0);					GetDialogItem(GetSelection, I_Manual, DType, DItem, tempRect);					HiliteControl(ControlHandle(DItem), 0);				   				   end;	{ IF (File_Cancel_Button)...}				   Refresh_Dialog;				 end;								 		UNTIL ExitDialog;		H_UnLock_Dispose(Handle(read_stuff),'read_stuff xx');		H_UnLock_Dispose(Handle(Kfile_Data),'');		H_UnLock_Dispose(Handle(Ka_data),'Kfile_Data xx');		H_UnLock_Dispose(Handle(Kb_Data),'Kb_Data xx');		H_UnLock_Dispose(Handle(KZ_Data),'KZ_Data xx');				 tempRect := GetSelection^.portRect;				 DisposeDialog(GetSelection);				 FillWhiteSpace(tempRect);                 Mouse_Active_Window;	END;	{procedure CLKfact}  Procedure WriteToCL;	{called from add_a_fit and Batch in Menus: CL_Output MUST  						 already exist; already did screen output if not batch}  BEGIN	{write DTSAname, spectnum, Class, number_of_peaks * area,etc...}	   errCode := FSOpen_err(Hall_name,Hall_vol, FileRefNum,'');	   errcode := SetFPos_err(FileRefNum, fsFromLEOF,0,'');	   bytecount := 20;	   errcode := FSWrite(FileRefNum,bytecount,@CL_OutPut^^.SpecID);       Bytecount := sizeof(integer) + 2 * sizeof(str_25); {DTSAname,spectnum,Class}	   errcode := FSWrite(FileRefNum,Bytecount,@CL_OutPut^^.DTSAname);	   IF  CL_OutPut^^.BaseInfo.Ox_by_Stoic then	        Bytecount := (CL_BsSetup^^.number_of_Peaks + 2) * sizeof(real)	   Else Bytecount := (CL_BsSetup^^.number_of_Peaks+1) * sizeof(real);	   errcode := FSWrite_err(FileRefNum, Bytecount, @CL_Output^^.area[1],'area');	   errcode := FSWrite_err(FileRefNum, Bytecount, @CL_Output^^.conc[1],'conc');	   errcode := FSWrite_err(FileRefNum, Bytecount, @CL_Output^^.stdev[1],'stdev');	   errcode := FSWrite_err(FileRefNum, Bytecount, @CL_Output^^.thickness[1],'thickness');	   errcode := FSWrite_err(FileRefNum, Bytecount, @CL_Output^^.valence[1],'valence');	   errCode := FSClose(FileRefNum);	   errCode := FlushVol(NIL, Hall_vol);	  		  if CL_OutPut <> NIL then	  begin			H_UnLock_Dispose(Handle(CL_OutPut),'CL_OutPut xx');	  end;  END;	{Procedure WriteToCL;...}  PROCEDURE AsciiCLResults;  VAR	n,nn,theVol               			: integer;   CLPlainName							: fnamestr;   fndrInfo                     		: FInfo;   errcode							 	: OSerr;   theDirID								: longint;   str,str1,str2,str8					: str255;   theVName								: str31;   						   		Procedure writeCL_Text; {writes the quant results for one anal_res}		VAR		   nn					:integer;		   ox_fract				: array[1..maxnumpks] of real;		   Stoic, Oxides			: boolean;			BEGIN		IF  CL_Output^^.BaseInfo.Ox_by_Stoic then Stoic := true		else Stoic := false;		IF  CL_Output^^.BaseInfo.Report_oxides then oxides := true		else oxides := false;				WITH CL_Output^^ do begin			 nn := BaseInfo.number_of_peaks + 1; 					 LineInfo[nn].Z_Number := BaseInfo.Base_Z;					 LineInfo[nn].line := BaseInfo.Base_line;					 LineInfo[nn].evloline := BaseInfo.base_loev;					 LineInfo[nn].evHiline := BaseInfo.base_hiev;			 IF  Stoic then			 begin 	{there is no LineInfo for Ox by stoic in the binary file so set it}				nn := BaseInfo.number_of_peaks + 2;				  LineInfo[nn].Z_Number := 8;				  LineInfo[nn].line := 'K';				  LineInfo[nn].evloline := 522.950;				  LineInfo[nn].evHiline := 522.950;			 end;			 IF  oxides then			 for nn := 1 to BaseInfo.number_of_peaks + 1 do			 begin			 	ox_fract[nn] := conc[nn] * (1.0 + 8.0 * valence[nn]/At_Wt^^.Value[LineInfo[nn].Z_Number]);			 end;			 str := ' ';			 writeln(Plain, Str);			 {numtostring(spectnum,str);}			 str1 := StringOf(CL_Output^^.spectnum);			 str := concat('Results for ',DTSAName,' spectrum #',str1,' ', class,': ',CL_Output^^.SpecID);			 writeln(Plain, Str);			 str:=' ';			 realtostring(BaseInfo.relative_error,3,1,str1);			 str := concat('Thickness reported for relative error in concentration of ',str1,'% due to absorption.');			 writeln(Plain, Str);			 str:=' ';			 if oxides then str := '   Family    Low Line ev    High Line ev      area     WtFract  OxideFract   thickness(nm) '			 else str := '   Family    Low Line ev    High Line ev      area     WtFract    thickness(nm) ';			 writeln(Plain, Str);			 str:='';			 nn := BaseInfo.number_of_peaks + 1; 			 str:=concat('   ',A^.Sym[LineInfo[nn].Z_Number],LineInfo[nn].line);			 if oxides then writeln(Plain,str, LineInfo[nn].evloline:16:1, LineInfo[nn].evhiline:14:1,area[nn]:16:1,Conc[nn]: 10:4,ox_fract[nn]: 10:4,(thickness[nn]*1e7):15 :1) 			 else           writeln(Plain,str, LineInfo[nn].evloline:16:1, LineInfo[nn].evhiline:14:1,area[nn]:16:1,Conc[nn]: 10:4, (thickness[nn]*1e7):15:1); 			 str:=' ';			 for nn := 1 to BaseInfo.number_of_peaks do begin			   str:=concat('   ',A^.Sym[LineInfo[nn].Z_Number],LineInfo[nn].line);			   if oxides then writeln(Plain,str, LineInfo[nn].evloline:16:1, LineInfo[nn].evhiline:14:1,area[nn]:16:1,Conc[nn]: 10:4, ox_fract[nn]: 10:4,(thickness[nn]*1e7):15:1) 			   else writeln(Plain,str, LineInfo[nn].evloline:16:1, LineInfo[nn].evhiline:14:1,area[nn]:16:1,Conc[nn]: 10:4, (thickness[nn]*1e7):15:1); 			  str:=' ';			 end;	{ for nn := 1...}								IF  BaseInfo.Ox_by_Stoic then				begin 	{there is no LineInfo for Ox by stoic in the binary file so set it}				   nn := BaseInfo.number_of_peaks + 2;				   str:=concat('   ',A^.Sym[LineInfo[nn].Z_Number],LineInfo[nn].line);				    if oxides then writeln(Plain,str, LineInfo[nn].evloline:16:1, LineInfo[nn].evhiline:14:1,area[nn]:16:1,Conc[nn]: 10:4, (thickness[nn]*1e7):25:1) 					else writeln(Plain,str, LineInfo[nn].evloline:16:1, LineInfo[nn].evhiline:14:1,area[nn]:16:1,Conc[nn]: 10:4, (thickness[nn]*1e7):15:1); 				   str:=' ';			    end;	{ IF BaseInfo.Ox_by_Stoic...}		END;	{ WITH CL_Output^^ ...}	 END;	{ procedure writeCL_Text; }		Procedure read_CLData;		  Begin {Read DTSAname, spectnum, Class, number_of_peaks + 1 or + 2 * results...}		     bytecount := 20;			 errcode := FSRead(FileRefNum,Bytecount,@CL_OutPut^^.SpecID);		     bytecount := 2 * sizeof(str_25) + sizeof(integer);			 errcode := FSRead(FileRefNum,Bytecount,@CL_OutPut^^.DTSAname);			 IF errcode = noerr then			 begin				{Read area...then conc...}				IF  CL_Output^^.BaseInfo.Ox_by_Stoic then				     Bytecount := (CL_OutPut^^.BaseInfo.number_of_peaks + 2) * sizeof(real)				Else Bytecount := (CL_OutPut^^.BaseInfo.number_of_peaks + 1) * sizeof(real);				errcode := FSRead(FileRefNum,Bytecount,@CL_OutPut^^.area[1]);				errcode := FSRead(FileRefNum,Bytecount,@CL_OutPut^^.conc[1]);				errcode := FSRead(FileRefNum,Bytecount,@CL_OutPut^^.stdev[1]);				errcode := FSRead(FileRefNum,Bytecount,@CL_OutPut^^.thickness[1]);				errcode := FSRead(FileRefNum,Bytecount,@CL_OutPut^^.valence[1]);		     end;	{IF errcode = noerr...}(*realtostring(CL_OutPut^^.conc[CL_OutPut^^.BaseInfo.number_of_peaks+1],1,5,str);putmessage('in read_CLData conc[base]] is',str,'','');*)		  End;	{Procedure read_CLData...}    BEGIN	{ PROCEDURE AsciiClResults;}   { have str,str1,str2,str8					: str255;}		if (CL_Output = NIL) then		begin		  ReserveMem(sizeof(CL_outstuff));		  if MemError = memFullErr then Bag_the_Program;		  CL_Output := CLOutHdl(NewHandle(sizeof(CL_outstuff)));		  HLock(Handle(CL_Output));		end;        if show_one then begin			CLPlainName := 'OneCL_Ascii';	{this is written over each time}			errcode := GetVol(Save_Volume_Name,show_Vol);{keep track of current vol}		end		else begin			CLPlainName := concat(showname,'_ASCii');			errcode := GetVol(Save_Volume_Name,save_vol);{keep track of current vol}			errcode := setvol(nil,Show_Vol); {only way to specify the vol for Plain}			{Open the binary file...}			errCode := FSOpen_err(showname,show_Vol, FileRefNum,'');			{read BaseInfo and ResultsName...}			bytecount:=sizeof(CL_BaseStuff);			errcode := FSRead(FileRefNum,Bytecount,@CL_OutPut^^);			{in the quant stuff, we make CL_LineStuff for Base and Oxygen but we don't			 write it to the binary file; there are only areas, etc for base and Oxygen by stoic}		(*	IF  CL_OutPut^^.BaseInfo.Ox_by_Stoic then			     bytecount:=  (CL_OutPut^^.BaseInfo.number_of_peaks + 2) * sizeof(CL_LineStuff)			ELSE bytecount:=  (CL_OutPut^^.BaseInfo.number_of_peaks + 1) * sizeof(CL_LineStuff);		*)				bytecount:=  (CL_OutPut^^.BaseInfo.number_of_peaks) * sizeof(CL_LineStuff);			{number_of_peaks * LineInfo is written to binary: we know base LineInfo and			 if Ox by stoic the values for Ox LineInfo} 			errcode := FSRead(FileRefNum,Bytecount,@CL_OutPut^^.LineInfo);			bytecount:=sizeof(integer) + sizeof(CL_OutPut^^.ResultsName) + sizeof(longint);			errcode := FSRead(FileRefNum,Bytecount,@CL_OutPut^^.ResultsVNum);			{...reads ResultsVNum, ResultsName, and ResultsDirId: · = 63 bytes}		end;				Rewrite(Plain, CLPlainName);	{ plain:text}        Rewrite(Plain);		        fndrInfo.fdcreator := 'MSWD';        fndrInfo.fdtype := 'TEXT';        fndrInfo.fdFlags := 0 {100};                                errCode := setfinfo(CLplainname, show_Vol, fndrInfo);	        Str := CONCAT('           ', CLPlainName);        writeln(Plain, Str);		str:=' ';		    theVol := show_Vol;			Get_WDInfo(theVName,theDirID,theVol); {in Utilities}			{...returns theVName,theDirID, and the Volume ref num in theVol}			Get_CreationDate(showname,theDirID,theVol);	{...defines theDateTime, a global}			str8:= DTRec2Str;			  IF (theDateTime.hour) >= 12 THEN str8 := CONCAT('           ',str8, ' pm')			  ELSE str8 := CONCAT('           ',str8, ' am');        writeln(Plain, Str8);		str:=' ';        writeln(Plain, Str);	    		WITH CL_Output^^,Baseinfo do begin		  if Kfitproc = 'ML' then		    str := 'C-L quant of ML fit results '		  else str := 'C-L quant of Simplex fit results ';		  str := concat(str,' ',CL_OutPut^^.ResultsName);		  writeln(Plain, Str);		  realtostring(base_loev,4,0,str1);		  realtostring(base_hiev,4,0,str2);		  str := concat('K factors are relative to ',a^.sym[Base_Z],Base_Line,' lines from ',str1,' ev to ',str2,' ev.');		  writeln(Plain, Str);		  				  n := 1;		 Repeat		  str8:=' ';		  str:= concat('From file ',CL_OutPut^^.BaseInfo.K_files[n],', K factors are');		  for nn := 1 to CL_OutPut^^.BaseInfo.number_of_peaks do begin		   if (CL_OutPut^^.LineInfo[nn].fileIndex = n) then begin		      str2:='';		      str1:='';			  str2:= concat(a^.sym[CL_OutPut^^.lineInfo[nn].Z_number],CL_OutPut^^.lineInfo[nn].line);			  realtostring(CL_OutPut^^.LineInfo[nn].KFactor,4,1,str1);			  str:= concat(str,str8, str1,' for ',str2);			  str8:=', ';(*putmessage(str,'','','');*)			end;	{ if (Std_File_Code...}		  end;	{for nn...}          writeln(Plain, Str);		  n := n+1;		  str:=' ';		Until ((CL_OutPut^^.BaseInfo.K_files[n] = ' ') or (n = 10));	 END;	{ WITH CL_OutPut^^,BaseInfo...}    writeln(Plain);	IF (show_one) THEN	BEGIN {only if doing one work spectrum}		writeCL_text;		writeln(Plain);		writeln(Plain);        writeln(Plain, '	***	USE "ADD FIT" to APPEND THESE DATA TO THE CL FILE *** ');    	{¥¥¥Do NOT Throw away CL_OutPut IF (show_one)!!!¥¥¥}	END	ELSE BEGIN	  REPEAT	  	Read_CLData;		if errcode = noerr then writeCL_text;	  UNTIL (errcode = EOFErr);	   errCode := FSClose(FileRefNum);	   errCode := FlushVol(NIL, Show_Vol);	  if CL_OutPut <> NIL then	  begin	{¥¥¥Do NOT Throw away IF (show_one)!!!¥¥¥}			H_UnLock_Dispose(Handle(CL_OutPut),'CL_OutPut xx');	  end;	END;	{ELSE BEGIN}	   Close(Plain);       errcode := setvol(Save_Volume_Name,save_vol);				ReviewFitResults(CLPlainName,Show_Vol);	(*	errcode := FSDelete(CLPlainName,Show_Vol);*)  		Mouse_Active_Window;  END;	{ PROCEDURE AsciiCLResults...}    PROCEDURE CLResults(only_one:boolean);{called from Add_a_Fit in SiliWin and show_CL in menus}  BEGIN	{ CLResults; }      If (only_one) then   Begin	   show_one := true;	   AsciiCLResults;		{shows data in current CL_Output^^}   End   Else Begin	   mytype := 'MCAo';	   myprompt := 'Show CL File';	  Repeat	  Until (GetFileName(showname, mytype, mytype, myprompt) = True) OR 			(File_Cancel_Button = False);  {open => T; cancel => F}	   IF (File_Cancel_Button) then	   Begin		   show_vol:= In_VolRefNum;		   show_one := false;  	       AsciiCLResults; {reads a file into CL_Output^^ if not show_one}	   End;   End;	{Else Begin}  END;	{ CLResults; }  		PROCEDURE Get_ValidPeak(Line_indek:integer; ZConst:real {double_t});	VAR		hold, i				 	:integer;	    theWeight,theYield		: real {double_t};		theEdge					: real;			  PROCEDURE Thin_Dependent_Peak_Gen(Pk_eV, Pk_Wt: Real; ParentLine: integer);      BEGIN        Valid_Peak := Valid_Peak + 1;        Line_Energy^[Valid_Peak] := Pk_eV;		if ParentLine <> 0 then       		Generated^[Valid_Peak] := Pk_Wt * Generated^[ParentLine]		else            Generated^[Valid_Peak] := Pk_Wt * Ql(Thin_KV, theEdge) * theYield *			  						  theWeight * ZConst;      END; { Procedure Thin_Dependent_Peak_Gen; }	PROCEDURE Get_the_Peak(indx, L_indek : integer);		BEGIN		With CL_OutPut^^ do		begin					IF (eV_Line[indx] >= LineInfo[Line_indek].evloLine) AND			   (eV_Line[indx] <= LineInfo[Line_indek].evhiLine) THEN			  Thin_Dependent_Peak_Gen(eV_Line[indx], Wt_Line[indx], Hold);		end;		END;	{PROCEDURE Get_the_Peak}		BEGIN	{ PROCEDURE Get_ValidPeak(Line_indek:integer);...}		With CL_OutPut^^ do		begin		  IF LineInfo[Line_indek].line = 'K' then		  BEGIN		   theWeight := SAK(A^.Thin_At_Num[Line_indek]);		   theYield := WK(A^.Thin_At_Num[Line_indek]);			IF (eV_Line[1] >= LineInfo[Line_indek].evloLine) AND			   (eV_Line[1] <= LineInfo[Line_indek].evhiLine) THEN			  BEGIN				Valid_Peak := Valid_Peak + 1;				Line_Energy^[Valid_Peak] := eV_Line[1];  				Generated^[Valid_Peak] := (Wt_Line[1] / (Wt_Line[1] + Wt_Line[2])) * Qk(Thin_KV, A^.edge[1]) *										  WK(A^.Thin_At_Num[Line_indek]) * SAK(A^.Thin_At_Num[Line_indek]) * ZConst;  			   Hold := Valid_Peak;			  END;  						IF (eV_Line[2] >= LineInfo[Line_indek].evloLine) AND			   (eV_Line[2] <= LineInfo[Line_indek].evhiLine) THEN			  BEGIN				Valid_Peak := Valid_Peak + 1;				Line_Energy^[Valid_Peak] := eV_Line[2];				Generated^[Valid_Peak] := Wt_Line[2] * Generated^[Hold];			  END;  			IF (eV_Line[3] >= LineInfo[Line_indek].evloLine) AND			   (eV_Line[3] <= LineInfo[Line_indek].evhiLine) THEN			  BEGIN				Valid_Peak := Valid_Peak + 1;				Line_Energy^[Valid_Peak] := eV_Line[3];				Generated^[Valid_Peak] := Wt_Line[3] * Generated^[Hold] * (1 + Wt_Line[2]) / (1 - Wt_Line[3]);			  END;			  			  theEdge := A^.edge[1];			  FOR i := 4 to 5 do			  	Get_the_Peak(i, Line_indek);			  			  END;	{ IF LineInfo[Line_indek].line = 'K'...}		  IF LineInfo[Line_indek].line = 'L' then		  BEGIN			theWeight := SAL(A^.Thin_At_Num[Line_indek]);			theYield := WL(A^.Thin_At_Num[Line_indek]);			IF (eV_Line[42] >= LineInfo[Line_indek].evloLine) AND			   (eV_Line[42] <= LineInfo[Line_indek].evhiLine) THEN			  BEGIN				Valid_Peak := Valid_Peak + 1;				Line_Energy^[Valid_Peak] := eV_Line[42];				Generated^[Valid_Peak] := Wt_Line[42] * Ql(Thin_KV, A^.edge[4]) *										  WL(A^.Thin_At_Num[Line_indek]) * SAL(A^.Thin_At_Num[Line_indek]) * ZConst;				Hold := Valid_Peak;			  END;		  		  theEdge := A^.edge[4];			  	Get_the_Peak(43, Line_indek);			  	Get_the_Peak(45, Line_indek);			  	Get_the_Peak(46, Line_indek);			  	Get_the_Peak(48, Line_indek);			  	Get_the_Peak(49, Line_indek);		    		  theEdge := A^.edge[3];			  	Get_the_Peak(29, Line_indek);			  	Get_the_Peak(31, Line_indek);			  	Get_the_Peak(32, Line_indek);			  	Get_the_Peak(35, Line_indek);			  	Get_the_Peak(24, Line_indek);  		  theEdge := A^.edge[2];			FOR i := 11 to 16 do 			  	Get_the_Peak(i, Line_indek);			  	Get_the_Peak(18, Line_indek);					  END;	{ IF LineInfo[Line_indek].line = 'L'...}		  IF LineInfo[Line_indek].line = 'M' then		  BEGIN			theWeight := SAM(A^.Thin_At_Num[Line_indek]);			theYield := WM(A^.Thin_At_Num[Line_indek]);			IF (eV_Line[72] >= LineInfo[Line_indek].evloLine) AND			   (eV_Line[72] <= LineInfo[Line_indek].evhiLine) THEN			  BEGIN				Valid_Peak := Valid_Peak + 1;				Line_Energy^[Valid_Peak] := eV_Line[72];				Generated^[Valid_Peak] := (Wt_Line[72] + Wt_Line[73])/2 *								 Qm(Thin_KV, A^.edge[9]) * WM(A^.Thin_At_Num[Line_indek]) * SAM(									A^.Thin_At_Num[Line_indek]) * ZConst; {ZConst:=(Domega * Thin_Physics_Constant / Pi4) *																		  (CL_Output^^.conc[Line_indek] / Atomic_Weight)}  				Hold := Valid_Peak;			  END;							theEdge := A^.edge[9];			  	Get_the_Peak(74, Line_indek);				 	   				theEdge := A^.edge[8];				FOR i := 69 to 70 do 				  	Get_the_Peak(i, Line_indek);								theEdge := A^.edge[7];			  	Get_the_Peak(61, Line_indek);				FOR i := 63 to 66 do 				  	Get_the_Peak(i, Line_indek);	   				theEdge := A^.edge[6];				FOR i := 56 to 57 do 				  	Get_the_Peak(i, Line_indek);	   				theEdge := A^.edge[5];				FOR i := 53 to 54 do 				  	Get_the_Peak(i, Line_indek);         		  END;	{IF LineInfo[Line_indek].line = 'M'...}		end;	{With CL_OutPut^^...}	End;	{Get_ValidPeak}					Procedure Get_MaxThickness;		Var		  cscTheta,rel_error              : Real;		  Rho_T                         : Real;		  WithAbs,TotalGenerated		: real;		  indek,nn,Z,J, npks			: integer;		  aZConst			    	    : real {double_t};		  		  BEGIN	{we made LineInfo for base and Ox if by stoic in the quant...this is NOT		         written to the binary file}	        rel_error := 1.0 - 0.01 * CL_BsSetup^^.relative_error;		    			if CL_BsSetup^^.Ox_by_Stoic then npks := CL_BsSetup^^.number_of_peaks + 2			else npks := CL_BsSetup^^.number_of_peaks + 1;						Xray_Data_Request := true;			thin_KV := analysis_result^^.ExptStuff.kV;			cscTheta := 1 / Sin(analysis_result^^.SpectrumStuff.spectrum_info.Take_Off_Angle / 57.295779);				FOR indek := 1 to npks Do			With CL_OutPut^^ do			begin			  A^.Thin_At_Num[indek] := LineInfo[indek].Z_number;			  Get_Energies(A^.Thin_At_Num[indek]); { get atomic weight, atomic rho, line energies etc. }			  Z := LineInfo[indek].Z_number;			  aZConst := conc[indek] / Atomic_Weight;			  Valid_Peak := 0;			  Get_ValidPeak(indek,aZConst);			  CL_OutPut^^.thickness[indek] := 0.0; {in cm} 		  			  {calculate the Mu_over_Rho due to all elements in the specimen at the channel of each			   valid peak from element indek...}				IF Valid_Peak > 0 then begin		{¥¥Added to skip oxygen by stoichiometry¥¥ 2/22/97}				TotalGenerated := 0.0;				FOR J := 1 TO Valid_Peak DO 				BEGIN				  mu_rho_P^[J] := 0.0; { At each channel get the mass absorption coefficient }				  FOR nn := 1 to npks DO				  WITH CL_OutPut^^,LineInfo[nn] DO				  BEGIN					  Get_Energies(Z_number); { get edge energies etc. }					  mu_rho_P^[J] := MassAbsCoeff(Line_Energy^[J], Z_number) * conc[nn] +  									 mu_rho_P^[J]; {...for Valid_Peak}				  END;				  				  TotalGenerated := TotalGenerated + Generated^[J];				END;	{ FOR J := 1 TO Valid_Peak DO...}					{¥¥¥There is a problem in this area whenever we do oxygen by stoichiometry¥¥¥}								Repeat				  CL_OutPut^^.thickness[indek] := CL_OutPut^^.thickness[indek] + 0.000001; {100 angstroms} 				  Rho_T := analysis_result^^.SpectrumStuff.Spectrum_info.Specimen_Density *						   CL_OutPut^^.thickness[indek];				  WithAbs := 0.0;				  FOR J := 1 TO Valid_Peak DO 					WithAbs :=  Generated^[J] * exp( - mu_rho_P^[J] * Rho_T  * cscTheta) +								WithAbs;									Until WithAbs/TotalGenerated <= rel_error;				END;	{IF Valid_Peak > 0}			end;	{ FOR indek := 1 to nn...}	 		END;	{Procedure Get_MaxThickness}	   PROCEDURE Do_CL_Quant;	   Var	  theConc,base_area,base_valence				: real;	  theZ,indeK,zindeK,n							: integer;      sumcov,AbyVox,BbyOx,theOxConc,	  OnePlusBbyOx,BOnePlusBbyOx			     	: real {double_t};	  std						: real {double_t};	  OnePlus					: array[1..MaxNumPks] of real {double_t};	  num_to_do					: longint;	  go_on						: boolean;	  KLorM						: STRING[1];   BEGIN{ Do_CL_Quant: was called from Do_a_fit only; Do_a_fit called from SiLi and Batch.		  In Sili, data only written to binary if add_a_fit called but		  CLResults - screen output - called for each fit; in batch, data written after each		  fit...CANNOT throw CL_Output away here!!!		  Now called from Quant_the_Fit as well.}	if (CL_Output = NIL) then	begin	  ReserveMem(sizeof(CL_outstuff));	  if MemError = memFullErr then Bag_the_Program;	  CL_Output := CLOutHdl(NewHandle(sizeof(CL_outstuff)));	  HLock(Handle(CL_Output));	end;		WITH Analysis_result^^,ExptStuff,SpectrumStuff,Spectrum_Info,Fit_Params,Fit_Result	DO BEGIN		   str := 'found';		   go_on := true;		   with CL_Output^^ do begin		   	spectnum	:=	spectrum_number;           	DTSAname	:=	'';           	Class	:=	'';			SpecID := '';			BlockMove(@MCA_filename,@DTSAname,sizeof(DTSAname));			IF Spectrum_Comment_Field = '' THEN SpecID := 'No Comments'			ELSE if Length(Spectrum_Comment_Field) > 19 then				SpecID := copy(Spectrum_Comment_Field,1,19)			ELSE SpecID := Spectrum_Comment_Field;           	Class	:=	Spectrum_class;		   end;	{with...}		   index :=0;		   base_area := 0.0;		   base_valence := 0.0;		   theZ := 0;	      for n := 1 to MaxNumPks do conc[n] := 0.0;		  {...in case there was a previous quant}		 {In general, the analysis res file that is being read defined the CL_Setup.		  But if a saved setup file is used the order of the peaks in this		  analysis_result and the setup file may not be the same...hence the search loop}		  		 {CL_BsSetup^^^^.Number_of_Peaks will equal the number of elements in the anal_res for		  which k factors are found not the total number of lines in anal_res.}		   		   {Find the base element data...}		   indek := 0;		   found := false;		   Repeat		     indek := indek + 1;		     KLorM :=Siegbahn[indek][1];		     If ((Atomic_Number[indek] =  CL_BsSetup^^.Base_Z) and			 	 ( CL_BsSetup^^.Base_Line = KLorM)) then			 begin				if ((CL_BsSetup^^.Kfitproc = 'ML') and					(ev_loLine[indek] =  CL_BsSetup^^.base_loev) and					(ev_hiLine[indek] =  CL_BsSetup^^.base_hiev)) then				begin						base_area := area[indek];						conc[indek] := 1.0;	{shows line was used in quant}						found := true;				end				Else if ((CL_BsSetup^^.Kfitproc = 'Sm') and						 (ev_loLine[indek] <=  CL_BsSetup^^.base_loev) and						 (ev_hiLine[indek] >=  CL_BsSetup^^.base_hiev)) then				begin				  zindek := indek;				  while				   ((indek <= Number_of_Peaks) and 					(ev_loLine[indek] = ev_loLine[zindek]) and					(ev_hiLine[indek] = ev_hiLine[zindek])) do				  begin					  if ((err_or_energy[indek] * 1000 >=  CL_BsSetup^^.base_roi_lo) and						  (err_or_energy[indek] * 1000 <=  CL_BsSetup^^.base_roi_hi)) 					  then begin					  	base_area := area[indek] + base_area;						conc[indek] := 1.0;	{shows line was used in quant}					  end;					  indek := indek + 1;				  end;				 found := true;				end;	{ Else if ((CL_BsSetup^^...}			 end;	{ If ((Atomic_Number[indek] =...}		   Until (found or (indek = Number_of_Peaks));	{Analysis_result^^...Number_of_Peaks}		   		  		   If found and (( CL_BsSetup^^.Report_oxides) or ( CL_BsSetup^^.Ox_by_Stoic)) then		   BEGIN			 zindek := 0;			 Base_Valence := 0.0;			 {find the Base Valence info in SpectrumStuff.element_info...			  this does NOT have the same index as the spectrum_info index!!!}			 Repeat				 zindek := zindek + 1;				 if (element_info[zindek].Atomic_number =  CL_BsSetup^^.Base_Z) then					Base_Valence := element_info[zindek].Valence;			 Until (element_info[zindek].Atomic_number =  CL_BsSetup^^.Base_Z) or				   (zindek = Number_of_elements);			 if (Base_Valence < 1.0) or (Base_Valence > 10.0) then found := false;			 go_on:= found;		   END;	{If found and ((Report_oxides)...}		   		   BlockMove(@CL_BsSetup^^,@CL_OutPut^^.BaseInfo,sizeof(CL_BaseStuff));		  		  IF (not found) THEN		  BEGIN		     str := concat(a^.sym[ CL_BsSetup^^.Base_Z],CL_BsSetup^^.Base_Line);			 if (not is_batch) then			 begin			   if go_on then putmessage('The analysis result either has no data for the base',str,'or the lines fit are different.','')			   else putmessage('Can`t do oxides. There is no Valence info for ',str,'','');		     end;		  END		  ELSE BEGIN	{if base z found...do the other lines...go_on is still true}			indek := 0;			REPEAT {find the anal_res info for each line to quant...}			 found := false;			 indek := indek + 1;			 index := 0;			 CL_Output^^.area[indeK] := 0.0;			   Repeat	{we're in a WITH Analysis_result^^...}				index := index + 1;				KLorM :=Siegbahn[index][1];				If (( Atomic_Number[index] = CL_Setup[indeK]^^.Z_number) and					(CL_Setup[indeK]^^.Line = KLorM)) then				Begin				 If ((CL_BsSetup^^.Kfitproc = 'ML') and (ref_index[index] < 1)) or				    ((CL_BsSetup^^.Kfitproc = 'Sm') and (ref_index[index] < 0))				 then begin	{the line should be fit , but isn't}				      found := true;				      str := concat(A^.Sym[CL_Setup[indeK]^^.Z_Number],							   CL_Setup[indeK]^^.line,' is not in this anal res.');					  CL_Output^^.area[indeK] := area[index];					  CL_Output^^.stdev[indeK] := 0.0;					  CL_Output^^.Valence[indeK] := 0.0;				 end				 Else if ((CL_BsSetup^^.Kfitproc = 'ML') and				          (ev_loLine[index] = CL_Setup[indeK]^^.evloLine) and					      (ev_hiLine[index] = CL_Setup[indeK]^^.evhiLine)) then				 begin					 CL_Output^^.area[indeK] := area[index]; {...analysis_result value}					 CL_Output^^.stdev[indeK] := 0.0;				     found := true;				 end	{ If...}				 Else if ((CL_BsSetup^^.Kfitproc = 'Sm') and				          (ev_loLine[index] <= CL_Setup[indeK]^^.evloLine) and						  (ev_hiLine[index] >= CL_Setup[indeK]^^.evhiLine)) then				 begin				 {¥¥¥err_or_energy is a fit KV value converted to a calibrated value...				  evloLine, evloRoi, etc are calibrated values too...and should be close				  to correct energies}	                     zindek := index;			     	 repeat	{index to next family or end of families}						if ((err_or_energy[index] * 1000 >= CL_Setup[indeK]^^.evloRoi) and							(err_or_energy[index] * 1000 <= CL_Setup[indeK]^^.evhiRoi)) 						then begin							CL_Output^^.area[indeK] := CL_Output^^.area[indeK] + area[index];							conc[index] := 1.0;	{anal_res value...indicates line used in quant}					    end;	{if ((err...}						index := index + 1; {...index reset to 0 for each new Z line so this IS ok}					 until (index > Analysis_result^^.Fit_params.Number_of_Peaks) or					       ((ev_loLine[index] <> ev_loLine[zindek]) and					        (ev_hiLine[index] <> ev_hiLine[zindek]));					 found := true;					 go_on := true;				  end;	{ Else...}				End;	{ if (( Atomic_Number[index] =...index ends at # of line for next Z}			  Until  ( found ) or ( index >= Analysis_result^^.Fit_params.Number_of_Peaks );			  			  If found then If (CL_BsSetup^^.Report_oxides) or (CL_BsSetup^^.Ox_by_Stoic) then			  Begin	{find the right Spectrumstuff.element_info...}				zindek := 0;				CL_Output^^.valence[indeK] := 0.0;				Repeat					zindek := zindek + 1;					if (element_info[zindek].Atomic_number = CL_Setup[indeK]^^.Z_Number) then					   CL_Output^^.valence[indeK] := element_info[zindek].Valence;				Until (element_info[zindek].Atomic_number = CL_Setup[indeK]^^.Z_Number) or					  (zindek = Number_of_elements);			    if (CL_Output^^.valence[indeK] < 1.0) or				   (CL_Output^^.valence[indeK] > 10.0) then found := false;				go_on := false;			 			  End;	{If found then  If (Report_oxides)...}			  IF (not found) and (not is_batch) THEN			  BEGIN				 str := concat(a^.sym[CL_Setup[indeK]^^.Z_Number],CL_Setup[indeK]^^.line);				   if go_on then putmessage('The analysis result either has no data for the base',str,'or the lines fit are different.','')				   else putmessage('Can`t do oxides. There is no Valence info for ',str,'','');			  END;			UNTIL (not found) or (indek = CL_BsSetup^^.number_of_peaks);		  END;	{If base z found...}	 IF not found then 	 WITH CL_Output^^ do 	 BEGIN	      If CL_BsSetup^^.Ox_by_Stoic then zindek := CL_BsSetup^^.number_of_peaks + 2		  else zindek := CL_BsSetup^^.number_of_peaks + 1;		  For indek := 1 to zindek do		  Begin			   area[indek] := 0.0;			   stdev[indek] := 0.0;			   valence[indek] := 0.0;			   conc[indek] := 0.0;			   thickness[indeK] := 0.0;			   if indek <= CL_BsSetup^^.number_of_peaks then			     blockmove(@CL_Setup[indek]^^,@CL_OutPut^^.LineInfo[indek],sizeof(CL_LineStuff));		  End;	{FOR...}	 END	{IF not found...WITH...}	 ELSE BEGIN	{if found...begin quant}  	 	 	  IF  CL_BsSetup^^.Ox_by_Stoic then	  BEGIN 	    AbyVox := 8.0; { At_Wt^^.Value[8] / 2.0;}		BbyOx := (8.0 * base_valence)/At_Wt^^.Value[CL_BsSetup^^.Base_Z];		OnePlusBbyOx := 1.0 + BbyOx;		BOnePlusBbyOx := base_area * OnePlusBbyOx;		FOR n := 1 TO CL_BsSetup^^.number_of_peaks DO		Begin		  OnePlus[n] := 1.0  + 					  (AbyVox * CL_Output^^.valence[n])/At_Wt^^.Value[CL_Setup[n]^^.Z_Number];				End;	  END;	     Ydata := WindowArrayHdl(NewHandle(sizeof(WindowArray)));	MoveHHi(Handle(Ydata));	HLock(Handle(Ydata));	FOR n := 1 TO max_fitting_chans DO Ydata^^[n] := 0.0;	 	  FOR indek := 1 to CL_BsSetup^^.number_of_peaks do	  BEGIN		{ solving set of eqns WFi[Areab/(Kib*Areai) + 1] + ·WFj...j<>i = 1 for all WFk;		 the coefficients are 1 for all terms except the diagonal terms in the series of		 eqns. There the coefficient is the [...]. }	   		If  CL_BsSetup^^.Ox_by_Stoic then 		Begin		  (* FOR indek := 1 TO CL_BsSetup^^.number_of_peaks DO		   	 Ydata^^[n] := OnePlus[n];	{1 + Valn/An * Aox/Valox}	*)		   Ydata^^[indek] := OnePlus[indek] * 		   							(CL_Output^^.area[indek] * CL_Setup[indek]^^.KFactor); 		End		{If  CL_BsSetup^^.Ox_by_Stoic ...}		Else Begin		  (* FOR n := 1 TO CL_BsSetup^^.number_of_peaks DO Ydata^^[n] := 1.0;		   Ydata^^[indek] := base_area/(CL_Output^^.area[indek]*CL_Setup[indek] ^^.KFactor) + 1.0;		  *) 		   Ydata^^[indek] := (CL_Output^^.area[indek] * CL_Setup[indek] ^^.KFactor);		end;			  END;	{ FOR indek := 1 to CL_BsSetup^^.number_of_peaks...}	  	 	    n := CL_BsSetup^^.number_of_peaks + 1; 	If  CL_BsSetup^^.Ox_by_Stoic then 	Begin	  (* FOR indek := 1 TO CL_BsSetup^^.number_of_peaks DO	   	 Ydata^^[n] := OnePlus[n];	{1 + Valn/An * Aox/Valox}	*)	    theConc := BOnePlusBbyOx; {the base term in the ·}       FOR indek := 1 TO CL_BsSetup^^.number_of_peaks DO			theConc := theConc + Ydata^^[indek]; {the base term + others, not O}	End		{If  CL_BsSetup^^.Ox_by_Stoic ...}    ELSE Begin         theConc := base_area;          FOR indek := 1 TO CL_BsSetup^^.number_of_peaks DO			theConc := theConc + Ydata^^[indek]; {the base term + others, not O}	End;	{If  CL_BsSetup^^.Ox_by_Stoic then...ELSE Begin...}	    CL_Output^^.conc[n] := base_area / theConc;{...the base wtf}		theConc := CL_Output^^.conc[n]; {base conc}		 	    H_UnLock_Dispose(Handle(Ydata),'Ydata in CLQuant');		theOxConc := 0.0;		FOR indek := 1 to CL_BsSetup^^.number_of_peaks Do		begin			CL_Output^^.conc[indek] := 0.0;			CL_Output^^.stdev[indek] := 0.0;	{someday we'll put something here}						If  CL_BsSetup^^.Ox_by_Stoic then			begin { from base wtF calc others except O}				CL_Output^^.conc[indek] := (CL_Output^^.conc[n]/base_area) *											CL_Output^^.area[indek] * CL_Setup[indek] ^^.KFactor;				theConc := theConc + CL_Output^^.conc[indek]; {· concs not inc Ox}			end			else begin				CL_Output^^.conc[indek] := (CL_Output^^.conc[n]/base_area) *											CL_Output^^.area[indek] * CL_Setup[indek] ^^.KFactor;				theConc := theConc + CL_Output^^.conc[indek];{· concs}			end;			blockmove(@CL_Setup[indek]^^,@CL_OutPut^^.LineInfo[indek],sizeof(CL_LineStuff));			 index := 0;			 found := false;			 Repeat				index := index + 1;				KLorM :=Siegbahn[index][1];		        If (( Atomic_Number[index] = CL_OutPut^^.LineInfo[indek].Z_number) and					( CL_OutPut^^.LineInfo[indek].line = KLorM)) then				begin				    found := true;					While (index <= Fit_params.Number_of_Peaks) and						  (Atomic_Number[index] = CL_OutPut^^.LineInfo[indek].Z_number) do					begin						{if 1.0, the line was used in the quant...put in calc'd conc}						if conc[index] = 1.0 then conc[index] := CL_Output^^.conc[indek];						index := index + 1;					end;				end;			 Until (found) or (index = Fit_params.Number_of_Peaks);		end;	{FOR indek := 1 to CL_BsSetup^^...}				{This part does the Base element...the value of indek for the base is always 		 CL_BsSetup^^.number_of_peaks + 1; for Ox,indek = number_of_peaks + 2;}		indek := CL_BsSetup^^.number_of_peaks + 1;	{indek for the base element}		 With CL_Output^^ do		 Begin			area[indek] := base_area;						valence[indek] := base_valence;						stdev[indek] := 0.0;			{make LineInfo for base and Ox if by stoic for Get_MaxThickness convenience...			 there is no LineInfo in the binary file for these two elements!!!}			LineInfo[indek].Z_number := CL_BsSetup^^.Base_Z;			LineInfo[indek].line := CL_BsSetup^^.Base_line;			LineInfo[indek].evloline := BaseInfo.base_loev;			LineInfo[indek].evhiline := BaseInfo.base_hiev;						If (not CL_BsSetup^^.Ox_by_Stoic) then			(*	CL_Output^^.conc[indek] := 1.0 - theConc	{wt f of base}*)			else begin				conc[indek + 1] := 1.0 - theConc;	{wt f of Ox}				area[indek + 1] := 0.0;							valence[indek + 1] := 2.0;							stdev[indek + 1] := 0.0;				LineInfo[indek + 1].Z_number := 8;				LineInfo[indek + 1].line := 'K';				LineInfo[indek + 1].evloline := 522.950;				LineInfo[indek + 1].evhiline := 522.950;			end;		End; 	{With...}			{there is no anal_res info for Ox, if Ox by stoic; otherwise it's one of the			 lines above...}			index := 0;			found := false;			Repeat	{put the base conc into the analysis_result field...there is no field					  for Ox if Ox by stoic since it wasn't fit}			   index := index + 1;			   KLorM :=Siegbahn[index][1];			   If (( Atomic_Number[index] = CL_BsSetup^^.Base_Z) and				   (CL_BsSetup^^.Base_line = KLorM)) then			   begin				   found := true;				   While (index <= Fit_params.Number_of_Peaks) and						 (Atomic_Number[index] = CL_BsSetup^^.Base_Z) do				   begin				       if conc[index] = 1.0 then  conc[index] := CL_Output^^.conc[indek];					   index := index + 1;				   end;			   end;			Until (found) or (index = Fit_params.Number_of_Peaks);		{...finished assigning output info for Base element}	  	  Get_MaxThickness;	END;	{if found...begin quant}   END;	{WITH Analysis_result...}  END;	{PROCEDURE Do_CL_Quant }  PROCEDURE Quant_the_Fit;	{ called only if quanting a fit results file }  { Reads through a file of fit results and calculates concentrations.}   Var   	refnum	: integer;	poscnt, thesize : longint;	BEGIN	{Called only from CL dialog: CL_Output was made in the CL dialog code...}			   errCode := FSOpen_err(MCA_ResultsName,MCA_Results_VolNum, refnum,'');			   thesize := 1;			   err := FSRead(refnum, thesize, @Is_Batch);			   MCA_File_Boolean := true;     		 {  errCode := SetFPos_err(refnum, fsFromStart,1,'error in SetFPos');}{ 1st byte has T or F for is_batch}			   thesize := sizeof(Simplex_Fit);			   poscnt := 1;			   REPEAT			    {read fit result}	              err := FSRead(refnum, thesize, @Analysis_Result^^);				  IF (err = noerr) then				  BEGIN				      Do_CL_Quant;	{this is called from Fit Batch code also...}					  { go back to start of the same fit result}					  if found then					  begin     		            errCode := SetFPos_err(refnum, fsFromStart,poscnt,'');					  {write fit result with calculated concentrations}                        errCode := FSWrite_err(refnum, thesize, @Analysis_Result^^,'');	                    { opens, writes to, closes CL file, called in Menus batch fit...}						    WriteToCL;						  end;					  poscnt := poscnt + thesize;				  END; { IF...  }			   UNTIL (err <> noerr);			   	 errCode := FSClose(refnum);				 errCode := FlushVol(NIL, MCA_Results_VolNum);		{this is called only from CL Dialog; that code throws away CL_Output}	END;	{PROCEDURE Quant_the_Fit;}		{$S CliffLor2}	PROCEDURE D_DialCL;	const		I_Do_Accept = 1;		I_Cancel = 2;		I_Save_Setup = 3;		I_Use_Setup_File = 4;		I_Do_Stoic = 5;		I_Do_Oxides = 6;		I_Do_Results = 7;		I_Do_Work = 8;		I_error = 11;		I_CL_Output = 12;		I_Help      = 15;		I_Flowchart = 16;		I_Get_Stds  = 18;		   var 		mytype : OsType;		myprompt : str255;		bytecount   		: Longint;		errcode, refnum, setnum, setup_vol : integer;		use_setup_File, show_CL, save_setup, found,		quant_fit, CL_accept, stds_zeroed, cancel, stoich, reportOxides, No_valences : boolean;		ExitDialog : boolean;		relerror	: real;		setup_name : fnamestr;		 		GetSelection : DialogPtr;		tempRect : Rect;		DType : Integer;		Index, fcnt : Integer;		DItem : Handle;		CItem	 : controlhandle;		sTemp : Str255;		itemHit : Integer;		temp : Integer;    PROCEDURE Get_Ks;{ have an analysis_result: specify k factor files to use and quant	                   any lines for which k factors are found; defines cl_setup;					   not called if setup file is used}	VAR		kdone,index,index1,knum, index0, nfound	:integer;		used, basefound, already_there	: boolean;		poscount,bytecount	: longint;		str8,str,str1,str2,str3	: str255;		err, errcode : integer;		KLorM		 : STRING[1];		    BEGIN	{FilesUsed is unit global zeroed in D_DialCL}	KZ_Data := KFactHdl(NewHandle(sizeof(KFact_rec)));	MoveHHi(Handle(KZ_Data));	HLock(Handle(KZ_Data));		Ka_Data := KFactHdl(NewHandle(sizeof(KFact_rec)));	MoveHHi(Handle(Ka_Data));	HLock(Handle(Ka_Data));		Kfile_Data := KExptHdl(NewHandle(sizeof(KFile_rec)));	MoveHHi(Handle(Kfile_Data));	HLock(Handle(Kfile_Data));	  	mytype := 'MCAK';    myprompt := 'K factor file to use?';	The_File_Name := 'K_File';	str8 := '';	found := false;	basefound := false;	nfound := 0;	index:=0;	kdone := 0;    REPEAT	{ UNTIL (found);...(File_Cancel_Button = False) also exits this procedure. }	  Repeat	 {GetFileName sets the Vol to that chosen in the file menu }	  Until (GetFileName(The_File_Name, mytype, mytype, myprompt) = True) OR 				(File_Cancel_Button = False);	  	  If (File_Cancel_Button = False) Then	  Begin	{if using a setup file CL_Setup^^.Number_of_peaks will have been			 made to agree with analysis_result^^ when this routine is called}				 H_UnLock_Dispose(Handle(KZ_Data),'KZ_Data xx');				 H_UnLock_Dispose(Handle(Kfile_Data),'Kfile_Data xx');				 H_UnLock_Dispose(Handle(Ka_Data),'Ka_Data xx');				 Exit(Get_Ks);	  End;	{ If (File_Cancel_Button = False...}	  poscount := 0;      errCode := FSOpen(The_File_Name,In_VolRefNum, knum);	  bytecount := sizeof(KFile_rec);	  errCode := FSRead(knum, bytecount,@Kfile_Data^^);	  poscount := poscount + bytecount;	  bytecount := sizeof(KFact_rec);	  errCode := FSRead(knum, bytecount,@KZ_Data^^);	  poscount := poscount + bytecount;	  bytecount := sizeof(KFact_rec);	  errCode := FSRead(knum, bytecount,@Ka_Data^^);	  poscount := poscount + bytecount;      err := FSClose(knum);	  if (errCode = eoferr) then putmessage('This is an empty file.','Pick another one.','','')	  else if (Errcode = noerr) then begin	     Errcode := EOFerr;		 If ((Kfile_Data^^.Kfitproc = 'ML') and 		      ((Quant_work and Simplex_active) or (Analysis_result^^.Fit_params.Fit_Procedure = 'Sm')))			  then putmessage('You are quantitating a Simplex fit; the K file is from ML fitting.','','','')		 Else if ((Kfile_Data^^.Kfitproc = 'Sm') and			   ((Quant_work and LLSQ_active) or (Analysis_result^^.Fit_params.Fit_Procedure = 'ML')))			  then putmessage('You are quantitating an ML fit; the K file is from Simplex fitting.','Try another file.','','')		 Else Errcode := Noerr;	     IF basefound THEN	{...not first time thru a K file}		   WITH New_base^^ DO {is base in this k file same as in first k file picked...}		   begin			 Errcode := EOFerr;			 KLorM := KZ_data^^.a_info.line[1];			 if ((Base_Z = KZ_data^^.a_info.Z) and				 (Base_line =KLorM)) and				(((Kfile_Data^^.Kfitproc = 'ML') and				  (base_loev = KZ_data^^.a_info.loline_ev) and	{these are all book energies}				  (base_hiev = KZ_data^^.a_info.hiLine_ev)) or				 ((Kfile_Data^^.Kfitproc = 'Sm') and				  (base_loev <= KZ_data^^.a_info.loline_ev) and				  (base_hiev >= KZ_data^^.a_info.hiLine_ev)))			 then Errcode := Noerr(*Finish this...else if answermessage('Umm, try another K factor file.',							       'The base element info in this K file',							       'doesn`t match the base already selected.',							       '')			 then Errcode := Noerr;		*)			 else Putmessage('Umm, try another K factor file.',							 'The base element info in this K file',							 'doesn`t match the data in fitting results.',							  '');	     End;	{IF basefound...WITH New_base^^...}	  End;	{ If (Errcode = Noerr)...}	 	 IF (Errcode = Noerr) THEN	 BEGIN	   used := false;	  index1 := 0;	  index := nfound;	  {IF NOT basefound, reading the first K File picked or still looking for one with base	   in anal_res}	  IF NOT basefound THEN {Go through analysis_result^^ to verify the base element is fit...}      WITH KZ_data^^,analysis_result^^,SpectrumStuff.Spectrum_Info,Fit_Params DO	  BEGIN	   str := concat(' the base element ',a^.sym[a_info.Z],a_info.line,' lines.');		 Repeat		   index1 := index1 + 1;		   if ((Atomic_Number[index1] = a_info.Z) and (siegbahn[index1][1] = a_info.line[1]))		   then begin			   if ((Kfile_Data^^.Kfitproc = 'ML') and				   (ev_loLine[index1] = KZ_data^^.a_info.loline_ev) and				   (ev_hiLine[index1] = KZ_data^^.a_info.hiLine_ev)) or				  ((Kfile_Data^^.Kfitproc = 'Sm') and				   (ev_loLine[index1] <= KZ_data^^.a_info.loline_ev) and				   (ev_hiLine[index1] >= KZ_data^^.a_info.hiLine_ev))			   then begin				   basefound := true;				   index := index1;	{hold the counter in index}				   while 					((ev_loLine[index1] = ev_loLine[index]) and					(ev_hiLine[index1] = ev_hiLine[index]))				   do index1 := index1 + 1;				   {index1 finishes as the index of the line that doesn't match}				   kdone := index1 - index; {...kdone counts # of anal_res lines accounted for}			   end;	{ if ((Kfile_Data^^.Kfitproc...then begin...}			 end;	{ if ((Atomic_Number[index1] =...then begin...}		 Until (basefound or (index1 >= Number_of_peaks));		   		 If basefound THEN		 Begin			{new_setup^^ goes to Cl_setup if Accept the main dialog...not here...}			Blockmove(@Kfile_Data^^,@new_base^^,sizeof(Kfile_rec));{3 fields}			bytecount := sizeof(ZInfo_rec) - sizeof(real);			Blockmove(@KZ_data^^.a_info.Z,@new_base^^.Base_Z,bytecount);		End		 Else		  Putmessage('Umm, try another K factor file.',					 'The data to quant doesn`t have a match for',					  str,'the base element in this K file.'); 	  END;	{IF NOT BASEFOUND... WITH KZ_data^^,analysis_result...}	  	  IF BASEFOUND THEN	  BEGIN	    REPEAT { read through the selected K file to see what other k factors are useable...	            we already read first Ka_data with file data and kZ_data}		 WITH analysis_result^^,SpectrumStuff.Spectrum_Info,Fit_Params DO		 BEGIN {does Ka_data^^ match any family group in analysis_result^^...}		  found := false;	      index1 := 1;		  {index1 counts clusters for ML and lines for Simplex}		  Repeat { is the line fit? does k match any family in analysis_result? }		  	 KLorM := siegbahn[index1][1];		     If ((ref_index[index1] = -1)) or			    ((Kfile_Data^^.Kfitproc = 'ML') and (ref_index[index1] = 0)) then			 Begin			   found := true; {there will not be any K factor stuff for the lines} 			 End			 Else If (stoich and (Ka_Data^^.a_info.Z = 8.0) and			     (Ka_Data^^.a_info.Z = Atomic_Number[index1])) then			 Begin	{...there's only one line}			 	found := true;			 End			 Else If (( Ka_Data^^.a_info.Z = Atomic_Number[index1]) and				 ( Ka_Data^^.a_info.line = KLorM)) then			 Begin	{right element and family but are the lines ok?}			 {lines_match := false;}			  If ((Kfile_Data^^.Kfitproc = 'ML') and			     (ev_loLine[index1] = Ka_Data^^.a_info.loline_ev) and				 (ev_hiLine[index1] = Ka_Data^^.a_info.hiLine_ev)) or				 {...these are all book energies}				((Kfile_Data^^.Kfitproc = 'Sm') and			     (ev_loLine[index1] <= Ka_Data^^.a_info.loline_ev) and				 (ev_hiLine[index1] >= Ka_Data^^.a_info.hiLine_ev)) then			  Begin {(( ev_loLine[index1]...}	     	    index := nfound + 1; {nfound has not yet been incremented for this element}				found := true; 				If nfound > 0 then				Begin  {do we already have a k factor for any line of the element?...}			      index := 1;				  already_there := false;				  repeat					 if ( new_setup[index]^^.Z_Number = Ka_Data^^.a_info.Z)					 then already_there := true {becomes true if new k data replaces new_setup[index]					 					   in answermessage else new k data is not used}					 else index := index + 1; 				  {...if not there index ends up nfound + 1}                  until ( (already_there) or (index > nfound));				  if (already_there) then {do NOT increment nfound which counts elements} 				  begin				      found := false;{so we keep the data in new_setup[index] unless					  				  answer message says replace it}					  realtostring(new_setup[index]^^.evloLine,4,0,str1);					  realtostring(new_setup[index]^^.evhiLine,4,0,str2);					  str1 := concat('I already have a kfactor for ',a^.sym[new_setup[index]^^.Z_Number],new_setup[index]^^.Line,' lines from ',str1,' to ',str2,' ev');					  realtostring(Ka_Data^^.a_info.loline_ev,4,0,str2);					  realtostring(Ka_Data^^.a_info.hiLine_ev,4,0,str3);					  str2 := concat('I found a kfactor for ',a^.sym[Ka_Data^^.a_info.Z],Ka_Data^^.a_info.line,' lines from ',str2,' to ',str3,' ev');					  if answermessage(str2,str1,'If IT`S OK I`ll use the new one;','IT`S NOT OK, I`ll use the first one.')					  then found := true;{haven't used this k factor data yet} 				  end	{ if (already_there)...}				  else nfound := nfound + 1; {have NEW k factor data; nfound now has same value as index}				{lines_match := true;}				End	{If nfound > 0 then...}				Else nfound := 1;	{for the first k factor, = index}			   			   {index is now either the index of existing  new_setup for the Z or				it equals nfound which just increased...the index for the new k factor data				in new_setup...				so If found we put the new k factor data into the old new_setup or a new one}				If found then				begin				   str8 := concat(str8,' ',a^.sym[Ka_Data^^.a_info.Z],Ka_Data^^.a_info.line);				   new_setup[index] := CLHdl(NewHandle(sizeof(CL_Linestuff)));				   MoveHHi(Handle(new_setup[index]));				   HLock(Handle(new_setup[index]));				   new_setup[index]^^.KFactor := Ka_Data^^.KaZ;				   new_setup[index]^^.Line := Ka_Data^^.a_info.line;				   new_setup[index]^^.Z_Number := Ka_Data^^.a_info.Z;				   str := concat(str,' ',a^.sym[new_setup[1]^^.Z_Number]);				   new_setup[index]^^.evloLine := Ka_Data^^.a_info.loline_ev;				   new_setup[index]^^.evhiLine := Ka_Data^^.a_info.hiline_ev;				   new_setup[index]^^.evloRoi := Ka_Data^^.a_info.fit_roi_lo;				   new_setup[index]^^.evhiRoi := Ka_Data^^.a_info.fit_roi_hi;				{for simplex skip rest of family in anal res...the 				 indecies ARE ok like this 'cause comparing anal_res to anal_res}				   if (not used) then begin					   used := true;					   FilesUsed := FilesUsed + 1;					   new_base^^.K_files[FilesUsed] := The_File_Name;				   end;	{if (not used)...}				   new_setup[index]^^.fileIndex := FilesUsed;				end { if found...}				else found := true; {...must be T because we are here}			  End;	{If ((Kfile_Data^^.Kfitproc = ...match}			 End;	{If (( Ka_Data^^.a_info.Z...}			 { index1 is counter on anal_res lines; index is counter on new_setup...we are not fin			   with index1...}			 index0 := index1;	{...to hold anal res counter for While}			 While ((ev_loLine[index1] = ev_loLine[index0]) and					(ev_hiLine[index1] = ev_hiLine[index0]))			 Do index1 := index1 + 1;{increment to first line in next family}				{kdone counts anal_res lines accounted for including those not to be fit...}        	if (found) then kdone := kdone + (index1 - index0);			if (ref_index[index0] < 1) then found := false;			{...haven't used the ka_data so continue looking thru anal_res for match}		  Until (found) or (index1 > Number_of_peaks);	{...for repeat reading anal_res entries}		END; { WITH analysis_result^^.Fit_Params DO... now read the next Ka_data^^... }		errCode := FSOpen(The_File_Name,In_VolRefNum, knum);		errcode := SetFPos_err(knum,FSFromStart,poscount,''); {for reads in WriteFitResults}		bytecount := sizeof(KFact_rec);		errCode := FSRead(knum, bytecount,@Ka_Data^^);	    poscount := poscount + bytecount;		err := FSClose(knum);	   UNTIL (Errcode = EOFerr) or (kdone = analysis_result^^.Fit_Params.Number_of_peaks);	  END;	{IF BASEFOUND... BEGIN REPEAT...}	 END;	{IF (Errcode = Noerr) ...}		   If Basefound then begin		 If ( kdone < analysis_result^^.Fit_Params.Number_of_peaks) then		 begin		  if str8 = '' then str1:=('No k factors for the lines in the fitting results file.')		  else str1:=concat('I have k factors only for ',str8,'.');		  Found := answermessage(str1,'If IT`S OK, we can proceed.','If IT`S NOT OK pick another K file to search.','');		 end	{If kdone < analysis_result^...}		 else found := true;		 new_base^^.Number_of_peaks := nfound;	   End;	{ If Basefound...}	UNTIL (found);	{GetFileName...(File_Cancel_Button = False) gets us out of routine}		H_UnLock_Dispose(Handle(KZ_Data),'KZ_Data xx');		H_UnLock_Dispose(Handle(Kfile_Data),'Kfile_Data xx');		H_UnLock_Dispose(Handle(Ka_Data),'Ka_Data xx');   END;		{PROCEDURE Get_Ks;}     PROCEDURE MakeClFile;{ opens the binary CL file; writes setup info  						 and some CL_Output to file}  VAR   index,errcode	 :integer;   bytecount		:longint;   str			    : str255; 	  BEGIN	   errCode := FSOpen_err(filename,save_vol, FileRefNum,'');	   IF errCode = NoErr THEN 	   BEGIN		  errcode := SetEOF(FileRefNum,0);		  errcode := SetFPos_err(FileRefNum, fsFromStart,0,'');		  bytecount:= sizeof(CL_BaseStuff);		  errcode := FSWrite_err(FileRefNum,bytecount,@CL_BsSetup^^,'');{base stuff}		  bytecount:= sizeof(CL_LineStuff);		  for index := 1 to CL_BsSetup^^.number_of_peaks do			   errcode := FSWrite_err(FileRefNum,bytecount,@CL_Setup[index]^^,''); {line stuff}			   {no CL_Setup[index]^^ for base line or Ox if done by stoic; the CL_BsSetup			   boolean Ox_by_Stoic tells if oxygen output required; Ox info IS known...}		  if filename = Hall_name then		  begin		    bytecount:= sizeof(fnamestr);{· ResultsVNum, ResultsName,ResultsDirId = 63bytes}		  	errcode := FSWrite_err(FileRefNum,bytecount,@CL_Output^^.ResultsVNum,'');		  end;		  errCode := FSClose(FileRefNum);		  errCode := FlushVol(NIL, save_vol);	  END	  ELSE BEGIN	     str := concat('Uh-Oh! The file ',filename,' did not open.');		 if filename = Hall_name then		 	  putmessage( str,'The quant results will not be saved AT ALL.','','')		 else putmessage( str,						 'After I`m done you can go back to the dialog, ',						 'turn off QUANT WORK and QUANT FIT, ',						 'select SAVE SETUP and ACCEPT');	  END;  END;	{ PROCEDURE MakeCLFile...}    PROCEDURE Refresh_Dialog;            BEGIN        SetPort(GetSelection);        GetDialogItem(GetSelection, I_Do_Accept, DType, DItem, tempRect);        PenSize(3, 3);        InsetRect(tempRect, - 4, - 4);        FrameRoundRect(tempRect, 16, 16);        PenSize(1, 1);      END;  PROCEDURE HelpCL;    VAR      tempRect                     : Rect;                  offset                       : integer;	  Left                         : integer;	  Top                          : integer;      n                            : integer;	  G_Help                       : DialogPtr;      itemHit                      : integer;      DType                         : Integer;      DItem                         : Handle;	  ExitDialog                    : Boolean; 	      CONST      G_Accept                      = 1;	  BEGIN                                             G_Help := GetNewDialog(433, NIL, POINTER( - 1));ShowWindow(G_Help);SelectWindow(G_Help);SetPort(G_Help);OutlineButton(G_Help, 1, 16); { outline the OK button }SetFont('Monaco', 9, []);offset := 12;Left := 5;Top := 15;		   n := 0;	  moveto(Left,Top);str := 'As usual, clicking the dialog selections IN ORDER will mostly work. However, to do a quant you'; DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'do need to have a file or files of K factors for the elements in your specimen. Select Help in';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'the main CL Menu for more information on making K factor files.';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'You can perform a CL quant on data in a file of results from MLLSQ or Simplex fitting of spectra; or';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'you can set up a fitting procedure and the CL quant for the file of spectra open for display. We';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'strongly recommend that you perform the fitting procedure first, examine the results, and then do the';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'quant if the results of the fitting procedure are acceptable. You then have a good file on which you may';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'try different strategies for quantitation. The quant on a fit results file is done when you click OK. The';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'quant on the WORK spectrum done when you click Do A Fit under the main display. To quant the WORK file';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'of spectra, select Fit ALL Work File Spectra under Analysis in the Main Menu Bar.';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'Click Use Setup File to access setup information saved from a previous quant. (The program checks that';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'data were acquired with about the same kV, same detector, etc; were fit with the same procedure; and ';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'that you want to quant the same elements.) Otherwise, you must click K Factors to select K factor files';  DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'to use. Based on the information in the fitting data, the program will search in the files you select ';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'for K factors. With MLLSQ fitting, you must have K factors for exactly the same lines as you have chosen';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'to fit in your specimen data. With Simplex fitting, the K factor lines must be among those fit for your ';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'specimen. The program asks if the K`s it has found are OK; if NOT, give it another file to search. ';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'The program will ask you to choose if it has found more than one K factor for an element. Once all the ';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'K factors are found, you may save the setup data. Click Save Setup and the program will prompt you for';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'a setup filename.  The Spectrum Headers must have valence information to do oxygen by stoichiometry or';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'report oxides. Click Name CL Results to give a unique name to the binary file of quant results.';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'If you quant a fit results file, a text file of quant results is made and displayed automatically.';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'The name is a concatenation of the CL Results name and `_Ascii`. Currently only 32 K bytes of the';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'file can be displayed inside DTSA, but his file can be manipulated outside DTSA just like any other';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'text file.';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'Select Output Options in the main CL Menu to make other more extensive text files/spread sheets that are ';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'basically ascii fit results files with concentrations.';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'For each element the thickness is reported at which the relative error in concentration due to absorption';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'becomes equal to the value entered.';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := '';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := '';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := ' ';DrawString(str); n := n+1; moveto(Left,Top + n*offset); REPEAT  ModalDialog(NIL, itemHit);  GetDialogItem(G_Help, itemHit, DType, DItem, tempRect);  IF (itemHit = G_Accept) THEN	BEGIN	  ExitDialog := True;	END;UNTIL ExitDialog;		            DisposeDialog(G_Help);			BeginUpdate(BackPlane);			DrawAxesFull;			Update_Full;			EndUpdate(BackPlane);		    UpDate_SiLi_Window(SiLiWindow) ;		END;     {End of HelpCL procedure}			BEGIN	{  main PROCEDURE D_DialCL; }	     		GetSelection := GetNewDialog(133, nil,  Pointer(-1) );			ShowWindow(GetSelection);			SelectWindow(GetSelection);			SetPort(GetSelection);			 			GetDialogItem(GetSelection,I_Flowchart,DType,DItem,tempRect);			HideControl(ControlHandle(DItem));			{Setup initial conditions}			Refresh_Dialog;			Use_Setup_File := false;			CL_accept := false;			show_CL := false;			show_one := false;			save_setup := false;			stds_zeroed :=  false;			ExitDialog := FALSE;			quant_work := false;	{this is a global}			quant_fit := false;			No_Valences := false;			if CL_BsSetup^^.Report_oxides then reportOxides := true else reportOxides := false;			if CL_BsSetup^^.Ox_by_Stoic then stoich := true else stoich := false;			relerror := CL_BsSetup^^.relative_error;						fcnt := 0;			FilesUsed := 0;			Make_Hall := false;		new_base := CLBsHdl(NewHandle(sizeof(CL_BaseStuff)));	    MoveHHi(Handle(new_base));		HLock(Handle(new_base));				for index := 1 to 10 do new_base^^.K_files[index] := ' ';				GetDialogItem(GetSelection, I_Do_Oxides, DType, DItem, tempRect);		CItem := ControlHandle(DItem);		If reportOxides then SetControlValue(CItem, 1)		else SetControlValue(CItem, 0);					GetDialogItem(GetSelection, I_Do_Stoic, DType, DItem, tempRect);		CItem := ControlHandle(DItem);		If stoich then SetControlValue(CItem, 1)		else SetControlValue(CItem, 0);					GetDialogItem(GetSelection,I_error,DType,DItem,tempRect);{Get the item handle}		realtostring(relerror,3,1,stemp);		SetDialogItemText(DItem, sTemp);{set the value read from setup info}			REPEAT	{ 	until ExitDialog; }				ModalDialog(NewModalFilterProc(@DefaultFilter), itemHit);				GetDialogItem(GetSelection, itemHit, DType, DItem, tempRect);				CItem := ControlHandle(DItem);								if (ItemHit =I_Save_Setup) then { immediate action button }				begin	    		   setup_name := 'CL_SetupSav';   { the user's choice replaces this }				   if (CreateFile(setup_name, 'Save CL Setup File:') = True) OR								   (File_Cancel_Button = False) then;				   IF (File_Cancel_Button) THEN				   begin				   		  setup_vol := Out_VolRefNum;				          (*errCode := Create(Outname, setup_vol, 'DTSA', 'MCAc');*)						  save_setup := true;				   end;			         Refresh_Dialog; 				end;	{if (ItemHit...}				 							  If (ItemHit =I_CL_Output) then			  Begin	    		   Hall_name := concat('CL_',MCA_ResultsName);   { the user's choice replaces this }				   if (CreateFile(Hall_name, 'Name binary CL File:') = True) OR								   (File_Cancel_Button = False) then;				   IF (File_Cancel_Button) THEN				   begin				    Make_Hall := true;				    Hall_vol:= Out_VolRefNum;				   end;				 Refresh_Dialog; 			  End;	{if (ItemHit =I_CL_Output...}				 				 					 if (ItemHit =I_Use_Setup_File) then { immediate action button }			 begin				 cancel := false;				 Use_setup_file := false;	{reset below...}				 mytype := 'MCAc';				 myprompt := 'Get CL Setup File';				 repeat					IF (GetFileName(Outname, mytype, mytype, myprompt)) then					BEGIN					  setup_vol := in_volrefnum;					  errcode := FSOpen_err(Outname,setup_vol,setNum,'');					 IF errCode = NoErr then begin						errcode := SetFPos_err(setnum,fsFromstart,0,'');						bytecount := sizeof(CL_BaseStuff);						errcode := FSRead(setNum,bytecount,@new_base^^);						if (quant_work or quant_fit) and 						   (analysis_result^^.fit_params.fit_procedure <> new_base^^.Kfitproc) then						   putmessage('','The fitting procedure for the setup file data',									  'is different from the procedure for the file to quant.',									  'Please pick a different setup file or select `Get K Factors`.')						else begin						  Use_setup_file := true;						  bytecount := sizeof(CL_LineStuff);						  for index := 1 to new_base^^.number_of_peaks do						  begin							   new_setup[index] := CLHdl(NewHandle(sizeof(CL_Linestuff)));							   MoveHHi(Handle(new_setup[index]));							   HLock(Handle(new_setup[index]));							   errcode := FSRead(setNum,bytecount,@new_setup[index]^^);						  end;						end;						IF errCode = NoErr then found := true;						errcode := FSClose(setNum);						errcode := FlushVol(nil,setup_vol);					 end;	{ IF errcode...}					END	{ IF (GetFileName...}					ELSE cancel := true;				  until Use_setup_file or cancel; 				   Refresh_Dialog;			 end;	{ if (ItemHit =I_Use_Setup_File)...}							 If (ItemHit =I_Do_Accept) then {button}			 begin				 if (not found) and (( quant_work) or ( quant_fit)) then				 begin					 putmessage('Please get K factors or open a setup file.','','','');					 CL_accept := false;				 end				 else if ( quant_work) or ( quant_fit) then 				 begin					 CL_accept := true;					 new_base^^.Report_oxides := reportOxides;					 new_base^^.Ox_by_Stoic := stoich;			         ExitDialog:=TRUE;				 end;	{else if ( quant_work)...begin}			 end;	{if (ItemHit =I_Do_Accept)...}								if (ItemHit =I_Cancel) then				begin				    CL_accept := false;					ExitDialog:=TRUE;				end;								if (ItemHit =I_Help) then				begin					HelpCL;					Refresh_Dialog;				end;								if (ItemHit =I_Do_Stoic) then				begin					temp := GetControlValue(CItem);					If temp = 1 then stoich := false				    else If no_Valences then					begin						putmessage('There are no valences available','so I can`t do oxygen by stoichiometry.','','');					    stoich := false;					end					else  If temp = 0 then stoich := true;					if stoich then SetControlValue(CItem, 1)					else SetControlValue(CItem, 0);				end;				if (ItemHit =I_Do_Oxides) then				begin					temp := GetControlValue(CItem);					If temp = 1 then reportOxides := false				    else If no_Valences then					begin						putmessage('There are no valences available','so I can`t report oxides.','','');						reportOxides := false;					end					else If temp = 0 then reportOxides := true;					if reportOxides then SetControlValue(CItem, 1)					else SetControlValue(CItem, 0);				end;			(*	if (ItemHit =I_Flowchart) then				begin					Flow_Chart(40); 				 Refresh_Dialog; 				end;*)    			if (ItemHit = I_Get_Stds) then					begin					If ((not quant_work) and (not quant_fit)) then					putmessage('Am I doing a WORK FILE or FIT RESULTS?','','','')					else Get_Ks; { specify k factor files to use, quants any lines for					 		   which it finds k factors }				end;											IF (ItemHit =I_Do_Work) or (ItemHit =I_Do_Results) then			Begin		{ radios: if one turns on the other turns off }				for Index:=I_Do_Results  to I_Do_Work do				begin					GetDialogItem(GetSelection, Index, DType, DItem, tempRect);					SetControlValue(ControlHandle(DItem), 0);	{ turn all buttons off }				end;	{for Index...}				SetControlValue(CItem, 1);	{ turn the selection on }								if (ItemHit =I_Do_Work) then				begin				   IF ( not LLSQ_active) and (not Simplex_Active) then 				   begin					   putmessage(' Sorry. To quantitate Work Spectra',								  ' either ML or Simplex fitting must be set up.','NOTE: Please name the binary Fit Results File.','');					   Use_setup_file := false;					   exitDialog := true;				   end				   else if (not MCA_OptionsBoolean) then				   begin					   putmessage('You didn`t name the binary Fit Results File.',								  'Please do that now,',								  'or be sure to make CL ascii files (Output Options)', 								  'as soon as you finish the quant.');					  binary_choice := true;					  D_Results_Options;	{defines MCA_Results_VolNum, etc...}				   end;				   Quant_Work := true;				   quant_fit := false;				   Refresh_Dialog; 				end		{ if (ItemHit =I_Do_Work)...}				else if (ItemHit =I_Do_Results)  then	{ stds may be read from other files as well }				begin						   Repeat					  mytype := 'MCAb';					  The_File_name := 'FileName';					  myprompt := ' Fit Results File to quantitate? '						 {GetFileName sets the Vol to that chosen in the file menu }				   Until (GetFileName(The_File_Name, mytype, mytype, myprompt) = True) OR 						 (File_Cancel_Button = False);				   IF (File_Cancel_Button) THEN 	{ a file was picked }				   Begin					 MCA_Results_VolNum := In_volrefnum;					 MCA_ResultsName := The_File_Name;					 MCA_ResultsDirID :=InVol_DirID;					 MCA_ResultsVNum := InVol_volnum;					 MCA_File_Boolean:=true;				 { Get info for finding standards }					 errCode := FSOpen_err(MCA_ResultsName,MCA_Results_VolNum, refnum,'The fit results file did not open.');					 if errCode = noerr then					 begin						 errCode := SetFPos_err(refnum, fsFromStart,0,'');						 bytecount := 1;						 errCode := FSRead(refnum, bytecount, @is_batch);						 if errcode = noerr then begin						   errcode := GetEOF(refnum,bytecount);						   if (bytecount >= 2 * sizeof(Simplex_fit) + 1) and (not is_batch) 							  then File_Cancel_Button :=								  answermessage('This is not a batch fit results file. The quant will work only if',												'the fitting procedure and lines are the same for all the fits.',												'If It`s OK, I`ll go on.','If It`s Not OK, pick another fit file or Cancel.');						   bytecount := sizeof(Simplex_fit);						   errCode := FSRead(refnum, bytecount, @Analysis_Result^^);						   quant_fit := true;						   Quant_Work := false;						 end;	{if errcode = noerr...}					 end;	{if errCode = noerr...}					 errcode := FSClose(refNum);					 errcode := FlushVol(nil,MCA_Results_VolNum);					 if errcode <> noerr then SetControlValue(CItem, 0); 				   End 	{ IF (File_Cancel_Button)...}				   Else IF ( not File_Cancel_Button) then 				    SetControlValue(CItem, 0);	{ turn the selection back off }			    end;	{if (ItemHit =I_Do_Results) ...}										 IF (Use_Setup_File) then  {have not hit ACCEPT yet so use new_base^^ here}			 Begin			 	Use_Setup_File := false;				if (Analysis_result^^.Fit_params.Fit_Procedure = 'Sm') and				   (new_base^^.Kfitproc = 'ML') then				   putmessage(' The current CL setup file is for an ML fit.',							  ' You are quantitating a Simplex fit.',							  ' Please pick a different setup file',							  ' or select `Get K Factors`.')				else If (Analysis_result^^.Fit_params.Fit_Procedure = 'ML') and						(new_base^^.Kfitproc = 'Sm') then				   putmessage(' The current CL setup file is for a Simplex fit.',							  ' You are quantitating an ML fit.',							  ' Please pick a different setup file',							  ' or select `Get K Factors`.')				else Use_Setup_File := true;		     End;	{ IF (Use_CLSetup_File)...}			 			 IF (quant_fit or Quant_Work) then			 BEGIN			   index := 0;			   no_Valences := false;			   if quant_fit then With Analysis_result^^, SpectrumStuff.Spectrum_Info do			   Repeat				   index := index +1;				   if (element_info[index].valence <= 0) or					 (element_info[index].valence > 10) then no_Valences := true;			   Until no_Valences or (index = Number_of_Elements)			   else  With Plt_Spec[10]^^, SpectrumStuff.Spectrum_Info do			   Repeat				   index := index + 1;				   if (element_info[index].valence <= 0) or					 (element_info[index].valence > 10) then no_Valences := true;			   Until no_Valences or (index = Number_of_Elements);			   			   If No_Valences then			   Begin				   reportOxides := false;				   stoich := false;		   				   GetDialogItem(GetSelection, I_Do_Oxides, DType, DItem, tempRect);				   SetControlValue(ControlHandle(DItem), 0);					   				   GetDialogItem(GetSelection, I_Do_Stoic, DType, DItem, tempRect);				   SetControlValue(ControlHandle(DItem), 0);			   End;	{IF No_Valences...}			 END;	{IF (quant_fit or Quant_Work) ...}					  End;	{if (ItemHit =I_Do_Work) or (ItemHit =I_Do_Results) ...}		UNTIL ExitDialog; 		 IF (CL_accept) then BEGIN			 CL_BsSetup^^ := new_base^^;	{the handle CL_BsSetup is created in Initialize.p}			 H_UnLock_Dispose(Handle(new_base),'new_base xx');			 			 GetDialogItem(GetSelection,I_error,DType,DItem,tempRect);{Get the item handle}			 GetDialogItemText(DItem, sTemp);{Get the text entered}			 CL_BsSetup^^.relative_error := Mystr2num(stemp);			 for index := 1 to MaxNumPks do			 begin			   if CL_Setup[index] <> NIL then			   begin					 H_UnLock_Dispose(Handle(CL_Setup[index]),'CL_Setup xx');			   end;			   			   if (index <= CL_BsSetup^^.number_of_peaks) then			   begin	{The CL_Setup[index] are NOT created in Initialize.p so there			             are never more than necessary around but they do stay around,						 as does CL_BsSetup.}					  if CL_Setup[index] = NIL then					  begin						CL_Setup[index] := CLHdl(NewHandle(sizeof(CL_Linestuff)));					  	MoveHHi(Handle(CL_Setup[index]));					  	HLock(Handle(CL_Setup[index]));					  end					  {else putmessage('CL_Setup[index] <> NIL','no new handle','','')};				      CL_Setup[index]^^ := new_setup[index]^^;				      H_UnLock_Dispose(Handle(new_setup[index]),'new_setup xx');			   end;			 end;	{for index := 1...}			if (CL_Output = NIL) then	{set to NIL in Initialize;										 always the same size...too big! Should dispose										 when finished writing quant results, and 										 Make a new one for each quant or output of										 Quant results.}			begin			  ReserveMem(sizeof(CL_outstuff));			  if MemError = memFullErr then Bag_the_Program;			  CL_Output := CLOutHdl(NewHandle(sizeof(CL_outstuff)));			  HLock(Handle(CL_Output));			end;			    {MCA_Resultsxxx is fit file info...this we know if they are doing				 work if they named the file in output options or if doing a fit file}			Cliff_Lorimer_Active := true;			CL_Output^^.ResultsName := '';			BlockMove(@MCA_ResultsName,@CL_Output^^.ResultsName,sizeof(CL_Output^^.ResultsName));			{CL_Output^^.ResultsName := MCA_ResultsName; 1/17/96} {too long, writes over ResultsDirId}			CL_Output^^.ResultsDirId := MCA_ResultsDirID;	{...from GetFileName call to Get_WDInfo}			CL_Output^^.ResultsVNum := MCA_ResultsVNum;			IF ( not Make_Hall) THEN begin  {Make_Hall is a global var}				 if quant_work then 					  Hall_vol := Binary_VolNum_Read				 else Hall_vol := MCA_Results_VolNum;				 Hall_name := 'CL_DefaultResults';			end;			errCode := Create(Hall_name, Hall_vol, 'DTSA', 'MCAo');			filename := Hall_name;			save_vol:= Hall_vol;(**)		MakeCLFile;	(**)	{opens the binary CL, sets EOF, writes CL_BsSetup and								 CL_Setup[index]^^,CL_Output^^.ResultsName...VNum}									  	(*		   if (save_setup) then begin			              errCode := Create(setup_name, setup_vol, 'DTSA', 'MCAc');						  filename := setup_name;						  save_vol:= setup_vol;						  MakeCLFile;	{writes only setup stuff, no CL_Output stuff}			   End; { if (save_setup)...}	*)	 			   If (Quant_fit) then begin				{  CL_Output^^.ResultsName := MCA_ResultsName;}				  Quant_the_Fit;	{MCA_ResultsName,MCA_Results_VolNum are defined above}				  if (Plain_boolean) or (Spread_Boolean) 				   then begin					do_ascii := true;					WriteFitResults;					do_ascii := false;					MCA_File_Boolean := False;					Plain_Boolean := False;					Spread_Boolean := false; 				  end;	{ if (Plain_boolean) ...}				   show_vol := Hall_vol;				   showname := Hall_name;				   show_one := false;				   AsciiCLResults;	{defines CLPlainName} 			  End;	{ If (Quant_fit) then begin...}		  		  END;	{ IF (CL_accept) }					  if (save_setup)		  then begin			 if ( Cliff_Lorimer_Active) then			 begin					   errCode := Create(setup_name, setup_vol, 'DTSA', 'MCAc');					   filename := setup_name;					   save_vol:= setup_vol;					   MakeCLFile;			 end		     else putmessage('There is no CL setup information to save.','','','');		  End; { if (save_setup)...}			   if CL_Output <> NIL then					 H_UnLock_Dispose(Handle(CL_Output),'CL_Output xx');			if ( ExitDialog ) then begin				 tempRect := GetSelection^.portRect;				 DisposeDialog(GetSelection);				 FillWhiteSpace(tempRect);                 Mouse_Active_Window;				end;			 	end;	{ PROCEDURE D_DialCL; }	end.    								{End of unit}