{[j=30/55,:+,u+,r+,o=120,k+,n+,#+,v+,q+,b+]}{[f-]} {*********************************} UNIT Global_Functions;{*********************************}  {**********************************} INTERFACE {**********************************} USES QuickDraw, QuickdrawText, Types, OSUtils, ToolUtils, Timer, Events, Errors, Menus, Files, Lists, Memory, Resources, Packages, Printing, Icons, TextEdit, TextUtils, Finder, Fonts, PasLibIntf, Windows, Retrace, SegLoad, Sound, Dialogs, fenv, fp, Controls, Spectrum_Structures, Declarations, INITIALIZE, xray, Xray_Energies;     PROCEDURE Escape; 	PROCEDURE FillWhiteSpace(coveredRect:	rect);{redraws plotting region, axes, Sili}    FUNCTION  AnswerMessage(S1, S2, S3, S4: Str255): Boolean;	PROCEDURE PutMessage(S1, S2, S3, S4: Str255);	PROCEDURE PutBusyMessage(S1, S2, S3, S4: Str255);    PROCEDURE CompactMemory;        PROCEDURE Mouse_Active_Window;	PROCEDURE ShowCursorValues(myEvent: EventRecord);    FUNCTION  AtSymbol_To_Znum(symbol: Str255): integer;    PROCEDURE WritePreferences;    PROCEDURE ReadPreferences;    PROCEDURE SpinCursor;    PROCEDURE BeepBeep;	PROCEDURE OutlineButton(theDialog: DialogPtr; itemNo, CornerRad: Integer);    FUNCTION  SetFPos_err(refNum: Integer; posMode: Integer; posOff: Longint; Msg: str255) : OSErr;	FUNCTION  FSOpen_err(name: Str255; vRefNum: Integer; VAR  refNum: Integer; Msg: str255) : OSErr; 	FUNCTION  FSRead_err(refNum: Integer; VAR count: Longint; buf: ptr; Msg: str255) : OSErr;    FUNCTION  FSWrite_err(refNum: Integer; VAR count: Longint; buf: ptr; Msg: str255) : OSErr;   { PROCEDURE Get_Energies(atm_num: integer);}	PROCEDURE Refresh_ROIs;	PROCEDURE Clear_the_Rois;	PROCEDURE Update_ROI_Window(whichWindow: WindowPtr);    FUNCTION  Log_Plot(Value: real {double_t}): real {double_t};    FUNCTION  Square_Root_Plot(Value: real {double_t}): real {double_t};    PROCEDURE Plot(theSpectrum      : integer;    			   {Dumie			: integer;} 	               DataMax          : real; 				   DataMin          : real; 				   ChannelMin       : integer; 				   ChannelMax       : integer;                   Pix_X_Min        : integer; 				   Pix_X_Max        : integer; 				   Pix_Y_Min        : integer; 				   Pix_Y_Max        : integer; 				   Color            : integer;                   PlotSymbol       : integer; 				   Connected        : integer  );	PROCEDURE Update_Full;	PROCEDURE Init_BackPlane;	PROCEDURE Open_BackPlane;	PROCEDURE DrawAxesFull;	PROCEDURE Init_SiLi_Window;	PROCEDURE Open_Sili_Window;	PROCEDURE UpDate_SiLi_Window (whichWindow: WindowPtr) ;	PROCEDURE Close_SiLi_Window(whichWindow: WindowPtr; VAR theInput: TEHandle);    PROCEDURE OffScreen_2_OnScreen;    PROCEDURE UpDate_Max_Min(Spectrum: integer);             { Updates the max and min as a 	                                                           spectrum is run through }    		PROCEDURE Markers;	    PROCEDURE Write_Static_Text(theDialog: DialogPtr; item: integer; Str: Str255);	    FUNCTION  fast_power(X, n: real {double_t}): real {double_t};    (*PROCEDURE RealToString(Val: real; width, fwidth: integer; VAR Str_x: Str255);*)	FUNCTION  Strip_Trailing_Blanks(symbol: str255): str255;	PROCEDURE SetFont(fontName: Str255; fontSize: integer; fontStyle: style);	PROCEDURE PutSymbol(Box       : Rect; 						fontName  : Str255; 						fontSize  : integer; 						fontStyle : style;						Element   : Str_2;						Family,						Greek     : Str_4);						     PROCEDURE UnCheck_AllSpectra;	PROCEDURE Flow_Chart( DialNum : Integer);    PROCEDURE Restore_Expt_Header( RefNum : Integer);    PROCEDURE Smooth_Spectrum (var theSpecIn,theSpecOut:spectrum_counts; which_Smooth: integer ) ;    PROCEDURE Convolve ;    PROCEDURE Convolve_Col1;    PROCEDURE CompareGen_To_Work(theSiLiRec : SiLi_RecHdl);    PROCEDURE GenFromWork(theSiLiRec : SiLi_RecHdl);	PROCEDURE Reset_Range_Buttons;	PROCEDURE Test_a_Handle ( VAR A_Handle : Handle ; message : str255  ) ;	FUNCTION OptionKeyDown : Boolean;	Procedure Kill_Quants;	PROCEDURE Reset_ROIs;    FUNCTION DefaultFilter (theDialog: DialogPtr; VAR theEvent: EventRecord; VAR itemHit: Integer): boolean;    PROCEDURE DrawLeftHL;	PROCEDURE CenterDialog(w : WindowPtr; shift_win : boolean; VAR p : Point);{******************************} IMPLEMENTATION {**********************************}{$S Global_Functions} {[f+]} (*FUNCTION hex2longint(ch: char): longint;    BEGIN     IF (ch >= '0') AND (ch <= '9') THEN        hex2longint := ord(ch)-ord('0')     ELSE        hex2longint := ord(ch)-ord('A')+10    END;  *) (* PROCEDURE aConvolve; EXTERNAL;*) {this has to be here for MPW PASCAL but above for TML PASCAL}  Procedure Kill_Quants;	BEGIN	  IF ZAF_Active THEN	  H_UnLock_Dispose( Handle(ZAF_Record),'ZAF_Record in C_Deactivate in menus.p');	  ZAF_Active           := FALSE;	  Hall_active          := FALSE;	  ZAF_Run              := FALSE;	  Whole_Cell_Active    := FALSE;	  IF (Cliff_Lorimer_Active) then begin                      		  if CL_OutPut <> NIL then		  		H_UnLock_Dispose( Handle(CL_OutPut),'CL_OutPut in C_Deactivate in menus.p');		 Cliff_Lorimer_Active := FALSE;	  end;	  Standardless_Active  := FALSE;	  if CitZAF_Active then	  begin		  H_UnLock_Dispose( Handle(ZAF_Record),'ZAF_Record in C_Deactivate in menus.p');		  Kill_citZAF := TRUE;	  end;	  CitZAF_Active        := FALSE;	  citZAF_Run		   := False;	END;  PROCEDURE Test_a_Handle {( VAR A_Handle : Handle ; message : str255 )} ;    BEGIN  (* if  A_Handle = NIL then exit(Test_a_Handle)  else begin    PutMessage('Attempt to make a Handle which is not NIL',message,'','');       {H_UnLock_Dispose( A_Handle, message );}  end;*)    END;  Function OptionKeyDown : Boolean;	 begin		GetKeys(theKeys);		OptionKeyDown := (theKeys[$3D] OR theKeys[$3A]);	 end;	   FUNCTION DefaultFilter {(theDialog: DialogPtr; VAR theEvent: EventRecord; VAR itemHit: Integer): boolean};	CONST		I_Done                        = 1;		I_Cancel					  = 2;		kVisualDelay				  = 8;		inButton					  = 10;		kReturnKey					  = $0D;		kEnterKey					  = $03;		kEscapeKey					  = $1B; 		kPeriodKey					  = $2E;    VAR      tempRect                      : Rect;	  DType                         : integer;	  DItem                         : Handle;	  CItem			                : controlhandle;	  finalTicks					: Longint;	  key							: Char;    BEGIN      DefaultFilter := FALSE;	    CASE theEvent.what OF			keyDown, Autokey:	{user pressed a key}			BEGIN				key := Char(BAnd(theEvent.message, charCodeMask));				IF (key = Char(kReturnKey)) OR (key = Char(kEnterKey)) THEN				  BEGIN				    GetDialogItem(theDialog, I_Done, DType, DItem, tempRect);        			CItem := controlhandle(DItem);							{invert the OK button for user feedback}					HiliteControl(CItem, inButton{kControlButtonPart});		{PROCEDURE HiliteControl(theControl: ControlRef; hiliteState: ControlPartCode);}					Delay(kVisualDelay, finalTicks);											{invert button for 8 ticks}					HiliteControl(CItem, 0);					DefaultFilter := TRUE;								{event's being handled}					itemHit := I_Done;								{return the default button}				  END;				IF (key = Char(kEscapeKey)) OR											{user pressed Esc key}					(Boolean(BAnd(theEvent.modifiers, cmdKey)) AND					(key = Char(kPeriodKey))) THEN											{user pressed Cmd-pd}				  BEGIN			{handle as if user clicked Cancel}					GetDialogItem(theDialog, I_Cancel, DType, DItem, tempRect);					CItem := controlhandle(DItem);							{invert the Cancel button for user feedback}					HiliteControl(CItem, inButton{kControlButtonPart});					Delay(kVisualDelay, finalTicks);											{invert button for 8 ticks}					HiliteControl(CItem, 0);					DefaultFilter := TRUE;								{event's being handled}					itemHit := I_Cancel;							{return the Cancel button}					{sysbeep(10);}				  END;		{of Cancel}				  				END; { keyDown, Autokey }			END;{CASE theEvent.what}		    END;PROCEDURE CenterDialog{(w : WindowPtr; shift_win : boolean; VAR p : Point)};	VAR			wPort				: CGrafPtr;			rsize,size,margin	: Integer;				BEGIN		GetCWMgrPort(wPort);		SetPort(w);		p.h := w^.portRect.left;		p.v := w^.portRect.top;		LocalToGlobal(p);		size := wPort^.portRect.right - wPort^.portRect.left;		rsize := w^.portRect.right - w^.portRect.left;		margin := (size - rsize) DIV 2;		if margin < 1 then margin := 1;		p.h := wPort^.portRect.left + margin;		size := wPort^.portRect.bottom - wPort^.portRect.top;		rsize := w^.portRect.bottom - w^.portRect.top;		margin := (size - rsize) DIV 3;		if margin < 1 then margin := 1;		p.v := wPort^.portRect.top + margin;		if shift_win then			MoveWindow(w,p.h,p.v,TRUE);	END;  PROCEDURE Escape; { Remove escape peaks from a real spectrum to avoid confusion                      with characteristics. Why don't we add the amp back into the 					  characteristic peak??? Is the algorithm correct as we use it?					  Should we use the apparent pk intensity or the real pk					  intensity? How does Statham's equation really work? If it is					  correct here with the spectrum intensity then the					  PROCEDURE Add_Escape_Peaks in Physics.p is wrong.	                  We are assuming that the intensity in Peter's eqn is the					  intensity observed in the spectrum.}  {еееееее need to correct energies with slope and intercept еееееееее}    VAR      nn, ndown, ndown1, ndown2, ndown3 : integer;      E, M, B, Re, ESCMAG, costrm   	: real;    BEGIN	{ PROCEDURE Escape;}      IF Si_Active THEN      BEGIN          costrm := COS((90 - Plt_spec[10]^^.Expt_Info.Detector_tilt) / 57.295779);          M := 0.01517 * costrm - 0.000803; { Peter Statham's equation }          B := 0.0455 * costrm + 0.01238;          ndown := rinttol(1740.0 / Plt_spec[10]^^.Expt_Info.dE);          FOR nn := Plt_spec[10]^^.Expt_Info.number_of_channels downto rinttol(1840 / Plt_spec[10]^^.Expt_Info.dE)		  DO BEGIN{ Subtract the Escape events }              E := nn * Plt_spec[10]^^.Expt_Info.dE;              E := E * 0.001; { ch energy in keV }              Re := 0.0202 / (1 + (M * E + B) * E * E);              ESCMAG := Re * Col_1^[nn];	{Col_1^[nn] is data spectrum cnt}              Col_1^[nn - ndown] := Col_1^[nn - ndown] - ESCMAG;			  Col_1^[nn] := Col_1^[nn] + ESCMAG;            END;      END	{ IF Si_Active...}      ELSE IF Ge_Active THEN      BEGIN          costrm := COS((90 - Plt_spec[10]^^.Expt_Info.Detector_tilt) / 57.295779);          M := 0.01517 * costrm - 0.000803; { Peter Statham's equation }          B := 0.0455 * costrm + 0.01238;          ndown := rinttol(9885.0 / Plt_spec[10]^^.Expt_Info.dE);	{ Ge K-alpha}		  ndown1 := rinttol(10980.0 / Plt_spec[10]^^.Expt_Info.dE);	{ Ge K-beta}		  ndown2 := rinttol(1188.0 / Plt_spec[10]^^.Expt_Info.dE);	{ Ge L-alpha1}		  ndown3 := rinttol(1218.0 / Plt_spec[10]^^.Expt_Info.dE);	{ Ge L-beta1}          FOR nn := rinttol(1217 / Plt_spec[10]^^.Expt_Info.dE) TO		  			Plt_spec[10]^^.Expt_Info.number_of_channels DO { Subtract the Escape events }            BEGIN              E := nn * Plt_spec[10]^^.Expt_Info.dE;              E := E * 0.001; { ch energy in keV }              Re := 0.0202 / (1 + (M * E + B) * E * E);              ESCMAG := Re * Col_1^[nn];              Col_1^[nn - ndown2] := Col_1^[nn - ndown2] - ESCMAG;	{L-alpha1}			  IF (nn > rinttol{Num2Integer}(1248 / Plt_spec[10]^^.Expt_Info.dE)) then 			  	Col_1^[nn - ndown3] := Col_1^[nn - ndown3] - ESCMAG;	{L-beta1}			  IF (nn > rinttol{Num2Integer}(11103 / Plt_spec[10]^^.Expt_Info.dE)) then begin			  	Col_1^[nn - ndown] := Col_1^[nn - ndown] - ESCMAG;	{K-alpha}			  	Col_1^[nn - ndown1] := Col_1^[nn - ndown1] - ESCMAG;	{K-beta}			  end;            END;	{ FOR nn := rinttol...}      END      ELSE	{ ELSE IF Ge_Active ...}       BEGIN		Putmessage('Both Ge_Active and Si_Active are false.',				   'No escape pks in WDS.','This message is in Escape',				   'in Global_Functions.p');      END;    END;	{Procedure Escape;}  PROCEDURE Reset_Range_Buttons;    VAR      n                             : integer;    BEGIN      ChannelMin := 1;      n := Plt_spec[10]^^.Expt_Info.Number_of_Channels;      IF (n > 0) AND (n <= 256) THEN n := 256      ELSE        IF (n > 256) AND (n <= 512) THEN n := 512        ELSE          IF (n > 512) AND (n <= 1024) THEN n := 1024          ELSE            IF (n > 1024) AND (n <= 2048) THEN n := 2048            ELSE              IF (n > 2048) AND (n <= 4096) THEN n := 4096              ELSE IF (n > 4096) AND (n <= Maximum_Channels) THEN n := Maximum_Channels;      GetPort(GrafPtr(SavePort));      SetPort(SiLiWindow);      CASE n OF        256:          BEGIN            IF SiLi_512CntHdl^^.contrlHilite = 10 THEN Hilitecontrol(SiLi_1024CntHdl, 0);            IF SiLi_1024CntHdl^^.contrlHilite = 10 THEN Hilitecontrol(SiLi_1024CntHdl, 0);            IF SiLi_2048CntHdl^^.contrlHilite = 10 THEN Hilitecontrol(SiLi_2048CntHdl, 0);            IF SiLi_4096CntHdl^^.contrlHilite = 10 THEN Hilitecontrol(SiLi_4096CntHdl, 0);            IF SiLi_8192CntHdl^^.contrlHilite = 10 THEN Hilitecontrol(SiLi_8192CntHdl, 0);            Range_Keeper := 5;            Spectrum_Size := 256;            New_Range := 256;            ChannelMax := 256;          END;        512:          BEGIN            IF SiLi_512CntHdl^^.contrlHilite = 0 THEN              BEGIN                IF SiLi_1024CntHdl^^.contrlHilite = 10 THEN Hilitecontrol(SiLi_1024CntHdl, 0);                IF SiLi_2048CntHdl^^.contrlHilite = 10 THEN Hilitecontrol(SiLi_2048CntHdl, 0);                IF SiLi_4096CntHdl^^.contrlHilite = 10 THEN Hilitecontrol(SiLi_4096CntHdl, 0);                IF SiLi_8192CntHdl^^.contrlHilite = 10 THEN Hilitecontrol(SiLi_8192CntHdl, 0);                Hilitecontrol(SiLi_512CntHdl, 10);                Range_Keeper := 6;                Spectrum_Size := 512;                New_Range := 512;                ChannelMax := 512;              END;          END;        1024:          BEGIN            IF SiLi_1024CntHdl^^.contrlHilite = 0 THEN              BEGIN                IF SiLi_512CntHdl^^.contrlHilite = 10 THEN Hilitecontrol(SiLi_512CntHdl, 0);                IF SiLi_2048CntHdl^^.contrlHilite = 10 THEN Hilitecontrol(SiLi_2048CntHdl, 0);                IF SiLi_4096CntHdl^^.contrlHilite = 10 THEN Hilitecontrol(SiLi_4096CntHdl, 0);                IF SiLi_8192CntHdl^^.contrlHilite = 10 THEN Hilitecontrol(SiLi_8192CntHdl, 0);                Hilitecontrol(SiLi_1024CntHdl, 10);                Range_Keeper := 7;                Spectrum_Size := 1024;                New_Range := 1024;                ChannelMax := 1024;              END;          END;        2048:          BEGIN            IF SiLi_2048CntHdl^^.contrlHilite = 0 THEN              BEGIN                IF SiLi_512CntHdl^^.contrlHilite = 10 THEN Hilitecontrol(SiLi_512CntHdl, 0);                IF SiLi_1024CntHdl^^.contrlHilite = 10 THEN Hilitecontrol(SiLi_1024CntHdl, 0);                IF SiLi_4096CntHdl^^.contrlHilite = 10 THEN Hilitecontrol(SiLi_4096CntHdl, 0);                IF SiLi_8192CntHdl^^.contrlHilite = 10 THEN Hilitecontrol(SiLi_8192CntHdl, 0);                Hilitecontrol(SiLi_2048CntHdl, 10);                Range_Keeper := 8;                Spectrum_Size := 2048;                New_Range := 2048;                ChannelMax := 2048;              END;          END;        4096:          BEGIN            IF SiLi_4096CntHdl^^.contrlHilite = 0 THEN              BEGIN                IF SiLi_512CntHdl^^.contrlHilite = 10 THEN Hilitecontrol(SiLi_512CntHdl, 0);                IF SiLi_1024CntHdl^^.contrlHilite = 10 THEN Hilitecontrol(SiLi_1024CntHdl, 0);                IF SiLi_2048CntHdl^^.contrlHilite = 10 THEN Hilitecontrol(SiLi_2048CntHdl, 0);                IF SiLi_8192CntHdl^^.contrlHilite = 10 THEN Hilitecontrol(SiLi_8192CntHdl, 0);                Hilitecontrol(SiLi_4096CntHdl, 10);                Range_Keeper := 9;                Spectrum_Size := 4096;                New_Range := 4096;                ChannelMax := 4096;              END;          END;        8192:          BEGIN            IF SiLi_8192CntHdl^^.contrlHilite = 0 THEN              BEGIN                IF SiLi_512CntHdl^^.contrlHilite = 10 THEN Hilitecontrol(SiLi_512CntHdl, 0);                IF SiLi_1024CntHdl^^.contrlHilite = 10 THEN Hilitecontrol(SiLi_1024CntHdl, 0);                IF SiLi_2048CntHdl^^.contrlHilite = 10 THEN Hilitecontrol(SiLi_2048CntHdl, 0);                IF SiLi_4096CntHdl^^.contrlHilite = 10 THEN Hilitecontrol(SiLi_4096CntHdl, 0);                Hilitecontrol(SiLi_8192CntHdl, 10);                Range_Keeper := 10;                Spectrum_Size := 8192;                New_Range := 8192;                ChannelMax := 8192;              END;          END;        END;      UpdateControls(SiLiWindow, GrafPtr(SiLiWindow)^.VisRgn);      SetPort(GrafPtr(SavePort));      Update_Full;      Mouse_Active_Window;    END; { Reset_Range_Buttons }  PROCEDURE GenFromWork{(theSiLiRec : SiLi_RecHdl)};    VAR      thePtr                        : SiLi_RecPtr;    BEGIN      thePtr := SiLi_RecPtr(NewPtr(sizeof(Sili_Rec)));				   if thePtr = NIL then				     begin					   SysBeep(1);				       putmessage('Not enough memory available for this operation',					   'Please quit the program, do a "get info" and assign more memory to DTSA.','',''); 					   exit(GenFromWork);					 end;	        thePtr := @Plt_spec[10]^^.Expt_Info.Detector;      theSiLiRec^^ := thePtr^; {this gets some geom stuff: Azimuth,Elevation,Detector_tilt}      WITH theSiLiRec^^ DO        BEGIN          Spec_Detector_Distance := Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.Spec_Detector_Distance;          X_Tilt := Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.X_Tilt;          Y_Tilt := Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.Y_Tilt;          Take_Off_Angle := Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.Take_Off_Angle;        END;      IF theSiLiRec^^.Detector.Spec = WDS THEN        BEGIN          WDS_Active := true;          Si_Active := false;          Ge_Active := false;        END      ELSE {IF theGenRec^^.Detector.Spec = EDS THEN}        BEGIN          WDS_Active := false;		  IF theSiLiRec^^.Detector.ID = 2 THEN begin			  Si_Active := false;			  Ge_Active := true;		  end		  ELSE {IF theGenRec^^.Detector.ID = 2 THEN}		  begin			  Si_Active := true;			  Ge_Active := false;		  end;        END;      DisposePtr(ptr(thePtr));	  thePtr := NIL;    END; { PROCEDURE GenFromWork;}  PROCEDURE CompareGen_To_Work{(theSiLiRec : SiLi_RecHdl)}; { theGenRec has what made the current response function }  	VAR  		indx		: integer;  		    BEGIN      WITH theSiLiRec^^ DO        BEGIN          IF (Plt_spec[10]^^.Expt_Info.BN_Thickness <> BN_Thickness) OR 		     (Plt_spec[10]^^.Expt_Info.SiN_Thickness <> SiN_Thickness) OR 			 (Plt_spec[10]^^.Expt_Info.Moxtek <> Moxtek) OR			 (Plt_spec[10]^^.Expt_Info.Paralene <> Paralene) OR			 (Plt_spec[10]^^.Expt_Info.Mylar <> Mylar) OR 			 (Plt_spec[10]^^.Expt_Info.Diamond <> Diamond) OR 			 (Plt_spec[10]^^.Expt_Info.Quantum <> Quantum) OR 			 (Plt_spec[10]^^.Expt_Info.Detector_Thickness <> Detector_Thickness) OR 			 (Plt_spec[10]^^.Expt_Info.Si_Thickness <> Si_Thickness) OR 			 (Plt_spec[10]^^.Expt_Info.Au_Thickness <> Au_Thickness) OR 			 (Plt_spec[10]^^.Expt_Info.Be_Thickness <> Be_Thickness) OR 			 (Plt_spec[10]^^.Expt_Info.Ice_Thickness <> Ice_Thickness) OR 			 (Plt_spec[10]^^.Expt_Info.C_Thickness <> C_Thickness) OR 			 (Plt_spec[10]^^.Expt_Info.Al_Thickness <> Al_Thickness) OR 			 (Plt_spec[10]^^.Expt_Info.Detector_tilt <> Detector_tilt) OR 			 (Plt_spec[10]^^.Expt_Info.dE <> dE) OR 			 (Plt_spec[10]^^.Expt_Info.Number_of_Channels > Number_of_Channels)              THEN            BEGIN              SiLi_Response_Calculated := false;            END;            indx := rinttol(1740.0/Plt_spec[10]^^.Expt_Info.dE);            IF Det_Effic_P^[Indx] <= 0.0 then            	SiLi_Response_Calculated := false;        END; { WITH }    END;  PROCEDURE Convolve_WDS;    VAR      nn                            : integer;      Cente                         : real;      Sigma                         : real;      SIGSQ                         : real;      Pisig                         : real;      MM                            : integer;      LN                            : integer;      E                             : real;      xx, yy, Dele                  : real;      DELESQ                        : real;      YE                            : real;      MN                            : integer;    BEGIN      (*dE := Plt_spec[10]^^.Expt_Info.dE;*)      WITH BigHndl^^ DO        BEGIN          FOR nn := 1 TO Spectrum_Size DO { in general Spectrum_Size below <> Maximum_channels }            Smooth_Array[nn] := Col_1^[nn];          FOR nn := - 29 TO 6 DO            Smooth_Array[nn] := 0.0; { Paranoia }          FOR nn := Spectrum_Size + 1 TO Spectrum_Size + 30 DO            Smooth_Array[nn] := 0.0;          { APPLY A GAUSSIAN + LORENTZIAN INSTRUMENTAL BROADENING FNC OVER 60 CHANNELS.}          (*SIGSQ := (Plt_spec[10]^^.Expt_Info.WDS_Resolution * Plt_spec[10]^^.Expt_Info.WDS_Resolution * aSigConst);*)		  SIGSQ := (FWHM * FWHM * aSigConst);		  Sigma := sqrt(SIGSQ);		  Pisig := Pirt / Sigma;		  yy := - 0.5 / SIGSQ;          FOR nn := 1 TO Spectrum_Size DO            BEGIN              SpinCursor;              Cente := nn * dE; {ARRAY ELEMENT N->ENERGY := N*DE}              IF Cente <= 50 THEN Cente := 50.0;              MN := nn - 29;              LN := nn + 30;              YE := 0.0;              xx := dE * Pisig;              FOR MM := MN TO LN DO                BEGIN                  E := MM * dE;                  Dele := Cente - E;                  DELESQ := Dele * Dele;                  (*YE := YE + xx * Smooth_Array[MM] * exp(yy * DELESQ);*)				  YE := YE + one_Coeff * xx * Smooth_Array[MM] * exp(yy * DELESQ) + 				  			(1 - one_Coeff) * xx * Smooth_Array[MM] / (1 + DELESQ);                END;              Col_1^[nn] := YE;            END;        END; { with bighndl...}    END; { Procedure Convolve_WDS }  PROCEDURE Convolve_Col1;        VAR      nn                      : integer;      str2, str3              : Str255;    BEGIN{```}	  if NOT Do_it_in_the_Dark then		{ Skip this when doing quals. }       PutBusyMessage('Busy convolving with detector response function.', 'Please wait.', '', '');      Math_Channels := Plt_spec[10]^^.Expt_Info.Number_of_Channels;	{ее5/8/93 special variable for math. ее}      dE := Plt_spec[10]^^.Expt_Info.dE;      IF Math_Channels > 8190 THEN Math_Channels := 8190;      IF (NOT WDS_Active) THEN FWHM := Plt_spec[10]^^.Expt_Info.Si_Resolution      ELSE FWHM := Plt_spec[10]^^.Expt_Info.WDS_Resolution;      { Globals FWHM and dE needed in the assembly code }      {NumToString(Math_Channels, str1);}      RealToString(FWHM, 5, 4, str2);      RealToString(dE, 5, 4, str3);      IF (NOT WDS_Active) AND (FWHM < 1.00) THEN        BEGIN          if NOT Do_it_in_the_Dark then	DisposeDialog(BusyMessage);          PutMessage('There was a fatal error in the spectrum convolver, I can not convolve this', 'spectrum.',                     'The Detector resolution was not appropriate for an EDS, it was', str2);          Exit(Convolve_Col1);        END;      IF (Math_Channels <= 8192) AND (Math_Channels > 511) THEN        BEGIN          IF WDS_Active THEN Convolve_WDS          ELSE		  Convolve		            (*  BEGIN              IF (FWHM >= 100) THEN Convolve              ELSE Convolve_WDS;            END;*)			        END      ELSE        BEGIN          if NOT Do_it_in_the_Dark then	DisposeDialog(BusyMessage);          PutMessage('There was a fatal error in the spectrum convolver, I can not convolve this', 'spectrum.',                     'The spectrum size was not valid. It was', str2);        END;      IF Math_Channels = 8190 THEN Math_Channels := 8192;      FOR nn := 8190 TO 8192 DO        Plt_spec[10]^^.s[nn] := 0.0;{```}   if NOT Do_it_in_the_Dark then	DisposeDialog(BusyMessage);    END;    (* ееееееееееееее Converted to assembly language starting from this code ееееееееееееее *)  PROCEDURE Convolve ;    VAR      nn                            : integer;      Cente                         : real;      Sigma                         : real;      SIGSQ                         : real;      Pisig                         : real;      MM                            : integer;      LN                            : integer;      E                             : real;      xx, yy, Dele                  : real;      DELESQ                        : real;      YE                            : real;      MN, Spectrum_Size                            : integer;    BEGIN  		Spectrum_Size := Plt_spec[10]^^.Expt_Info.number_of_channels;      WITH BigHndl^^ DO        BEGIN            FOR nn := 1 TO Spectrum_Size DO { in general Spectrum_Size below <> Maximum_channels }            Smooth_Array[nn] := Col_1^[nn];          FOR nn := - 29 TO 6 DO            Smooth_Array[nn] := 0.0; { Paranoia }          FOR nn := Spectrum_Size + 1 TO Spectrum_Size + 30 DO            Smooth_Array[nn] := Smooth_Array[Spectrum_Size];          { APPLY A GAUSSIAN INSTRUMENTAL BROADENING FNC OVER 60 CHANNELS.}          SigSqMn := (FWHM * FWHM * aSigConst);          FOR nn := 1 TO Spectrum_Size DO            BEGIN              SpinCursor;              Cente := nn * dE; {ARRAY ELEMENT N->ENERGY := N*DE}              IF Cente <= 50 THEN Cente := 50.0;              SIGSQ := theSigConst * (Cente - 5895.0) + SigSqMn;			  IF FWHM < 125.0 then			  	SIGSQ := SigSqMn;              Sigma := sqrt(SIGSQ);              Pisig := Pirt / Sigma;              MN := nn - 29;              LN := nn + 30;              YE := 0.0;              xx := dE * Pisig;              yy := - 0.5 / SIGSQ;              FOR MM := MN TO LN DO                BEGIN                  E := MM * dE;                  Dele := Cente - E;                  DELESQ := Dele * Dele;                  YE := YE + xx * Smooth_Array[MM] * exp(yy * DELESQ);                END;              Col_1^[nn] := YE;            END;        END; { with bighndl...}       END; { Procedure Convolve  }   PROCEDURE Smooth_Spectrum {(var theSpecIn,theSpecOut:spectrum_counts; which_Smooth: integer )} ;   {example call   Smooth_Spectrum(Plt_Spec[10]^^.S, Plt_Spec[9]^^.S, Points_for_Smooth );}    VAR	  Spectrum_Size	: integer;      nn                           : integer;      {[f-]}    BEGIN  	  Spectrum_Size := Plt_spec[10]^^.Expt_Info.number_of_channels;	  WITH BigHndl^^ do BEGIN      IF (which_Smooth = 5)        THEN          BEGIN		  Smooth_Array[1] := zero;		  Smooth_Array[2] := zero;		  Smooth_Array[Spectrum_Size-1] := zero;		  Smooth_Array[Spectrum_Size] := zero;          SpinCursor;            FOR nn := 3 TO Spectrum_Size-2 DO                          Smooth_Array[nn] := ( - 3  * thespecin[nn - 2]                                                + 12 * thespecin[nn -1]                                                + 17 * thespecin[nn]                                                + 12 * thespecin[nn + 1]                                                  - 3  * thespecin[nn + 2]) / 35;             For nn := 1 to Spectrum_size Do theSpecOut[nn]:= Smooth_array[nn];		  END;      IF (which_Smooth = 7)        THEN          BEGIN		   Smooth_Array[1] := zero;		   Smooth_Array[2] := zero;		   Smooth_Array[3] := zero;		   Smooth_Array[Spectrum_Size - 2] := zero;		   Smooth_Array[Spectrum_Size - 1] := zero;		   Smooth_Array[Spectrum_Size ] := zero;           SpinCursor;            FOR nn := 4 TO Spectrum_Size-3 DO                          Smooth_Array[nn] := ( - 2 * thespecin[nn - 3]                                                + 3 * thespecin[nn - 2]                                                + 6 * thespecin[nn -1]                                                + 7 * thespecin[nn]                                                + 6 * thespecin[nn + 1]                                                + 3 * thespecin[nn +2]                                                - 2 * thespecin[nn + 3]) / 21;              For nn := 1 to Spectrum_size Do theSpecOut[nn]:= Smooth_array[nn];          END;      IF (which_Smooth = 9)        THEN          BEGIN		   Smooth_Array[1] := zero;		   Smooth_Array[2] := zero;		   Smooth_Array[3] := zero;		   Smooth_Array[4] := zero;		   Smooth_Array[Spectrum_Size - 3 ] := zero;		   Smooth_Array[Spectrum_Size - 2] := zero;		   Smooth_Array[Spectrum_Size - 1] := zero;		   Smooth_Array[Spectrum_Size ] := zero;           SpinCursor;            FOR nn := 5 TO Spectrum_Size-4 DO                          Smooth_Array[nn] := ( - 21 * thespecin[nn - 4]                                                + 14 * thespecin[nn - 3]                                                + 39 * thespecin[nn -2]                                                + 54 * thespecin[nn -1]                                                + 59 * thespecin[nn]                                                + 54 * thespecin[nn +1]                                                + 39 * thespecin[nn + 2]                                                + 14 * thespecin[nn + 3]                                                - 21 * thespecin[nn + 4]) / 231;              For nn := 1 to Spectrum_size Do theSpecOut[nn]:= Smooth_array[nn];          END;{[f+]}          IF (which_Smooth = 1) THEN            BEGIN { Gaussian Convolve }              FOR nn := 1 TO Spectrum_Size DO                Col_1^[nn] := theSpecIn[nn];              Convolve_Col1; { io.a assembler code. Goes from Smooth_Array to col1 }              FOR nn := 1 TO Spectrum_Size DO                theSpecOut[nn] := Col_1^[nn];            END; { IF (which_Smooth = 1) }        END; { with bighndl...}    END; { procedure Smooth_Spectrum }  PROCEDURE Restore_Expt_Header(refNum: integer);{Note that the file mark is left at end of expt header, several places that use this proc require  this to be the case }    VAR      errCode                       : OSErr;      bytecount                     : Longint;    BEGIN      errCode := SetFPos_err(refNum, fsFromStart, 0, 'Restore_Expt_Header');      bytecount := sizeof(expt_infoRec);      errCode := FSRead_err(refNum, bytecount, @Plt_spec[10]^^.Expt_Info, 'Restore_Expt_Header');    END;  PROCEDURE Flow_Chart {( DialNum : Integer)} ;    VAR      tempRect                      : rect;      GetFlowChart                  : DialogPtr;      itemHit                       : integer;      DType                         : integer;      DItem                         : Handle;      ExitDialog                    : Boolean;    CONST      G_Accept                      = 1;    BEGIN      GetFlowChart := GetNewDialog(DialNum, NIL, POINTER( - 1));      ShowWindow(GetFlowChart);      SelectWindow(GetFlowChart);      SetPort(GetFlowChart);      OutlineButton(GetFlowChart, 1, 16); { outline the OK button }      REPEAT        ModalDialog(NIL, itemHit);        GetDialogItem(GetFlowChart, itemHit, DType, DItem, tempRect);        IF (itemHit = G_Accept) THEN          BEGIN            ExitDialog := true;          END;      UNTIL ExitDialog;      DisposeDialog(GetFlowChart);      BeginUpdate(BackPlane);      DrawAxesFull;      Update_Full;      EndUpdate(BackPlane);      UpDate_SiLi_Window(SiLiWindow);    END; {End of FlowChart procedure}  PROCEDURE UnCheck_AllSpectra;    BEGIN      Spectrum_Full[10] := false;      CheckItem(FullMenu, A^.C_Full[10], Spectrum_Full[10]);      Spectrum_Full[9] := false;      CheckItem(FullMenu, A^.C_Full[9], Spectrum_Full[9]);      Spectrum_Full[8] := false;      CheckItem(FullMenu, A^.C_Full[8], Spectrum_Full[8]);      Spectrum_Full[7] := false;      CheckItem(FullMenu, A^.C_Full[7], Spectrum_Full[7]);      Spectrum_Full[6] := false;      CheckItem(FullMenu, A^.C_Full[6], Spectrum_Full[6]);      Spectrum_Full[5] := false;      CheckItem(FullMenu, A^.C_Full[5], Spectrum_Full[5]);      Spectrum_Full[4] := false;      CheckItem(FullMenu, A^.C_Full[4], Spectrum_Full[4]);      Spectrum_Full[3] := false;      CheckItem(FullMenu, A^.C_Full[3], Spectrum_Full[3]);      Spectrum_Full[2] := false;      CheckItem(FullMenu, A^.C_Full[2], Spectrum_Full[2]);      Spectrum_Full[1] := false;      CheckItem(FullMenu, A^.C_Full[1], Spectrum_Full[1]);    END;  PROCEDURE Clear_the_Rois;    VAR      nn                            : integer;    BEGIN      ROI^^.Scale.Exists := false;      ROI^^.Scale.Hi := 1;      ROI^^.Scale.Value := zero;      ROI^^.Quant.Exists := false;      ROI^^.Quant.Hi := 1;      ROI^^.Quant.Value := zero;      FOR nn := 1 TO Max_Rois DO        BEGIN          ROI^^.Peak[nn].Lo := 1;          ROI^^.Peak[nn].Hi := 1;          ROI^^.Peak[nn].Value := zero;          ROI^^.Peak[nn].Exists := false;          ROI^^.Peak[nn].ROI := nn;          ROI^^.BackGround[nn].Lo := 1;          ROI^^.BackGround[nn].Hi := 1;          ROI^^.BackGround[nn].Value := zero;          ROI^^.BackGround[nn].Exists := false;          ROI^^.BackGround[nn].ROI := nn;        END;      Number_of_BackGrounds := 1;      Number_of_PeakRois := 1;	  Kill_Quants;	  Simplex_active := False;	  LLSQ_active := False;      Refresh_ROIs;      Update_Full;      GetPort(GrafPtr(SavePort));      SetPort(ROIWindow);      InValRect(ROIWindow^.portRect);      SetPort(GrafPtr(SavePort));    END;  {=================================}  {$S Global_Functions1}  PROCEDURE Init_BackPlane;    BEGIN      BackPlane := NIL;    END;  {========================================================================================}  PROCEDURE Open_BackPlane;    VAR      pixDepth                      : Longint;      pixRowBytes                   : Longint;      buffersize                    : Longint;      bufferAddr                    : ptr;      Str, str1             : Str255;    BEGIN      colorPPtr := @colorPort;      OpenCPort(colorPPtr);      IF (BackPlane = NIL) THEN        BEGIN   (*  resource 'WIND' (11, "Full") {             { 35,   15, 335, 640}, PlainDBox,     invisible,   noGoAway, 0xB, "Full" };resource 'WIND' (13, "BackPlane") {             { 20,   0, 356, 640}, PlainDBox,     invisible,   noGoAway, 0xD, "BackPlane" };            t,    l,   b,   rresource 'WIND' (12, "SiLi") {             {357,   0, 480, 640}, PlainDBox,     invisible,   noGoAway, 0xC, "SiLi Window" };                     480-357 = 123  ScreenArea := screenBits.Bounds;  { get max size of screen (don't assume) }  with ScreenArea do        SetRect(MaxWindowRect,0,38,right,bottom); { set max size available for                                                application windows (global)}  *)          BackPlane := GetNewCWindow(313, NIL, POINTER( - 1));          SizeWindow(BackPlane, MaxWindowRect.Right, MaxWindowRect.Bottom - 144, true); {еее Fit to Available Screen еее}          SelectWindow(BackPlane);          ShowWindow(BackPlane);          SetPort(GrafPtr(BackPlane));          {?????????????}          BackPlaneRect.Left := BackPlane^.portRect.Left;          BackPlaneRect.Top := BackPlane^.portRect.Top;          BackPlaneRect.Right := BackPlane^.portRect.Right;          BackPlaneRect.Bottom := BackPlane^.portRect.Bottom;          {?????????????}          RGBBackColor(BackGround_Color);          EraseRect(BackPlaneRect);          MoveHHi(Handle(CGrafPort(BackPlane^).portPixMap));          HLock(Handle(CGrafPort(BackPlane^).portPixMap));          {еееееее}          FullWindowRect := BackPlane^.portRect;          FullWindowRect.Top := FullWindowRect.Top + 15;          FullWindowRect.Left := FullWindowRect.Left + 15;          FullWindowRect.Bottom := FullWindowRect.Bottom - 40; { moves the lower axes and the bottom of the spectrum }          {еееееее}          (* get bounds of drawing rectangle { 35, 15, 335, 640} t,l,b,r in MCA.r *)          Full_top_Screen := FullWindowRect.Top;          Full_Left_Screen := FullWindowRect.Left - 2;          Full_Right_Screen := FullWindowRect.Right - 8;          Full_Bottom_Screen := FullWindowRect.Bottom - 1; { moves the bottom of the spectrum }          Full_MarkerTOP := Full_top_Screen;          Full_MarkerBOTTOM := Full_Bottom_Screen; { These two are used in the KLM marker }          copyRect := FullWindowRect;          LocalToGlobal(copyRect.TopLeft);          LocalToGlobal(copyRect.botRight);          deepDeviceHdl := GetMaxDevice(copyRect);          pixDepth := deepDeviceHdl^^.gdPMap^^.pixelSize;          GlobalToLocal(copyRect.TopLeft);          GlobalToLocal(copyRect.botRight);          pixRowBytes := ((pixDepth * (copyRect.Right - copyRect.Left - 1) DIV 16) + 1) * 2;          buffersize := (copyRect.Bottom - copyRect.Top) * pixRowBytes;          IF FreeMem < buffersize THEN            BEGIN             {NumToString(FreeMem, Str);              NumToString(buffersize, str1);}              RealToString(FreeMem, 5, 1, Str);              RealToString(buffersize, 5, 1, str1);              Str := CONCAT(' Only ', Str, ' bytes left,', ' Need at least ', str1, ' bytes.');              PutMessage('Not enough memory available to run program.', Str,                         'If you are in multifinder, try going to the "Get Info" box and assigning more memory.',                         'To avoid a crash the program must terminate.');              Halt;            END;          bufferAddr := NewPtr(buffersize);				   if bufferAddr = NIL then				     begin					   SysBeep(1);              PutMessage('Not enough memory available to run program.', Str,                         'If you are in multifinder, try going to the "Get Info" box and assigning more memory.',                         'To avoid a crash the program must terminate.'); 					   Halt;					 end;          IF MemError <> 0 THEN            BEGIN              PutMessage('There was a memory error when the off screen bit map was being created.',                         'If you are in multifinder, or using System 7 or higher,',                         ' try going to the "Get Info" box and assigning more memory.',                         'To avoid a crash the program must terminate.');              Halt;            END;          WITH colorPPtr^.portPixMap^^ DO            BEGIN              baseAddr := bufferAddr;              rowBytes := pixRowBytes;              bitSet(@rowBytes, 0); { turn on high bit }              Bounds := copyRect;              pixelSize := pixDepth;            END;           savedDevice := GetGDevice; { preserve the graphics device }          SetGDevice(deepDeviceHdl); { make the deep device current }          SetPort(GrafPtr(colorPPtr)); {...and set the new one }          RGBBackColor(BackGround_Color);          EraseRect(colorPPtr^.portRect);		            {еееееее}          LeftHLCGPtr := CGrafPtr(NewPtr(sizeof(CGrafPort)));          IF LeftHLCGPtr = NIL THEN            BEGIN              PutMessage('Error creating Left Bottom Number OffScreen PixMap Record', '', '', '');              Halt;            END;          SetRect(copyRect, BackPlane^.portRect.Left + 1, BackPlane^.portRect.Bottom - 29, BackPlane^.portRect.Right,                  BackPlane^.portRect.Bottom - 21);          pixRowBytes := ((pixDepth * (copyRect.Right - copyRect.Left - 1) DIV 16) + 1) * 2;          buffersize := (copyRect.Bottom - copyRect.Top) * pixRowBytes;          bufferAddr := NewPtr(buffersize);          IF bufferAddr = NIL THEN            BEGIN              PutMessage('Error creating Left Bottom Number OffScreen PixMap storage', '', '', '');              Halt;            END;          OpenCPort(LeftHLCGPtr);          WITH LeftHLCGPtr^.portPixMap^^ DO            BEGIN              baseAddr := bufferAddr;              rowBytes := pixRowBytes;              bitSet(@rowBytes, 0); { turn on high bit }              Bounds := copyRect;              pixelSize := pixDepth;            END;          MoveHHi(Handle(LeftHLCGPtr^.portPixMap));          HLock(Handle(LeftHLCGPtr^.portPixMap));          SetPort(GrafPtr(LeftHLCGPtr));          RGBBackColor(BackGround_Color);          EraseRect(LeftHLCGPtr^.portPixMap^^.Bounds);          {еееееее}          SpecIDInfoCGPtr := CGrafPtr(NewPtr(sizeof(CGrafPort)));          IF SpecIDInfoCGPtr = NIL THEN            BEGIN              PutMessage('Error creating Spectrum Label OffScreen PixMap Record', '', '', '');              Halt;            END;          SetRect(copyRect, BackPlane^.portRect.Left + 5, 		                    BackPlane^.portRect.Bottom - 20, 							BackPlane^.portRect.Right - 1, 							BackPlane^.portRect.Bottom - 1);          pixRowBytes := ((pixDepth * (copyRect.Right - copyRect.Left - 1) DIV 16) + 1) * 2;          buffersize := (copyRect.Bottom - copyRect.Top) * pixRowBytes;          bufferAddr := NewPtr(buffersize);          IF bufferAddr = NIL THEN            BEGIN              PutMessage('Error creating Spectrum Label OffScreen PixMap storage', '', '', '');              Halt;            END;          OpenCPort(SpecIDInfoCGPtr);          WITH SpecIDInfoCGPtr^.portPixMap^^ DO            BEGIN              baseAddr := bufferAddr;              rowBytes := pixRowBytes;              bitSet(@rowBytes, 0); { turn on high bit }              Bounds := copyRect;              pixelSize := pixDepth;            END;          MoveHHi(Handle(SpecIDInfoCGPtr^.portPixMap));          HLock(Handle(SpecIDInfoCGPtr^.portPixMap));          SetPort(GrafPtr(SpecIDInfoCGPtr));          RGBBackColor(BackGround_Color);          EraseRect(SpecIDInfoCGPtr^.portPixMap^^.Bounds);          {еееееее}          UpVLCGPtr := CGrafPtr(NewPtr(sizeof(CGrafPort)));          IF UpVLCGPtr = NIL THEN            BEGIN              PutMessage('Error creating Right Top Number OffScreen PixMap Record', '', '', '');              Halt;            END;          SetRect(copyRect, BackPlane^.portRect.Left + 1, BackPlane^.portRect.Top, BackPlane^.portRect.Left + 60,                  BackPlane^.portRect.Top + 12);          pixRowBytes := ((pixDepth * (copyRect.Right - copyRect.Left - 1) DIV 16) + 1) * 2;          buffersize := (copyRect.Bottom - copyRect.Top) * pixRowBytes;          bufferAddr := NewPtr(buffersize);          IF bufferAddr = NIL THEN            BEGIN              PutMessage('Error creating Right Top Number OffScreen PixMap storage', '', '', '');              Halt;            END;          OpenCPort(UpVLCGPtr);          WITH UpVLCGPtr^.portPixMap^^ DO            BEGIN              baseAddr := bufferAddr;              rowBytes := pixRowBytes;              bitSet(@rowBytes, 0); { turn on high bit }              Bounds := copyRect;              pixelSize := pixDepth;            END;          MoveHHi(Handle(UpVLCGPtr^.portPixMap));          HLock(Handle(UpVLCGPtr^.portPixMap));          SetPort(GrafPtr(UpVLCGPtr));          RGBBackColor(BackGround_Color);          EraseRect(UpVLCGPtr^.portPixMap^^.Bounds);          {еееееее}          ChanNumCGPtr := CGrafPtr(NewPtr(sizeof(CGrafPort)));          IF ChanNumCGPtr = NIL THEN            BEGIN              PutMessage('Error creating Channel Number OffScreen PixMap Record', '', '', '');              Halt;            END;          SetRect(copyRect, BackPlane^.portRect.Left + 100, BackPlane^.portRect.Top, BackPlane^.portRect.Left + 140,                  BackPlane^.portRect.Top + 15);          pixRowBytes := ((pixDepth * (copyRect.Right - copyRect.Left - 1) DIV 16) + 1) * 2;          buffersize := (copyRect.Bottom - copyRect.Top) * pixRowBytes;          bufferAddr := NewPtr(buffersize);          IF bufferAddr = NIL THEN            BEGIN              PutMessage('Error creating Channel Number OffScreen PixMap storage', '', '', '');              Halt;            END;          OpenCPort(ChanNumCGPtr);          WITH ChanNumCGPtr^.portPixMap^^ DO            BEGIN              baseAddr := bufferAddr;              rowBytes := pixRowBytes;              bitSet(@rowBytes, 0); { turn on high bit }              Bounds := copyRect;              pixelSize := pixDepth;            END;          MoveHHi(Handle(ChanNumCGPtr^.portPixMap));          HLock(Handle(ChanNumCGPtr^.portPixMap));          SetPort(GrafPtr(ChanNumCGPtr));          RGBBackColor(BackGround_Color);          EraseRect(ChanNumCGPtr^.portPixMap^^.Bounds);          {еееееее}          ChanKvCGPtr := CGrafPtr(NewPtr(sizeof(CGrafPort)));          IF ChanKvCGPtr = NIL THEN            BEGIN              PutMessage('Error creating Channel Kv OffScreen PixMap Record', '', '', '');              Halt;            END;          SetRect(copyRect, BackPlane^.portRect.Left + 183, BackPlane^.portRect.Top, BackPlane^.portRect.Left + 255,                  BackPlane^.portRect.Top + 15);          pixRowBytes := ((pixDepth * (copyRect.Right - copyRect.Left - 1) DIV 16) + 1) * 2;          buffersize := (copyRect.Bottom - copyRect.Top) * pixRowBytes;          bufferAddr := NewPtr(buffersize);          IF bufferAddr = NIL THEN            BEGIN              PutMessage('Error creating Channel Kv OffScreen PixMap storage', '', '', '');              Halt;            END;          OpenCPort(ChanKvCGPtr);          WITH ChanKvCGPtr^.portPixMap^^ DO            BEGIN              baseAddr := bufferAddr;              rowBytes := pixRowBytes;              bitSet(@rowBytes, 0); { turn on high bit }              Bounds := copyRect;              pixelSize := pixDepth;            END;          MoveHHi(Handle(ChanKvCGPtr^.portPixMap));          HLock(Handle(ChanKvCGPtr^.portPixMap));          SetPort(GrafPtr(ChanKvCGPtr));          RGBBackColor(BackGround_Color);          EraseRect(ChanKvCGPtr^.portPixMap^^.Bounds);          {еееееее}          WorkCntsCGPtr := CGrafPtr(NewPtr(sizeof(CGrafPort)));          IF WorkCntsCGPtr = NIL THEN            BEGIN              PutMessage('Error creating Work Number OffScreen PixMap Record', '', '', '');              Halt;            END;          SetRect(copyRect, BackPlane^.portRect.Left + 293, BackPlane^.portRect.Top, BackPlane^.portRect.Left + 363,                  BackPlane^.portRect.Top + 15);          pixRowBytes := ((pixDepth * (copyRect.Right - copyRect.Left - 1) DIV 16) + 1) * 2;          buffersize := (copyRect.Bottom - copyRect.Top) * pixRowBytes;          bufferAddr := NewPtr(buffersize);          IF bufferAddr = NIL THEN            BEGIN              PutMessage('Error creating Work Number OffScreen PixMap storage', '', '', '');              Halt;            END;          OpenCPort(WorkCntsCGPtr);          WITH WorkCntsCGPtr^.portPixMap^^ DO            BEGIN              baseAddr := bufferAddr;              rowBytes := pixRowBytes;              bitSet(@rowBytes, 0); { turn on high bit }              Bounds := copyRect;              pixelSize := pixDepth;            END;          MoveHHi(Handle(WorkCntsCGPtr^.portPixMap));          HLock(Handle(WorkCntsCGPtr^.portPixMap));          SetPort(GrafPtr(WorkCntsCGPtr));          RGBBackColor(BackGround_Color);          EraseRect(WorkCntsCGPtr^.portPixMap^^.Bounds);          {еееееее}          ResultsCntsCGPtr := CGrafPtr(NewPtr(sizeof(CGrafPort)));          IF ResultsCntsCGPtr = NIL THEN            BEGIN              PutMessage('Error creating Results Number OffScreen PixMap Record', '', '', '');              Halt;            END;          SetRect(copyRect, BackPlane^.portRect.Left + 418, BackPlane^.portRect.Top, BackPlane^.portRect.Left + 488,                  BackPlane^.portRect.Top + 15);          pixRowBytes := ((pixDepth * (copyRect.Right - copyRect.Left - 1) DIV 16) + 1) * 2;          buffersize := (copyRect.Bottom - copyRect.Top) * pixRowBytes;          bufferAddr := NewPtr(buffersize);          IF bufferAddr = NIL THEN            BEGIN              PutMessage('Error creating Results Number OffScreen PixMap storage', '', '', '');              Halt;            END;          OpenCPort(ResultsCntsCGPtr);          WITH ResultsCntsCGPtr^.portPixMap^^ DO            BEGIN              baseAddr := bufferAddr;              rowBytes := pixRowBytes;              bitSet(@rowBytes, 0); { turn on high bit }              Bounds := copyRect;              pixelSize := pixDepth;            END;          MoveHHi(Handle(ResultsCntsCGPtr^.portPixMap));          HLock(Handle(ResultsCntsCGPtr^.portPixMap));          SetPort(GrafPtr(ResultsCntsCGPtr));          RGBBackColor(BackGround_Color);          EraseRect(ResultsCntsCGPtr^.portPixMap^^.Bounds);          {еееееее}          AtomicNumberCGPtr := CGrafPtr(NewPtr(sizeof(CGrafPort)));          IF AtomicNumberCGPtr = NIL THEN            BEGIN              PutMessage('Error creating Atomic Number OffScreen PixMap Record', '', '', '');              Halt;            END;          SetRect(copyRect, BackPlane^.portRect.Left + 535, BackPlane^.portRect.Top, BackPlane^.portRect.Left + 640,                  BackPlane^.portRect.Top + 15);          pixRowBytes := ((pixDepth * (copyRect.Right - copyRect.Left - 1) DIV 16) + 1) * 2;          buffersize := (copyRect.Bottom - copyRect.Top) * pixRowBytes;          bufferAddr := NewPtr(buffersize);          IF bufferAddr = NIL THEN            BEGIN              PutMessage('Error creating Atomic Number OffScreen PixMap storage', '', '', '');              Halt;            END;          OpenCPort(AtomicNumberCGPtr);          WITH AtomicNumberCGPtr^.portPixMap^^ DO            BEGIN              baseAddr := bufferAddr;              rowBytes := pixRowBytes;              bitSet(@rowBytes, 0); { turn on high bit }              Bounds := copyRect;              pixelSize := pixDepth;            END;          MoveHHi(Handle(AtomicNumberCGPtr^.portPixMap));          HLock(Handle(AtomicNumberCGPtr^.portPixMap));          SetPort(GrafPtr(AtomicNumberCGPtr));          RGBBackColor(BackGround_Color);          EraseRect(AtomicNumberCGPtr^.portPixMap^^.Bounds);          {еееееее}          TopCGPtr := CGrafPtr(NewPtr(sizeof(CGrafPort)));          IF TopCGPtr = NIL THEN            BEGIN              PutMessage('Error creating Top OffScreen PixMap Record', '', '', '');              Halt;            END;          SetRect(copyRect, BackPlane^.portRect.Left, BackPlane^.portRect.Top, BackPlane^.portRect.Right {Left + 640} ,                  BackPlane^.portRect.Top + 15);          pixRowBytes := ((pixDepth * (copyRect.Right - copyRect.Left - 1) DIV 16) + 1) * 2;          buffersize := (copyRect.Bottom - copyRect.Top) * pixRowBytes;          bufferAddr := NewPtr(buffersize);          IF bufferAddr = NIL THEN            BEGIN              PutMessage('Error creating Top OffScreen PixMap storage', '', '', '');              Halt;            END;          OpenCPort(TopCGPtr);          WITH TopCGPtr^.portPixMap^^ DO            BEGIN              baseAddr := bufferAddr;              rowBytes := pixRowBytes;              bitSet(@rowBytes, 0); { turn on high bit }              Bounds := copyRect;              pixelSize := pixDepth;            END;          MoveHHi(Handle(TopCGPtr^.portPixMap));          HLock(Handle(TopCGPtr^.portPixMap));          SetPort(GrafPtr(TopCGPtr));          RGBBackColor(BackGround_Color);          EraseRect(TopCGPtr^.portPixMap^^.Bounds);          {еееееее}          LeftCGPtr := CGrafPtr(NewPtr(sizeof(CGrafPort)));          IF LeftCGPtr = NIL THEN            BEGIN              PutMessage('Error creating left OffScreen PixMap Record', '', '', '');              Halt;            END;          SetRect(copyRect, BackPlane^.portRect.Left, BackPlane^.portRect.Top + 15, BackPlane^.portRect.Left + 15,                  BackPlane^.portRect.Bottom - 18);          pixRowBytes := ((pixDepth * (copyRect.Right - copyRect.Left - 1) DIV 16) + 1) * 2;          buffersize := (copyRect.Bottom - copyRect.Top) * pixRowBytes;          bufferAddr := NewPtr(buffersize);          IF bufferAddr = NIL THEN            BEGIN              PutMessage('Error creating left OffScreen PixMap storage', '', '', '');              Halt;            END;          OpenCPort(LeftCGPtr);          WITH LeftCGPtr^.portPixMap^^ DO            BEGIN              baseAddr := bufferAddr;              rowBytes := pixRowBytes;              bitSet(@rowBytes, 0); { turn on high bit }              Bounds := copyRect;              pixelSize := pixDepth;            END;          MoveHHi(Handle(LeftCGPtr^.portPixMap));          HLock(Handle(LeftCGPtr^.portPixMap));          SetPort(GrafPtr(LeftCGPtr));          RGBBackColor(BackGround_Color);          EraseRect(LeftCGPtr^.portPixMap^^.Bounds);          {еееееее}          BottomCGPtr := CGrafPtr(NewPtr(sizeof(CGrafPort)));          IF BottomCGPtr = NIL THEN            BEGIN              PutMessage('Error creating bottom OffScreen PixMap Record', '', '', '');              Halt;            END;          SetRect(copyRect, BackPlane^.portRect.Left, BackPlane^.portRect.Bottom - 40 {20} , BackPlane^.portRect.Right{Left                    + 640} , BackPlane^.portRect.Bottom);          pixRowBytes := ((pixDepth * (copyRect.Right - copyRect.Left - 1) DIV 16) + 1) * 2;          buffersize := (copyRect.Bottom - copyRect.Top) * pixRowBytes;          bufferAddr := NewPtr(buffersize);          IF bufferAddr = NIL THEN            BEGIN              PutMessage('Error creating bottom OffScreen PixMap storage', '', '', '');              Halt;            END;          OpenCPort(BottomCGPtr);          WITH BottomCGPtr^.portPixMap^^ DO            BEGIN              baseAddr := bufferAddr;              rowBytes := pixRowBytes;              bitSet(@rowBytes, 0); { turn on high bit }              Bounds := copyRect;              pixelSize := pixDepth;            END;          MoveHHi(Handle(BottomCGPtr^.portPixMap));          HLock(Handle(BottomCGPtr^.portPixMap));          SetPort(GrafPtr(BottomCGPtr));          RGBBackColor(BackGround_Color);          EraseRect(BottomCGPtr^.portPixMap^^.Bounds);          {еееееее}        END;    END;  {=================================}  PROCEDURE Open_Sili_Window;    CONST      SiLi_CopyW                    = 685;            {Button ID}      SiLi_CopyR                    = 686;            {Button ID}      SiLi_Rotate                   = 6685;           {Button ID}      SiLi_Review                   = 648;            {Button ID}      SiLi_Math                     = 647;            {Button ID}      SiLi_Calibrate                = 646;            {Button ID}      SiLi_Simplex                  = 1646;           {Button ID}      SiLi_ML_Lst_Sq                = 1647;           {Button ID}      SiLi_Do_Fit                   = 1648;           {Button ID}      SiLi_Add_Fit                  = 1649;           {Button ID}      SiLi_CLC                      = 548;            {Button ID}      SiLi_Fix                      = 339;            {Button ID}      SiLi_Pick                     = 3391;           {Button ID}      SiLi_Set                      = 344;            {Button ID  Markers Off}      {SiLi_CLM                      = 516; }           {Button ID  Markers On}      SiLi_Peak_ID                  = 1595;           {Button ID}      SiLi_ROI                      = 610;            {Button ID}      {SiLi_Strip_Escapes            = 960;}            {Button ID}      {SiLi_Strip_Peaks              = 1769;}           {Button ID}      SiLi_Save_Work                = 1059;           {Button ID}      SiLi_Auto                     = 332;            {Checkbox ID}      SiLi_Expand_Energy            = 500;            {Radio ID}      SiLi_Contract_Energy          = 502;            {Radio ID}      SiLi_Expand_Vert              = 504;            {Radio ID}      SiLi_Contract_Vert            = 506;            {Radio ID}      SiLi_Bipolar                  = 1024;           {Radio ID}      SiLi_Lin                      = 308;            {Radio ID}      SiLi_Sqrt                     = 309;            {Radio ID}      SiLi_Log                      = 310;            {Radio ID}      SiLi_Vertical                 = 652;            {Scroll bar ID}      SiLi_Energy                   = 650;            {Scroll bar ID}      SiLi_AcqCntl                  = 128;      SiLi_InAcqCntl                = 129;      SiLi_OutAcqCntl               = 130;      SiLi_512                      = 131;      SiLi_1024                     = 132;      SiLi_2048                     = 133;      SiLi_4096                     = 134;      SiLi_8192                     = 135;    BEGIN {Start of Window open routine}      IF (SiLiWindow = NIL) THEN        BEGIN          SiLiWindow := GetNewWindow(312, NIL, POINTER( - 1));          MoveWindow(SiLiWindow, MaxWindowRect.Left, MaxWindowRect.Bottom - 123, true);          ShowWindow(SiLiWindow);          SelectWindow(SiLiWindow);          SetPort(SiLiWindow);          SiLi_CtrlHandle := GetNewControl(SiLi_CopyW, SiLiWindow); { button}          SiLi_CtrlHandle := GetNewControl(SiLi_CopyR, SiLiWindow); { button}          SiLi_CtrlHandle := GetNewControl(SiLi_Rotate, SiLiWindow); { button}          SiLi_CtrlHandle := GetNewControl(SiLi_Math, SiLiWindow); { button}          SiLi_SeeFitCntlHdl := GetNewControl(SiLi_Review, SiLiWindow); { button}          SiLi_CalibCntlHdl := GetNewControl(SiLi_Calibrate, SiLiWindow); { button}          SiLi_CtrlHandle := GetNewControl(SiLi_CLC, SiLiWindow); { button}          SiLi_CtrlHandle := GetNewControl(SiLi_Fix, SiLiWindow); { button}          SiLi_CtrlHandle := GetNewControl(SiLi_Pick, SiLiWindow); { button}          SiLi_CtrlHdl_Mark := GetNewControl(SiLi_Set, SiLiWindow); { button}          {SiLi_CtrlHandle := GetNewControl(SiLi_CLM, SiLiWindow);} { button}          SiLi_CtrlHandle := GetNewControl(SiLi_Peak_ID, SiLiWindow); { button}          SiLi_CtrlHandle := GetNewControl(SiLi_ROI, SiLiWindow); { button}          {SiLi_CtrlHandle := GetNewControl(SiLi_Strip_Escapes, SiLiWindow);} { button}          {SiLi_CtrlHandle := GetNewControl(SiLi_Strip_Peaks, SiLiWindow);} { button}          SiLi_CtrlHandle := GetNewControl(SiLi_Save_Work, SiLiWindow); { button}          SiLi_CtrlHandle := GetNewControl(SiLi_Simplex, SiLiWindow); { button}          SiLi_CtrlHandle := GetNewControl(SiLi_ML_Lst_Sq, SiLiWindow); { button}          SiLi_DoFitCntlHdl := GetNewControl(SiLi_Do_Fit, SiLiWindow); { button}          SiLi_AddFitCntlHdl := GetNewControl(SiLi_Add_Fit, SiLiWindow); { button}          AutoScale_CtrlHandle := GetNewControl(SiLi_Auto, SiLiWindow); { checkbox}          SiLi_R1Control[1] := GetNewControl(SiLi_Expand_Energy, SiLiWindow); { radio }          SiLi_R1Control[2] := GetNewControl(SiLi_Contract_Energy, SiLiWindow); { radio }          SiLi_R1Control[3] := GetNewControl(SiLi_Expand_Vert, SiLiWindow); { radio }          SiLi_R1Control[4] := GetNewControl(SiLi_Contract_Vert, SiLiWindow); { radio }          Si_Li_Bipolar := GetNewControl(SiLi_Bipolar, SiLiWindow); { radio }          SiLi_R3Control[1] := GetNewControl(SiLi_Sqrt, SiLiWindow); { radio }          SiLi_R3Control[2] := GetNewControl(SiLi_Log, SiLiWindow); { radio }          SiLi_R3Control[3] := GetNewControl(SiLi_Lin, SiLiWindow); { radio }          Vertical_SiLi_CtrlHandle := GetNewControl(SiLi_Vertical, SiLiWindow); { scrollbar}          Energy_SiLi_CtrlHandle := GetNewControl(SiLi_Energy, SiLiWindow); { scrollbar}          SiLi_512CntHdl := GetNewControl(SiLi_512, SiLiWindow);          SiLi_1024CntHdl := GetNewControl(SiLi_1024, SiLiWindow);          SiLi_2048CntHdl := GetNewControl(SiLi_2048, SiLiWindow);          SiLi_4096CntHdl := GetNewControl(SiLi_4096, SiLiWindow);          SiLi_8192CntHdl := GetNewControl(SiLi_8192, SiLiWindow);{SDD}     SiLi_InCntHdl 	:= GetNewControl(SiLi_InAcqCntl, SiLiWindow);{SDD}     SiLi_OutCntHdl 	:= GetNewControl(SiLi_OutAcqCntl, SiLiWindow);{SDD}     SiLi_AcqCntlHdl 	:= GetNewControl(SiLi_AcqCntl, SiLiWindow);		  {SiLi_AcqCntlHdl^^.ContrlData := Handle(Plt_spec[10]);}	{commented on 3/9/94еее}			        END {End for if (SiLiWindow<>nil)}      ELSE {Already open, so ......}        BEGIN          ShowWindow(SiLiWindow);          SelectWindow(SiLiWindow);          SetPort(SiLiWindow);          IF Log_Scale_Display THEN SetControlValue(SiLi_R3Control[2], 1);          IF Log_Scale_Display = false THEN SetControlValue(SiLi_R3Control[2], 0);          IF Linear_Display THEN SetControlValue(SiLi_R3Control[3], 1);          IF Linear_Display = false THEN SetControlValue(SiLi_R3Control[3], 0);          IF Square_Root_Display THEN SetControlValue(SiLi_R3Control[1], 1);          IF Square_Root_Display = false THEN SetControlValue(SiLi_R3Control[1], 0);          IF Mouse_Function_Contract THEN SetControlValue(SiLi_R1Control[2], 1);          IF Mouse_Function_Contract = false THEN SetControlValue(SiLi_R1Control[2], 0);          IF Mouse_Function_Expand THEN SetControlValue(SiLi_R1Control[1], 1);          IF Mouse_Function_Expand = false THEN SetControlValue(SiLi_R1Control[1], 0);          IF Mouse_Vert_Contract THEN SetControlValue(SiLi_R1Control[4], 1);          IF Mouse_Vert_Contract = false THEN SetControlValue(SiLi_R1Control[4], 0);          IF Mouse_Vert_Expand THEN SetControlValue(SiLi_R1Control[3], 1);          IF Mouse_Vert_Expand = false THEN SetControlValue(SiLi_R1Control[3], 0);          IF Bipolar_Display THEN SetControlValue(Si_Li_Bipolar, 1);          IF Bipolar_Display = false THEN SetControlValue(Si_Li_Bipolar, 0);          IF Auto_Scale_Display THEN SetControlValue(AutoScale_CtrlHandle, 1);          IF Auto_Scale_Display = false THEN SetControlValue(AutoScale_CtrlHandle, 0);		  		  IF ShowMarkers = true Then		  	SetControlTitle(SiLi_CtrlHdl_Mark,'Off')		  ELSE		    SetControlTitle(SiLi_CtrlHdl_Mark,'On');		            { IF Scale_123_Display THEN SetControlValue(Scale_123_CtrlHandle, 1); }          { IF Scale_123_Display = FALSE THEN SetControlValue(Scale_123_CtrlHandle, 0); }        END; { ELSE }    END; {End of procedure}  {=================================}{$S Global_Functions5}  PROCEDURE Init_SiLi_Window;    BEGIN      SiLiWindow := NIL;    END;  {=================================}  PROCEDURE Close_SiLi_Window(whichWindow: WindowPtr; VAR theInput: TEHandle);    BEGIN      IF (SiLiWindow <> NIL) AND (SiLiWindow = whichWindow) THEN        BEGIN          DisposeWindow(SiLiWindow);          SiLiWindow := NIL;        END; {End for if (SiLiWindow<>nil)}    END; {End of procedure}  PROCEDURE UpDate_SiLi_Window {(whichWindow: WindowPtr)} ;    VAR      Icon_Handle                   : Handle;      sTemp                         : Str255;    BEGIN      IF (SiLiWindow <> NIL) AND (SiLiWindow = whichWindow) {true by the procedure definition }         THEN        BEGIN          GetPort(GrafPtr(SavePort));          SetPort(SiLiWindow);		(*  IF (Simplex_active) OR (LLSQ_active) THEN begin		  	Hilitecontrol(SiLi_DoFitCntlHdl, 0);			Hilitecontrol(SiLi_AddFitCntlHdl, 0);			Hilitecontrol(SiLi_SeeFitCntlHdl, 0);		  end		  else begin		  	Hilitecontrol(SiLi_DoFitCntlHdl, 255);			Hilitecontrol(SiLi_AddFitCntlHdl, 255);			Hilitecontrol(SiLi_SeeFitCntlHdl, 255);		  end; *)          BeginUpdate(whichWindow); {Set the clipping to the update area}          {Draw the Icon, ееееееееееее ScaleUp еееееееееееее}          Icon_Handle := GetIcon(314);          IF Auto_Scale_Display THEN            BEGIN              BackColor(WhiteColor);              ForeColor(BlackColor);            END          ELSE            BEGIN              BackColor(WhiteColor);              ForeColor(BlueColor);            END;          SetRect(tempRect, 475, 16, 507, 49); {left,top,right,bottom}          IF (Icon_Handle <> NIL) THEN            BEGIN              PlotIcon(tempRect, Icon_Handle);            END;          {Draw the Icon, ееееееееееее ScaleDown  еееееееееееее}          Icon_Handle := GetIcon(318);          IF Auto_Scale_Display THEN            BEGIN              BackColor(WhiteColor);              ForeColor(BlackColor);            END          ELSE            BEGIN              BackColor(WhiteColor);              ForeColor(BlueColor);            END;          SetRect(tempRect, 475, 49, 507, 81); {left,top,right,bottom}          IF (Icon_Handle <> NIL) THEN            BEGIN              PlotIcon(tempRect, Icon_Handle);            END;          {Draw the Icon, ееееееееееее File Left  еееееееееееее}          Icon_Handle := GetIcon(334);          IF MCA_Spectrum_Active OR display_Ref THEN            BEGIN              BackColor(WhiteColor);              ForeColor(BlueColor);            END          ELSE            BEGIN              BackColor(WhiteColor);              ForeColor(BlackColor);            END;          SetRect(tempRect, 364, 72, 396, 104); {left,top,right,bottom}          IF (Icon_Handle <> NIL) THEN            BEGIN              PlotIcon(tempRect, Icon_Handle); {Draw the standard icon}            END;          {Draw the Icon, ееееееееееее File Right  еееееееееееее}          Icon_Handle := GetIcon(335);          IF MCA_Spectrum_Active OR display_Ref THEN            BEGIN              BackColor(WhiteColor);              ForeColor(BlueColor);            END          ELSE            BEGIN              BackColor(WhiteColor);              ForeColor(BlackColor);            END;          SetRect(tempRect, 396, 72, 428, 104); {left,top,right,bottom}          IF (Icon_Handle <> NIL) THEN            BEGIN              PlotIcon(tempRect, Icon_Handle);            END;          {Draw the Icon, ееееееееееее MarkerLeft  еееееееееееее}          Icon_Handle := GetIcon(336);          BackColor(WhiteColor);          ForeColor(BlueColor);          SetRect(tempRect, 364, 20, 396, 52); {left,top,right,bottom}          IF (Icon_Handle <> NIL) THEN            BEGIN              PlotIcon(tempRect, Icon_Handle);            END;          {Draw the Icon, ееееееееееее MarkerRight  еееееееееееее}          Icon_Handle := GetIcon(337);          BackColor(WhiteColor);          ForeColor(BlueColor);          SetRect(tempRect, 396, 20, 428, 52); {left,top,right,bottom}          IF (Icon_Handle <> NIL) THEN            BEGIN              PlotIcon(tempRect, Icon_Handle);            END;          SetFont('Monaco', 9, [bold,underline]);          { Draw a line, Drawn line }          PenSize(2, 2);          MoveTo(471, 3);          LINETO(471, 122);          PenSize(1, 1);          SetRect(tempRect, 474, 3, 512, 16);          sTemp := 'Scale';          TETextbox(POINTER(Ord(@sTemp) + 1), length(sTemp), tempRect, Tejustleft);		  SetFont('Geneva', 10, [bold,underline]);          SetRect(tempRect, 362, 56, 464, 72);          sTemp := 'Select Spectrum:'; { Increment }          TETextbox(POINTER(Ord(@sTemp) + 1), length(sTemp), tempRect, Tejustleft);		  SetFont('Geneva', 12, [bold,underline]);		  SetRect(tempRect, 236, 0, 352, 32);          sTemp := 'Click at Point in Spectrum to:';          TETextbox(POINTER(Ord(@sTemp) + 1), length(sTemp), tempRect, Tejustleft);          SetFont('Monaco', 9, []);          SetRect(tempRect, 364, 2, 464, 18);          EraseRect(tempRect);          MoveTo(368, 14);          CASE MarkerPopup OF { These labels appear in the little box before a mouse down,, go to SiLiWindow.p for the                               part that appears after a mouse down. Also in MCA.r}            1:              BEGIN                DrawString('Pks+Escs+Dbles');              END;            2:              BEGIN                DrawString('+ Satellites');              END;            3:              BEGIN                DrawString('Peaks Alone');              END;            4:              BEGIN                DrawString('Excitation Edges');              END;            5:              BEGIN                DrawString('WDS 2nd order');              END;            6:              BEGIN                DrawString('WDS 3rd order');              END;            7:              BEGIN                DrawString('WDS 4th order');              END;            8:              BEGIN                DrawString('WDS 5th order');              END;            OTHERWISE              BEGIN              END;            END;          Framerect(tempRect);          BackColor(WhiteColor);          ForeColor(BlackColor);          MoveTo(tempRect.Left + 1, tempRect.Bottom);          LINETO(tempRect.Right, tempRect.Bottom);          LINETO(tempRect.Right, tempRect.Top + 1);          BackColor(WhiteColor);          ForeColor(BlackColor);          Draw1Control(SiLi_InCntHdl);          Draw1Control(SiLi_OutCntHdl);{SDD3}    Draw1Control(SiLi_AcqCntlHdl);{SDD3}    (* UpdateControls(SiLiWindow,GrafPtr(SiLiWindow)^.VisRgn);*)		  		  {еее}  {Need to update axes and markers if the cal values have changed...}		  IF Calibrate_Energy_Scale THEN 		{*** bob 11/3/92 ***}		  	HiliteControl (SiLi_CalibCntlHdl, 1)		  ELSE		    HiliteControl (SiLi_CalibCntlHdl, 0);		 		           (* Hilitecontrol(SiLi_512CntHdl, 0);          Hilitecontrol(SiLi_1024CntHdl, 0);          Hilitecontrol(SiLi_2048CntHdl, 0);          Hilitecontrol(SiLi_4096CntHdl, 0);          Hilitecontrol(SiLi_8192CntHdl, 0);*)          CASE Spectrum_Size OF            512:              BEGIN              	Hilitecontrol(SiLi_512CntHdl, 10);		          Hilitecontrol(SiLi_1024CntHdl, 0);		          Hilitecontrol(SiLi_2048CntHdl, 0);		          Hilitecontrol(SiLi_4096CntHdl, 0);		          Hilitecontrol(SiLi_8192CntHdl, 0);              END;            1024:              BEGIN              	Hilitecontrol(SiLi_1024CntHdl, 10);              	  Hilitecontrol(SiLi_512CntHdl, 0);		          Hilitecontrol(SiLi_2048CntHdl, 0);		          Hilitecontrol(SiLi_4096CntHdl, 0);		          Hilitecontrol(SiLi_8192CntHdl, 0);              END;            2048:              BEGIN              	Hilitecontrol(SiLi_2048CntHdl, 10);              	  Hilitecontrol(SiLi_512CntHdl, 0);		          Hilitecontrol(SiLi_1024CntHdl, 0);		          Hilitecontrol(SiLi_4096CntHdl, 0);		          Hilitecontrol(SiLi_8192CntHdl, 0);              END;            4096:              BEGIN              	Hilitecontrol(SiLi_4096CntHdl, 10);              	  Hilitecontrol(SiLi_512CntHdl, 0);		          Hilitecontrol(SiLi_1024CntHdl, 0);		          Hilitecontrol(SiLi_2048CntHdl, 0);		          Hilitecontrol(SiLi_8192CntHdl, 0);              END;            8192:              BEGIN              	Hilitecontrol(SiLi_8192CntHdl, 10);              	  Hilitecontrol(SiLi_512CntHdl, 0);		          Hilitecontrol(SiLi_1024CntHdl, 0);		          Hilitecontrol(SiLi_2048CntHdl, 0);		          Hilitecontrol(SiLi_4096CntHdl, 0);              END;            END; { Case...}          UpdateControls(SiLiWindow, GrafPtr(SiLiWindow)^.VisRgn); {sdd moved from above}          EndUpdate(whichWindow); {Return to normal clipping area}          SetPort(GrafPtr(SavePort));        END; {End for if (SiLiWindow<>nil)}    END; {End of procedure} (* PROCEDURE Plot_Linear(XIntPtr: IntArrayPtr; YIntPtr: IntArrayPtr; SpectraPtr: Spectrum_Ptr; ChannelMin: integer;                         ChannelMax: integer; Pix_X_Min: integer; Pix_X_Max: integer; Pix_Y_Min: integer; Pix_Y_Max:                        integer; SY: real; IY: real; SX: real; IX: real); EXTERNAL;*)    PROCEDURE CompactMemory;    BEGIN      grow := 4000000;      PurgeMem(grow);      grow := CompactMem(grow);      IF MemError <> 0 THEN PutMessage('Error in attempting to CompactMem', '', '', '');    END;  FUNCTION AtSymbol_To_Znum { (symbol: Str255): integer } ;       {       This function accepts a one or two character string of atomic symbol or number       and converts it to a number.       It works for atomic numbers 1 -> maxatno.       It only wants to look at one or two characters.       If more than two characters are passed, it beeps & returns -1.       If both characters are not letters, it beeps & returns -2.       It is not case sensitive.       If successful, it returns the atomic number of the element.       If unsuccessful(the two letters are not an element symbol,                                              it beeps and returns -3.       It will accept single letter element symbols as single character or a pair of          characters with either the first or second one as a space.       }    VAR      Index, atno                   : integer;      numZ                          : Longint;      messtr                        : Str255;    FUNCTION IsaLetter(chr: char): Boolean; {operates on a single character}      { Purpose:    if chr is an upper or lower case letter, returns TRUE,                   otherwise, returns false.}      BEGIN        IF ((Ord(chr) > 64) AND (Ord(chr) < 91)) OR ((Ord(chr) > 96) AND (Ord(chr) < 123)) THEN IsaLetter := true        ELSE IsaLetter := false      END; {of IsaLetter}    FUNCTION IsaNumber(chr: char): Boolean; {operates on a single character}       {Purpose:    if chr is a number, returns TRUE,                   otherwise, returns false.}      BEGIN        IF (Ord(chr) > 47) AND (Ord(chr) < 58) THEN IsaNumber := true        ELSE IsaNumber := false      END; {of IsaNumber}    FUNCTION ToUpperCase(chr: char): char; {operates on a single character}       {Purpose: if chr is a lower case letter, returns the corresponding                   upper case letter, otherwise, chr is unchanged.}      BEGIN        IF (Ord(chr) > 96) AND (Ord(chr) < 123) THEN ToUpperCase := char(Ord(chr) - 32)        ELSE ToUpperCase := chr      END; {of ToUpperCase}    BEGIN {main function}      (* first, perform several checks on the input data *)      IF (length(symbol) = 0) THEN        BEGIN          AtSymbol_To_Znum := 0;          Exit(AtSymbol_To_Znum);        END;      IF (length(symbol) = 1) THEN        BEGIN          IF (symbol[1] = ' ') THEN            BEGIN              AtSymbol_To_Znum := 0;              Exit(AtSymbol_To_Znum);            END;        END;      IF (length(symbol) = 2) THEN        BEGIN          IF ((symbol[1] = ' ') AND (symbol[2] = ' ')) THEN            BEGIN              AtSymbol_To_Znum := 0;              Exit(AtSymbol_To_Znum);            END;        END;      IF (length(symbol) > 2) {2 char max, else error}         THEN        BEGIN          AtSymbol_To_Znum := - 1; {error = too long input string}          Index := length(symbol);          {NumToString(Index, messtr);}          RealToString(Index, 4, 1, messtr);          messtr := CONCAT('error = too many characters: ', messtr);          { PutMessage(messtr, symbol, '', ''); }          Exit(AtSymbol_To_Znum);        END      ELSE        IF (length(symbol) = 1) THEN          BEGIN            IF (IsaNumber(symbol[1]) = true) THEN              BEGIN                StringtoNum(symbol, numZ);                AtSymbol_To_Znum := numZ;                Exit(AtSymbol_To_Znum);              END            ELSE              IF (IsaLetter(symbol[1]) = false) THEN                BEGIN                  BeepBeep;                  AtSymbol_To_Znum := - 2;                  Exit(AtSymbol_To_Znum);                END;          END        ELSE          IF (length(symbol) = 2) THEN            BEGIN              IF ((symbol[1] = ' ') AND (symbol[2] = ' ')) THEN                BEGIN                  AtSymbol_To_Znum := - 2; {error = non-letter input}                  BeepBeep;                  Exit(AtSymbol_To_Znum);                END;              IF ((IsaNumber(symbol[1]) = true) AND (symbol[2] = ' ')) THEN                BEGIN                  symbol[2] := symbol[1];                  symbol[1] := ' ';                END;              IF (((IsaNumber(symbol[1]) = true) AND (IsaNumber(symbol[2]) = true)) OR ((IsaNumber(symbol[2]) = true)                 AND (symbol[1] = ' '))) THEN                BEGIN                  StringtoNum(symbol, numZ);                  AtSymbol_To_Znum := numZ;                  Exit(AtSymbol_To_Znum);                END              ELSE                IF (((IsaLetter(symbol[1]) = false) AND (symbol[1] <> ' ')) OR ((IsaLetter(symbol[2]) = false) AND (                   symbol[2] <> ' '))) THEN                  BEGIN                    BeepBeep;                    AtSymbol_To_Znum := - 2;                    Exit(AtSymbol_To_Znum);                  END;            END;      { changes to simplify testing later:}      IF (length(symbol) = 1) THEN symbol := CONCAT(symbol, ' '); { make two chrs }      IF (symbol[1] = ' ') {if a space & a letter, make letter capital & first}         THEN        BEGIN          symbol[1] := symbol[2];          symbol[2] := ' '        END;      symbol[1] := ToUpperCase(symbol[1]); { make upper case}      IF (Ord(symbol[2]) > 64) AND (Ord(symbol[2]) < 91) THEN symbol[2] := char(Ord(symbol[2]) + 32); { make lower        case}      { this is where the atomic number is assigned }      Index := 0;      REPEAT        Index := Index + 1;      UNTIL (A^.Sym[Index] = symbol) OR (Index >= 95);      IF Index <= 95 THEN atno := Index      ELSE atno := 0;      IF (atno > 0) { if 0, no match}         THEN        BEGIN          AtSymbol_To_Znum := atno;          Exit(AtSymbol_To_Znum);        END      ELSE        BEGIN          AtSymbol_To_Znum := - 3; {error = no match}          BeepBeep;          Exit(AtSymbol_To_Znum);        END;    END; {of Function AtSymbol_To_Znum}  FUNCTION FSOpen_err(name: Str255; vRefNum: integer; VAR refNum: integer; Msg: Str255): OSErr;    VAR      err                           : OSErr;      Str                           : Str255;    BEGIN      err := FSOpen(name, vRefNum, refNum);      IF err <> NoErr THEN        BEGIN          IF err = bdNamErr THEN Str := 'System FSOpen Error: Bad File Name';          IF err = extFSErr THEN Str := 'System FSOpen Error: External file system error';          IF err = fnfErr THEN Str := 'System FSOpen Error: File not found';          IF err = ioErr THEN Str := 'System FSOpen Error: I/O error';          IF err = nsvErr THEN Str := 'System FSOpen Error: no such volume';          IF err = opWrErr THEN Str := 'System FSOpen Error: File already open for writing';          IF err = tmfoErr THEN Str := 'System FSOpen Error: Too many files open';          PutMessage(Str, 'From', name, Msg);        END;      FSOpen_err := err;    END; { Function }  FUNCTION FSRead_err(refNum: integer; VAR count: Longint; buf: ptr; Msg: Str255): OSErr;    VAR      err                           : OSErr;      Str                           : Str255;    BEGIN      err := FSRead(refNum, count, buf);      IF err <> NoErr THEN        BEGIN          IF err = eofErr THEN Str := 'System FSRead Error: End of file ';          IF err = extFSErr THEN Str := 'System FSRead Error: External file system error';          IF err = fnOpnErr THEN Str := 'System FSRead Error: File not open';          IF err = ioErr THEN Str := 'System FSRead Error: I/O error';          IF err = paramErr THEN Str := 'System FSRead Error: negative count';          IF err = rfNumErr THEN Str := 'System FSRead Error: Bad reference number';          PutMessage(Str, Msg, '', '');        END;      FSRead_err := err;    END; { Function }  FUNCTION FSWrite_err(refNum: integer; VAR count: Longint; buf: ptr; Msg: Str255): OSErr;    VAR      err                           : OSErr;      Str                           : Str255;    BEGIN      err := FSWrite(refNum, count, buf);      IF err <> NoErr THEN        BEGIN          IF err = dskFulErr THEN Str := 'System FSWrite Error: Disk Full';          IF err = fLckdErr THEN Str := 'System FSWrite Error: File locked';          IF err = fnOpnErr THEN Str := 'System FSWrite Error: File not open';          IF err = ioErr THEN Str := 'System FSWrite Error: I/O error';          IF err = paramErr THEN Str := 'System FSWrite Error: negative count';          IF err = rfNumErr THEN Str := 'System FSWrite Error: Bad reference number';          IF err = vLckdErr THEN Str := 'System FSWrite Error: Software volume lock';          IF err = wPrErr THEN Str := 'System FSWrite Error: hardware volume lock';          IF err = wrPermErr THEN Str := 'System FSWrite Error: Read/Write permission doesn`t allow writing';          PutMessage(Str, Msg, '', '');        END;      FSWrite_err := err;    END; { Function }  FUNCTION SetFPos_err(refNum: integer; posMode: integer; posOff: Longint; Msg: Str255): OSErr;    VAR      err                           : OSErr;      Str                           : Str255;    BEGIN      err := SetFPos(refNum, posMode, posOff);      IF err <> NoErr THEN        BEGIN          IF err = eofErr THEN Str := 'System SetFPos Error: End of file error';          IF err = extFSErr THEN Str := 'System SetFPos Error: External file system error';          IF err = fnOpnErr THEN Str := 'System SetFPos Error: File not open';          IF err = ioErr THEN Str := 'System SetFPos Error: I/O error';          IF err = posErr THEN Str := 'System SetFPos Error: Attempt to position before start of file';          IF err = rfNumErr THEN Str := 'System SetFPos Error: Bad reference number';          PutMessage(Str, Msg, '', '');        END;      SetFPos_err := err;    END; { Function }  PROCEDURE SpinCursor;    CONST      SpinCursor1                   = 7;      SpinCursor2                   = 8;      SpinCursor3                   = 9;      SpinCursor4                   = 10;      SpinCursor5                   = 11;      SpinCursor6                   = 12;      SpinCursor7                   = 13;      SpinCursor8                   = 14;      SpinCursor9                   = 15;      SpinCursor10                  = 16;      SpinCursor11                  = 17;      SpinCursor12                  = 18;      SpinCursor13                  = 19;    BEGIN      IF Ticks > TickCount - 15 THEN Exit(SpinCursor);      SpinCursorCounter := SpinCursorCounter + 1;      IF SpinCursorCounter = SpinCursor1 THEN ChangeCursor(SpinC1);      IF SpinCursorCounter = SpinCursor2 THEN ChangeCursor(SpinC2);      IF SpinCursorCounter = SpinCursor3 THEN ChangeCursor(SpinC3);      IF SpinCursorCounter = SpinCursor4 THEN ChangeCursor(SpinC4);      IF SpinCursorCounter = SpinCursor5 THEN ChangeCursor(SpinC5);      IF SpinCursorCounter = SpinCursor6 THEN ChangeCursor(SpinC6);      IF SpinCursorCounter = SpinCursor7 THEN ChangeCursor(SpinC7);      IF SpinCursorCounter = SpinCursor8 THEN ChangeCursor(SpinC8);      IF SpinCursorCounter = SpinCursor9 THEN ChangeCursor(SpinC9);      IF SpinCursorCounter = SpinCursor10 THEN ChangeCursor(SpinC10);      IF SpinCursorCounter = SpinCursor11 THEN ChangeCursor(SpinC11);      IF SpinCursorCounter = SpinCursor12 THEN ChangeCursor(SpinC12);      IF SpinCursorCounter = SpinCursor13 THEN ChangeCursor(SpinC13);      IF SpinCursorCounter > SpinCursor13 THEN SpinCursorCounter := SpinCursor1 - 1;      Ticks := TickCount;    END;  PROCEDURE OutlineButton {(theDialog: DialogPtr; itemNo, CornerRad: Integer)} ;   { Draws a border around a button. 16 is the normal cornerRad for small buttons }    VAR      itemType                      : integer;      itemBox                       : rect;      itemHdl                       : Handle;      tempPort                      : GrafPtr;    BEGIN      GetPort(tempPort);      SetPort(theDialog);      GetDialogItem(theDialog, itemNo, itemType, itemHdl, itemBox);      PenSize(3, 3);      InSetRect(itemBox, - 4, - 4);      FrameRoundRect(itemBox, CornerRad, CornerRad);      PenSize(1, 1);      SetPort(tempPort);    END;  PROCEDURE BeepBeep;	VAR		beep_state		: integer;    BEGIN	  SndGetSysBeepState(beep_state);      IF beep_state = sysBeepEnable THEN       Sysbeep(10);    END;	  PROCEDURE Reset_ROIs;    VAR      Counter                       : integer;      n , m                         : integer;    BEGIN { PROCEDURE...}      ROI^^.Scale.Value := 0.0;      ROI^^.Quant.Value := 0.0;	  IF (DisplayROI = 1) then m := 10	  ELSE IF (DisplayROI = 2) then m := 9	  ELSE m := DisplayROI - 2;      Counter := Number_of_PeakRois;      IF (Number_of_BackGrounds > Number_of_PeakRois) THEN Counter := Number_of_BackGrounds;      FOR n := 1 TO Counter DO        BEGIN          ROI^^.Peak[n].Value := 0.0;          ROI^^.BackGround[n].Value := 0.0;        END; { FOR n...}      IF ROI^^.Scale.Exists THEN        BEGIN          FOR Counter := ROI^^.Scale.Lo TO ROI^^.Scale.Hi DO            BEGIN              ROI^^.Scale.Value := ROI^^.Scale.Value + Plt_spec[m]^^.s[Counter];            END;        END; { IF ROI^^...}      IF ROI^^.Quant.Exists THEN        BEGIN          FOR Counter := ROI^^.Quant.Lo TO ROI^^.Quant.Hi DO            BEGIN              ROI^^.Quant.Value := ROI^^.Quant.Value + Plt_spec[m]^^.s[Counter];            END;        END; { IF ROI^^...}      FOR n := 1 TO Number_of_PeakRois DO        BEGIN          IF (ROI^^.Peak[n].Exists = true) THEN            FOR Counter := ROI^^.Peak[n].Lo TO ROI^^.Peak[n].Hi DO              BEGIN                ROI^^.Peak[n].Value := ROI^^.Peak[n].Value + Plt_spec[m]^^.s[Counter];              END;        END; { FOR n := ...}      FOR n := 1 TO Number_of_BackGrounds DO        BEGIN          IF (ROI^^.BackGround[n].Exists = true) THEN            FOR Counter := ROI^^.BackGround[n].Lo TO ROI^^.BackGround[n].Hi DO              BEGIN                ROI^^.BackGround[n].Value := ROI^^.BackGround[n].Value + Plt_spec[m]^^.s[Counter];              END;        END; { FOR n := 1...}    END; { PROCEDURE Reset_ROIs }  PROCEDURE Update_ROI_Window { (whichWindow: WindowPtr) } ;    VAR      Str                           : Str255;      j                             : integer;      n                             : integer;      X_OffSet                      : integer;      Y_OffSet                      : integer;      Bumper                        : Boolean;      Value                         : real {double_t};    BEGIN      IF (ROIWindow <> NIL) AND (ROIWindow = whichWindow) THEN        BEGIN          GetPort(GrafPtr(SavePort));          SetPort(ROIWindow);          BeginUpdate(ROIWindow); {Set the clipping to the update area}          Mouse_Active_Window;          SetFont('geneva', 9, []);          SetRect(ROIRect, 275, 1, 638, 123); {left,top,right,bottom}          BackColor(WhiteColor); { The ROI dialog window is old style, not the new color structure }          ForeColor(BlackColor);          EraseRect(ROIRect);          Framerect(ROIRect);          X_OffSet := 175;          Y_OffSet := 11;          Bumper := false;          DrawControls(ROIWindow);          {UpdateControls(ROIWindow,GrafPtr(ROIWindow)^.VisRgn);}		  BackColor(YellowColor);		  ForeColor(RedColor);          SetFont('Chicago', 14, []);          SetRect(tempRect, 149, 19, 274, 39);          EraseRect(tempRect);		  MoveTo(tempRect.left + 2, tempRect.top + 15);          {MoveTo(152, 34);}          CASE DisplayROI OF { These labels appear in the little box before a mouse down,, go to SiLiWindow.p for the                               part that appears after a mouse down. Also in MCA.r}            1:              BEGIN                DrawString('Work  ->');				Reset_ROIs;              END;            2:              BEGIN                DrawString('Results  ->');				Reset_ROIs;              END;            3:              BEGIN                DrawString('Spectrum 1 ->');				Reset_ROIs;              END;            4:              BEGIN                DrawString('Spectrum 2 ->');				Reset_ROIs;              END;            5:              BEGIN                DrawString('Spectrum 3 ->');				Reset_ROIs;              END;            6:              BEGIN                DrawString('Spectrum 4 ->');				Reset_ROIs;              END;            7:              BEGIN                DrawString('Spectrum 5 ->');				Reset_ROIs;              END;            8:              BEGIN                DrawString('Spectrum 6 ->');				Reset_ROIs;              END;            9:              BEGIN                DrawString('Spectrum 7 ->');				Reset_ROIs;              END;            10:              BEGIN                DrawString('Spectrum 8 ->');				Reset_ROIs;              END;            OTHERWISE              BEGIN              END;            END;          Framerect(tempRect);		  BackColor(YellowColor);		  ForeColor(RedColor);		            MoveTo(tempRect.Left + 1, tempRect.Bottom);          LINETO(tempRect.Right, tempRect.Bottom);          LINETO(tempRect.Right, tempRect.Top + 1);		  		  SetFont('geneva', 9, []);          BackColor(WhiteColor);          ForeColor(BlackColor);		            IF ROI^^.Quant.Exists THEN            BEGIN              IF (SHow_ROI) { rename this variable to normalize }                 THEN                Value := ROI^^.Quant.Value / (ROI^^.Quant.Hi - ROI^^.Quant.Lo + 1)              ELSE Value := ROI^^.Quant.Value;              MoveTo(285, 11);              NumToString(ROI^^.Quant.Lo, Str);              DrawString('Quant : ');              DrawString(Str);              DrawString(' : ');              NumToString(ROI^^.Quant.Hi, Str);              DrawString(Str);              DrawString(' := ');              RealToString(Value, 3,  1, Str);              DrawString(Str);            END;          IF ROI^^.Scale.Exists THEN            BEGIN              IF (SHow_ROI) { rename this variable to normalize }                 THEN                Value := ROI^^.Scale.Value / (ROI^^.Scale.Hi - ROI^^.Scale.Lo + 1)              ELSE Value := ROI^^.Scale.Value;              MoveTo(285, 22);              NumToString(ROI^^.Scale.Lo, Str);              DrawString('Scale : ');              DrawString(Str);              DrawString(' : ');              NumToString(ROI^^.Scale.Hi, Str);              DrawString(Str);              DrawString(' := ');              RealToString(Value, 3,  1, Str);              DrawString(Str);            END;          j := 1;          n := 1;          WHILE j < 19 DO            BEGIN              WHILE (Bumper = false) OR (n <= Max_Rois) DO                BEGIN                  IF ROI^^.Peak[n].Exists THEN                    BEGIN                      IF (SHow_ROI) THEN Value := ROI^^.Peak[n].Value / (ROI^^.Peak[n].Hi - ROI^^.Peak[n].Lo + 1)                      ELSE Value := ROI^^.Peak[n].Value;                      IF j < 10 THEN MoveTo(285, 33 + (j - 1) * Y_OffSet);                      IF j >= 10 THEN MoveTo(285 + X_OffSet, 33 + (j - 12) * Y_OffSet);                      DrawString('P');                      NumToString(ROI^^.Peak[n].ROI, Str);                      DrawString(Str);                      DrawString(': ');                      NumToString(ROI^^.Peak[n].Lo, Str);                      DrawString(Str);                      DrawString(' : ');                      NumToString(ROI^^.Peak[n].Hi, Str);                      DrawString(Str);                      DrawString(' := ');                      RealToString(Value, 3,  1, Str);                      DrawString(Str);                      Bumper := true;                      j := j + 1;                    END;                  IF ROI^^.BackGround[n].Exists THEN                    BEGIN                      IF (SHow_ROI) THEN                        Value := ROI^^.BackGround[n].Value / (ROI^^.BackGround[n].Hi - ROI^^.BackGround[n].Lo + 1)                      ELSE Value := ROI^^.BackGround[n].Value;                      IF j < 10 THEN MoveTo(285, 33 + (j - 1) * Y_OffSet);                      IF j >= 10 THEN MoveTo(285 + X_OffSet, 33 + (j - 12) * Y_OffSet);                      DrawString('B');                      NumToString(ROI^^.BackGround[n].ROI, Str);                      DrawString(Str);                      DrawString(': ');                      NumToString(ROI^^.BackGround[n].Lo, Str);                      DrawString(Str);                      DrawString(' : ');                      NumToString(ROI^^.BackGround[n].Hi, Str);                      DrawString(Str);                      DrawString(' := ');                      RealToString(Value, 3, 1, Str);                      DrawString(Str);                      Bumper := true;                      j := j + 1;                    END;                  n := n + 1;                  IF n = Max_Rois THEN Exit(Update_ROI_Window);                END; { WHILE Bumper = False or (N <= max_rois) }              IF Bumper = false THEN Exit(Update_ROI_Window);            END; { WHILE j<19 loop }          EndUpdate(ROIWindow); {Return to normal clipping area}          SetPort(GrafPtr(SavePort));          SetFont('Chicago', 12, [bold]);        END; {End for if (ROIWindow<>nil)}    END; {End of procedure}  PROCEDURE Refresh_ROIs;		{Moved to FilePlugins}    VAR      Counter                       : integer;      n                             : integer;    BEGIN { PROCEDURE...}      ROI^^.Scale.Value := 0.0;      ROI^^.Quant.Value := 0.0;      Counter := Number_of_PeakRois;      IF (Number_of_BackGrounds > Number_of_PeakRois) THEN Counter := Number_of_BackGrounds;      FOR n := 1 TO Counter DO        BEGIN          ROI^^.Peak[n].Value := 0.0;          ROI^^.BackGround[n].Value := 0.0;        END; { FOR n...}      IF ROI^^.Scale.Exists THEN        BEGIN          FOR Counter := ROI^^.Scale.Lo TO ROI^^.Scale.Hi DO            BEGIN              ROI^^.Scale.Value := ROI^^.Scale.Value + Plt_spec[10]^^.s[Counter];            END;        END; { IF ROI^^...}      IF ROI^^.Quant.Exists THEN        BEGIN          FOR Counter := ROI^^.Quant.Lo TO ROI^^.Quant.Hi DO            BEGIN              ROI^^.Quant.Value := ROI^^.Quant.Value + Plt_spec[10]^^.s[Counter];            END;        END; { IF ROI^^...}      FOR n := 1 TO Number_of_PeakRois DO        BEGIN          IF (ROI^^.Peak[n].Exists = true) THEN            FOR Counter := ROI^^.Peak[n].Lo TO ROI^^.Peak[n].Hi DO              BEGIN                ROI^^.Peak[n].Value := ROI^^.Peak[n].Value + Plt_spec[10]^^.s[Counter];              END;        END; { FOR n := ...}      FOR n := 1 TO Number_of_BackGrounds DO        BEGIN          IF (ROI^^.BackGround[n].Exists = true) THEN            FOR Counter := ROI^^.BackGround[n].Lo TO ROI^^.BackGround[n].Hi DO              BEGIN                ROI^^.BackGround[n].Value := ROI^^.BackGround[n].Value + Plt_spec[10]^^.s[Counter];              END;        END; { FOR n := 1...}    END; { PROCEDURE Refresh_ROIs }  PROCEDURE OffScreen_2_OnScreen;    BEGIN      { SetGDevice(savedDevice); }      SetPort(GrafPtr(BackPlane));      HLock(Handle(colorPPtr^.portPixMap));      RGBBackColor(White_Color);      RGBForeColor(Black_Color); { These are critical for the success of copybits }      CopyBits(BitMapHandle(colorPPtr^.portPixMap)^^, BitMapHandle(CGrafPort(BackPlane^).portPixMap)^^, colorPPtr^.               portPixMap^^.Bounds, FullWindowRect, SrcCopy, NIL);      HunLock(Handle(colorPPtr^.portPixMap));      RGBBackColor(BackGround_Color);    END; { Procedure }  PROCEDURE DrawLeftHL; {ееееееееее write the left horizontal axis label ееееееееееееееее}        VAR      temp, M, Left_Val, Right_Val, increment: real;      Screen_increment              : integer;      strLeft, strRight             : Str255;      str_1, Str_2, str_3, Str_4, str_5, str_6, str_7, str_8, str_9: Str255;    BEGIN      {е LEFT е}     (* IF Calibrate_Energy_Scale THEN	  {slope and icpt calculated from Ch# * dE = slope * ChName + icpt.	   Left_Val is a ChName.}        Left_Val := ((ChannelMin * Plt_spec[10]^^.Expt_Info.dE / 1000) - Plt_spec[10]^^.Expt_Info.Energy_Intercept /                    1000) / Plt_spec[10]^^.Expt_Info.Energy_Slope      ELSE Left_Val := ChannelMin * Plt_spec[10]^^.Expt_Info.dE / 1000;	  *)      M := (8000 - ChannelMin) / (8192 - ChannelMin);      temp := ChannelMax * M + (8000 - M * 8192); {Calculate the value at the 10th tic mark}      	  IF Calibrate_Energy_Scale THEN	  BEGIN	  {slope and icpt calculated from Ch# * dE = slope * ChName + icpt.	   Left_Val is a ChName.}        Left_Val := ((ChannelMin * Plt_spec[10]^^.Expt_Info.dE / 1000) - Cal_Vals.Energy_Intercept /                    1000) / Cal_Vals.Energy_Slope;        Right_Val := ((temp * Plt_spec[10]^^.Expt_Info.dE / 1000) - Cal_Vals.Energy_Intercept / 1000) /                     Cal_Vals.Energy_Slope;      END	  ELSE BEGIN	  	Left_Val := ChannelMin * Plt_spec[10]^^.Expt_Info.dE / 1000;		Right_Val := temp * Plt_spec[10]^^.Expt_Info.dE / 1000;	  END;      	  Left_Val := ABS(Left_Val - Plt_spec[10]^^.Expt_Info.dE / 1000); { take care of a little numerical imprecision}      RealToString(Left_Val, 4, 2, strLeft);      strLeft := Strip_Trailing_Blanks(strLeft);(*      IF Calibrate_Energy_Scale THEN        Right_Val := ((temp * Plt_spec[10]^^.Expt_Info.dE / 1000) - Plt_spec[10]^^.Expt_Info.Energy_Intercept / 1000) /                     Plt_spec[10]^^.Expt_Info.Energy_Slope      ELSE Right_Val := temp * Plt_spec[10]^^.Expt_Info.dE / 1000; *)     	  RealToString(Right_Val, 4, 2, strRight);      strRight := Strip_Trailing_Blanks(strRight);      increment := (Right_Val - Left_Val) / 10;      Screen_increment := rinttol((LeftHLCGPtr^.portPixMap^^.Bounds.Right - LeftHLCGPtr^.portPixMap^^.Bounds.Left) /                                10.5);      RealToString(Left_Val + increment, 4, 2, str_1);      str_1 := Strip_Trailing_Blanks(str_1);      RealToString(Left_Val + 2 * increment, 4, 2, Str_2);      Str_2 := Strip_Trailing_Blanks(Str_2);      RealToString(Left_Val + 3 * increment, 4, 2, str_3);      str_3 := Strip_Trailing_Blanks(str_3);      RealToString(Left_Val + 4 * increment, 4, 2, Str_4);      Str_4 := Strip_Trailing_Blanks(Str_4);      RealToString(Left_Val + 5 * increment, 4, 2, str_5);      str_5 := Strip_Trailing_Blanks(str_5);      RealToString(Left_Val + 6 * increment, 4, 2, str_6);      str_6 := Strip_Trailing_Blanks(str_6);      RealToString(Left_Val + 7 * increment, 4, 2, str_7);      str_7 := Strip_Trailing_Blanks(str_7);      RealToString(Left_Val + 8 * increment, 4, 2, str_8);      str_8 := Strip_Trailing_Blanks(str_8);      RealToString(Left_Val + 9 * increment, 4, 2, str_9);      str_9 := Strip_Trailing_Blanks(str_9);      IF (Old_LeftHoriz <> strLeft) OR (Old_RightHoriz <> strRight) THEN        BEGIN          SetPort(GrafPtr(LeftHLCGPtr));          RGBBackColor(BackGround_Color);		  RGBForeColor(Axes_Color);          SetFont('Monaco', 9, []);          Old_LeftHoriz := strRight;          Old_RightHoriz := Str;		  MoveTo(LeftHLCGPtr^.portPixMap^^.Bounds.Left + 1, LeftHLCGPtr^.portPixMap^^.Bounds.Bottom - 1);		  EraseRect(LeftHLCGPtr^.portPixMap^^.Bounds);          DrawString(strLeft);          MoveTo(LeftHLCGPtr^.portPixMap^^.Bounds.Right - rinttol(0.048*LeftHLCGPtr^.portPixMap^^.Bounds.Right), 		         LeftHLCGPtr^.portPixMap^^.Bounds.Bottom - 1);          IF length(strRight) = 5 THEN            BEGIN          MoveTo(LeftHLCGPtr^.portPixMap^^.Bounds.Right - rinttol(0.048*LeftHLCGPtr^.portPixMap^^.Bounds.Right), 		         LeftHLCGPtr^.portPixMap^^.Bounds.Bottom - 1);              DrawString(strRight);              MoveTo({rinttol}(((LeftHLCGPtr^.portPixMap^^.Bounds.Right - rinttol(0.048*LeftHLCGPtr^.portPixMap^^.Bounds.Right)) - Screen_increment)), LeftHLCGPtr^.                     portPixMap^^.Bounds.Bottom - 1);              DrawString(str_9);              MoveTo({rinttol}(((LeftHLCGPtr^.portPixMap^^.Bounds.Right - rinttol(0.048*LeftHLCGPtr^.portPixMap^^.Bounds.Right)) - 2 * Screen_increment)), LeftHLCGPtr^.                     portPixMap^^.Bounds.Bottom - 1);              DrawString(str_8);              MoveTo({rinttol}(((LeftHLCGPtr^.portPixMap^^.Bounds.Right - rinttol(0.048*LeftHLCGPtr^.portPixMap^^.Bounds.Right)) - 3 * Screen_increment)), LeftHLCGPtr^.                     portPixMap^^.Bounds.Bottom - 1);              DrawString(str_7);              MoveTo({rinttol}(((LeftHLCGPtr^.portPixMap^^.Bounds.Right - rinttol(0.048*LeftHLCGPtr^.portPixMap^^.Bounds.Right)) - 4 * Screen_increment)), LeftHLCGPtr^.                     portPixMap^^.Bounds.Bottom - 1);              DrawString(str_6);              MoveTo({rinttol}(((LeftHLCGPtr^.portPixMap^^.Bounds.Right - rinttol(0.048*LeftHLCGPtr^.portPixMap^^.Bounds.Right)) - 5 * Screen_increment)), LeftHLCGPtr^.                     portPixMap^^.Bounds.Bottom - 1);              DrawString(str_5);              MoveTo({rinttol}(((LeftHLCGPtr^.portPixMap^^.Bounds.Right - rinttol(0.048*LeftHLCGPtr^.portPixMap^^.Bounds.Right)) - 6 * Screen_increment)), LeftHLCGPtr^.                     portPixMap^^.Bounds.Bottom - 1);              DrawString(Str_4);              MoveTo({rinttol}(((LeftHLCGPtr^.portPixMap^^.Bounds.Right - rinttol(0.048*LeftHLCGPtr^.portPixMap^^.Bounds.Right)) - 7 * Screen_increment)), LeftHLCGPtr^.                     portPixMap^^.Bounds.Bottom - 1);              DrawString(str_3);              MoveTo({rinttol}(((LeftHLCGPtr^.portPixMap^^.Bounds.Right - rinttol(0.048*LeftHLCGPtr^.portPixMap^^.Bounds.Right)) - 8 * Screen_increment)), LeftHLCGPtr^.                     portPixMap^^.Bounds.Bottom - 1);              DrawString(Str_2);              MoveTo({rinttol}(((LeftHLCGPtr^.portPixMap^^.Bounds.Right - rinttol(0.048*LeftHLCGPtr^.portPixMap^^.Bounds.Right)) - 9 * Screen_increment)), LeftHLCGPtr^.                     portPixMap^^.Bounds.Bottom - 1);              DrawString(str_1);            END			ELSE          IF length(strRight) = 4 THEN            BEGIN              MoveTo(LeftHLCGPtr^.portPixMap^^.Bounds.Right - rinttol(0.043*LeftHLCGPtr^.portPixMap^^.Bounds.Right), LeftHLCGPtr^.portPixMap^^.Bounds.Bottom - 1);              DrawString(strRight);              MoveTo({rinttol}(((LeftHLCGPtr^.portPixMap^^.Bounds.Right - rinttol(0.043*LeftHLCGPtr^.portPixMap^^.Bounds.Right)) - Screen_increment)), LeftHLCGPtr^.                     portPixMap^^.Bounds.Bottom - 1);              DrawString(str_9);              MoveTo({rinttol}(((LeftHLCGPtr^.portPixMap^^.Bounds.Right - rinttol(0.043*LeftHLCGPtr^.portPixMap^^.Bounds.Right)) - 2 * Screen_increment)), LeftHLCGPtr^.                     portPixMap^^.Bounds.Bottom - 1);              DrawString(str_8);              MoveTo({rinttol}(((LeftHLCGPtr^.portPixMap^^.Bounds.Right - rinttol(0.043*LeftHLCGPtr^.portPixMap^^.Bounds.Right)) - 3 * Screen_increment)), LeftHLCGPtr^.                     portPixMap^^.Bounds.Bottom - 1);              DrawString(str_7);              MoveTo({rinttol}(((LeftHLCGPtr^.portPixMap^^.Bounds.Right - rinttol(0.043*LeftHLCGPtr^.portPixMap^^.Bounds.Right)) - 4 * Screen_increment)), LeftHLCGPtr^.                     portPixMap^^.Bounds.Bottom - 1);              DrawString(str_6);              MoveTo({rinttol}(((LeftHLCGPtr^.portPixMap^^.Bounds.Right - rinttol(0.043*LeftHLCGPtr^.portPixMap^^.Bounds.Right)) - 5 * Screen_increment)), LeftHLCGPtr^.                     portPixMap^^.Bounds.Bottom - 1);              DrawString(str_5);              MoveTo({rinttol}(((LeftHLCGPtr^.portPixMap^^.Bounds.Right - rinttol(0.043*LeftHLCGPtr^.portPixMap^^.Bounds.Right)) - 6 * Screen_increment)), LeftHLCGPtr^.                     portPixMap^^.Bounds.Bottom - 1);              DrawString(Str_4);              MoveTo({rinttol}(((LeftHLCGPtr^.portPixMap^^.Bounds.Right - rinttol(0.043*LeftHLCGPtr^.portPixMap^^.Bounds.Right)) - 7 * Screen_increment)), LeftHLCGPtr^.                     portPixMap^^.Bounds.Bottom - 1);              DrawString(str_3);              MoveTo({rinttol}(((LeftHLCGPtr^.portPixMap^^.Bounds.Right - rinttol(0.043*LeftHLCGPtr^.portPixMap^^.Bounds.Right)) - 8 * Screen_increment)), LeftHLCGPtr^.                     portPixMap^^.Bounds.Bottom - 1);              DrawString(Str_2);              MoveTo({rinttol}(((LeftHLCGPtr^.portPixMap^^.Bounds.Right - rinttol(0.043*LeftHLCGPtr^.portPixMap^^.Bounds.Right)) - 9 * Screen_increment)), LeftHLCGPtr^.                     portPixMap^^.Bounds.Bottom - 1);              DrawString(str_1);            END			ELSE          IF length(strRight) = 3 THEN            BEGIN              MoveTo(LeftHLCGPtr^.portPixMap^^.Bounds.Right - rinttol(0.038*LeftHLCGPtr^.portPixMap^^.Bounds.Right), LeftHLCGPtr^.portPixMap^^.Bounds.Bottom - 1);              DrawString(strRight);              MoveTo({rinttol}(((LeftHLCGPtr^.portPixMap^^.Bounds.Right - rinttol(0.038*LeftHLCGPtr^.portPixMap^^.Bounds.Right)) - Screen_increment)), LeftHLCGPtr^.                     portPixMap^^.Bounds.Bottom - 1);              DrawString(str_9);              MoveTo({rinttol}(((LeftHLCGPtr^.portPixMap^^.Bounds.Right - rinttol(0.038*LeftHLCGPtr^.portPixMap^^.Bounds.Right)) - 2 * Screen_increment)), LeftHLCGPtr^.                     portPixMap^^.Bounds.Bottom - 1);              DrawString(str_8);              MoveTo({rinttol}(((LeftHLCGPtr^.portPixMap^^.Bounds.Right - rinttol(0.038*LeftHLCGPtr^.portPixMap^^.Bounds.Right)) - 3 * Screen_increment)), LeftHLCGPtr^.                     portPixMap^^.Bounds.Bottom - 1);              DrawString(str_7);              MoveTo({rinttol}(((LeftHLCGPtr^.portPixMap^^.Bounds.Right - rinttol(0.038*LeftHLCGPtr^.portPixMap^^.Bounds.Right)) - 4 * Screen_increment)), LeftHLCGPtr^.                     portPixMap^^.Bounds.Bottom - 1);              DrawString(str_6);              MoveTo({rinttol}(((LeftHLCGPtr^.portPixMap^^.Bounds.Right - rinttol(0.038*LeftHLCGPtr^.portPixMap^^.Bounds.Right)) - 5 * Screen_increment)), LeftHLCGPtr^.                     portPixMap^^.Bounds.Bottom - 1);              DrawString(str_5);              MoveTo({rinttol}(((LeftHLCGPtr^.portPixMap^^.Bounds.Right - rinttol(0.038*LeftHLCGPtr^.portPixMap^^.Bounds.Right)) - 6 * Screen_increment)), LeftHLCGPtr^.                     portPixMap^^.Bounds.Bottom - 1);              DrawString(Str_4);              MoveTo({rinttol}(((LeftHLCGPtr^.portPixMap^^.Bounds.Right - rinttol(0.038*LeftHLCGPtr^.portPixMap^^.Bounds.Right)) - 7 * Screen_increment)), LeftHLCGPtr^.                     portPixMap^^.Bounds.Bottom - 1);              DrawString(str_3);              MoveTo({rinttol}(((LeftHLCGPtr^.portPixMap^^.Bounds.Right - rinttol(0.038*LeftHLCGPtr^.portPixMap^^.Bounds.Right)) - 8 * Screen_increment)), 			  LeftHLCGPtr^.portPixMap^^.Bounds.Bottom - 1);              DrawString(Str_2);              MoveTo({rinttol}(((LeftHLCGPtr^.portPixMap^^.Bounds.Right - rinttol(0.038*LeftHLCGPtr^.portPixMap^^.Bounds.Right)) - 9 * Screen_increment)), 			                 LeftHLCGPtr^.portPixMap^^.Bounds.Bottom - 1);              DrawString(str_1);            END			ELSE DrawString(strRight);			          SetPort(GrafPtr(BackPlane));          RGBBackColor(White_Color);          RGBForeColor(Black_Color); { These are critical for the success of copybits }          CopyBits(BitMapHandle(LeftHLCGPtr^.portPixMap)^^, BitMapHandle(CGrafPort(BackPlane^).portPixMap)^^,                   LeftHLCGPtr^.portPixMap^^.Bounds, LeftHLCGPtr^.portPixMap^^.Bounds, SrcCopy, NIL);          RGBBackColor(BackGround_Color);        END;    END;  PROCEDURE DrawSpecIDInfo; {еееееее write the Spectum ID information at Bottom ееееееее}    VAR      j                             : integer;      Str, str1, str5               : Str255;    BEGIN      str5 := 'No Spectrum currently displayed.';      FOR j := 1 TO 8 DO        IF Spectrum_Full[j] THEN          BEGIN            NumToString(j, str5);            str5 := CONCAT('DISPLAY ', str5, ': ');            leave;          END;      IF Spectrum_Full[9] THEN        BEGIN          j := 9;          str5 := 'RESULTS: ';        END;      IF Spectrum_Full[10] THEN        BEGIN          j := 10;          str5 := 'WORK: ';        END;      Str := Strip_Trailing_Blanks(Plt_spec[j]^^.SpectrumStuff.Spectrum_Info.Spectrum_Comment_Field);      NumToString(Plt_spec[j]^^.SpectrumStuff.Spectrum_Info.Spectrum_Number, str1);      IF Plt_spec[j]^^.Expt_Info.RefFile THEN        BEGIN          Str := CONCAT(Plt_spec[j]^^.SpectrumStuff.Spectrum_Info.Spectrum_class, '; ', Str);        END;      Str := CONCAT(str5, '#', str1, '  ', Str);      IF Old_Label <> Str THEN        BEGIN          SetPort(GrafPtr(SpecIDInfoCGPtr));          SetFont('Monaco', 9, []);          MoveTo(SpecIDInfoCGPtr^.portPixMap^^.Bounds.Left + 5, SpecIDInfoCGPtr^.portPixMap^^.Bounds.Bottom - 5);          aRGB := SpectrumColor[j {VLabelColor}];          RGBForeColor(aRGB);          RGBBackColor(BackGround_Color);          EraseRect(SpecIDInfoCGPtr^.portPixMap^^.Bounds); { Clear previous }          Old_Label := Str;          DrawString(Str);          SetPort(GrafPtr(BackPlane));          RGBBackColor(White_Color);          RGBForeColor(Black_Color); { These are critical for the success of copybits }          CopyBits(BitMapHandle(SpecIDInfoCGPtr^.portPixMap)^^, BitMapHandle(CGrafPort(BackPlane^).portPixMap)^^,                   SpecIDInfoCGPtr^.portPixMap^^.Bounds, SpecIDInfoCGPtr^.portPixMap^^.Bounds, SrcCopy, NIL);          RGBBackColor(BackGround_Color);        END;      {  END; }    END;  PROCEDURE DrawUpVL; { еееееееее write the upper vertical axis label еееееееее }        VAR      Str                           : Str255;    BEGIN      IF (rinttol(Counts_FullScale) <> Counts_FullScale) AND (rinttol(Counts_FullScale) < 50) { no need for real axis above           50, it looks shitty }         THEN { Determined whether integer or real }        RealToString(Counts_FullScale, 3,  2, Str) { and setup appropriate format }      ELSE NumToString(rinttol(Counts_FullScale), Str);      Str := Strip_Trailing_Blanks(Str);      IF Old_UpperVert <> Str THEN        BEGIN          SetPort(GrafPtr(UpVLCGPtr));          SetFont('Monaco', 9, []);          MoveTo(BackPlane^.portRect.Left + 1, BackPlane^.portRect.Top + 12);          RGBForeColor(SpectrumColor[VLabelColor]);          RGBBackColor(BackGround_Color);          EraseRect(UpVLCGPtr^.portPixMap^^.Bounds); { clear the old text }          Old_UpperVert := Str;          MoveTo(UpVLCGPtr^.portPixMap^^.Bounds.Left + 1, UpVLCGPtr^.portPixMap^^.Bounds.Top + 12);          DrawString(Str);          SetPort(GrafPtr(BackPlane));          RGBBackColor(White_Color);          RGBForeColor(Black_Color); { These are critical for the success of copybits }          CopyBits(BitMapHandle(UpVLCGPtr^.portPixMap)^^, BitMapHandle(CGrafPort(BackPlane^).portPixMap)^^, UpVLCGPtr^.                   portPixMap^^.Bounds, UpVLCGPtr^.portPixMap^^.Bounds, SrcCopy, NIL);          RGBBackColor(BackGround_Color);        END;    END;  PROCEDURE DrawChanNum; {еееееее write the Channel Number at top ееееее}    VAR      Str                           : Str255;    BEGIN      SetPort(GrafPtr(ChanNumCGPtr));      SetFont('geneva', 12, [bold]);      MoveTo(ChanNumCGPtr^.portPixMap^^.Bounds.Left + 2, ChanNumCGPtr^.portPixMap^^.Bounds.Top + 12);      BackColor(YellowColor);      ForeColor(RedColor);      EraseRect(ChanNumCGPtr^.portPixMap^^.Bounds); { clear the old text }      OldChan_Num := Chan_Num;      NumToString(Chan_Num, Str);      DrawString(Str);      SetPort(GrafPtr(BackPlane));      RGBBackColor(White_Color);      RGBForeColor(Black_Color); { These are critical for the success of copybits }      CopyBits(BitMapHandle(ChanNumCGPtr^.portPixMap)^^, BitMapHandle(CGrafPort(BackPlane^).portPixMap)^^,               ChanNumCGPtr^.portPixMap^^.Bounds, ChanNumCGPtr^.portPixMap^^.Bounds, SrcCopy, NIL);      RGBBackColor(BackGround_Color);    END;  PROCEDURE DrawChanKv; {еееееее write the Channel kV at top ееееее}    VAR      Str                           : Str255;    BEGIN      SetPort(GrafPtr(ChanKvCGPtr));      SetFont('geneva', 12, [bold]);      IF Calibrate_Energy_Scale THEN       (* RealToString(((Chan_Num * Plt_spec[10]^^.Expt_Info.dE / 1000) - Plt_spec[10]^^.Expt_Info.Energy_Intercept /                     1000) / Plt_spec[10]^^.Expt_Info.Energy_Slope, 6, 4, Str)       *)	    RealToString(((Chan_Num * Plt_spec[10]^^.Expt_Info.dE / 1000) - Cal_Vals.Energy_Intercept /                     1000) / Cal_Vals.Energy_Slope, 6, 4, Str)      ELSE RealToString(Chan_Num * Plt_spec[10]^^.Expt_Info.dE / 1000, 6, 4, Str);      MoveTo(ChanKvCGPtr^.portPixMap^^.Bounds.Left + 2, ChanKvCGPtr^.portPixMap^^.Bounds.Top + 12);      BackColor(YellowColor);      ForeColor(RedColor);      EraseRect(ChanKvCGPtr^.portPixMap^^.Bounds); { clear the old text }      DrawString(Str);      SetPort(GrafPtr(BackPlane));      RGBBackColor(White_Color);      RGBForeColor(Black_Color); { These are critical for the success of copybits }      CopyBits(BitMapHandle(ChanKvCGPtr^.portPixMap)^^, BitMapHandle(CGrafPort(BackPlane^).portPixMap)^^, ChanKvCGPtr^.               portPixMap^^.Bounds, ChanKvCGPtr^.portPixMap^^.Bounds, SrcCopy, NIL);      RGBBackColor(BackGround_Color);    END;  PROCEDURE DrawWorkCnts; {еееееее write the Work spectrum counts at top ееееее}    VAR      Str                           : Str255;    BEGIN      SetPort(GrafPtr(WorkCntsCGPtr));      SetFont('Monaco', 9, []);      MoveTo(WorkCntsCGPtr^.portPixMap^^.Bounds.Left + 2, WorkCntsCGPtr^.portPixMap^^.Bounds.Top + 12);      RGBBackColor(BackGround_Color);      RGBForeColor(SpectrumColor[10]);      EraseRect(WorkCntsCGPtr^.portPixMap^^.Bounds); { clear the old text }      Old_Work := Plt_spec[10]^^.s[Chan_Num];      IF rinttol(Old_Work) <> Old_Work THEN { Determine whether integer or real }        RealToString(Old_Work, 5,  2, Str) { and setup appropriate format }      ELSE NumToString(rinttol(Old_Work), Str);      DrawString(Str);      SetPort(GrafPtr(BackPlane));      RGBBackColor(White_Color);      RGBForeColor(Black_Color); { These are critical for the success of copybits }      CopyBits(BitMapHandle(WorkCntsCGPtr^.portPixMap)^^, BitMapHandle(CGrafPort(BackPlane^).portPixMap)^^,               WorkCntsCGPtr^.portPixMap^^.Bounds, WorkCntsCGPtr^.portPixMap^^.Bounds, SrcCopy, NIL);      RGBBackColor(BackGround_Color);    END;  PROCEDURE DrawResultsCnts; {еееееее write the Results spectrum counts at top ееееее}        VAR      Str                           : Str255;    BEGIN      SetPort(GrafPtr(ResultsCntsCGPtr));      SetFont('Monaco', 9, []);      MoveTo(ResultsCntsCGPtr^.portPixMap^^.Bounds.Left + 2, ResultsCntsCGPtr^.portPixMap^^.Bounds.Top + 12);      RGBBackColor(BackGround_Color);      RGBForeColor(SpectrumColor[9]);      EraseRect(ResultsCntsCGPtr^.portPixMap^^.Bounds); { clear the old text }      Old_Results := Plt_spec[9]^^.s[Chan_Num];      IF rinttol(Old_Results) <> Old_Results THEN { Determine whether integer or real }        RealToString(Old_Results, 5,  2, Str) { and setup appropriate format }      ELSE NumToString(rinttol(Old_Results), Str);      DrawString(Str);      SetPort(GrafPtr(BackPlane));      RGBBackColor(White_Color);      RGBForeColor(Black_Color); { These are critical for the success of copybits }      CopyBits(BitMapHandle(ResultsCntsCGPtr^.portPixMap)^^, BitMapHandle(CGrafPort(BackPlane^).portPixMap)^^,               ResultsCntsCGPtr^.portPixMap^^.Bounds, ResultsCntsCGPtr^.portPixMap^^.Bounds, SrcCopy, NIL);      RGBBackColor(BackGround_Color);    END;  PROCEDURE DrawAtomic_Number; {еееееее write the Atomic_Number at top ееееее}        VAR      Str, str1                     : Str255;    BEGIN      SetPort(GrafPtr(AtomicNumberCGPtr));      SetFont('geneva', 12, [bold]);      MoveTo(AtomicNumberCGPtr^.portPixMap^^.Bounds.Left + 4, AtomicNumberCGPtr^.portPixMap^^.Bounds.Top + 12);      BackColor(YellowColor);      ForeColor(BlueColor);      EraseRect(AtomicNumberCGPtr^.portPixMap^^.Bounds); { clear the old text }      Old_Atomic_Number := Atomic_Number;      NumToString(Atomic_Number, Str);      str1 := CONCAT(A^.Sym[Atomic_Number], '   ');      str1 := CONCAT('   ', str1);      str1 := CONCAT(str1, Str);      DrawString(str1);      SetPort(GrafPtr(BackPlane));      RGBBackColor(White_Color);      RGBForeColor(Black_Color); { These are critical for the success of copybits }      CopyBits(BitMapHandle(AtomicNumberCGPtr^.portPixMap)^^, BitMapHandle(CGrafPort(BackPlane^).portPixMap)^^,               AtomicNumberCGPtr^.portPixMap^^.Bounds, AtomicNumberCGPtr^.portPixMap^^.Bounds, SrcCopy, NIL);      RGBBackColor(BackGround_Color);    END;  {$S Global_Functions3}  PROCEDURE PutSymbol(Box: rect; fontName: Str255; fontSize: integer; fontStyle: style; Element: Str_2; Family: Str_4;                       Greek: Str_4);    VAR      theFontID                     : integer;      GFontID                       : integer;      thePenLoc                     : Point;    BEGIN      GetFNum(fontName, theFontID); { Get the font ID. }      TextFont(theFontID); { Set it. }      TextSize(fontSize); { Set the size... }      TextFace(fontStyle); { ...and the style. }      MoveTo(Box.Left + 2, Box.Top + 10);      DrawString(Element);      DrawString(Family);      GetFNum('Symbol', GFontID); { Get the font ID. }      TextFont(GFontID); { Set it. }      GetPen(thePenLoc);      MoveTo(thePenLoc.h, thePenLoc.v + 3); { Subscript the Greek Letter }      DrawString(Greek);    END; { PROCEDURE PutSymbol(...) }  PROCEDURE ReCalcLabelRects;    VAR      slopeX, Xclip                 : real;      k, nn                         : integer;    BEGIN      slopeX := (ChannelMax - ChannelMin) / (Full_Right_Screen - Full_Left_Screen);      IF (Old_ChannelMin <> ChannelMin) OR (Old_ChannelMax <> ChannelMax) THEN        BEGIN          IF Label_Counter > MaxLabels THEN Label_Counter := MaxLabels;          FOR nn := 1 TO Label_Counter DO            BEGIN { If the horizontal endpoints change then update the rects }              IF (Lab^^.s[nn].Exists) THEN                BEGIN                  k := Chan_Num;                  IF Chan_Num < Lab^^.s[nn].Channel + Lab_Left_Limit THEN k := Lab^^.s[nn].Channel + Lab_Left_Limit;                  IF Chan_Num > Lab^^.s[nn].Channel - Lab_Right_Limit THEN k := Lab^^.s[nn].Channel - Lab_Right_Limit;                  Lab^^.s[nn].ShiftedChannel := k;				  				  Xclip := (k - ChannelMin + slopeX * 13) / slopeX;				  				  if Xclip > 16384.0 then			{ Right side of screen }				  	Lab^^.s[nn].XCenter := 16384				  else                  	Lab^^.s[nn].XCenter := rinttol{Num2Integer}(Xclip);				  				  if Xclip <= Full_Left_Screen + 20 then			{ Left side of screen }				  	Lab^^.s[nn].XCenter := 16000				  else                  	Lab^^.s[nn].XCenter := rinttol{Num2Integer}(Xclip);									 (* IF (Lab^^.s[nn].XCenter <= Full_Left_Screen + 20) then Lab^^.s[nn].XCenter := Full_Left_Screen + 20;*)                  Lab^^.s[nn].Box.Left := Lab^^.s[nn].XCenter - 20;                  Lab^^.s[nn].Box.Top := Lab^^.s[nn].YCenter - 6;                  SetRect(Lab^^.s[nn].Box, Lab^^.s[nn].Box.Left, Lab^^.s[nn].Box.Top, Lab^^.s[nn].Box.Left + 35, Lab^^.                          s[nn].Box.Top + 15);                END;            END;          Old_ChannelMin := ChannelMin;          Old_ChannelMax := ChannelMax;        END;    END;  PROCEDURE ShowCursorValues(myEvent: EventRecord);    VAR      VL_axisRect                   : rect;      counts                        : ARRAY [1..10] OF real;      offset                        : integer;      Position                      : integer;      j, Index, nn            		: integer;      pt                            : Point;      slopeX                        : real;      tmpRect                       : rect;      Str                           : Str255;    BEGIN      SetPort(GrafPtr(BackPlane));      GetMouse(pt); { Local Coordinates for the Full window, NOTE, mouselocation is local for the screen}      slopeX := (ChannelMax - ChannelMin) / (Full_Right_Screen - Full_Left_Screen);      IF Label_Counter = 0 THEN Active_Peak_Label := 0;      {ееееееееееееееееDefine the rect'sееееееееееееее   }      { l,t,r,b make room for other spectra as needed in the little, floating, box for 1-8}      SetRect(BoxRect, BoxRect.Left, BoxRect.Top, BoxRect.Left + 108, BoxRect.Top + 10);      BoxVisable := false;      nn := 0;      FOR j := 1 TO 8 DO        IF Spectrum_Full[j] THEN nn := nn + 1;      SetRect(BoxRect, BoxRect.Left, BoxRect.Top, BoxRect.Left + 108, BoxRect.Top + 11 * nn + 15);      IF nn <> 0 THEN BoxVisable := true;      ReCalcLabelRects;      DragBox := false;      DragLabel := false;      Active_Peak_Label := 0;      IF Label_Counter > MaxLabels THEN Label_Counter := MaxLabels;      FOR nn := 1 TO Label_Counter DO        Lab^^.s[nn].Active := false;      IF (ROI_Window_Active = false) AND (SiLiWindow <> FrontWindow) THEN        BEGIN          {Check if the mouse is over any drag-able areas and change the cursor to show}          IF (BoxVisable AND PtInRect(pt, BoxRect)) THEN            BEGIN              DragBox := true;            END          ELSE            IF NOT (Clr_One OR Clr_Family) THEN              BEGIN                IF Label_Counter > MaxLabels THEN Label_Counter := MaxLabels;                IF Label_Counter > MaxLabels THEN Label_Counter := MaxLabels;                FOR nn := 1 TO Label_Counter DO                  BEGIN                    IF (Lab^^.s[nn].Exists) AND (PtInRect(pt, Lab^^.s[nn].Box)) THEN                      BEGIN                        DragLabel := true;                        Active_Peak_Label := nn; { get the "hot" one }                        Lab^^.s[nn].Active := true;                        leave;                      END;                  END;              END;        END;      IF (DragBox OR DragLabel) THEN ChangeCursor(DragC)      ELSE ChangeCursor(ArrowC);(*                ROI^^.PEAK[1].Lo := rinttol(1300.0/Plt_Spec[10]^^.Expt_Info.dE);                ROI^^.PEAK[1].Hi := rinttol(1710.0/Plt_Spec[10]^^.Expt_Info.dE);                  ROI^^.PEAK[1].Exists := true;				  ROI^^.value[1]				  Plt_spec[10]^^SpectrumStuff.Acq_Info.ActualLiveTime *)      IF (Acquiring) and (ROI^^.PEAK[1].Exists) then	  begin (*		          BoxVisable := true;  				  SetRect(tmpRect, BoxRect.Left, BoxRect.Top, BoxRect.Left + 108, BoxRect.Top + 50);                  EraseRect(tmpRect);				  Framerect(tmpRect);                  SetFont('geneva', 14, [bold]);				  MoveTo(tmpRect.Left + 4, tmpRect.Top + 15);				  RGBForeColor(SpectrumColor[10]);				  RealToString(ROI^^.Peak[1].value/Plt_spec[10]^^.SpectrumStuff.Acq_Info.ActualLiveTime, 10, 1, Str) ;				  DrawString(Str);				 				                 x1 := 3;              x2 := rinttol(2500000/(ROI^^.Peak[1].value/Plt_spec[10]^^.SpectrumStuff.Acq_Info.ActualLiveTime));                        IF (x2 >= Full_Bottom_Screen ) THEN x2 := Full_Bottom_Screen ;          IF (x2 <= Full_top_Screen) THEN x2 := Full_top_Screen;                                     RGBForeColor(BackGround_Color);                   PenSize(3, 1);                   MoveTo(x1, Full_Bottom_Screen);                     LINETO(x1, Full_top_Screen);				  				                     RGBForeColor(Axes_Color);                   PenSize(3, 1);                   MoveTo(x1, Full_Bottom_Screen);                     LINETO(x1, x2); *)          end;				  				    	   	        IF (xTemp <> Mouselocation.h) OR { check for movement to prevent unneeded refreshes }         (Ytemp <> Mouselocation.v) OR (KLM_Boolean) THEN        BEGIN { if moved then }          { draw all the axes labels and main label. }          RGBBackColor(BackGround_Color);          SetFont('geneva', 9, [bold]);          DrawLeftHL; {е write the left horizontal axis label е}          DrawSpecIDInfo; {е write the Spectum ID information at Bottom е}          DrawUpVL; {е write the upper vertical axis label е}          IF OldChan_Num <> Chan_Num THEN            BEGIN              DrawChanNum;              DrawChanKv;              IF BoxVisable THEN                BEGIN                  FOR Index := 1 TO 8 DO                    counts[Index] := (Plt_spec[Index]^^.s[Chan_Num]);                  offset := 11;                  nn := 2;                  RGBBackColor(BackGround_Color);                  RGBForeColor(Axes_Color);                  tmpRect := BoxRect;                  tmpRect.Top := tmpRect.Top + 11;                  tmpRect.Left := tmpRect.Left + 1;                  tmpRect.Right := tmpRect.Right - 1;                  tmpRect.Bottom := tmpRect.Bottom - 1;                  EraseRect(tmpRect);                  SetFont('geneva', 9, []);                  FOR j := 1 TO 8 DO                    BEGIN                      IF Spectrum_Full[j] THEN                        BEGIN                          MoveTo(BoxRect.Left + 4, BoxRect.Top + nn * offset);                          RGBForeColor(SpectrumColor[j]);                          NumToString(j, Str);                          DrawString(Str);                          DrawString('       ');                          IF rinttol(counts[j]) <> counts[j] THEN { Determine whether integer or real }                            RealToString(counts[j], 5,  2, Str) { and setup appropriate format }                          ELSE NumToString(rinttol(counts[j]), Str);                          DrawString(Str);                          nn := nn + 1;                        END;                    END; { J Loop }                END;            END;          IF Old_Work <> Plt_spec[10]^^.s[Chan_Num] THEN DrawWorkCnts;          IF Old_Results <> Plt_spec[9]^^.s[Chan_Num] THEN DrawResultsCnts;          IF Old_Atomic_Number <> Atomic_Number THEN DrawAtomic_Number;        END;      IF Counts_BottomScale <> 0 THEN        BEGIN          IF (rinttol(Counts_BottomScale) <> Counts_BottomScale) AND (ABS(Counts_BottomScale) < 50) { no need for real               axis above 50, it looks shitty }             THEN { Determine whether integer or real }            RealToString(Counts_BottomScale, 3, 2, Str) { and setup appropriate format }          ELSE NumToString(rinttol(Counts_BottomScale), Str);          Position := StringWidth(Str);          Str := Strip_Trailing_Blanks(Str);          SetPort(GrafPtr(BackPlane));          SetFont('Monaco', 9, []);          Position := StringWidth(Str);          MoveTo(BackPlane^.portRect.Left + 15 + 6, BackPlane^.portRect.Bottom - {20}40 - 6);          SetRect(VL_axisRect, BackPlane^.portRect.Left + 15 + 5, BackPlane^.portRect.Bottom - 20 - 15, BackPlane^.                  portRect.Left + 15 + 7 + Position, BackPlane^.portRect.Bottom - 20 - 4); { l,t,r,b }          RGBForeColor(SpectrumColor[VLabelColor]);          RGBBackColor(BackGround_Color);          IF Old_LowerVert <> Str THEN            BEGIN              Old_LowerVert := Str;              EraseRect(VL_axisRect);            END;          DrawString(Str); { еееееееее write the lower vertical axis label еееееееееее }        END; { IF Counts_BottomScale <> 0 THEN... }      SetFont('geneva', 12, []);      xTemp := Mouselocation.h;      Ytemp := Mouselocation.v;	  KLM_Boolean := False;    END;  PROCEDURE SetFont(fontName: Str255; fontSize: integer; fontStyle: style);    VAR      theFontID                     : integer;      thePenLoc                     : Point;    BEGIN      GetFNum(fontName, theFontID); { Get the font ID. }      TextFont(theFontID); { Set it. }      TextSize(fontSize); { Set the size... }      TextFace(fontStyle); { ...and the style. }      GetPen(thePenLoc); { Save the current pen position. }      DrawChar(' '); { Draw a space so the font gets downloaded.}      MoveTo(thePenLoc.h, thePenLoc.v); { Restore the original pen position. }    END;  {=================================}  FUNCTION fast_power(X, n: real {double_t}): real {double_t};    VAR      temp_x, temp_1               : real {double_t};    BEGIN {fast_power}      IF X > 0.0 THEN fast_power := exp(n * LN(X))      ELSE        IF X = 0.0 THEN fast_power := 0.0        ELSE          BEGIN            IF rinttol(n / 2) = rinttol(n) / 2 THEN temp_x := 1.0            ELSE temp_x := - 1.0;            temp_1 := LN(ABS(X));            fast_power := exp(n * temp_1) * temp_x;          END;    END; {fast_power}  PROCEDURE Mouse_Active_Window;{ The purpose of this procedure is to remember which of the below windows was hot when  the mouse moves up into the main plotting envirnment so that upon return that window  can be reactivated. }    BEGIN      IF BackPlane = FrontWindow THEN Exit(Mouse_Active_Window);      ROI_Window_Active := false;      SiLi_Window_Active := false;      StripPeak_Window_Active := false;      Calibrate_Window_Active := false;      Simplex_Results_Active := false;      ID_Window_Active := false;      IF FrontWindow = SiLiWindow THEN        BEGIN          SiLi_Window_Active := true;        END      ELSE	  IF FrontWindow = ROIWindow THEN		BEGIN		  ROI_Window_Active := true;		END	  ELSE	  IF FrontWindow = Strip_PeakWindow THEN		BEGIN		  StripPeak_Window_Active := true;		END	  ELSE	  IF FrontWindow = Calibrate_GetSelection THEN		BEGIN		  Calibrate_Window_Active := true;		END	  ELSE	  IF FrontWindow = Main_ID_Window THEN		BEGIN		  ID_Window_Active := true;		END	  ELSE	  IF FrontWindow = TextWindow THEN		BEGIN		  Simplex_Results_Active := true;		END;  END; { Procedure Mouse_Active_Window }  PROCEDURE Write_Static_Text {(theDialog: DialogPtr; item: Integer; Str : Str255)} ;    VAR      itemType                      : integer;      itemBox                       : rect;      itemHdl                       : Handle;    BEGIN      GetDialogItem(theDialog, item, itemType, itemHdl, itemBox);      SetDialogItemText(itemHdl, Str);    END;  PROCEDURE UpDate_Max_Min {( Spectrum : integer)} ; { Updates the max and min }	{Moved to FilePlugins}    VAR      nn                            : integer;    BEGIN	{for autoscale purposes we want the ams and min in the displayed segment	         what ever the size, but for now we'll use the button sizes, Spectrum_Size}      WITH Plt_spec[Spectrum]^^ DO        BEGIN          SpectrumStuff.Spectrum_Info.Maximum_Counts := - 1.0E100;          SpectrumStuff.Spectrum_Info.Minimum_Counts := 1.0E100;          FOR nn := 1 TO Spectrum_Size DO            BEGIN              IF SpectrumStuff.Spectrum_Info.Maximum_Counts < s[nn] THEN                BEGIN                  SpectrumStuff.Spectrum_Info.Maximum_Counts := s[nn];                END              ELSE                IF SpectrumStuff.Spectrum_Info.Minimum_Counts > s[nn] THEN                  BEGIN                    SpectrumStuff.Spectrum_Info.Minimum_Counts := s[nn];                  END;            END;          IF ABS(SpectrumStuff.Spectrum_Info.Minimum_Counts - SpectrumStuff.Spectrum_Info.Maximum_Counts) < 1E-30 THEN            SpectrumStuff.Spectrum_Info.Maximum_Counts := 2 * SpectrumStuff.Spectrum_Info.Minimum_Counts;        END; { with...for...}    END;  PROCEDURE DrawAxesFull; { In Update section of main event loop }    VAR      j                             : integer;      Xinc, Yinc                    : real;      Pix_X_Max                     : integer;      Pix_X_Min                     : integer;      Pix_Y_Max                     : integer;      Pix_Y_Min                     : integer;      Str                           : Str255;    BEGIN      Old_LowerVert := ''; { Force an update if screen is covered by window or dialog box }      Old_Label := '';      Old_UpperVert := '';      Old_LeftHoriz := '';      Old_RightHoriz := '';      Old_Work := - 1;      Old_Results := - 1;      OldSpec1 := - 1;      OldSpec2 := - 1;      OldSpec3 := - 1;      OldSpec4 := - 1;      OldSpec5 := - 1;      OldSpec6 := - 1;      OldSpec7 := - 1;      OldSpec8 := - 1;      OldChan_Num := - 1;      Old_Atomic_Number := 1;      SetPort(GrafPtr(TopCGPtr)); {Erase and draw off top area}      RGBBackColor(BackGround_Color);      RGBForeColor(Axes_Color);      SetFont('Monaco', 9, []);      EraseRect(TopCGPtr^.portPixMap^^.Bounds);      MoveTo(TopCGPtr^.portPixMap^^.Bounds.Left + 75, TopCGPtr^.portPixMap^^.Bounds.Top + 12);      Str := 'Ch#:        Ch kV:             ';      DrawString(Str);      Str := 'Work:             ';      RGBForeColor(SpectrumColor[10]);      DrawString(Str);      Str := 'Results:             ';      RGBForeColor(SpectrumColor[9]);      DrawString(Str);      RGBForeColor(Axes_Color);      Str := 'Marker:';      DrawString(Str);      {Left upper scale to off top}      RGBBackColor(White_Color);      RGBForeColor(Black_Color); { These are critical for the success of copybits }      CopyBits(BitMapHandle(UpVLCGPtr^.portPixMap)^^, BitMapHandle(TopCGPtr^.portPixMap)^^, UpVLCGPtr^.portPixMap^^.               Bounds, UpVLCGPtr^.portPixMap^^.Bounds, SrcCopy, NIL);      RGBBackColor(BackGround_Color);      {Channel number to off top}      RGBBackColor(White_Color);      RGBForeColor(Black_Color); { These are critical for the success of copybits }      CopyBits(BitMapHandle(ChanNumCGPtr^.portPixMap)^^, BitMapHandle(TopCGPtr^.portPixMap)^^, ChanNumCGPtr^.               portPixMap^^.Bounds, ChanNumCGPtr^.portPixMap^^.Bounds, SrcCopy, NIL);      RGBBackColor(BackGround_Color);      {Channel Kv to Off top}      RGBBackColor(White_Color);      RGBForeColor(Black_Color); { These are critical for the success of copybits }      CopyBits(BitMapHandle(ChanKvCGPtr^.portPixMap)^^, BitMapHandle(TopCGPtr^.portPixMap)^^, ChanKvCGPtr^.portPixMap^^               .Bounds, ChanKvCGPtr^.portPixMap^^.Bounds, SrcCopy, NIL);      RGBBackColor(BackGround_Color);      {Work to off Top}      RGBBackColor(White_Color);      RGBForeColor(Black_Color); { These are critical for the success of copybits }      CopyBits(BitMapHandle(WorkCntsCGPtr^.portPixMap)^^, BitMapHandle(TopCGPtr^.portPixMap)^^, WorkCntsCGPtr^.               portPixMap^^.Bounds, WorkCntsCGPtr^.portPixMap^^.Bounds, SrcCopy, NIL);      RGBBackColor(BackGround_Color);      {Results to off top}      RGBBackColor(White_Color);      RGBForeColor(Black_Color); { These are critical for the success of copybits }      CopyBits(BitMapHandle(ResultsCntsCGPtr^.portPixMap)^^, BitMapHandle(TopCGPtr^.portPixMap)^^, ResultsCntsCGPtr^.               portPixMap^^.Bounds, ResultsCntsCGPtr^.portPixMap^^.Bounds, SrcCopy, NIL);      RGBBackColor(BackGround_Color);      {Atomic Number to off top}      RGBBackColor(White_Color);      RGBForeColor(Black_Color); { These are critical for the success of copybits }      CopyBits(BitMapHandle(AtomicNumberCGPtr^.portPixMap)^^, BitMapHandle(TopCGPtr^.portPixMap)^^, AtomicNumberCGPtr^.               portPixMap^^.Bounds, AtomicNumberCGPtr^.portPixMap^^.Bounds, SrcCopy, NIL);      RGBBackColor(BackGround_Color);      {Now on to the screen}      SetPort(GrafPtr(BackPlane));      RGBBackColor(White_Color);      RGBForeColor(Black_Color); { These are critical for the success of copybits }      CopyBits(BitMapHandle(TopCGPtr^.portPixMap)^^, BitMapHandle(CGrafPort(BackPlane^).portPixMap)^^, TopCGPtr^.               portPixMap^^.Bounds, TopCGPtr^.portPixMap^^.Bounds, SrcCopy, NIL);      RGBBackColor(BackGround_Color);      Pix_Y_Min := BackPlane^.portRect.Top + 14;      Pix_X_Min := BackPlane^.portRect.Left + 14; ;      Pix_Y_Max := BackPlane^.portRect.Bottom - {18} 38;      Pix_X_Max := BackPlane^.portRect.Right - 13; { these are to correct the two window sizes }      Xinc := (Pix_X_Max - Pix_X_Min) / 10.24;      Yinc := (Pix_Y_Max - Pix_Y_Min) / 10;      { Draw the axis}      SetPort(GrafPtr(LeftCGPtr)); {Draw axis into off left}      RGBBackColor(BackGround_Color);      RGBForeColor(Axes_Color);      EraseRect(LeftCGPtr^.portPixMap^^.Bounds);      PenSize(2, 2);      MoveTo(Pix_X_Min - 3, Pix_Y_Min);      LINETO(Pix_X_Min - 3, Pix_Y_Max);      FOR j := 1 TO 10 DO        BEGIN {put tics on Y axis}          MoveTo(Pix_X_Min, rinttol{Num2Integer}(Pix_Y_Max - j * Yinc));          LINETO(Pix_X_Min - 5, rinttol{Num2Integer}(Pix_Y_Max - j * Yinc));        END;      SetPort(GrafPtr(BackPlane)); {Now copy to screen }      RGBBackColor(White_Color);      RGBForeColor(Black_Color); { These are critical for the success of copybits }      CopyBits(BitMapHandle(LeftCGPtr^.portPixMap)^^, BitMapHandle(CGrafPort(BackPlane^).portPixMap)^^, LeftCGPtr^.               portPixMap^^.Bounds, LeftCGPtr^.portPixMap^^.Bounds, SrcCopy, NIL);      RGBBackColor(BackGround_Color);      SetPort(GrafPtr(BottomCGPtr)); {Erase, Draw axis in off bottom}      RGBBackColor(BackGround_Color);      RGBForeColor(Axes_Color);      EraseRect(BottomCGPtr^.portPixMap^^.Bounds);      PenSize(2, 2);      MoveTo(Pix_X_Min, Pix_Y_Max);      LINETO(Pix_X_Max, Pix_Y_Max);      FOR j := 1 TO 10 DO        BEGIN {put tics on X axis}          MoveTo(rinttol{Num2Integer}(Pix_X_Min + j * Xinc), Pix_Y_Max);          LINETO(rinttol{Num2Integer}(Pix_X_Min + j * Xinc), Pix_Y_Max + 5);        END;      RGBBackColor(White_Color); {Lower left scale into off bottom}      RGBForeColor(Black_Color); { These are critical for the success of copybits }      CopyBits(BitMapHandle(LeftHLCGPtr^.portPixMap)^^, BitMapHandle(BottomCGPtr^.portPixMap)^^, LeftHLCGPtr^.               portPixMap^^.Bounds, LeftHLCGPtr^.portPixMap^^.Bounds, SrcCopy, NIL);      RGBBackColor(BackGround_Color);      RGBBackColor(White_Color); {Spectrum label into off bottom}      RGBForeColor(Black_Color); { These are critical for the success of copybits }      CopyBits(BitMapHandle(SpecIDInfoCGPtr^.portPixMap)^^, BitMapHandle(BottomCGPtr^.portPixMap)^^, SpecIDInfoCGPtr^.               portPixMap^^.Bounds, SpecIDInfoCGPtr^.portPixMap^^.Bounds, SrcCopy, NIL);      RGBBackColor(BackGround_Color);      RGBBackColor(White_Color); {Lower right scale into off bottom}      RGBForeColor(Black_Color); { These are critical for the success of copybits }      CopyBits(BitMapHandle(LeftHLCGPtr^.portPixMap)^^, BitMapHandle(BottomCGPtr^.portPixMap)^^, LeftHLCGPtr^.               portPixMap^^.Bounds, LeftHLCGPtr^.portPixMap^^.Bounds, SrcCopy, NIL);      RGBBackColor(BackGround_Color);      SetPort(GrafPtr(BackPlane)); {Now off bottom onto screen}      RGBBackColor(White_Color);      RGBForeColor(Black_Color); { These are critical for the success of copybits }      CopyBits(BitMapHandle(BottomCGPtr^.portPixMap)^^, BitMapHandle(CGrafPort(BackPlane^).portPixMap)^^, BottomCGPtr^.               portPixMap^^.Bounds, BottomCGPtr^.portPixMap^^.Bounds, SrcCopy, NIL);      RGBBackColor(BackGround_Color);    END; {drawaxesFull}  FUNCTION Log_Plot(Value: real {double_t}): real {double_t};    BEGIN { negative case is here to handle bipolar plots }      IF (Value >= 0) THEN Value := Value + 1;      IF (Value < 0) THEN Value := Value - 1;      IF (Value <= - 1.0) THEN Log_Plot := - Log10(ABS(Value));	{LN(ABS(Value))}      IF (Value >= 1.0) THEN Log_Plot := Log10(Value);				{LN(Value)}    END;  FUNCTION Square_Root_Plot(Value: real {double_t}): real {double_t};    BEGIN      IF (Value < 0.0) THEN Square_Root_Plot := - sqrt(ABS(Value))      ELSE Square_Root_Plot := sqrt(Value);    END;  PROCEDURE Plot_Linear(   XIntPtr		: IntArrayPtr;   YIntPtr		: IntArrayPtr;   SpectraPtr   : Spectrum_Ptr;   ChannelMin   : integer;   ChannelMax   : integer;   Pix_X_Min   : integer;   Pix_X_Max   : integer;   Pix_Y_Min   : integer;   Pix_Y_Max   : integer;   SY     : Real;   IY     : Real;   SX     : Real;   IX     : Real);VAR Long_Pix		: longint; channel 		: Integer; X_Pixel 		: Integer; Y_Pixel 		: Integer; Last_X 		: Integer; Last_Y			: Integer;BEGIN  IF (ChannelMin < 1) or (ChannelMin > 8192) then    begin    Putmessage('ChannelMin out of range in Plot_Linear','','','');    exit(Plot_Linear);   end;  IF (ChannelMax < 1) or (ChannelMax > 8192) then    begin    Putmessage('ChannelMax out of range in Plot_Linear','','','');    exit(Plot_Linear);   end; Last_X := -1; Last_Y := -1; FOR channel := ChannelMin TO ChannelMax DO BEGIN  		Long_Pix := rinttol{Num2Integer}(SY * (SpectraPtr^[channel]) + IY);          { Pix_Y_Max here means the bottom of the screen as per Quickdraw  convention }          IF Long_Pix < Pix_Y_Max THEN          	Y_Pixel := Pix_Y_Max          ELSE IF Long_Pix > Pix_Y_Min THEN          	Y_Pixel := Pix_Y_Min          ELSE          	Y_Pixel := Long_Pix;  X_Pixel := rinttol{Num2Integer}(SX * channel + IX);  IF (Last_X <> X_Pixel) OR           (Last_Y <>Y_Pixel) THEN BEGIN{ dont redo the same screen pixel or 'zeros'}   LineTo(X_Pixel, Y_Pixel);  END; END;           { if (Last_X <> X_Pixel) } Last_X := X_Pixel; Last_Y := Y_Pixel;END;  {[f-]}PROCEDURE PLOT{(          theSpectrum  : integer;							Dumie		 : integer;                            DataMax      : real;                            DataMin      : real;                            ChannelMin   : integer;                            ChannelMax   : integer;                            Pix_X_Min    : integer;                            Pix_X_Max    : integer;                            Pix_Y_Min    : integer;                            Pix_Y_Max    : integer;                            Color        : integer;                            PlotSymbol   : integer;                            Connected    : integer                                                   ) } ;{[f+]}    VAR      Long_Pix						: longint;      Channel, Index                : integer;      Last_X, Last_Y                : integer;      Sptr                          : Spectrum_Ptr;	  str1,str2 					:str255;    PROCEDURE Draw_ROI(VAR RoiChoice: ROI_Data_Structure);      VAR        Channel	                : integer;      BEGIN        IF (RoiChoice.Lo < 1) OR (RoiChoice.Lo > 8192) THEN          BEGIN		    numtostring(RoiChoice.Lo,str1);            PutMessage('RoiChoice.Lo out of range in Draw_ROI, it`s', str1, '', '');            Exit(Draw_ROI);          END;        IF (RoiChoice.Hi < 1) OR (RoiChoice.Hi > 8192) THEN          BEGIN		    numtostring(RoiChoice.Hi,str2);            PutMessage('RoiChoice.Hi out of range in Draw_ROI, it`s', str2, '', '');            Exit(Draw_ROI);          END;        IF Acquiring THEN Exit(Draw_ROI);        WITH RoiChoice, Plt_spec[theSpectrum]^^ DO          BEGIN            IF (Bipolar_Display = true) THEN              BEGIN                InterceptY := - (Pix_Y_Max - Pix_Y_Min) / 2;                slopeY := - (Pix_Y_Max + InterceptY) / DataMax;              END            ELSE              BEGIN                slopeY := (Pix_Y_Max - Pix_Y_Min) / (DataMax - DataMin);                InterceptY := Pix_Y_Min - slopeY * DataMin;              END;            slopeX := (Pix_X_Max - Pix_X_Min) / (ChannelMax - ChannelMin);            InterceptX := Pix_X_Min - slopeX * ChannelMin;            IF (Log_Scale_Display = true) THEN              BEGIN                MoveTo(rinttol{Num2Integer}(slopeX * Lo + InterceptX), rinttol{Num2Integer}(slopeY * Log10(s[Lo]) + InterceptY));	{LN(s[Lo])}              END            ELSE              IF (Square_Root_Display = true) THEN                BEGIN                  MoveTo(rinttol{Num2Integer}(slopeX * Lo + InterceptX), rinttol{Num2Integer}(slopeY * sqrt(s[Lo]) + InterceptY));                END              ELSE                IF (Linear_Display = true) THEN                  BEGIN                    MoveTo(rinttol{Num2Integer}(slopeX * Lo + InterceptX), rinttol{Num2Integer}(slopeY * (s[Lo]) + InterceptY));                  END;            colorPPtr^.pnSize.h := 1;            colorPPtr^.pnSize.v := 4; { ееWas 2 }            FOR Channel := Lo TO Hi DO              BEGIN                IF (Log_Scale_Display = true) THEN                  BEGIN                    Y_Pixel := rinttol{Num2Integer}(slopeY * Log_Plot(s[Channel]) + InterceptY);                  END                ELSE                  IF (Square_Root_Display = true) THEN                    BEGIN                      Y_Pixel := rinttol{Num2Integer}(slopeY * Square_Root_Plot(s[Channel]) + InterceptY);                    END                  ELSE                    IF (Linear_Display = true) THEN                      BEGIN                        Y_Pixel := rinttol{Num2Integer}(slopeY * (s[Channel]) + InterceptY);                      END;                IF (Y_Pixel < Pix_Y_Max) THEN Y_Pixel := Pix_Y_Max;                IF (Y_Pixel > Pix_Y_Min) THEN Y_Pixel := Pix_Y_Min; { Pix_Y_Max here means the bottom of the screen as                                                                      per Quickdraw convention }                X_Pixel := rinttol{Num2Integer}(slopeX * Channel + InterceptX);                {MoveTo(X_Pixel, Y_Pixel);}                LINETO(X_Pixel, Y_Pixel);              END; { for channel...}          END; {with...}      END; { Procedure Draw_ROI }    PROCEDURE MAX_AND_MIN(Max, Min: real); { ееееChange this to case statements }      VAR        Index                         : integer;      BEGIN        FOR Index := 1 TO 10 DO          BEGIN            IF theSpectrum = Index THEN A^.DataMaxS[Index] := Max;            IF theSpectrum = Index THEN A^.DataMinS[Index] := Min;          END; { for...}      END; {MAX_AND_MIN}    BEGIN { ееееееееееееееее procedure PLOT еееееееееееееееееееееееееееееееееееееееееееееее }      SetPort(GrafPtr(colorPPtr)); { Set up to write into off screen buffer }      RGBBackColor(BackGround_Color);      IF ChannelMin < 1 THEN ChannelMin := 1;     (* IF ChannelMax > Spectrum_Size THEN ChannelMax := Spectrum_Size;*)      IF ChannelMax > 8192 THEN ChannelMax := 8192;      IF (Auto_Scale_Display = false) THEN        BEGIN          DataMax := V_Scale_Top; { V_Scale_Top and V_Scale_Bottom are globals that }          DataMin := V_Scale_Bottom; { get manipulated in the SiLi_Window section }          IF (Log_Scale_Display = true) THEN            BEGIN              IF (DataMin > - 1) OR (DataMin < 1) THEN DataMin := 1;              DataMin := - Log10(ABS(DataMin));		{LN(ABS(DataMin))}            END;        END;      IF DataMax <= DataMin + 1E-32 THEN DataMax := DataMin + 1E-32;      IF (Auto_Scale_Display = true) THEN        BEGIN          IF (Log_Scale_Display = true) THEN            BEGIN              DataMax := Log10(DataMax);		{LN(DataMax)}              IF (DataMin > - 1) OR (DataMin < 1) THEN DataMin := 1;              DataMin := - Log10(ABS(DataMin));		{LN(ABS(DataMin))}            END          ELSE            IF (Square_Root_Display = true) THEN              BEGIN                DataMax := sqrt(DataMax);                DataMin := - sqrt(ABS(DataMin));              END;        END;      IF (Bipolar_Display = true) THEN DataMin := - DataMax;      { Label the vertical axis with info from the "top" displayed spectrum. }      MAX_AND_MIN(DataMax, DataMin);      FOR Index := 1 TO 10 DO        BEGIN          IF Spectrum_Full[Index] THEN            BEGIN              Counts_FullScale := {V_Scale_Top} A^.DataMaxS[Index];              Counts_BottomScale := {V_Scale_Bottom} A^.DataMinS[Index];              VLabelColor := Index;            END;        END; { for ...}      { Here, Pix_Y_Max is the top of the plotting envioronment }      IF (Bipolar_Display = true) THEN        BEGIN          slopeY := - (Pix_Y_Max - (Pix_Y_Max - Pix_Y_Min) / 2) / DataMax;          InterceptY := - (Pix_Y_Max - Pix_Y_Min) / 2;        END      ELSE        BEGIN          slopeY := (Pix_Y_Max - Pix_Y_Min) / (DataMax - DataMin);          InterceptY := Pix_Y_Min - slopeY * DataMin;        END;      slopeX := (Pix_X_Max - Pix_X_Min) / (ChannelMax - ChannelMin);      InterceptX := Pix_X_Min - slopeX * ChannelMin;      WITH Plt_spec[theSpectrum]^^ DO        BEGIN          IF (Log_Scale_Display = true) THEN            BEGIN              MoveTo(rinttol{Num2Integer}(slopeX * ChannelMin + InterceptX), rinttol{Num2Integer}(slopeY * Log10(s[ChannelMin]) +                                                                                InterceptY));	{LN(s[ChannelMin])}            END          ELSE            IF (Square_Root_Display = true) THEN              BEGIN                MoveTo(rinttol{Num2Integer}(slopeX * ChannelMin + InterceptX), rinttol{Num2Integer}(slopeY * sqrt(s[ChannelMin]) +                                                                                  InterceptY));              END            ELSE              IF (Linear_Display = true) THEN                BEGIN                  MoveTo(rinttol{Num2Integer}(slopeX * ChannelMin + InterceptX), rinttol{Num2Integer}(slopeY * (s[ChannelMin]) +                                                                                    InterceptY));                END;        END; { WITH...}      IF PlotSymbol = 1 THEN        BEGIN          colorPPtr^.pnSize.h := 1;          colorPPtr^.pnSize.v := 1;        END      ELSE        IF PlotSymbol = 3 THEN          BEGIN            colorPPtr^.pnSize.h := 2;            colorPPtr^.pnSize.v := 1;          END        ELSE          IF PlotSymbol = 4 THEN            BEGIN              colorPPtr^.pnSize.h := 1;              colorPPtr^.pnSize.v := 2;            END          ELSE            IF PlotSymbol = 5 THEN              BEGIN                colorPPtr^.pnSize.h := 2;                colorPPtr^.pnSize.v := 2;              END;      aRGB := SpectrumColor[theSpectrum];      RGBForeColor(aRGB);      Last_X := 1;      {ееее Main Plotting loopееее}      WITH Plt_spec[theSpectrum]^^ DO        BEGIN          IF ((Linear_Display) AND (Connected = 1)) THEN            BEGIN              Sptr := @s;              Plot_Linear(XIntPtr, YIntPtr, Sptr, ChannelMin, ChannelMax, Pix_X_Min, Pix_X_Max, Pix_Y_Min, Pix_Y_Max,                          slopeY, InterceptY, slopeX, InterceptX);            END          ELSE            BEGIN              FOR Channel := ChannelMin TO ChannelMax DO                BEGIN                  IF Log_Scale_Display THEN                    BEGIN                      Long_Pix {Y_Pixel} := rinttol{Num2Integer}(slopeY * Log_Plot(s[Channel]) + InterceptY);                    END                  ELSE                    IF Square_Root_Display THEN                      BEGIN                        Long_Pix {Y_Pixel} := rinttol{Num2Integer}(slopeY * Square_Root_Plot(s[Channel]) + InterceptY);                      END                    ELSE                      IF Linear_Display THEN                        BEGIN                          Long_Pix {Y_Pixel} := rinttol{Num2Integer}(slopeY * (s[Channel]) + InterceptY);                        END;                  { Pix_Y_Max here means the bottom of the screen as per Quickdraw  convention }                  IF Long_Pix < Pix_Y_Max THEN                  	Y_Pixel := Pix_Y_Max                  ELSE IF Long_Pix > Pix_Y_Min THEN                  	Y_Pixel := Pix_Y_Min                  ELSE                  	Y_Pixel := Long_Pix;                                    X_Pixel := rinttol{Num2Integer}(slopeX * Channel + InterceptX);                  IF (Last_X <> X_Pixel) OR (Last_Y <> Y_Pixel) THEN                    BEGIN { dont redo the same screen pixel or 'zeros'}                      IF Connected = 0 THEN                        BEGIN                          IF PlotSymbol = 2 THEN                            BEGIN { Draw a plus }                              colorPPtr^.pnSize.h := 1;                              colorPPtr^.pnSize.v := 1;                              MoveTo(X_Pixel - 2, Y_Pixel);                              LINETO(X_Pixel + 2, Y_Pixel);                              MoveTo(X_Pixel, Y_Pixel - 2);                              LINETO(X_Pixel, Y_Pixel + 2);                            END                          ELSE                            IF PlotSymbol = 6 THEN                              BEGIN { Draw a square }                                colorPPtr^.pnSize.h := 1;                                colorPPtr^.pnSize.v := 1;                                MoveTo(X_Pixel - 2, Y_Pixel - 2);                                LINETO(X_Pixel - 2, Y_Pixel + 2);                                LINETO(X_Pixel + 2, Y_Pixel + 2);                                LINETO(X_Pixel + 2, Y_Pixel - 2);                                LINETO(X_Pixel - 2, Y_Pixel - 2);                              END                            ELSE                              BEGIN { Draw what was chosen above other than 2 or 6 }                                MoveTo(X_Pixel, Y_Pixel);                                LINETO(X_Pixel, Y_Pixel);                              END;                        END                      ELSE                        IF Connected = 1 THEN                          BEGIN { line plot }                            LINETO(X_Pixel, Y_Pixel);                          END                      ELSE                      	IF Connected = 2 THEN                      	  BEGIN                      	    MoveTo(X_Pixel, Y_Pixel);                      	    LINETO(X_Pixel, Pix_Y_Min);                      	    MoveTo(X_Pixel, Y_Pixel);                      	  END;                    END; { if (Last_X <> X_Pixel) }                  Last_X := X_Pixel;                  Last_Y := Y_Pixel;                END; { WITH...}            END;			          IF (Bipolar_Display = true) OR (Auto_Scale_Display = true) THEN            BEGIN              colorPPtr^.pnSize.h := 1;              colorPPtr^.pnSize.v := 1;               MoveTo(rinttol{Num2Integer}(InterceptX), rinttol{Num2Integer}(InterceptY));              LINETO(rinttol{Num2Integer}(slopeX * ChannelMax + InterceptX), rinttol{Num2Integer}(InterceptY));            END;          IF NOT Roi_Showing THEN            BEGIN              IF (ROI^^.Scale.Exists = true) THEN                BEGIN                  RGBForeColor(ScaleROI_Color);                  Draw_ROI(ROI^^.Scale);                END;              IF (ROI^^.Quant.Exists = true) THEN                BEGIN                  RGBForeColor(QuantROI_Color);                  Draw_ROI(ROI^^.Quant);                END;              RGBForeColor(PeakROI_Color);              FOR Index := 1 TO Number_of_PeakRois DO                IF (ROI^^.Peak[Index].Exists = true) THEN Draw_ROI(ROI^^.Peak[Index]);              RGBForeColor(BkgROI_Color);              FOR Index := 1 TO Number_of_BackGrounds DO                IF (ROI^^.BackGround[Index].Exists = true) THEN Draw_ROI(ROI^^.BackGround[Index]);              Roi_Showing := true;            END;        END;    END; { procedure PLOT }  PROCEDURE ReDrawLables;    VAR      nn                            : integer;    BEGIN      ReCalcLabelRects;      IF Label_Counter > MaxLabels THEN Label_Counter := MaxLabels;      FOR nn := 1 TO Label_Counter DO        BEGIN          IF ((Lab^^.s[nn].Exists) AND NOT (Lab^^.s[nn].Active)) THEN            BEGIN              RGBForeColor(PeakLabel_Color);              PutSymbol(Lab^^.s[nn].Box, 'Monaco', LabelSize, [], Lab^^.s[nn].Element, Lab^^.s[nn].Family, Lab^^.s[nn].Greek);            END;        END;    END;  {$S Global_Functions4}  PROCEDURE Markers;	TYPE		esc_array = ARRAY [1..4] of real;    VAR      x1, x2, x3			        : integer;      slopeX, slopeY,PslopeY, maxE, minE    : real;      R1, R2, R3                    : real;      nn                            : integer;      Left                          : integer;      Right                         : integer;      Line_Energy                   : ARRAY [1..300] OF real;      Generated                     : ARRAY [1..300] OF real;	  esc_E							: esc_array;	  esc_H							: esc_array;      theTop                        : integer;      TheBottom                     : integer;      theCeiling                    : integer;      TheFloor                      : integer;	  esc_count						: integer;      str3, str4					: Str255;        PROCEDURE MarkerData;      VAR        nn, nesc, index             : integer;      PROCEDURE Escape(Peak_Energy, Peak_Height: real; VAR Escape_Energy, Escape_Height: esc_array);        VAR          E                             : real {double_t};          M                             : real {double_t};          B                             : real {double_t};		  nindx							: integer;        BEGIN			 for nindx := 1 to 4 do begin              Escape_Height[nindx] := 0.0;              Escape_Energy[nindx] := 0.0;			 end;			  esc_count := 0;          IF WDS_Active THEN            BEGIN              Exit(Escape);            END          ELSE IF (Si_Active {or Ge_Active}) THEN            BEGIN              IF Peak_Energy < 1840 THEN                BEGIN                  Exit(Escape);                END;              M := 0.01517 * COS((90 - Geom.Beta_Angle) / 57.295779) - 0.000803; { Statham's equation }              B := 0.0455 * COS((90 - Geom.Beta_Angle) / 57.295779) + 0.01238;              E := Peak_Energy * 0.001;              Escape_Height[1] := 0.0202 / (1 + (M * E + B) * E * E) * Peak_Height;              Escape_Energy[1] := Peak_Energy - 1740;			  esc_count := 1;          END          ELSE IF Ge_Active THEN            BEGIN              IF Peak_Energy < 1217 THEN		{L3 edge}                BEGIN                  Exit(Escape);                END;              M := 0.01517 * COS((90 - Geom.Beta_Angle) / 57.295779) - 0.000803; { Statham's equation }              B := 0.0455 * COS((90 - Geom.Beta_Angle) / 57.295779) + 0.01238;			  esc_count := 1;              E := Peak_Energy * 0.001;              Escape_Height[esc_count] := 0.0202 / (1 + (M * E + B) * E * E) * Peak_Height;              Escape_Energy[esc_count] := Peak_Energy - 1188;		{Ge La1}			  if Peak_Energy > 1248 then begin				  esc_count := esc_count + 1;				  E := Peak_Energy * 0.001;				  Escape_Height[esc_count] := 0.0202 / (1 + (M * E + B) * E * E) * Peak_Height;				  Escape_Energy[esc_count] := Peak_Energy - 1218;		{Ge Lb1}			  end;			  if Peak_Energy > 11103 then begin				  esc_count := esc_count + 1;				  E := Peak_Energy * 0.001;				  Escape_Height[esc_count] := 0.0202 / (1 + (M * E + B) * E * E) * Peak_Height;				  Escape_Energy[esc_count] := Peak_Energy - 9885;		{Ge Ka1}				  esc_count := esc_count + 1;				  Escape_Height[esc_count] := 0.0202 / (1 + (M * E + B) * E * E) * Peak_Height;				  Escape_Energy[esc_count] := Peak_Energy - 10980;		{Ge Kb1}				  			  end;			              END;        END; { procedure Escape }      BEGIN { PROCEDURE MarkerData; }        FOR nn := 1 TO 300 DO          BEGIN            Line_Energy[nn] := 0.0;            Generated[nn] := 0.0;          END;				Xray_Data_Request := false;	{just to be sure}        Get_Energies(Atomic_Number);        nn := 1;        IF Marker_Peaks THEN          BEGIN          	nn := 1;			FOR index := 1 to 76 do begin				Line_Energy[nn] := eV_Line[index];				Generated[nn] := Wt_Line[index];				IF Marker_Escapes THEN	              BEGIN	              	IF ((index = 1) OR	              		(index = 3) OR	              		(index = 29) OR	              		(index = 31) OR	              		(index = 42) OR	              		(index = 57) OR	              		(index = 66) OR	              		(index = 69) OR	              		(index = 72) OR	              		(index = 74)) THEN BEGIN	                Escape(Line_Energy[nn], Generated[nn], esc_E, esc_H);					for nesc := 1 to esc_count do begin						nn := nn + 1;						Line_Energy[nn] := esc_E[nesc];						Generated[nn] := esc_H[nesc];					end;	              	END;	              END;	{IF Marker_Escapes}	              nn := nn + 1;	                          {ее Now the sum peaks }	            IF Marker_Sums THEN	              BEGIN	              	IF ((index = 1) OR		              	(index = 42) OR		              	(index = 72)) THEN BEGIN		                Line_Energy[nn] := 2 * eV_Line[index];		                Generated[nn] := 0.05 * Wt_Line[index];		                nn := nn + 1;		              END;		          END;	{IF Marker_Sums}	              	            IF Marker_WDS THEN	              BEGIN	                Line_Energy[nn] := 1 / WDS_Order * eV_Line[index];	                Generated[nn] := Wt_Line[index];	                nn := nn + 1;				  END;	{IF Marker_WDS}				  				end;	{FOR index := 1 to 76 do}								IF Marker_Satellites THEN	              BEGIN	              	FOR index := 77 to 143 Do begin           		            	Line_Energy[nn] := eV_Line[index];		            	Generated[nn] := Wt_Line[index];	           		 	nn := nn + 1;           		 	end;           		  END;        	Line_Energy[nn] := eV_Line[144];	{this is the LG2 line}        	Generated[nn] := Wt_Line[144];		END;	{IF Marker_Peaks}        IF Marker_Edges THEN          BEGIN            FOR nn := 1 TO 300 DO              BEGIN                Line_Energy[nn] := 0.0;                Generated[nn] := 0.0;              END;            FOR nn := 1 TO 17 DO              BEGIN                Line_Energy[nn] := A^.edge[nn];                IF nn = 1 THEN Generated[nn] := 1 * 0.2; { K edge }                IF nn = 2 THEN Generated[nn] := 1 * 0.2; { LI edge }                IF nn = 3 THEN Generated[nn] := 1.17 * 0.2; { LII edge }                IF nn = 4 THEN Generated[nn] := 1.63 * 0.2; { LIII edge }                IF nn = 5 THEN Generated[nn] := 1 * 0.2; { MI edge }                IF nn = 6 THEN Generated[nn] := 1.16 * 0.2; { MII edge }                IF nn = 7 THEN Generated[nn] := 1.4 * 0.2; { MIII edge }                IF nn = 8 THEN Generated[nn] := 1.62 * 0.2; { MIV edge }                IF nn = 9 THEN Generated[nn] := 1.78 * 0.2; { MV edge }                IF nn = 10 THEN Generated[nn] := 1 * 0.2; { Nl edge }				IF nn = 11 THEN Generated[nn] := 1 * 0.2; { Nll edge }				IF nn = 12 THEN Generated[nn] := 1 * 0.2; { Nlll edge }				IF nn = 13 THEN Generated[nn] := 1 * 0.2; { NlV edge }				IF nn = 14 THEN Generated[nn] := 1 * 0.2; { NV edge }				IF nn = 15 THEN Generated[nn] := 1 * 0.2; { NVl edge }				IF nn = 16 THEN Generated[nn] := 1 * 0.2; { NVll edge }				IF nn = 17 THEN Generated[nn] := 1 * 0.2; { Ol edge }              END;          END;        Marker_Counter := nn; { If you go over ее210ее then you must redimension the variable.}      END; { PROCEDURE MarkerData; }    BEGIN { MARKERS }      IF (MainPtr = FrontWindow) THEN Exit(Markers);      GetPort(GrafPtr(SavePort));      IF NOT Marker_Plot THEN        BEGIN          SetPort(GrafPtr(BackPlane));          KLM_Boolean := true; {Permits update of new Z in upper right results window }          IF (Atomic_Number < 3) THEN Atomic_Number := 3;          IF (Atomic_Number > 95) THEN Atomic_Number := 95; { Paranoia }          OffScreen_2_OnScreen;          RGBForeColor(KLMColor);          Right := Full_Right_Screen;          Left := Full_Left_Screen;        END      ELSE        BEGIN          theTop := Full_MarkerTOP;          TheBottom := Full_MarkerBOTTOM;          theCeiling := Ceiling;          TheFloor := Floor_x;          SetPort(GrafPtr(thePrPort));          thePrPort^.gPort.pnSize.h := 1;          thePrPort^.gPort.pnSize.v := 1;          Right := PrintWindow.Right;          Left := PrintWindow.Left;        END;      IF (UpArrow = true) THEN        BEGIN          Full_MarkerTOP := Full_MarkerTOP - 5;          Full_MarkerBOTTOM := Full_MarkerBOTTOM - 5;          UpArrow := false;          ShowMarkers := true;        END;      IF (DownArrow = true) THEN        BEGIN          Full_MarkerTOP := Full_MarkerTOP + 5;          Full_MarkerBOTTOM := Full_MarkerBOTTOM + 5;          IF Full_MarkerBOTTOM >= Full_Bottom_Screen + 5 THEN            BEGIN              Full_MarkerTOP := Full_MarkerTOP - 5;              Full_MarkerBOTTOM := Full_MarkerBOTTOM - 5;            END;          DownArrow := false;          ShowMarkers := true;        END;      maxE := ChannelMax * Plt_spec[10]^^.Expt_Info.dE;      minE := ChannelMin * Plt_spec[10]^^.Expt_Info.dE;      slopeX := (Right - Left) / (maxE - minE);      slopeY := (Full_MarkerTOP - Full_MarkerBOTTOM) / (Ceiling - Floor_x);      IF (LeftArrow = true AND (Atomic_Number > 1) AND (Atomic_Number <= 95)) THEN        BEGIN          Atomic_Number := Atomic_Number - 1;          LeftArrow := false;          ShowMarkers := true;        END;      IF (RightArrow = true AND (Atomic_Number >= 1) AND (Atomic_Number < 95)) THEN        BEGIN          Atomic_Number := Atomic_Number + 1;          RightArrow := false;          ShowMarkers := true;        END;      IF Atomic_Number >= 95 THEN Atomic_Number := 95;      IF Atomic_Number <= 3 THEN Atomic_Number := 3; {Paranoia}      MarkerData;      FOR nn := 1 TO Marker_Counter DO        BEGIN          x1 := rinttol{Num2Integer}(slopeX * Line_Energy[nn] + (Left - slopeX * minE));          IF x1 <= Full_Left_Screen THEN            BEGIN              x1 := - 10000;              Generated[nn] := zero;            END;          IF x1 >= Full_Right_Screen THEN            BEGIN              x1 := 10000;              Generated[nn] := zero;            END;          R3 := slopeY * 100 + (Full_MarkerTOP - slopeY * Ceiling); { The linear top }          R1 := slopeY * 100 * Generated[nn] + (Full_MarkerTOP - slopeY * Ceiling);          x3 := rinttol{Num2Integer}(slopeY * Floor_x + (Full_MarkerBOTTOM - slopeY * Floor_x)); { Bottom }          IF x3 > Full_Bottom_Screen THEN x3 := Full_Bottom_Screen;          IF x3 < Full_top_Screen THEN x3 := Full_top_Screen;          x2 := rinttol{Num2Integer}(R1);          R2 := ABS(x3 - R3);          IF Square_Root_Display THEN            BEGIN              R2 := R2 / sqrt(R2); { get the scaling factor }              R1 := ABS(x3 - R1); { get the length of the line }              R1 := R2 * sqrt(R1);              x2 := rinttol{Num2Integer}(Full_MarkerBOTTOM - R1);            END;          IF Log_Scale_Display THEN            BEGIN              R2 := R2 / Log10(R2); 	{LN(R2)}	{ get the scaling factor }              R1 := x3 - R1; { get the length of the line }              IF R1 < 0 THEN R1 := 0;              R1 := R1 + 1; {shift the curve over so that no data can be less than 1 }              R1 := Log10(R1);		{LN(R1)}              R1 := R2 * R1;              x2 := rinttol{Num2Integer}(Full_MarkerBOTTOM - R1);            END;          IF (x2 >= Full_Bottom_Screen + 5) THEN x2 := Full_Bottom_Screen + 5;          IF (x2 <= Full_top_Screen) THEN x2 := Full_top_Screen;          NumToString(x3, str3);          NumToString(x2, str4);          IF ShowMarkers THEN            BEGIN              IF NOT Marker_Plot THEN                BEGIN                  MoveTo(x1, x3); { Bottom }                  IF (x2 - x3 < 0) THEN LINETO(x1, x2);                END              ELSE                BEGIN                  PslopeY := (PrintWindow.Bottom - PrintWindow.Top) / (Full_MarkerBOTTOM - Full_MarkerTOP);                  x3 := rinttol{Num2Integer}(PslopeY * x3 + (PrintWindow.Bottom - PslopeY * Full_MarkerBOTTOM));                  x2 := rinttol{Num2Integer}(PslopeY * x2 + (PrintWindow.Bottom - PslopeY * Full_MarkerBOTTOM));                   MoveTo(x1, x3); { Bottom }                  IF (x2 - x3 < 0) THEN LINETO(x1, x2);                 END;            END;        END;      IF NOT Marker_Plot THEN        BEGIN          ReDrawLables;          DrawAtomic_Number;        END      ELSE        BEGIN        END;      SetPort(GrafPtr(SavePort));    END; {Markers}  PROCEDURE ReDrawBox;    VAR      counts                        : ARRAY [1..10] OF real;      offset                        : integer;      j, n, nn                   	: integer;      Str                           : Str255;      Index                         : integer;    BEGIN      SetRect(BoxRect, BoxRect.Left, BoxRect.Top, BoxRect.Left + 108, BoxRect.Top + 10);      BoxVisable := false;      nn := 0;      FOR j := 1 TO 8 DO        IF Spectrum_Full[j] THEN nn := nn + 1;      SetRect(BoxRect, BoxRect.Left, BoxRect.Top, BoxRect.Left + 108, BoxRect.Top + 11 * nn + 15);      IF nn <> 0 THEN BoxVisable := true;      IF BoxVisable THEN        BEGIN          FOR Index := 1 TO 8 DO            counts[Index] := (Plt_spec[Index]^^.s[Chan_Num]);          offset := 11;          n := 2;          MoveTo(BoxRect.Left + 4, BoxRect.Top + 10);          RGBBackColor(BackGround_Color);          RGBForeColor(Axes_Color);          SetFont('geneva', 9, []);          DrawString('Spec#      Counts ');          PenSize(1, 1);          Framerect(BoxRect);          FOR j := 1 TO 8 DO            BEGIN              IF Spectrum_Full[j] THEN                BEGIN                  MoveTo(BoxRect.Left + 4, BoxRect.Top + n * offset);                  RGBForeColor(SpectrumColor[j]);                  NumToString(j, Str);                  DrawString(Str);                  DrawString('       ');                  IF rinttol(counts[j]) <> counts[j] THEN { Determine whether integer or real }                    RealToString(counts[j], 5,  2, Str) { and setup appropriate format }                  ELSE NumToString(rinttol(counts[j]), Str);                  DrawString(Str);                  n := n + 1;                END;            END; { J Loop }        END;    END;  PROCEDURE Update_Full;    VAR      Index{, Dumie}               : integer;    BEGIN      RefreshScreen_Finished := false;      GetPort(GrafPtr(savedPort)); { preserve the grafport also }      SetPort(GrafPtr(colorPPtr)); {...and set the off-screen buffer }      RGBBackColor(BackGround_Color);      IF (BackPlane <> NIL) THEN        BEGIN          EraseRect(colorPPtr^.portPixMap^^.Bounds);          Roi_Showing := false;          FOR Index := 10 DOWNTO 1 DO            BEGIN              IF Spectrum_Full[Index] THEN                Plot(Index, { array to be plotted }                	 {Dumie,}                     Plt_spec[Index]^^.SpectrumStuff.Spectrum_Info.Maximum_Counts, { DataMax }                     Plt_spec[Index]^^.SpectrumStuff.Spectrum_Info.Minimum_Counts, { DataMin }                     ChannelMin, { }                     ChannelMax, { }                     Full_Left_Screen, { Pix_X_Min }                     Full_Right_Screen, { Pix_X_Max }                     Full_Bottom_Screen, { Pix_Y_Min }                     Full_top_Screen, { Pix_Y_Max }                     A^.Plot_Color[Index], { }                     A^.Plot_Symbol[Index], { }                     A^.Plot_Connected[Index]); { }            END;          DrawSpecIDInfo; {е write the WORK ID information at Bottom е}          ReDrawBox;          Markers; { OffScreen_2_OnScreen called in markers }        END; {End for if (BackPlane<>nil)}      SetPort(GrafPtr(savedPort));      RefreshScreen_Finished := true;    END; {End of procedure UpdateFull}  {***********************************************************}  PROCEDURE PutMessage { (s1,s2,s3,s4:str255) } ;    VAR      mylog                         : DialogPtr;      item                          : integer;      itemType                      : integer;      itemBox                       : rect;      itemHdl                       : Handle;      RectBounds                    : rect;    BEGIN      GetPort(GrafPtr(SavePort));      UseResFile(MCA_Home_Res_RefNum);      mylog := GetNewDialog(11035, NIL, POINTER( - 1));      ChangeCursor(ArrowC);      ShowWindow(mylog); {Open a dialog box}      SelectWindow(mylog); {Lets see it}      SetPort(mylog); {Prepare to add conditional text}      GetDialogItem(mylog, 1, itemType, itemHdl, itemBox);      PenSize(3, 3);      InSetRect(itemBox, - 4, - 4);      FrameRoundRect(itemBox, 16, 16);      REPEAT        MoveTo(25, 15); { Leave these inside the repeat loop, }        DrawString(S1); { to avoid buffer problem }        MoveTo(25, 30);        DrawString(S2);        MoveTo(25, 45);        DrawString(S3);        MoveTo(25, 60);        DrawString(S4);        ModalDialog(NIL, item);      UNTIL (item = 1);      RectBounds := mylog^.portRect;      DisposeDialog(mylog);      FillWhiteSpace(RectBounds);      SetPort(GrafPtr(SavePort));    END;  FUNCTION AnswerMessage(S1, S2, S3, S4: Str255): Boolean;    VAR      mylog                         : DialogPtr;      item                          : integer;      itemType                      : integer;      itemBox                       : rect;      itemHdl                       : Handle;      RectBounds                    : rect;    BEGIN      GetPort(GrafPtr(SavePort));      UseResFile(MCA_Home_Res_RefNum);      mylog := GetNewDialog(8603, NIL, POINTER( - 1));      ChangeCursor(ArrowC);      ShowWindow(mylog); {Open a dialog box}      SelectWindow(mylog); {Lets see it}      SetPort(mylog); {Prepare to add conditional text}      GetDialogItem(mylog, 1, itemType, itemHdl, itemBox);      PenSize(3, 3);      InSetRect(itemBox, - 4, - 4);      FrameRoundRect(itemBox, 16, 16);      REPEAT        MoveTo(25, 15); { Leave these inside the repeat loop, }        DrawString(S1); { to avoid buffer problem }        MoveTo(25, 30);        DrawString(S2);        MoveTo(25, 45);        DrawString(S3);        MoveTo(25, 60);        DrawString(S4);        ModalDialog(NewModalFilterProc(@DefaultFilter), item);      UNTIL (item = 1) OR (item = 2);      IF item = 1 THEN AnswerMessage := true; { It's OK }      IF item = 2 THEN AnswerMessage := false; { It's NOT OK }      RectBounds := mylog^.portRect;{mylog is the active dialog}      DisposeDialog(mylog);      FillWhiteSpace(RectBounds);      SetPort(GrafPtr(SavePort));    END;  PROCEDURE PutBusyMessage { (s1,s2,s3,s4:str255) } ;    BEGIN      QuitBusyMessage := false;      BusyMessage := GetNewDialog(11036, NIL, POINTER( - 1));      ShowWindow(BusyMessage); {Open a dialog box}      SelectWindow(BusyMessage); {Lets see it}      SetPort(BusyMessage); {Prepare to add text}      MoveTo(25, 15);      DrawString(S1);      MoveTo(25, 30);      DrawString(S2);      MoveTo(25, 45);      DrawString(S3);      MoveTo(25, 60);      DrawString(S4);    END;  PROCEDURE FillWhiteSpace {(coveredRect:rect)} ;  (* in the calling Proc:  ...there is always a temprect          temprect := thedialogname^.portRect;              DisposeDialog(thedialogname);          FillWhiteSpace(temprect);*)     BEGIN      GetPort(GrafPtr(SavePort));	{port of dialog going away}      SetPort(BackPlane);      InValRect(coveredRect);	{coveredRect is the rct of the dialog}      BeginUpdate(BackPlane);      DrawAxesFull;      Update_Full;      EndUpdate(BackPlane);      UpDate_SiLi_Window(SiLiWindow);      SetPort(GrafPtr(SavePort));    END;{$S Global_Functions9}	  FUNCTION Strip_Trailing_Blanks { (symbol : str255) : str255 } ;   { Strips trailing blanks from a str255. }    VAR      nn, count            : integer;    BEGIN {main function}      count := length(symbol);      IF count = 1 THEN        BEGIN          Strip_Trailing_Blanks := symbol;          Exit(Strip_Trailing_Blanks);        END;      FOR nn := count DOWNTO 1 DO        BEGIN          IF symbol[nn] = ' ' THEN Delete(symbol, nn, 1)          ELSE            BEGIN              Strip_Trailing_Blanks := symbol;              Exit(Strip_Trailing_Blanks);            END;        END;      Strip_Trailing_Blanks := symbol;    END; {of Function Strip_Trailing_Blanks}  PROCEDURE WritePreferences;    VAR      n, VersionNumber              : integer;      bytecount                     : Longint;      errCode                       : integer;      theRefnum                     : integer;      fndrInfo                      : FInfo;    BEGIN	        VersionNumber := 14; {еее If you change this procedure then up this integer here and in ReadPreferences еее}      errCode := Create(Pref_File, Pref_VolNum, 'DTSA', 'MCAp');      errCode := FSOpen_err(Pref_File, Pref_VolNum, theRefnum, '');      IF errCode <> NoErr THEN Exit(WritePreferences);      errCode := SetFPos_err(theRefnum, fsFromStart, 0, '');      bytecount := 2;      errCode := FSWrite(theRefnum, bytecount, @VersionNumber);      bytecount := sizeof(Plt_spec[10]^^);      errCode := FSWrite(theRefnum, bytecount, @Plt_spec[10]^^);      bytecount := sizeof(Text_Color);      errCode := FSWrite(theRefnum, bytecount, @Text_Color);      errCode := FSWrite(theRefnum, bytecount, @PeakROI_Color);      errCode := FSWrite(theRefnum, bytecount, @BkgROI_Color);      errCode := FSWrite(theRefnum, bytecount, @ScaleROI_Color);      errCode := FSWrite(theRefnum, bytecount, @QuantROI_Color);      errCode := FSWrite(theRefnum, bytecount, @Axes_Color);      errCode := FSWrite(theRefnum, bytecount, @BackGround_Color);      errCode := FSWrite(theRefnum, bytecount, @PeakLabel_Color);      errCode := FSWrite(theRefnum, bytecount, @KLMColor);      errCode := FSWrite(theRefnum, bytecount, @SpectrumColor[10]);      errCode := FSWrite(theRefnum, bytecount, @SpectrumColor[9]);      errCode := FSWrite(theRefnum, bytecount, @SpectrumColor[8]);      errCode := FSWrite(theRefnum, bytecount, @SpectrumColor[7]);      errCode := FSWrite(theRefnum, bytecount, @SpectrumColor[6]);      errCode := FSWrite(theRefnum, bytecount, @SpectrumColor[5]);      errCode := FSWrite(theRefnum, bytecount, @SpectrumColor[4]);      errCode := FSWrite(theRefnum, bytecount, @SpectrumColor[3]);      errCode := FSWrite(theRefnum, bytecount, @SpectrumColor[2]);      errCode := FSWrite(theRefnum, bytecount, @SpectrumColor[1]);      bytecount := sizeof(Geom);      errCode := FSWrite(theRefnum, bytecount, @Geom);      bytecount := sizeof(ROI^^);      errCode := FSWrite(theRefnum, bytecount, @ROI^^);      bytecount := sizeof(Analysis_Result^^);      errCode := FSWrite(theRefnum, bytecount, @Analysis_Result^^);      bytecount := sizeof(Constraint_Switch);      errCode := FSWrite(theRefnum, bytecount, @Constraint_Switch);      bytecount := sizeof(Incomplete_Charge_Switch);      errCode := FSWrite(theRefnum, bytecount, @Incomplete_Charge_Switch);      bytecount := sizeof(WtSwitch);      errCode := FSWrite(theRefnum, bytecount, @WtSwitch);      bytecount := sizeof(Number_of_BackGrounds);      errCode := FSWrite(theRefnum, bytecount, @Number_of_BackGrounds);      bytecount := sizeof(Number_of_PeakRois);      errCode := FSWrite(theRefnum, bytecount, @Number_of_PeakRois);      bytecount := sizeof(A^.Spectrum_Class_Holding_String[1]);      FOR n := 1 TO 13 DO        errCode := FSWrite(theRefnum, bytecount, @A^.Spectrum_Class_Holding_String[n]);      bytecount := sizeof(BoxLeft);      errCode := FSWrite(theRefnum, bytecount, @BoxLeft);      errCode := FSWrite(theRefnum, bytecount, @BoxTop);      errCode := FSWrite(theRefnum, bytecount, @XCenter);      errCode := FSWrite(theRefnum, bytecount, @YCenter);      bytecount := sizeof(High_Peak_Meas);      errCode := FSWrite(theRefnum, bytecount, @High_Peak_Meas);      errCode := FSWrite(theRefnum, bytecount, @High_Peak_Book);      errCode := FSWrite(theRefnum, bytecount, @Low_Peak_Meas);      errCode := FSWrite(theRefnum, bytecount, @Low_Peak_Book);      bytecount := sizeof(NM_Alpha);      errCode := FSWrite(theRefnum, bytecount, @NM_Alpha);      bytecount := sizeof(NM_Beta);      errCode := FSWrite(theRefnum, bytecount, @NM_Beta);      bytecount := sizeof(NM_Gamma);      errCode := FSWrite(theRefnum, bytecount, @NM_Gamma);      bytecount := sizeof(Amp_Perturb);      errCode := FSWrite(theRefnum, bytecount, @Amp_Perturb);      bytecount := sizeof(Energy_Perturb);      errCode := FSWrite(theRefnum, bytecount, @Energy_Perturb);      bytecount := sizeof(Width_Perturb);      errCode := FSWrite(theRefnum, bytecount, @Width_Perturb);      bytecount := sizeof(Energy_Estimate);      errCode := FSWrite(theRefnum, bytecount, @Energy_Estimate);      bytecount := sizeof(Num_Noise_Spectra);      errCode := FSWrite(theRefnum, bytecount, @Num_Noise_Spectra);      bytecount := sizeof(Thin_Fluor_Yield);      errCode := FSWrite(theRefnum, bytecount, @Thin_Fluor_Yield);      bytecount := sizeof(Bulk_Fluor_Yield);      errCode := FSWrite(theRefnum, bytecount, @Bulk_Fluor_Yield);      bytecount := sizeof(Thin_K_Xsect);      errCode := FSWrite(theRefnum, bytecount, @Thin_K_Xsect);      errCode := FSWrite(theRefnum, bytecount, @Bulk_K_Xsect);     { errCode := FSWrite(theRefnum, bytecount, @Thin_K_Xsect);}	{Removed 7/25/96}      errCode := FSWrite(theRefnum, bytecount, @Thin_L_Xsect);      errCode := FSWrite(theRefnum, bytecount, @Bulk_L_Xsect);      errCode := FSWrite(theRefnum, bytecount, @Thin_M_Xsect);      errCode := FSWrite(theRefnum, bytecount, @Bulk_M_Xsect);      errCode := FSWrite(theRefnum, bytecount, @Bulk_CONT_Xsect);      errCode := FSWrite(theRefnum, bytecount, @Thin_CONT_Xsect);      errCode := FSWrite(theRefnum, bytecount, @Thin_CONT_Xsect_BG);      errCode := FSWrite(theRefnum, bytecount, @Bulk_CONT_Xsect_BG);      errCode := FSWrite(theRefnum, bytecount, @Thin_Wk_Choice);      errCode := FSWrite(theRefnum, bytecount, @Thin_Rslt_Choice);      errCode := FSWrite(theRefnum, bytecount, @Thin_S1_Choice);      errCode := FSWrite(theRefnum, bytecount, @Thin_S2_Choice);      errCode := FSWrite(theRefnum, bytecount, @Thin_S3_Choice);      errCode := FSWrite(theRefnum, bytecount, @Thin_S4_Choice);      errCode := FSWrite(theRefnum, bytecount, @Thin_S5_Choice);      errCode := FSWrite(theRefnum, bytecount, @Thin_S6_Choice);      errCode := FSWrite(theRefnum, bytecount, @Thin_S7_Choice);      errCode := FSWrite(theRefnum, bytecount, @Thin_S8_Choice);      errCode := FSWrite(theRefnum, bytecount, @Bulk_Wk_Choice);      errCode := FSWrite(theRefnum, bytecount, @Bulk_Rslt_Choice);      errCode := FSWrite(theRefnum, bytecount, @Bulk_S1_Choice);      errCode := FSWrite(theRefnum, bytecount, @Bulk_S2_Choice);      errCode := FSWrite(theRefnum, bytecount, @Bulk_S3_Choice);      errCode := FSWrite(theRefnum, bytecount, @Bulk_S4_Choice);      errCode := FSWrite(theRefnum, bytecount, @Bulk_S5_Choice);      errCode := FSWrite(theRefnum, bytecount, @Bulk_S6_Choice);      errCode := FSWrite(theRefnum, bytecount, @Bulk_S7_Choice);      errCode := FSWrite(theRefnum, bytecount, @Bulk_S8_Choice);      bytecount := sizeof(Bulk_K_ScaleFactor);      errCode := FSWrite(theRefnum, bytecount, @Bulk_K_ScaleFactor);      errCode := FSWrite(theRefnum, bytecount, @Bulk_L_ScaleFactor);      errCode := FSWrite(theRefnum, bytecount, @Bulk_M_ScaleFactor);      errCode := FSWrite(theRefnum, bytecount, @Bulk_CONT_ScaleFactor);      errCode := FSWrite(theRefnum, bytecount, @Thin_K_ScaleFactor);      errCode := FSWrite(theRefnum, bytecount, @Thin_L_ScaleFactor);      errCode := FSWrite(theRefnum, bytecount, @Thin_M_ScaleFactor);      errCode := FSWrite(theRefnum, bytecount, @Thin_CONT_ScaleFactor);      bytecount := sizeof(Mu_Choice);      errCode := FSWrite(theRefnum, bytecount, @Mu_Choice);      bytecount := sizeof(Live_Time);      errCode := FSWrite(theRefnum, bytecount, @Live_Time);      bytecount := sizeof(Faraday_Current);      errCode := FSWrite(theRefnum, bytecount, @Faraday_Current);      bytecount := sizeof(tilt);      errCode := FSWrite(theRefnum, bytecount, @tilt);      bytecount := sizeof(Thin_KV);      errCode := FSWrite(theRefnum, bytecount, @Thin_KV);      bytecount := sizeof(Thin_density);      errCode := FSWrite(theRefnum, bytecount, @Thin_density);      bytecount := sizeof(Specimen_Thickness);      errCode := FSWrite(theRefnum, bytecount, @Specimen_Thickness);      bytecount := sizeof(Bulk_KV);      errCode := FSWrite(theRefnum, bytecount, @Bulk_KV);      bytecount := sizeof(Number_of_Elements_Simplexed);      errCode := FSWrite(theRefnum, bytecount, @Number_of_Elements_Simplexed);      bytecount := sizeof(periodic_picks[1]);      FOR n := 1 TO Number_of_Elements_Simplexed DO        errCode := FSWrite(theRefnum, bytecount, @periodic_picks[n]);      FOR n := 1 TO 15 DO        BEGIN          bytecount := sizeof(A^.Thin_At_Num[1]);          errCode := FSWrite(theRefnum, bytecount, @A^.Thin_At_Num[n]);          errCode := FSWrite(theRefnum, bytecount, @A^.Bulk_At_Num[n]);          bytecount := sizeof(A^.Thin_Concentration[1]);          errCode := FSWrite(theRefnum, bytecount, @A^.Thin_Concentration[n]);          errCode := FSWrite(theRefnum, bytecount, @A^.Bulk_Concentration[n]);          bytecount := sizeof(A^.Thin_valence[1]);          errCode := FSWrite(theRefnum, bytecount, @A^.Thin_valence[n]);          errCode := FSWrite(theRefnum, bytecount, @A^.Bulk_valence[n]);        END;      bytecount := sizeof(Elements_Chosen);      errCode := FSWrite(theRefnum, bytecount, @Elements_Chosen);      bytecount := sizeof(Running_Bulk_Mode);      errCode := FSWrite(theRefnum, bytecount, @Running_Bulk_Mode);      errCode := FSWrite(theRefnum, bytecount, @Running_Thin_Mode);      errCode := FSWrite(theRefnum, bytecount, @Thin_Physics_Boolean);      errCode := FSWrite(theRefnum, bytecount, @Bulk_Physics_Boolean);      bytecount := sizeof(Clmn1);      errCode := FSWrite(theRefnum, bytecount, @Clmn1);      errCode := FSWrite(theRefnum, bytecount, @Clmn2);      errCode := FSWrite(theRefnum, bytecount, @Clmn3);      bytecount := sizeof(WW);      errCode := FSWrite(theRefnum, bytecount, @WW);      bytecount := sizeof(xx);      errCode := FSWrite(theRefnum, bytecount, @xx);      bytecount := sizeof(yy);      errCode := FSWrite(theRefnum, bytecount, @yy);      bytecount := sizeof(ZZ);      errCode := FSWrite(theRefnum, bytecount, @ZZ);      bytecount := sizeof(Normal_Output);      errCode := FSWrite(theRefnum, bytecount, @Normal_Output);      errCode := FSWrite(theRefnum, bytecount, @reduced_Output);      bytecount := sizeof(One_Coeff);      errCode := FSWrite(theRefnum, bytecount, @One_Coeff);      bytecount := sizeof(Two_Coeff);      errCode := FSWrite(theRefnum, bytecount, @Two_Coeff);      bytecount := sizeof(theGenRec^^);      errCode := FSWrite(theRefnum, bytecount, @theGenRec^^);      bytecount := sizeof(Scale_Button);      errCode := FSWrite(theRefnum, bytecount, @Scale_Button);      bytecount := sizeof(myDCInfo);      errCode := FSWrite(theRefnum, bytecount, @myDCInfo);      bytecount := sizeof(spectrum_counts);      errCode := FSWrite(theRefnum, bytecount, @Gen_ResponseFnc^);      errCode := FSWrite(theRefnum, bytecount, @Bkg_responseFnc^);      errCode := FSWrite(theRefnum, bytecount, @Det_Effic_P^);      bytecount := sizeof(Gaussian_Energy);      errCode := FSWrite(theRefnum, bytecount, @Gaussian_Energy);      errCode := FSWrite(theRefnum, bytecount, @Gaussian_Width);      errCode := FSWrite(theRefnum, bytecount, @Gaussian_Amplitude);      bytecount := sizeof(WDS_Active);      errCode := FSWrite(theRefnum, bytecount, @WDS_Active);      errCode := FSWrite(theRefnum, bytecount, @Ge_Active);      errCode := FSWrite(theRefnum, bytecount, @Si_Active);	  errCode := FSWrite(theRefnum, bytecount, @Majors);	  errCode := FSWrite(theRefnum, bytecount, @Minors);	  errCode := FSWrite(theRefnum, bytecount, @Satellites);	  bytecount := sizeof(WDS_Fitting_Resolution);	  errCode := FSWrite(theRefnum, bytecount, @WDS_Fitting_Resolution);	  bytecount := sizeof(search_Range);	  errCode := FSWrite(theRefnum, bytecount, @search_Range);	  errCode := FSWrite(theRefnum, bytecount, @sensi);	  bytecount := sizeof(EDS_eV);	  errCode := FSWrite(theRefnum, bytecount, @EDS_eV);	  errCode := FSWrite(theRefnum, bytecount, @WDS_eV);	  bytecount := sizeof(Use_Manual_ROIs);	  errCode := FSWrite(theRefnum, bytecount, @Use_Manual_ROIs);      errCode := FSWrite(theRefnum, bytecount, @Calibrate_Energy_Scale);	  bytecount := sizeof(Calib_Record);      errCode := FSWrite(theRefnum, bytecount, @Cal_vals);	  bytecount := sizeof(SiLi_Response_Calculated);      errCode := FSWrite(theRefnum, bytecount, @SiLi_Response_Calculated);	  bytecount := sizeof(Xray_Data_Request);      errCode := FSWrite(theRefnum, bytecount, @Xray_Data_Request);	  bytecount := sizeof(File_Calibration);	  errCode := FSWrite(theRefnum, bytecount, @File_Calibration);      fndrInfo.fdcreator := 'DTSA';      fndrInfo.fdtype := 'MCAp';      fndrInfo.fdFlags := 100;      errCode := setfinfo(Pref_File, Pref_VolNum, fndrInfo);      errCode := FSClose(theRefnum);      errCode := FlushVol(NIL, Pref_VolNum);    END;  PROCEDURE ReadPreferences;    VAR      n, nn, VersionNumber          : integer;      Index                         : integer;      nel                           : integer;      bytecount                     : Longint;      errCode                       : OSErr;      theRefnum                     : integer;    BEGIN             errCode := FSOpen(Pref_name, In_VolRefNum, theRefnum);      IF (errCode = NoErr) OR (errCode = opWrErr) THEN        BEGIN          errCode := SetFPos_err(theRefnum, fsFromStart, 0, '');          bytecount := 2;          errCode := FSRead(theRefnum, bytecount, @VersionNumber);          IF errCode <> NoErr THEN Exit(ReadPreferences);          IF VersionNumber <> 14 THEN            BEGIN              SiLi_Response_Calculated := false;              PutMessage('The version number of the Preferences File is not valid and it can not be used.',                         ' When you quit the program the invalid version of "Preferences" will be overwritten.', '', '')               ;              FillWhiteSpace(BackPlane^.portRect);              errCode := FSClose(theRefnum);              errCode := FlushVol(NIL, In_VolRefNum);              Exit(ReadPreferences);            END;          bytecount := sizeof(Plt_spec[10]^^);          errCode := FSRead(theRefnum, bytecount, @Plt_spec[10]^^);          bytecount := sizeof(Text_Color);          errCode := FSRead(theRefnum, bytecount, @Text_Color);          errCode := FSRead(theRefnum, bytecount, @PeakROI_Color);          errCode := FSRead(theRefnum, bytecount, @BkgROI_Color);          errCode := FSRead(theRefnum, bytecount, @ScaleROI_Color);          errCode := FSRead(theRefnum, bytecount, @QuantROI_Color);          errCode := FSRead(theRefnum, bytecount, @Axes_Color);          errCode := FSRead(theRefnum, bytecount, @BackGround_Color);          errCode := FSRead(theRefnum, bytecount, @PeakLabel_Color);          errCode := FSRead(theRefnum, bytecount, @KLMColor);          errCode := FSRead(theRefnum, bytecount, @SpectrumColor[10]);          errCode := FSRead(theRefnum, bytecount, @SpectrumColor[9]);          errCode := FSRead(theRefnum, bytecount, @SpectrumColor[8]);          errCode := FSRead(theRefnum, bytecount, @SpectrumColor[7]);          errCode := FSRead(theRefnum, bytecount, @SpectrumColor[6]);          errCode := FSRead(theRefnum, bytecount, @SpectrumColor[5]);          errCode := FSRead(theRefnum, bytecount, @SpectrumColor[4]);          errCode := FSRead(theRefnum, bytecount, @SpectrumColor[3]);          errCode := FSRead(theRefnum, bytecount, @SpectrumColor[2]);          errCode := FSRead(theRefnum, bytecount, @SpectrumColor[1]);          bytecount := sizeof(Geom);          errCode := FSRead(theRefnum, bytecount, @Geom);          bytecount := sizeof(ROI^^);          errCode := FSRead(theRefnum, bytecount, @ROI^^);          bytecount := sizeof(Analysis_Result^^);          errCode := FSRead(theRefnum, bytecount, @Analysis_Result^^);          bytecount := sizeof(Constraint_Switch);          errCode := FSRead(theRefnum, bytecount, @Constraint_Switch);          bytecount := sizeof(Incomplete_Charge_Switch);          errCode := FSRead(theRefnum, bytecount, @Incomplete_Charge_Switch);          bytecount := sizeof(WtSwitch);          errCode := FSRead(theRefnum, bytecount, @WtSwitch);          bytecount := sizeof(Number_of_BackGrounds);          errCode := FSRead(theRefnum, bytecount, @Number_of_BackGrounds);          bytecount := sizeof(Number_of_PeakRois);          errCode := FSRead(theRefnum, bytecount, @Number_of_PeakRois);          bytecount := sizeof(A^.Spectrum_Class_Holding_String[1]);          FOR n := 1 TO 13 DO            errCode := FSRead(theRefnum, bytecount, @A^.Spectrum_Class_Holding_String[n]);          bytecount := sizeof(BoxLeft);          errCode := FSRead(theRefnum, bytecount, @BoxLeft);          errCode := FSRead(theRefnum, bytecount, @BoxTop);          errCode := FSRead(theRefnum, bytecount, @XCenter);          errCode := FSRead(theRefnum, bytecount, @YCenter);          bytecount := sizeof(High_Peak_Meas);          errCode := FSRead(theRefnum, bytecount, @High_Peak_Meas);          errCode := FSRead(theRefnum, bytecount, @High_Peak_Book);          errCode := FSRead(theRefnum, bytecount, @Low_Peak_Meas);          errCode := FSRead(theRefnum, bytecount, @Low_Peak_Book);          bytecount := sizeof(NM_Alpha);          errCode := FSRead(theRefnum, bytecount, @NM_Alpha);          bytecount := sizeof(NM_Beta);          errCode := FSRead(theRefnum, bytecount, @NM_Beta);          bytecount := sizeof(NM_Gamma);          errCode := FSRead(theRefnum, bytecount, @NM_Gamma);          bytecount := sizeof(Amp_Perturb);          errCode := FSRead(theRefnum, bytecount, @Amp_Perturb);          bytecount := sizeof(Energy_Perturb);          errCode := FSRead(theRefnum, bytecount, @Energy_Perturb);          bytecount := sizeof(Width_Perturb);          errCode := FSRead(theRefnum, bytecount, @Width_Perturb);          bytecount := sizeof(Energy_Estimate);          errCode := FSRead(theRefnum, bytecount, @Energy_Estimate);          bytecount := sizeof(Num_Noise_Spectra);          errCode := FSRead(theRefnum, bytecount, @Num_Noise_Spectra);          bytecount := sizeof(Thin_Fluor_Yield);          errCode := FSRead(theRefnum, bytecount, @Thin_Fluor_Yield);          bytecount := sizeof(Bulk_Fluor_Yield);          errCode := FSRead(theRefnum, bytecount, @Bulk_Fluor_Yield);          bytecount := sizeof(Thin_K_Xsect);          errCode := FSRead(theRefnum, bytecount, @Thin_K_Xsect);          errCode := FSRead(theRefnum, bytecount, @Bulk_K_Xsect);          {errCode := FSRead(theRefnum, bytecount, @Thin_K_Xsect);}		{Removed 7/25/96}          errCode := FSRead(theRefnum, bytecount, @Thin_L_Xsect);          errCode := FSRead(theRefnum, bytecount, @Bulk_L_Xsect);          errCode := FSRead(theRefnum, bytecount, @Thin_M_Xsect);          errCode := FSRead(theRefnum, bytecount, @Bulk_M_Xsect);          errCode := FSRead(theRefnum, bytecount, @Bulk_CONT_Xsect);          errCode := FSRead(theRefnum, bytecount, @Thin_CONT_Xsect);          errCode := FSRead(theRefnum, bytecount, @Thin_CONT_Xsect_BG);          errCode := FSRead(theRefnum, bytecount, @Bulk_CONT_Xsect_BG);          errCode := FSRead(theRefnum, bytecount, @Thin_Wk_Choice);          errCode := FSRead(theRefnum, bytecount, @Thin_Rslt_Choice);          errCode := FSRead(theRefnum, bytecount, @Thin_S1_Choice);          errCode := FSRead(theRefnum, bytecount, @Thin_S2_Choice);          errCode := FSRead(theRefnum, bytecount, @Thin_S3_Choice);          errCode := FSRead(theRefnum, bytecount, @Thin_S4_Choice);          errCode := FSRead(theRefnum, bytecount, @Thin_S5_Choice);          errCode := FSRead(theRefnum, bytecount, @Thin_S6_Choice);          errCode := FSRead(theRefnum, bytecount, @Thin_S7_Choice);          errCode := FSRead(theRefnum, bytecount, @Thin_S8_Choice);          errCode := FSRead(theRefnum, bytecount, @Bulk_Wk_Choice);          errCode := FSRead(theRefnum, bytecount, @Bulk_Rslt_Choice);          errCode := FSRead(theRefnum, bytecount, @Bulk_S1_Choice);          errCode := FSRead(theRefnum, bytecount, @Bulk_S2_Choice);          errCode := FSRead(theRefnum, bytecount, @Bulk_S3_Choice);          errCode := FSRead(theRefnum, bytecount, @Bulk_S4_Choice);          errCode := FSRead(theRefnum, bytecount, @Bulk_S5_Choice);          errCode := FSRead(theRefnum, bytecount, @Bulk_S6_Choice);          errCode := FSRead(theRefnum, bytecount, @Bulk_S7_Choice);          errCode := FSRead(theRefnum, bytecount, @Bulk_S8_Choice);          bytecount := sizeof(Bulk_K_ScaleFactor);          errCode := FSRead(theRefnum, bytecount, @Bulk_K_ScaleFactor);          errCode := FSRead(theRefnum, bytecount, @Bulk_L_ScaleFactor);          errCode := FSRead(theRefnum, bytecount, @Bulk_M_ScaleFactor);          errCode := FSRead(theRefnum, bytecount, @Bulk_CONT_ScaleFactor);          errCode := FSRead(theRefnum, bytecount, @Thin_K_ScaleFactor);          errCode := FSRead(theRefnum, bytecount, @Thin_L_ScaleFactor);          errCode := FSRead(theRefnum, bytecount, @Thin_M_ScaleFactor);          errCode := FSRead(theRefnum, bytecount, @Thin_CONT_ScaleFactor);          bytecount := sizeof(Mu_Choice);          errCode := FSRead(theRefnum, bytecount, @Mu_Choice);          bytecount := sizeof(Live_Time);          errCode := FSRead(theRefnum, bytecount, @Live_Time);          bytecount := sizeof(Faraday_Current);          errCode := FSRead(theRefnum, bytecount, @Faraday_Current);          bytecount := sizeof(tilt);          errCode := FSRead(theRefnum, bytecount, @tilt);          bytecount := sizeof(Thin_KV);          errCode := FSRead(theRefnum, bytecount, @Thin_KV);          bytecount := sizeof(Thin_density);          errCode := FSRead(theRefnum, bytecount, @Thin_density);          bytecount := sizeof(Specimen_Thickness);          errCode := FSRead(theRefnum, bytecount, @Specimen_Thickness);          bytecount := sizeof(Bulk_KV);          errCode := FSRead(theRefnum, bytecount, @Bulk_KV);          bytecount := sizeof(Number_of_Elements_Simplexed);          errCode := FSRead(theRefnum, bytecount, @Number_of_Elements_Simplexed);          bytecount := sizeof(periodic_picks[1]);          FOR n := 1 TO Number_of_Elements_Simplexed DO            errCode := FSRead(theRefnum, bytecount, @periodic_picks[n]);          FOR n := 1 TO 15 DO            BEGIN              bytecount := sizeof(A^.Thin_At_Num[1]);              errCode := FSRead(theRefnum, bytecount, @A^.Thin_At_Num[n]);              errCode := FSRead(theRefnum, bytecount, @A^.Bulk_At_Num[n]);              bytecount := sizeof(A^.Thin_Concentration[1]);              errCode := FSRead(theRefnum, bytecount, @A^.Thin_Concentration[n]);              errCode := FSRead(theRefnum, bytecount, @A^.Bulk_Concentration[n]);              bytecount := sizeof(A^.Thin_valence[1]);              errCode := FSRead(theRefnum, bytecount, @A^.Thin_valence[n]);              errCode := FSRead(theRefnum, bytecount, @A^.Bulk_valence[n]);            END;          bytecount := sizeof(Elements_Chosen);          errCode := FSRead(theRefnum, bytecount, @Elements_Chosen);          bytecount := sizeof(Running_Bulk_Mode);          errCode := FSRead(theRefnum, bytecount, @Running_Bulk_Mode);          errCode := FSRead(theRefnum, bytecount, @Running_Thin_Mode);          errCode := FSRead(theRefnum, bytecount, @Thin_Physics_Boolean);          errCode := FSRead(theRefnum, bytecount, @Bulk_Physics_Boolean);          bytecount := sizeof(Clmn1);          errCode := FSRead(theRefnum, bytecount, @Clmn1);          errCode := FSRead(theRefnum, bytecount, @Clmn2);          errCode := FSRead(theRefnum, bytecount, @Clmn3);          bytecount := sizeof(WW);          errCode := FSRead(theRefnum, bytecount, @WW);          bytecount := sizeof(xx);          errCode := FSRead(theRefnum, bytecount, @xx);          bytecount := sizeof(yy);          errCode := FSRead(theRefnum, bytecount, @yy);          bytecount := sizeof(ZZ);          errCode := FSRead(theRefnum, bytecount, @ZZ);          bytecount := sizeof(Normal_Output);          errCode := FSRead(theRefnum, bytecount, @Normal_Output);          errCode := FSRead(theRefnum, bytecount, @reduced_Output);          bytecount := sizeof(One_Coeff);          errCode := FSRead(theRefnum, bytecount, @One_Coeff);          bytecount := sizeof(Two_Coeff);          errCode := FSRead(theRefnum, bytecount, @Two_Coeff);          bytecount := sizeof(theGenRec^^);          errCode := FSRead(theRefnum, bytecount, @theGenRec^^);          bytecount := sizeof(Scale_Button);          errCode := FSRead(theRefnum, bytecount, @Scale_Button);          bytecount := sizeof(myDCInfo);          errCode := FSRead(theRefnum, bytecount, @myDCInfo);          bytecount := sizeof(spectrum_counts);          errCode := FSRead(theRefnum, bytecount, @Gen_ResponseFnc^);          errCode := FSRead(theRefnum, bytecount, @Bkg_responseFnc^);          errCode := FSRead(theRefnum, bytecount, @Det_Effic_P^);          bytecount := sizeof(Gaussian_Energy);          errCode := FSRead(theRefnum, bytecount, @Gaussian_Energy);          errCode := FSRead(theRefnum, bytecount, @Gaussian_Width);          errCode := FSRead(theRefnum, bytecount, @Gaussian_Amplitude);          bytecount := sizeof(WDS_Active);          errCode := FSRead(theRefnum, bytecount, @WDS_Active);          errCode := FSRead(theRefnum, bytecount, @Ge_Active);          errCode := FSRead(theRefnum, bytecount, @Si_Active);		  errCode := FSRead(theRefnum, bytecount, @Majors);		  errCode := FSRead(theRefnum, bytecount, @Minors);		  errCode := FSRead(theRefnum, bytecount, @Satellites);          bytecount := sizeof(WDS_Fitting_Resolution);          errCode := FSRead(theRefnum, bytecount, @WDS_Fitting_Resolution);          bytecount := sizeof(search_Range);          errCode := FSRead(theRefnum, bytecount, @search_Range);          errCode := FSRead(theRefnum, bytecount, @sensi);		  bytecount := sizeof(EDS_eV);		  errCode := FSRead(theRefnum, bytecount, @EDS_eV);		  errCode := FSRead(theRefnum, bytecount, @WDS_eV);		  bytecount := sizeof(Use_Manual_ROIs);		  errCode := FSRead(theRefnum, bytecount, @Use_Manual_ROIs); 		  errCode := FSRead(theRefnum, bytecount, @Calibrate_Energy_Scale);		  bytecount := sizeof(Calib_Record);		  errCode := FSRead(theRefnum, bytecount, @Cal_vals);		  bytecount := sizeof(SiLi_Response_Calculated);		  errCode := FSRead(theRefnum, bytecount, @SiLi_Response_Calculated);		  bytecount := sizeof(Xray_Data_Request);		  errCode := FSRead(theRefnum, bytecount, @Xray_Data_Request);		  bytecount := sizeof(File_Calibration);		  errCode := FSRead(theRefnum, bytecount, @File_Calibration);          Index := 0;          FOR nel := 3 TO 97 {4} DO            BEGIN              FOR nn := 1 TO Number_of_Elements_Simplexed DO                IF periodic_picks[nn] = nel THEN                  BEGIN                    Index := Index + 1;                    Get_Energies(nel);                  END;            END;          Reset_Range_Buttons;           IF (Det_Effic_P^[300] = 0) THEN SiLi_Response_Calculated := false          ELSE SiLi_Response_Calculated := true;          SiLi_Buffer_Calculated := true; {the last one calculated is saved at the end of Preferences}          errCode := FSClose(theRefnum);          errCode := FlushVol(NIL, In_VolRefNum);        END { IF (errCode = NoErr) OR (errCode = opWrErr)...}		{ELSE putmessage('there is no preferences file','take this message out of global_functions','','')};    END;END. 