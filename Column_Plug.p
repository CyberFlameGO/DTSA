UNIT Column_Plug;INTERFACEUSES		Types, QuickDraw, Memory, fp, StandardFile, GestaltEqu, Errors, Files,	TextUtils, {PascalA4,} FilePlugIns;const		__procinfo : longint = $3F80;{$Main}PROCEDURE	ENTRYPOINT(message:Integer; VAR InPtr:IOPlugPtr; VAR theResult:OSerr);IMPLEMENTATION{$IFC NOT POWERPC}uses PascalA4;{$ENDC}PROCEDURE	ReadFromASCII(VAR InPtr:IOPlugPtr; VAR theResult:OSerr);FORWARD;PROCEDURE	DoAbout(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);FORWARD;PROCEDURE	DoOpen(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);FORWARD;PROCEDURE	DoWrite(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);FORWARD;FUNCTION	Str2Num(s: Str255): Real;FORWARD;{*****************************************************************************}PROCEDURE 	ENTRYPOINT(message:Integer; VAR InPtr:IOPlugPtr; VAR theResult:OSErr);		{ Main dispatching routine.  Initializes and sets up the global variables,	}		{		and performs the operation specified by the message. 				}VAR	firstTime	: BOOLEAN;	OldA4		: Longint;BEGIN{$IFC NOT POWERPC}	oldA4 := SetCurrentA4();	RememberA4();{$ENDC}	theResult:=noErr;	firstTime:=(InPtr=NIL);						{ See if this is the first time called }	IF firstTime THEN BEGIN						{ If so, allocate and initialize a data area }		InPtr:= IOPlugPtr(NewPtrClear(sizeof(IOPlug)));		IF (InPtr=NIL) THEN BEGIN			debugstr('memFullErr');			theResult:=memFullErr;{$IFC NOT POWERPC}	oldA4 := SetA4(oldA4);{$ENDC}			EXIT(ENTRYPOINT);		END;				END;	CASE message OF								{ Perform the requested operation }		fileAbout		:DoAbout(InPtr, theResult);		ImpFile			:ReadFromASCII(InPtr, theResult);		ExpFile			:DoWrite(InPtr, theResult);		OpenInPlug		:DoOpen(InPtr, theResult);		OpenExPlug		:DoOpen(InPtr, theResult);	END; {CASE message}{$IFC NOT POWERPC}	oldA4 := SetA4(oldA4);{$ENDC}END;{*****************************************************************************}PROCEDURE DoAbout(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);BEGINEND;	{*****************************************************************************}PROCEDURE DoOpen(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);BEGIN	InPtr^.PlugInName:='Read ASCII Column';	{Debugstr('Inside of Column_Plug - Do Open');}	theResult := noErr;END;	{*****************************************************************************}PROCEDURE DoWrite(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);BEGINEND;{*****************************************************************************}PROCEDURE ReadFromASCII(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);	{ Brings up Dialog Box and Opens a File }	{ Simple Column Format, only numbers in a column }TYPE	TByte                   = PACKED ARRAY [1..1] OF byte;    tBuffer                 = PACKED ARRAY [1..50000] OF signedbyte;    tBufPtr                 = ^tBuffer;VAR	xx                            : real;	End_of_File, nn               : longint;	Current_File_Position         : longint;	FileSize               		  : longint;	bytecount                     : longint;	indexL                        : longint;	n, counter, kk            	  : integer;	err                           : integer;	refnum                        : integer;	Value                         : Extended;	theType                       : OSType;	Prompt , mssg                 : str255;	errCode                       : OSErr;	reply                         : SFReply;	FStr	                      : str255;	strLength                     : TByte;	tipBufPtr                     : tBufPtr;BEGIN	refnum := InPtr^.Rd_Refnum;	{Debugstr('Inside of Column_Plug - ReadFromASCII');}	InPtr^.Specimen_Comment_Field := '';			nn := 0;	err := GetEOF(refnum, FileSize);	tipBufPtr := tBufPtr(NewPtr(sizeof(tBuffer)));	err := FSRead(refnum, FileSize, Pointer(tipBufPtr));	indexL := 0;	kk := 1;		REPEAT {еееее This REPEAT part reads in the spectrum еееее}		FStr := ''; {еееее This fragment reads a channel еееее}		WHILE ((tipBufPtr^[indexL] = $20 {sp} ) OR	  		   (tipBufPtr^[indexL] = $09 {tab} ) OR			   (tipBufPtr^[indexL] = $0A {lf} )) DO BEGIN	    	indexL := indexL + 1; { jump over a run of spaces/tabs/lfs }	    END;			WHILE ((tipBufPtr^[indexL] <> $20 {sp} ) AND	  		   (tipBufPtr^[indexL] <> $09 {tab}) AND			   (tipBufPtr^[indexL] <> $0D {cr} ) AND			   (tipBufPtr^[indexL] <> $0A {lf} )) DO BEGIN			FStr := CONCAT(FStr, chr(tipBufPtr^[indexL]));			indexL := indexL + 1;		END; { While }			IF LENGTH(FStr) > 0 THEN BEGIN			InPtr^.Spec_cts[kk] := Str2Num(FStr);			kk := kk + 1;		END;		indexL := indexL + 1;	UNTIL (indexL >= FileSize); {еееее}		InPtr^.Number_of_Channels := kk;	InPtr^.LastChannel := kk;	theResult := noErr;END; { PROCEDURE ReadFromASCII... }{*****************************************************************************}FUNCTION Str2Num(s: Str255): Real;   { Pascal implementation of Str2Num (fp.p: Str2Dec, Dec2Str) }VAR	aDecimal		: Decimal;	aCStr			: ConstCStringPtr;	anIndex			: Integer;	aValidPrefix	: Integer; { ignore }BEGIN	aCStr := P2CStr(@s);	anIndex := 0;	str2dec( aCStr, anIndex, aDecimal, aValidPrefix );	Str2Num := dec2num( aDecimal );END;END.