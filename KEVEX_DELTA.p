UNIT KEVEX_DELTA_Plug;INTERFACEUSES	Types, QuickDraw, Memory, fp, StandardFile, GestaltEqu, Errors, Files,	TextUtils, {PascalA4,} FilePlugIns;const		__procinfo : longint = $3F80;{$Main}PROCEDURE	ENTRYPOINT(message:Integer; VAR InPtr:IOPlugPtr; VAR theResult:OSerr);IMPLEMENTATION{$IFC NOT POWERPC}uses PascalA4;{$ENDC}PROCEDURE KEVEX_DELTA(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);FORWARD;PROCEDURE DoAbout(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);FORWARD;PROCEDURE DoOpen(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);FORWARD;PROCEDURE DoWrite(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);FORWARD;FUNCTION	Str2Num(s: Str255): Real;FORWARD;PROCEDURE 	ENTRYPOINT{(message:Integer; VAR InPtr:IOPlugPtr; VAR theResult:OSErr)};		{ Main dispatching routine.  Initializes and sets up the global variables,	}		{		and performs the operation specified by the message. 				}VAR	firstTime	: BOOLEAN;	OldA4		: Longint;BEGIN{$IFC NOT POWERPC}	oldA4 := SetCurrentA4();	RememberA4();{$ENDC}	theResult:=noErr;	firstTime:=(InPtr=NIL);					{ See if this is the first time called }	IF firstTime THEN BEGIN						{ If so, allocate and initialize a data area }		InPtr:= IOPlugPtr(NewPtrClear(sizeof(IOPlug)));		IF (InPtr=NIL) THEN BEGIN			debugstr('memFullErr');			theResult:=memFullErr;{$IFC NOT POWERPC}	oldA4 := SetA4(oldA4);{$ENDC}			EXIT(ENTRYPOINT);		END;				END;		CASE message OF					{ Perform the requested operation }		fileAbout		:DoAbout(InPtr, theResult);		ImpFile			:KEVEX_DELTA(InPtr, theResult);		ExpFile			:DoWrite(InPtr, theResult);		OpenInPlug		:DoOpen(InPtr, theResult);		OpenExPlug		:DoOpen(InPtr, theResult);		END; {CASE message}		{$IFC NOT POWERPC}	oldA4 := SetA4(oldA4);{$ENDC}END;PROCEDURE DoAbout(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);	Begin	End;	PROCEDURE DoOpen(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);	Begin		InPtr^.PlugInName:='KEVEX DELTA ASCII';		{Debugstr('Inside of KEVEX_DELTA - Do Open');}		theResult := noErr;	End;	PROCEDURE DoWrite(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);	Begin	End;  PROCEDURE KEVEX_DELTA(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);    CONST      tBufferSize            = 100000; {Never more than a single spectrum, 8192 chans ┼ 80K}    TYPE      tBuffer                 = PACKED ARRAY [1..tBufferSize] OF signedbyte;      tBufPtr                 = ^tBuffer;	  TByte                   = PACKED ARRAY [1..1] OF byte;        VAR      index, n, nn, counter, kk     : integer;      err                           : integer;      refnum                        : integer;      FileSize                      : longint;      tipBufPtr                     : tBufPtr;      indexL                        : longint;	  strLength                     : TByte;	  str, Fstr						: str255;	  	LABEL	  100;    BEGIN		refnum := InPtr^.Rd_Refnum;		{Debugstr('Inside of TN_5500_XI');}		InPtr^.Specimen_Comment_Field := '';						err := GetEOF(refnum, FileSize);		tipBufPtr := tBufPtr(NewPtr(sizeof(tBuffer)));		err := FSRead(refnum, FileSize, Pointer(tipBufPtr));		theResult := err;		indexL := 0;        strLength[1] := 14;        BlockMove(@strLength, @str[0], 1);        FOR nn := 1 TO 200 DO { move into the buffer up to 200 characters until the string "Acquire time =" found, and register from this}          BEGIN            indexL := indexL + 1;            BlockMove(@tipBufPtr^[indexL], @str[1], strLength[1]);            IF str = 'Acquire time =' THEN              BEGIN                indexL := indexL + 1; {next char}                GOTO 100;              END;          END;        DisposePtr(Ptr(tipBufPtr));		theResult := badFileFormat;        exit(KEVEX_DELTA);      100:      InPtr^.Specimen_Comment_Field := 'KEVEX';        WHILE ((tipBufPtr^[indexL] = $20) OR (tipBufPtr^[indexL] = $09) OR (tipBufPtr^[indexL] = $0A {lf} )) DO          indexL := indexL + 1; { jump over a run of spaces, tabs, cr or lf }        str := '';        WHILE NOT ((tipBufPtr^[indexL] = $20) OR (tipBufPtr^[indexL] = $09) OR					(tipBufPtr^[indexL] = $0A {lf} ) OR (tipBufPtr^[indexL] = $0D {cr} )) DO          BEGIN            str := CONCAT(str, chr(tipBufPtr^[indexL]));            indexL := indexL + 1;          END; { While }        IF (LENGTH(str) > 0) THEN InPtr^.Live_Time := ROUND(str2num(str));	  		kk := 1;		        REPEAT {еееее This REPEAT part reads in the spectrum еееее}          FStr := ''; {еееее This fragment reads a channel еееее}          WHILE ((tipBufPtr^[indexL] = $20 {sp} ) OR		  		(tipBufPtr^[indexL] = $09 {tab} ) OR				(tipBufPtr^[indexL] = $0A {lf} )) DO            indexL := indexL + 1; { jump over a run of spaces/tabs/lfs }          WHILE ((tipBufPtr^[indexL] <> $20 {sp} ) AND		  		 (tipBufPtr^[indexL] <> $09 {tab}) AND				 (tipBufPtr^[indexL] <> $0D {cr} ) AND				 (tipBufPtr^[indexL] <> $0A {lf} )) DO            BEGIN              FStr := CONCAT(FStr, chr(tipBufPtr^[indexL]));              indexL := indexL + 1;            END; { While }          IF LENGTH(FStr) > 0 THEN            BEGIN              InPtr^.Spec_cts[kk] := str2num(FStr);              kk := kk + 1;            END;          indexL := indexL + 1;        UNTIL indexL >= FileSize; {еееее}		InPtr^.Number_of_Channels := kk;		InPtr^.LastChannel := kk;		theResult := noErr;    END; { еееее KEVEX DELTA еееее}{*****************************************************************************}FUNCTION Str2Num(s: Str255): Real;   { Pascal implementation of Str2Num (fp.p: Str2Dec, Dec2Str) }VAR	aDecimal		: Decimal;	aCStr			: ConstCStringPtr;	anIndex			: Integer;	aValidPrefix	: Integer; { ignore }BEGIN	aCStr := P2CStr(@s);	anIndex := 0;	str2dec( aCStr, anIndex, aDecimal, aValidPrefix );	Str2Num := dec2num( aDecimal );END;    END.