UNIT Tennelec_ASCII_Plug;INTERFACEUSES	Types, QuickDraw, Memory, fp, StandardFile, GestaltEqu, Errors, Files,	TextUtils, {PascalA4,} FilePlugIns;const		__procinfo : longint = $3F80;{$Main}PROCEDURE	ENTRYPOINT(message:Integer; VAR InPtr:IOPlugPtr; VAR theResult:OSerr);IMPLEMENTATION{$IFC NOT POWERPC}uses PascalA4;{$ENDC}PROCEDURE Tennelec_ASCII(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);FORWARD;PROCEDURE DoAbout(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);FORWARD;PROCEDURE DoOpen(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);FORWARD;PROCEDURE DoWrite(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);FORWARD;FUNCTION	Str2Num(s: Str255): Real;FORWARD;PROCEDURE 	ENTRYPOINT{(message:Integer; VAR InPtr:IOPlugPtr; VAR theResult:OSErr)};		{ Main dispatching routine.  Initializes and sets up the global variables,	}		{		and performs the operation specified by the message. 				}VAR	firstTime	: BOOLEAN;	OldA4		: Longint;BEGIN{$IFC NOT POWERPC}	oldA4 := SetCurrentA4();	RememberA4();{$ENDC}	theResult:=noErr;	firstTime:=(InPtr=NIL);					{ See if this is the first time called }	IF firstTime THEN BEGIN						{ If so, allocate and initialize a data area }		InPtr:= IOPlugPtr(NewPtrClear(sizeof(IOPlug)));		IF (InPtr=NIL) THEN BEGIN			debugstr('memFullErr');			theResult:=memFullErr;{$IFC NOT POWERPC}	oldA4 := SetA4(oldA4);{$ENDC}			EXIT(ENTRYPOINT);		END;				END;		CASE message OF					{ Perform the requested operation }		fileAbout		:DoAbout(InPtr, theResult);		ImpFile			:Tennelec_ASCII(InPtr, theResult);		ExpFile			:DoWrite(InPtr, theResult);		OpenInPlug		:DoOpen(InPtr, theResult);		OpenExPlug		:DoOpen(InPtr, theResult);		END; {CASE message}		{$IFC NOT POWERPC}	oldA4 := SetA4(oldA4);{$ENDC}END;PROCEDURE DoAbout(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);	Begin	End;	PROCEDURE DoOpen(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);	Begin		InPtr^.PlugInName:='Tennelec ASCII';		{Debugstr('Inside of Tennelec_ASCII - Do Open');}		theResult := noErr;	End;	PROCEDURE DoWrite(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);	Begin	End;  PROCEDURE Tennelec_ASCII(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);    CONST      tBufferSize            = 100000; {Never more than a single spectrum, 8192 chans Å 80K}    TYPE      tBuffer                 = PACKED ARRAY [1..tBufferSize] OF signedbyte;      tBufPtr                 = ^tBuffer;	  TByte                   = PACKED ARRAY [1..1] OF byte;    VAR      index, nn, jj, kk             : integer;      err                           : integer;      refnum                        : integer;      FileSize                      : longint;      tipBufPtr                     : tBufPtr;      indexL                        : longint;      {counter                       : integer;}      strLength                     : TByte;      bytecount                     : longint;      str, str1		                : str255;	  IValue						: longint;	  RValue                        : real;	  Gain, Offset					: longint;	  Chnl, Enr						: Array [1..2] of real;	  str2							: Array [1..2] of str255;      BEGIN		refnum := InPtr^.Rd_Refnum;		{Debugstr('Inside of Tennelec_ASCII');}		InPtr^.Specimen_Comment_Field := '';			nn := 0;		err := GetEOF(refnum, FileSize);		tipBufPtr := tBufPtr(NewPtr(sizeof(tBuffer)));		err := FSRead(refnum, FileSize, Pointer(tipBufPtr));		theResult := err;        indexL := 0;        strLength[1] := 27;        BlockMove(@strLength, @str[0], 1);        indexL := indexL + 1;        BlockMove(@tipBufPtr^[indexL], @str[1], strLength[1]);		InPtr^.Specimen_Comment_Field := str;		{Nov 19 1994     02:41:17 am}		indexL := indexL + 27;        strLength[1] := 4;        BlockMove(@strLength, @str[0], 1);        REPEAT          BlockMove(@tipBufPtr^[indexL], @str[1], strLength[1]);          indexL := indexL + 1;        UNTIL str = 'Elt:';        indexL := indexL + strLength[1];		        WHILE ((tipBufPtr^[indexL] = $20) OR (tipBufPtr^[indexL] = $09)) DO          indexL := indexL + 1; { jump over a run of spaces }        str := '';        WHILE NOT ((tipBufPtr^[indexL] = $20) OR (tipBufPtr^[indexL] = $09)) DO          BEGIN            str := CONCAT(str, chr(tipBufPtr^[indexL]));            indexL := indexL + 1;          END; { While }        IF (LENGTH(str) > 0) THEN InPtr^.Live_Time := str2num(str);        IF InPtr^.Live_Time <= 0 THEN          BEGIN			DisposePtr(Ptr(tipBufPtr));			theResult := badFileFormat;            exit(Tennelec_ASCII);          END;        strLength[1] := 3;        BlockMove(@strLength, @str[0], 1);        REPEAT          BlockMove(@tipBufPtr^[indexL], @str[1], strLength[1]);          indexL := indexL + 1;        UNTIL str = 'ID:';        indexL := indexL + strLength[1];		        WHILE NOT (tipBufPtr^[indexL] = $0D) DO          BEGIN            str := CONCAT(str, chr(tipBufPtr^[indexL]));            indexL := indexL + 1;          END; { While }        InPtr^.Specimen_Comment_Field := CONCAT(InPtr^.Specimen_Comment_Field, ' ', str);		indexL := indexL + 1;		        strLength[1] := 12;        BlockMove(@strLength, @str[0], 1);        REPEAT          BlockMove(@tipBufPtr^[indexL], @str[1], strLength[1]);          indexL := indexL + 1;        UNTIL str = 'Memory Size:';        indexL := indexL + strLength[1];        WHILE ((tipBufPtr^[indexL] = $20) OR (tipBufPtr^[indexL] = $09)) DO          indexL := indexL + 1; { jump over a run of spaces }        str := '';        WHILE NOT ((tipBufPtr^[indexL] = $20) OR (tipBufPtr^[indexL] = $09)) DO          BEGIN            str := CONCAT(str, chr(tipBufPtr^[indexL]));            indexL := indexL + 1;          END; { While }        IF (LENGTH(str) > 0) THEN InPtr^.Number_of_Channels := rinttol(str2num(str));        strLength[1] := 16;        BlockMove(@strLength, @str[0], 1);        REPEAT          BlockMove(@tipBufPtr^[indexL], @str[1], strLength[1]);          indexL := indexL + 1;        UNTIL str = 'Conversion Gain:';        indexL := indexL + strLength[1];        WHILE ((tipBufPtr^[indexL] = $20) OR (tipBufPtr^[indexL] = $09)) DO          indexL := indexL + 1; { jump over a run of spaces }        str := '';        WHILE NOT ((tipBufPtr^[indexL] = $20) OR (tipBufPtr^[indexL] = $09)) DO          BEGIN            str := CONCAT(str, chr(tipBufPtr^[indexL]));            indexL := indexL + 1;          END; { While }        IF (LENGTH(str) > 0) THEN Gain := rinttol(str2num(str));		indexL := indexL + 1;		        strLength[1] := 11;        BlockMove(@strLength, @str[0], 1);        REPEAT          BlockMove(@tipBufPtr^[indexL], @str[1], strLength[1]);          indexL := indexL + 1;        UNTIL str = 'Adc Offset:';        indexL := indexL + strLength[1];        WHILE ((tipBufPtr^[indexL] = $20) OR (tipBufPtr^[indexL] = $09)) DO          indexL := indexL + 1; { jump over a run of spaces }        str := '';        WHILE NOT ((tipBufPtr^[indexL] = $20) OR (tipBufPtr^[indexL] = $09)) DO          BEGIN            str := CONCAT(str, chr(tipBufPtr^[indexL]));            indexL := indexL + 1;          END; { While }        IF (LENGTH(str) > 0) THEN Offset := rinttol(str2num(str));		indexL := indexL + 1;		        strLength[1] := 12;        BlockMove(@strLength, @str[0], 1);        REPEAT          BlockMove(@tipBufPtr^[indexL], @str[1], strLength[1]);          indexL := indexL + 1;        UNTIL str = 'Calibration:';        indexL := indexL + strLength[1];				str2[1] := '01';		str2[2] := '02';		FOR nn := 1 to 2 Do begin			strLength[1] := 2;			BlockMove(@strLength, @str[0], 1);			REPEAT			  BlockMove(@tipBufPtr^[indexL], @str[1], strLength[1]);			  indexL := indexL + 1;			UNTIL str = str2[nn];			indexL := indexL + strLength[1];				WHILE ((tipBufPtr^[indexL] = $20) OR (tipBufPtr^[indexL] = $09)) DO			  indexL := indexL + 1; { jump over a run of spaces }			str := '';			WHILE NOT ((tipBufPtr^[indexL] = $20) OR (tipBufPtr^[indexL] = $09)) DO			  BEGIN				str := CONCAT(str, chr(tipBufPtr^[indexL]));				indexL := indexL + 1;			  END; { While }			IF (LENGTH(str) > 0) THEN Chnl[nn] := str2num(str);			indexL := indexL + 1;				strLength[1] := 3;			BlockMove(@strLength, @str[0], 1);			REPEAT			  BlockMove(@tipBufPtr^[indexL], @str[1], strLength[1]);			  indexL := indexL + 1;			UNTIL str = 'CHL';			indexL := indexL + strLength[1];				WHILE ((tipBufPtr^[indexL] = $20) OR (tipBufPtr^[indexL] = $09)) DO			  indexL := indexL + 1; { jump over a run of spaces }			str := '';			WHILE NOT ((tipBufPtr^[indexL] = $20) OR (tipBufPtr^[indexL] = $09)) DO			  BEGIN				str := CONCAT(str, chr(tipBufPtr^[indexL]));				indexL := indexL + 1;			  END; { While }			IF (LENGTH(str) > 0) THEN Enr[nn] := str2num(str);			indexL := indexL + 1;		end;		{FOR nn := 1 to 2 Do}				InPtr^.Energy_Slope := (Chnl[2] - Chnl[1])/(Enr[2] - Enr[1]);		InPtr^.Energy_Intercept := -(InPtr^.Energy_Slope * Enr[1] - Chnl[1]);		InPtr^.dE := 1000/InPtr^.Energy_Slope;		InPtr^.NDoffset := rinttol(InPtr^.Energy_Intercept);		InPtr^.Energy_Slope := 1.0;		InPtr^.Energy_Intercept := 0.0;			strLength[1] := 18;			BlockMove(@strLength, @str[0], 1);			REPEAT			  BlockMove(@tipBufPtr^[indexL], @str[1], strLength[1]);			  indexL := indexL + 1;			UNTIL str = 'Chn    Counts  ROI';			indexL := indexL + strLength[1];				FOR nn := 1 to InPtr^.Number_of_Channels DO BEGIN				indexL := indexL + 6;	{skip across channel # and a ','}								WHILE ((tipBufPtr^[indexL] = $20) OR (tipBufPtr^[indexL] = $09)) DO				  indexL := indexL + 1; { jump over a run of spaces }				str := '';				WHILE NOT ((tipBufPtr^[indexL] = $20) OR (tipBufPtr^[indexL] = $09) OR (tipBufPtr^[indexL] = $2C)) DO				  BEGIN					str := CONCAT(str, chr(tipBufPtr^[indexL]));					indexL := indexL + 1;				  END; { While }				IF (LENGTH(str) > 0) THEN InPtr^.Spec_cts[nn] := str2num(str);				indexL := indexL + 1;				WHILE NOT (tipBufPtr^[indexL] = $0D) DO					indexL := indexL + 1;				indexL := indexL + 1;			END;	{FOR nn := 1 to InPtr^.Number_of_Channels}		      InPtr^.LastChannel := InPtr^.Number_of_Channels;      DisposePtr(Ptr(tipBufPtr));	  theResult := noErr;    END;{*****************************************************************************}FUNCTION Str2Num(s: Str255): Real;   { Pascal implementation of Str2Num (fp.p: Str2Dec, Dec2Str) }VAR	aDecimal		: Decimal;	aCStr			: ConstCStringPtr;	anIndex			: Integer;	aValidPrefix	: Integer; { ignore }BEGIN	aCStr := P2CStr(@s);	anIndex := 0;	str2dec( aCStr, anIndex, aDecimal, aValidPrefix );	Str2Num := dec2num( aDecimal );END;END.