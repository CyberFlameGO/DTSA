 {[j=30/55,:+,u+,r+,o=120,k+,n+,#+,v+,q+,b+]}{[f-]} {*********************************} UNIT Tools;{*********************************}{**********************************} INTERFACE {**********************************} USES QuickDraw, QuickdrawText, Types, OSUtils, ToolUtils, Timer, Errors, Menus, Files, Lists, Memory, Events, Dialogs, Controls, Windows,   Packages, Printing, StandardFile, ColorPicker, Sound, Resources, Scrap, fenv, fp {SANE}, Retrace, TextEdit, TextUtils, Finder, Script,   SegLoad, PasLibIntf, Spectrum_Structures, Declarations, INITIALIZE, Global_Functions, Utilities, Physics, Physics_Windows, Sandia, CurveFit, {SiLiWin,} Calibrate; PROCEDURE D_Plot_Symbols;PROCEDURE GetPreferences;PROCEDURE SavePreferences;PROCEDURE Write_Preferences;PROCEDURE Get_Preferences;PROCEDURE WriteToFile(sp_Number : integer);PROCEDURE AppendDTSA;PROCEDURE ReadFromFile;{FUNCTION  MyTrapAvailable (tNumber:   integer; tType:     TrapType): boolean;} {SDD ¥  PasLibIntf; contains TrapAvailable routine ¥}	 {SDD FUNCTION  TrapAvailable (tNumber:   integer; tType:     TrapType): boolean;}FUNCTION  IsAppWindow(Window : WindowPtr) : Boolean;PROCEDURE ReadDeskScrap;PROCEDURE WriteDeskScrap;PROCEDURE InitScrap;PROCEDURE DoApp4Event;FUNCTION  GetSleep: longint;PROCEDURE DoActivate( window : WindowPtr);PROCEDURE DoDeActivate( window : WindowPtr);PROCEDURE Marker_Type_in(Chcode,LineCode: Integer);PROCEDURE Get_New_Range( Up_Down  : Integer);PROCEDURE Do_Header_Information(myEvent: EventRecord; VAR theInput: TEHandle);PROCEDURE Open_Header_Information(Spectrum : Integer);PROCEDURE Update_Header_Information(whichWindow: WindowPtr);PROCEDURE Close_Header_Information(whichWindow: WindowPtr; VAR theInput: TEHandle);PROCEDURE Init_Header_Information;PROCEDURE Show_About;PROCEDURE DefaultColors;PROCEDURE Show_Disclaimer;{******************************} IMPLEMENTATION {**********************************} {[f+]} {$S Tools}     PROCEDURE Show_About;      VAR        mylog                        : DialogPtr;        itemHit                      : integer;        tempRect                     : Rect;        DType                        : integer;        DItem                        : Handle;      BEGIN        UseResFile(MCA_Home_Res_RefNum);        mylog := GetNewDialog(11034, NIL, pointer( - 1));        OutlineButton(mylog, 1, 16);        BeepBeep;        UseResFile(MCA_Home_Res_RefNum);        REPEAT          ModalDialog(NIL, itemHit);          GetDialogItem(mylog, itemHit, DType, DItem, tempRect);          IF itemHit = 2            THEN BeepBeep;                      { Carol }          IF itemHit = 3            THEN BeepBeep;                     { Bob }          IF itemHit = 4            THEN BeepBeep;                         { Chuck }          IF itemHit = 5            THEN BeepBeep;                { Text Field }        UNTIL (itemHit = 1);		tempRect := mylog^.portRect;		DisposeDialog(mylog);      	FillWhiteSpace(tempRect);        Mouse_Active_Window;        DrawAxesFull;      END;    PROCEDURE Show_Disclaimer;      VAR        mylog                        : DialogPtr;        itemHit                      : integer;		where						 : Point;      BEGIN        {UseResFile(MCA_Home_Res_RefNum);} 		{¥¥¥New dialog - Disclaimer¥¥¥} 		UseResFile(MCA_Home_Res_RefNum);        mylog := GetNewDialog(135, NIL, pointer( - 1));		CenterDialog(mylog, TRUE, where);        ShowWindow(mylog);                            {Open a dialog box}        SelectWindow(mylog);                          {Lets see it}		SetPort(mylog);        REPEAT          ModalDialog(NIL, itemHit);		         UNTIL (itemHit = 1);        DisposeDialog(mylog);        Mouse_Active_Window;        DrawAxesFull;   {End New dialog}    	        END;    FUNCTION IsAppWindow(Window: WindowPtr): boolean;      BEGIN        IF Window = NIL          THEN IsAppWindow := false          ELSE IsAppWindow := WindowPeek(Window)^.windowKind >= 0;      END;    PROCEDURE ReadDeskScrap;      TYPE        OSTypePtr                     = ^OSType;        OSTypeHandle                  = ^OSTypePtr;      VAR        scrapPtr                     : ScrapStuffPtr;        scrapTypeHndl                : OSTypeHandle;        scrapLength                  : longint;        offset                       : longint;      BEGIN        scrapPtr := InfoScrap;        WITH scrapPtr^ DO          BEGIN            IF scrapCompare <> scrapCount              THEN                BEGIN                  IF scrapHandle = NIL                    THEN                      BEGIN                        scrapType := '????';                      END                    ELSE                      BEGIN                        scrapTypeHndl := OSTypeHandle(scrapHandle);                        scrapType := scrapTypeHndl^^;                      END;                  TESetScrapLength(0);                  IF GetScrap(NIL, 'TEXT', offset) > 0                    THEN                      BEGIN                        scrapLength := TEFromScrap;                      END;                  scrapCompare := scrapCount;                END;                                  {if}          END;                                        {with}      END;                                            {ReadDeskScrap}    PROCEDURE WriteDeskScrap;      VAR        errCode                      : OSErr;      BEGIN        IF scrapDirty          THEN            BEGIN              scrapCompare := ZeroScrap;              errCode := TEToScrap;              scrapType := 'TEXT';              scrapDirty := false;            END;                                      {if}      END;                                            {WriteDeskScrap}    PROCEDURE InitScrap;      VAR        scrapPtr                     : ScrapStuffPtr;      BEGIN        scrapPtr := InfoScrap;        scrapDirty := false;        scrapCompare := scrapPtr^.scrapCount + 1;        ReadDeskScrap;      END;                                            {InitScrap}  (*  FUNCTION MyTrapAvailable(tNumber: integer; tType: TrapType): boolean;      BEGIN        MyTrapAvailable := (NGetTrapAddress(tNumber, tType) <> NGetTrapAddress(_Unimplemented));      END;	*)    PROCEDURE DoApp4Event;      CONST        suspendResumeMsg              = 1;        resumeMask                    = 1;      VAR        resume                       : boolean;        front                        : WindowPtr;      BEGIN        myEvent.what := nullEvent;        IF BitShift(myEvent.message, - 24) = suspendResumeMsg          THEN            BEGIN              resume := (BitAnd(myEvent.message, resumeMask) <> 0);              IF resume                THEN                  BEGIN                    ReadDeskScrap;                  END                ELSE                  BEGIN                    WriteDeskScrap;                  END;              inBackground := NOT resume;              front := FrontWindow;              IF front <> NIL                THEN                  BEGIN                    myEvent.what := activateEvt;                    myEvent.modifiers := LoWord(myEvent.message);                    myEvent.message := longint(front);                  END;            END;      END;                                            {DoApp4Event}    FUNCTION GetSleep: longint;      VAR        sleep                        : longint;      BEGIN        sleep := MaxLongint;        Mouse_Active_Window;        IF (NOT inBackground) & (FrontWindow <> NIL)          THEN            BEGIN              IF SiLi_Window_Active OR ROI_Window_Active OR StripPeak_Window_Active OR Calibrate_Window_Active OR                 ID_Window_Active OR Simplex_Results_Active                THEN                  BEGIN                    sleep := GetCaretTime;            {``}                  END                ELSE                  BEGIN                               {DA or modeless dialog}                    sleep := GetCaretTime;                  END;              sleep := GetCaretTime;            END;        GetSleep := sleep;      END;                                            {GetSleep}    PROCEDURE DoActivate(Window: WindowPtr);      BEGIN        IF IsAppWindow(Window)          THEN TEActivate(DocumentPeek(Window)^.te);      END;    PROCEDURE DoDeActivate(Window: WindowPtr);      BEGIN        IF IsAppWindow(Window)          THEN TEDeActivate(DocumentPeek(Window)^.te);      END;    PROCEDURE Marker_Type_in(Chcode,LineCode: integer);      VAR        Charac                       : str255;      BEGIN        IF (Ord(Chcode) = 32)  OR 		  ((Ord(Chcode) > 64) AND 		   (Ord(Chcode) < 91)) OR 		  ((Ord(Chcode) > 96) AND 		   (Ord(Chcode) < 123)){ it's a letter } OR 		  ((Ord(Chcode) > 47) AND (Ord(Chcode) < 58)) { it's a number }  OR		  ((Ord(Chcode) = 13) and (length(Marker_Input_text) = 1))          THEN BEGIN		      IF (Ord(Chcode) = 13) then Charac := ' '			  ELSE Charac := Chr(Chcode);               Marker_Input_text := CONCAT(Marker_Input_text, Charac);              IF length(Marker_Input_text) = 2                THEN                  BEGIN                    Atomic_Number := AtSymbol_To_Znum(Marker_Input_text);                    IF (Atomic_Number < 3)                      THEN Atomic_Number := 3;                    IF (Atomic_Number > 95)                      THEN Atomic_Number := 95;                    IF (Atomic_Number >= 3) AND (Atomic_Number <= 95)                      THEN IF (linecode <1) then Markers					  ELSE AutoROI_Data( Atomic_Number,  LineCode);                    Marker_Input_text := '';                  END;              IF length(Marker_Input_text) > 2                THEN Marker_Input_text := '';            END;      END;                                            { PROCEDURE Marker_Type_in }    PROCEDURE Get_New_Range(Up_Down: integer);      BEGIN	  IF (Up_Down = 1) and (Range_Keeper > 1) then	  begin			Range_Keeper := Range_Keeper - 1;{...if 512 button, 5 - 1}			New_Range := New_Range div 2;	{...if 512 button, 512 div 2}	  end	  else if (Up_Down = 2) and  (Range_Keeper < 10) then	  if (New_Range * 2 <= Spectrum_Size) then	  begin			Range_Keeper := Range_Keeper + 1;			New_Range := New_Range * 2;	  end	  else putmessage('The spectrum is fully displayed.',	                  'I can only contract when the range displayed',					  'is less than the Spectrum display button value.','');	                   	        END;                                            {End of procedure}    {========================================================================================}		PROCEDURE DefaultColors;		  BEGIN        Plt_spec[10]^^.Plot_Info.Spectrum_Color.red := $FFFF;        Plt_spec[10]^^.Plot_Info.Spectrum_Color.green := 20108;        Plt_spec[10]^^.Plot_Info.Spectrum_Color.blue := $9D1D;        Plt_spec[9]^^.Plot_Info.Spectrum_Color.red := 26759;        Plt_spec[9]^^.Plot_Info.Spectrum_Color.green := $FFFF;        Plt_spec[9]^^.Plot_Info.Spectrum_Color.blue := 27060;        Plt_spec[8]^^.Plot_Info.Spectrum_Color.red := $FFFF;        Plt_spec[8]^^.Plot_Info.Spectrum_Color.green := $FFFF;        Plt_spec[8]^^.Plot_Info.Spectrum_Color.blue := 16;        Plt_spec[7]^^.Plot_Info.Spectrum_Color.red := $99CA;        Plt_spec[7]^^.Plot_Info.Spectrum_Color.green := $DA68;        Plt_spec[7]^^.Plot_Info.Spectrum_Color.blue := $FFFF;        Plt_spec[6]^^.Plot_Info.Spectrum_Color.red := 1080;        Plt_spec[6]^^.Plot_Info.Spectrum_Color.green := $A35E;        Plt_spec[6]^^.Plot_Info.Spectrum_Color.blue := 20385;        Plt_spec[5]^^.Plot_Info.Spectrum_Color.red := $FFFF;        Plt_spec[5]^^.Plot_Info.Spectrum_Color.green := 19160;        Plt_spec[5]^^.Plot_Info.Spectrum_Color.blue := 7176;        Plt_spec[4]^^.Plot_Info.Spectrum_Color.red := $FFFF;        Plt_spec[4]^^.Plot_Info.Spectrum_Color.green := $902C;        Plt_spec[4]^^.Plot_Info.Spectrum_Color.blue := $ADE4;        Plt_spec[3]^^.Plot_Info.Spectrum_Color.red := 15000;        Plt_spec[3]^^.Plot_Info.Spectrum_Color.green := 30000;        Plt_spec[3]^^.Plot_Info.Spectrum_Color.blue := $FFFF;        Plt_spec[2]^^.Plot_Info.Spectrum_Color.red := $FFFF;        Plt_spec[2]^^.Plot_Info.Spectrum_Color.green := $AF3C;        Plt_spec[2]^^.Plot_Info.Spectrum_Color.blue := 4114;        Plt_spec[1]^^.Plot_Info.Spectrum_Color.red := $F793;        Plt_spec[1]^^.Plot_Info.Spectrum_Color.green := 1732;        Plt_spec[1]^^.Plot_Info.Spectrum_Color.blue := 17033;        WITH SpectrumColor[1] DO   { the below are the actual spectra colors, 		                             the above are the headers }          BEGIN            red := $F793;            green := 1732;            blue := 17033;          END;        WITH SpectrumColor[2] DO          BEGIN            red := $FFFF;            green := $AF3C;            blue := 4114;          END;        WITH SpectrumColor[3] DO          BEGIN            red := 15000;            green := $7530;            blue := $FFFF;          END;        WITH SpectrumColor[4] DO          BEGIN            red := $FFFF;            green := $902C;            blue := $ADE4;          END;        WITH SpectrumColor[5] DO          BEGIN            red := $FFFF;            green := 19160;            blue := 7176;          END;        WITH SpectrumColor[6] DO          BEGIN            red := 1080;            green := $A35E;            blue := 20385;          END;        WITH SpectrumColor[7] DO          BEGIN            red := $99CA;            green := $DA68;            blue := $FFFF;          END;        WITH SpectrumColor[8] DO          BEGIN            red := $FFFF;            green := $FFFF;            blue := 16;          END;        WITH SpectrumColor[10] DO          BEGIN            red := $FFFF;            green := 20108;            blue := $9D1D;          END;        WITH SpectrumColor[9] DO          BEGIN            red := $A76E;            green := $FFFF;            blue := 2604;          END;        WITH BackGround_Color DO          BEGIN            red := 688;            green := 1602;            blue := 23713;          END;        WITH PeakROI_Color DO          BEGIN            red := $FFFF;            green := $FFFF;            blue := $FFFF;          END;        WITH Text_Color DO          BEGIN            red := $FFFF;            green := $B9B3;            blue := 632;          END;        WITH BkgROI_Color DO          BEGIN            red := $A898;            blue := $C9F7;            green := $FDE8;          END;        WITH QuantROI_Color DO          BEGIN            red := $FDE8;            blue := $C9F7;            green := $A898;          END;        WITH ScaleROI_Color DO          BEGIN            red := 748;            green := $E023;            blue := $FFFF;          END;        WITH Axes_Color DO          BEGIN            red := 10;            green := $FFFF;            blue := 10;          END;        WITH KLMColor DO          BEGIN            red := $FFFF;            green := $FFFF;            blue := $FFFF;          END;        WITH PeakLabel_Color DO          BEGIN            red := $EC46;            green := $FDE8;            blue := 752;          END;	END;	{ PROCEDURE DefaultColors }    PROCEDURE D_Plot_Symbols;      CONST        Syms_Accept                   = 1;        Dot                           = 2;        Single_Pixel                  = 13;        Plus                          = 14;        Syms_2_Horiz                  = 15;        Syms_2_Vert                   = 16;        Syms_4_Pixel                  = 17;        Syms_Square                   = 18;        Bkg_ROI_Color                 = 19;        Connected                     = 21;        the_Axes_Color                = 22;        the_Background_Color          = 23;        Peak_ROI_Color                = 24;        Scale_ROI_Color               = 25;        KLM_Color                     = 26;        Peak_Label_Color              = 27;        Quant_ROI_Color               = 28;        Spec_Color                    = 29;		Default_Color				  = 30;				No_Header                     = 31;		{2/16/94}		Filled_spectra				  = 32;		{4/18/97}		      VAR        ColorSelection               : DialogPtr;        tempRect                     : Rect;        DType                        : integer;        index                        : integer;        DItem                        : Handle;        CItem			             : ControlHandle;        itemHit                      : integer;        temp                         : integer;        Test                         : boolean;        where                        : Point;        Syms_Exitdialog              : boolean;        str,str1		   : str255; 		      PROCEDURE docolors;        BEGIN          pensize(10, 17);          RGBForeColor(SpectrumColor[10]);          moveto(121, 56);          lineto(121, 56);          RGBForeColor(SpectrumColor[9]);          moveto(121, 76);          lineto(121, 76);          RGBForeColor(SpectrumColor[8]);          moveto(121, 236);          lineto(121, 236);          RGBForeColor(SpectrumColor[7]);          moveto(121, 216);          lineto(121, 216);          RGBForeColor(SpectrumColor[6]);          moveto(121, 196);          lineto(121, 196);          RGBForeColor(SpectrumColor[5]);          moveto(121, 176);          lineto(121, 176);          RGBForeColor(SpectrumColor[4]);          moveto(121, 156);          lineto(121, 156);          RGBForeColor(SpectrumColor[3]);          moveto(121, 136);          lineto(121, 136);          RGBForeColor(SpectrumColor[2]);          moveto(121, 116);          lineto(121, 116);          RGBForeColor(SpectrumColor[1]);          moveto(121, 96);          lineto(121, 96);          RGBForeColor(Axes_Color);          moveto(147, 296);          lineto(147, 296);          RGBForeColor(BackGround_Color);          moveto(318, 296);          lineto(318, 296);          RGBForeColor(PeakROI_Color);          moveto(147, 320);          lineto(147, 320);          RGBForeColor(ScaleROI_Color);          moveto(147, 272);          lineto(147, 272);          RGBForeColor(KLMColor);          moveto(318, 320);          lineto(318, 320);          RGBForeColor(PeakLabel_Color);          moveto(318, 344);          lineto(318, 344);          RGBForeColor(QuantROI_Color);          moveto(318, 272);          lineto(318, 272);          RGBForeColor(BkgROI_Color);          moveto(147, 344);          lineto(147, 344);          pensize(1, 1);          BackColor(WhiteColor);          ForeColor(BlackColor);        END;      BEGIN        ColorSelection := GetNewDialog(447, NIL, pointer( - 1));        ShowWindow(ColorSelection);        SelectWindow(ColorSelection);        SetPort(ColorSelection);        OutlineButton(ColorSelection, 1, 16);         { outline the accept button }        docolors;        where.h := 175;        where.v := 45;        Syms_Exitdialog := false;        Plt_Syms_Spectrum_Number := 10;          GetDialogItem(ColorSelection, No_Header, DType, DItem, tempRect);	{Turn off checkbox} {2/16/94}          CItem := controlhandle(DItem);		  if NOT No_Header_in_Print then          SetControlValue(CItem, 0)		  else		  SetControlValue(CItem, 1);				{2/16/94}		          REPEAT          ModalDialog(NIL, itemHit);          GetDialogItem(ColorSelection, itemHit, DType, DItem, tempRect);          CItem := controlhandle(DItem);          docolors;          IF (itemHit = Connected)            THEN              BEGIN                A^.Plot_Connected[Plt_Syms_Spectrum_Number] := 1;              END;			  		  		  IF (itemHit = Dot)            THEN              BEGIN                A^.Plot_Connected[Plt_Syms_Spectrum_Number] := 0;              END;		  IF (itemHit = Filled_spectra)            THEN              BEGIN                A^.Plot_Connected[Plt_Syms_Spectrum_Number] := 2;              END;          FOR index := 1 TO 10 DO            BEGIN              IF (itemHit = A^.Plt_Syms_S[index])                THEN                  BEGIN                    Plt_Syms_Spectrum_Number := index;                  END;            END;          IF (itemHit = Spec_Color)            THEN              BEGIN                aRGB := SpectrumColor[Plt_Syms_Spectrum_Number];                numToString(Plt_Syms_Spectrum_Number, str);                IF Plt_Syms_Spectrum_Number = 10                  THEN str := '"Work"';                IF Plt_Syms_Spectrum_Number = 9                  THEN str := '"Results"';                str1 := CONCAT('Spectrum ', str);                str1 := CONCAT(str1, ' Color');                Test := GetColor(where, str1, aRGB, aRGB);                IF Test                  THEN SpectrumColor[Plt_Syms_Spectrum_Number] := aRGB;                docolors;              END;          IF (itemHit = Single_Pixel)            THEN              BEGIN                A^.Plot_Symbol[Plt_Syms_Spectrum_Number] := 1;              END;          IF (itemHit = Plus)            THEN              BEGIN                A^.Plot_Symbol[Plt_Syms_Spectrum_Number] := 2;              END;          IF (itemHit = Syms_2_Horiz)            THEN              BEGIN                A^.Plot_Symbol[Plt_Syms_Spectrum_Number] := 3;              END;          IF (itemHit = Syms_2_Vert)            THEN              BEGIN                A^.Plot_Symbol[Plt_Syms_Spectrum_Number] := 4;              END;          IF (itemHit = Syms_4_Pixel)            THEN              BEGIN                A^.Plot_Symbol[Plt_Syms_Spectrum_Number] := 5;              END;          IF (itemHit = Syms_Square)            THEN              BEGIN                A^.Plot_Symbol[Plt_Syms_Spectrum_Number] := 6;              END;          IF (itemHit = the_Background_Color)            THEN              BEGIN                str1 := 'Background Color';                Test := GetColor(where, str1, BackGround_Color, BackGround_Color);                docolors;              END;          IF (itemHit = Peak_ROI_Color)               { dialog item #24 }            THEN              BEGIN                str1 := 'Peak ROI Color';                Test := GetColor(where, str1, PeakROI_Color, PeakROI_Color);                docolors;              END;          IF (itemHit = Bkg_ROI_Color)                { Dialog item #19 }            THEN              BEGIN                str1 := 'Bkg ROI Color';                Test := GetColor(where, str1, BkgROI_Color, BkgROI_Color);                docolors;              END;          IF (itemHit = the_Axes_Color)               { Dialog item #22 }            THEN              BEGIN                str1 := 'Axes Color';                Test := GetColor(where, str1, Axes_Color, Axes_Color);                docolors;              END;          IF (itemHit = Scale_ROI_Color)              { Dialog item #25 }            THEN              BEGIN                str1 := 'Scale ROI Color';                Test := GetColor(where, str1, ScaleROI_Color, ScaleROI_Color);                docolors;              END;          IF (itemHit = KLM_Color)                    { Dialog item #26 }            THEN              BEGIN                str1 := 'KLM Color';                Test := GetColor(where, str1, KLMColor, KLMColor);                docolors;              END;          IF (itemHit = Peak_Label_Color)             { Dialog item #27 }            THEN              BEGIN                str1 := 'Peak Label Color';                Test := GetColor(where, str1, PeakLabel_Color, PeakLabel_Color);                docolors;              END;          IF (itemHit = Quant_ROI_Color)              { Dialog item #28 }            THEN              BEGIN                str1 := 'Quant ROI Color';                Test := GetColor(where, str1, QuantROI_Color, QuantROI_Color);                docolors;              END;			  		  IF (itemHit = Default_Color)					{ Dialog item #30 }            THEN              BEGIN                DefaultColors;                docolors;              END;		          IF (itemHit = No_Header) THEN		{2/16/94}          BEGIN            temp := GetControlValue(CItem);            SetControlValue(CItem, (temp + 1) MOD 2);            IF (temp = 0) THEN No_Header_in_Print := true            ELSE No_Header_in_Print := FALSE;          END;								{2/16/94}          IF (itemHit = Syms_Accept)            THEN              BEGIN                Syms_Exitdialog := true;              END;          OutlineButton(ColorSelection, 1, 16);       { outline the accept button }        UNTIL Syms_Exitdialog;        DisposeDialog(ColorSelection);		Update_Full;      END;                                            {End of procedure}    PROCEDURE GetPreferences;      BEGIN	          Pref_name := 'Preferences.MCA';			  In_VolRefNum := MCA_VolRefNum;              ReadPreferences;	{in GlobalFunctions; reads settings to variables}      END;    PROCEDURE SavePreferences;      BEGIN	     Pref_File := 'Preferences.MCA';		 Pref_VolNum := MCA_VolRefNum;         WritePreferences; {values to settings} 	  END;    PROCEDURE Preferences_IO(Direction: integer);     { Write_Out is constant := 1, Read_In := 0 }      VAR	     errCode : integer;         mytype                       : OSType;        myprompt                     : str255;      BEGIN        IF Direction = Write_Out          THEN            BEGIN            (*  errCode := SetVol(NIL, MCA_VolRefNum);*)              Pref_File := 'ThePreferences';              if (not CreateFile(Pref_File, 'All parameters to:')) OR			  	 (File_Cancel_Button = false) THEN exit(Preferences_IO);			  Pref_VolNum := Out_VolRefNum; 			    WritePreferences;	{Global_Functions.p}              END;        IF Direction = Read_In          THEN            BEGIN              errCode := SetVol(NIL, MCA_VolRefNum);              mytype := 'MCAp';              myprompt := 'Get a Preferences File';              REPEAT              UNTIL (GetFileName(Pref_Name, mytype, mytype, myprompt) = true) OR (File_Cancel_Button = false);              IF (File_Cancel_Button = false) THEN exit(Preferences_IO);              ReadPreferences;			  Update_Full;			  END;	       END;     { PROCEDURE Preferences_IO }    PROCEDURE Write_Preferences;      BEGIN        Preferences_IO(Write_Out);                    { Write_Out is constant := 1 }      END;    PROCEDURE Get_Preferences;      BEGIN        Preferences_IO(Read_In);                      { Read_In is constant := 0 }      END;    PROCEDURE WriteToFile{(sp_Number)};      VAR        refnum                       : integer;        bytecount                    : longint;        errCode                      : integer;		str, str1, defName   		 : str255;		Outreply					 : StandardFileReply;		savename                     : fnamestr;		savevol         			 : integer;		save_dirID					 : longint;      BEGIN        IF ((NOT demo_DTSA) OR (Plt_spec[sp_Number]^^.Expt_Info.spare2))          THEN            BEGIN							numToString(Spectrum_Size, str);				str1 := CONCAT('You are about to save a spectrum of ',str,' channels.');				if not Answermessage(str1,'If "It`s OK" I will do this.',				'If "It`s NOT OK" then select the size with the Front Panel buttons',				'"1K" for 1024, "2K" for 2048, etc.')						then EXIT(WriteToFile);						              defName := 'Spectrum.Dat';        { the user's choice replaces this }			  StandardPutFile('Save "Work" to DTSA File:', defName, Outreply);		{¥¥New DTSA file spec¥¥}			  File_Cancel_Button := Outreply.sfGood;			  if NOT Outreply.sfGood Then exit(WriteToFile);			  Write_DTSA_Spec := Outreply.sfFile;			  			  errCode := FSpCreate(Write_DTSA_Spec, 'DTSA', 'MCAf',smSystemScript);		{¥¥New DTSA file spec¥¥}			  			  			               IF (File_Cancel_Button = false)                THEN exit(WriteToFile);				              (*Binary_VolNum_Write := OutVol_volnum;*)			  								errCode := FSpOpenDF(Write_DTSA_Spec, fsRdWrPerm, refNum);		{¥¥New DTSA file spec¥¥}				              IF (errCode = NoErr)                THEN                  BEGIN                    save_work_open := true;					  WrtBinaryName := Write_DTSA_Spec.name;					  OutVol_volnum := Write_DTSA_Spec.vRefNum;					  OutVol_DirID := Write_DTSA_Spec.parID;					  {¥¥¥¥¥¥ set this true to make a demo spectrum ¥¥¥¥¥¥}					  if OptionKeyDown then Plt_spec[10]^^.Expt_Info.spare2 := TRUE					  ELSE Plt_spec[10]^^.Expt_Info.spare2 := False;					  					  {The volume names in the folowing calls are all StringPtr}					  errcode := HGetVol(@savename, savevol, save_dirID);{keep track of default vol}					  errcode := HSetVol(@OutVol_volname, OutVol_volnum, OutVol_DirID);{get name of current vol}					  errcode := HGetVol(@OutVol_volname, OutVol_volnum, OutVol_DirID);{get name of current vol}					  errcode := HSetVol(@savename, savevol, save_dirID);{restore default vol}					WrtBinaryName := Write_DTSA_Spec.name;                    bytecount := 0;                    errCode := SetEOF(refnum, bytecount);					{MCA_Filename < WrtBinaryName but the next field in Expt_Info					 is Spectrum_comments which is written later. What dumb luck! Ha!					 WrtBinaryName > 25 => SysBomb!!!}					If length(WrtBinaryName) < 26 then                      Plt_spec[sp_Number]^^.Expt_Info.MCA_Filename := WrtBinaryName					else 					  Plt_spec[sp_Number]^^.Expt_Info.MCA_Filename := copy(WrtBinaryName,1,25);                    Plt_spec[sp_Number]^^.Expt_Info.FirstSpec := 1;                    Plt_spec[sp_Number]^^.Expt_Info.LastSpect := 1;                    Plt_spec[sp_Number]^^.SpectrumStuff.Spectrum_Info.Spectrum_number := 1;					Plt_spec[sp_Number]^^.Expt_Info.Number_of_Channels := Spectrum_Size;					If Plt_spec[sp_Number]^^.SpectrumStuff.Spectrum_Info.Number_of_Elements <1					then Plt_spec[sp_Number]^^.SpectrumStuff.Spectrum_Info.This_is_a_standard := false;                    errCode := SetFPos_err(refnum, fsFromstart, 0, '');                    bytecount := sizeof(Work_spectrum) - sizeof(Spectrum_Counts); { 10 is the "work" spectrum }                    bytecount := bytecount + 4 * longint(Plt_spec[sp_Number]^^.Expt_Info.Number_of_Channels);                    errCode := FSWrite_err(refnum, bytecount, @Plt_spec[sp_Number]^^, 'In WriteToFile'); {~~}                    IF errCode = NoErr                      THEN 					  begin					  	SpecWork_has_been_Changed := false;					    ItsBeenAcquired := false;                        saved_displayed := true;					  end;					  					                      { so you can't SAVE WORK the same spectrum to this new file }    {     errCode := GetFPos(refnum,bytecount);         errCode := SetEOF(refnum,bytecount);   }                  END;              errCode := FSClose(refnum);              errCode := FlushVol(NIL, Write_DTSA_Spec.vRefnum);              IF errCode <> NoErr                THEN                  BEGIN                    PutMessage('A Flush Volume error just occured', '', '', '');                    IF errCode = BdNamErr                      THEN PutMessage('Bad Volume Name', '', '', '');                    IF errCode = ioErr                      THEN PutMessage('I/O error', '', '', '');                    IF errCode = nsvErr                      THEN PutMessage('No such volume', '', '', '');                  END;            END          ELSE PutMessage('I`m sorry, but I can only save spectra supplied with the demo disk.', '', '', '');      END;                                            { WriteToFile }    PROCEDURE ReadFromFile;                           { Brings up Dialog Box and Opens a File }      VAR        refnum, errCode, n           : integer;        bytecount                    : longint;        myprompt			         : str255;        mytype                       : ARRAY [0..3] of OSType {SFTypeList};		sfPtr             			 : ConstSFTypeListPtr;		savename                     : fnamestr;		savevol         			 : integer;		Inreply						 : StandardFileReply;		saveFSSpec					 : FSSpec;		save_dirID					 : longint;		errOpen						 : integer;       BEGIN        myprompt := 'Get a binary DTSA File';        mytype[0] := 'MCAf';		sfPtr := @mytype;		If MCA_Spectrum_Active		then begin		   savename := RdBinaryName;		   saveFSSpec := Read_DTSA_Spec;		   savevol := Binary_VolNum_Read;		end		else begin		   savename := '';		   savevol := Binary_VolNum_Read;		end;		REPEAT		  StandardGetFile(NIL,1, sfPtr, Inreply);		{¥¥New DTSA file spec¥¥}		  File_Cancel_Button := Inreply.sfGood;		  if NOT Inreply.sfGood Then exit(ReadFromFile);		if ItsBeenAcquired then			if not Answermessage('You are about to overwrite an unsaved spectrum in work!!!!!',						     'If "It`s OK" I will do this, if "It`s NOT OK" then I won`t.',						     '','') then EXIT(ReadFromFile);							 		  Read_DTSA_Spec := Inreply.sfFile;        For n := 1 to Maximum_Channels do Plt_Spec[10]^^.S[n] := 0.0;                { define the write names to SaveWork to this file }		errOpen := FSpOpenDF(Read_DTSA_Spec, fsRdWrPerm, refnum);				if errOpen = noerr then BEGIN		  InVol_volnum := Read_DTSA_Spec.vRefNum;		  InVol_DirID := Read_DTSA_Spec.parID;		  (*numToString(InVol_volnum, str1);		  numToString(InVol_DirID, str2);		putmessage('reading DTSA spectrum - InVol_volnum:',str1,' InVol_DirID:',str2);*)		  {The volume names in the folowing calls are all StringPtr}		  errcode := HGetVol(@savename, savevol, save_dirID);{keep track of default vol}		 (* numToString(savevol, str1);		  numToString(save_dirID, str2);		putmessage('Default values - savevol:',str1,' save_dirID:',str2);*)		  		  errcode := HSetVol(@InVol_volname, InVol_volnum, InVol_DirID);{get name of current vol}		  errcode := HGetVol(@InVol_volname, InVol_volnum, InVol_DirID);{get name of current vol}		 (* numToString(InVol_volnum, str1);		  numToString(InVol_DirID, str2);		putmessage('Set the default to spectrum - InVol_volnum:',str1,' InVol_DirID:',str2); *)		  errcode := HSetVol(@savename, savevol, save_dirID);{restore default vol}		(*putmessage('Reset back to original vol','','','');		putmessage('InVol_volname volname is',InVol_volname,' default is:',savename);*)		(*Binary_VolNum_Read := savevol;		In_VolRefNum := savevol;*)				RdBinaryName := Read_DTSA_Spec.name;        bytecount := sizeof(Expt_InfoRec);        errCode := SetFPos_err(refnum, fsFromstart, 0, '');        errCode := FSRead_err(refnum, bytecount, (@Plt_spec[10]^^.Expt_Info), '');        		IF ((demo_DTSA = true) and (Plt_spec[10]^^.Expt_Info.spare2 = false))		then begin		  errCode := FSClose(refnum);		  errCode := FlushVol(NIL, Read_DTSA_Spec.vRefnum);          PutMessage('I`m sorry, but I can only display spectra supplied with the demo disk.', '', '', '');		  RdBinaryName := savename;		  Binary_VolNum_Read := savevol;		  Read_DTSA_Spec := saveFSSpec;		  If MCA_Spectrum_Active		  then begin			 errCode := FSpOpenDF(Read_DTSA_Spec, fsRdWrPerm, refnum);			 RdBinaryName := Read_DTSA_Spec.name;			 bytecount := sizeof(expt_infoRec) + sizeof(Plot_infoRec) + 						  (longint(Spectrum_Counter) - 1) * ( sizeof(Spectrum_Structure) + 						  Longint(Plt_spec[10]^^.Expt_Info.Number_of_Channels) * 4);			 { to position mark at end of spectrum preceeding the spectrum of interest}			 errCode := SetFPos_err(refnum, fsFromStart, bytecount,''); {end of preceeding spectrum }			 bytecount := sizeof(Spectrum_Structure); {ie SpectrumStuff}			 errCode := FSRead_err(refnum, bytecount, @Plt_spec[10]^^.SpectrumStuff,'');			 bytecount := Longint(Plt_spec[10]^^.Expt_Info.Number_of_Channels) * 4;			 errCode := FSRead_err(refnum, bytecount, @Plt_spec[10]^^.S,'');			 Spectrum_Full[10] := True;			 CheckItem(FullMenu, A^.C_Full[10], Spectrum_Full[10]);		  end; { If MCA_Spectrum_Active...}		end	{ IF ((demo_DTSA = true)...}        Else        BEGIN			if Plt_Spec[10]^^.Expt_info.RefFile <> FALSE			then Plt_Spec[10]^^.Expt_info.RefFile := FALSE;	{7/6/95}	 			(*      if (Plt_Spec[10]^^.Expt_info.Detector.Spec <> EDS) AND			   (Plt_Spec[10]^^.Expt_info.Detector.Spec <> WDS) AND			   (Plt_Spec[10]^^.Expt_info.Detector.Spec <> EELS) {means its an old file, before .RefFile}	        then Plt_Spec[10]^^.Expt_info.Detector.Spec := EDS;	{7/6/95}	 *) 			WDS_Active := False;			Ge_Active := False; 			Si_Active := False;						If Plt_Spec[10]^^.Expt_Info.Detector.spec = WDS then WDS_Active := TRUE            Else if Plt_Spec[10]^^.Expt_Info.Detector.spec = EDS Then		    Begin			   if Plt_Spec[10]^^.Expt_Info.Detector.ID = 2 then Ge_Active := TRUE 			   else if Plt_Spec[10]^^.Expt_Info.Detector.ID = 1 then Si_Active := TRUE			   else begin	{fix the undefined stuff...}			      if answermessage('I don`t know if the EDS detector is Si or Ge.',				  				   'If IT`S OK, I will EDIT Detector ID to Si EDS in the file.',								   'If IT`S NOT OK, I will EDIT Detector ID to Ge EDS.',							       'Remember, you can edit the Experiment Header.')				  then begin				  	Si_Active := TRUE;				  	Plt_Spec[10]^^.Expt_Info.Detector.ID := 1;				  end	{if answermessage...}				  else begin				  	Ge_Active := TRUE;				  	Plt_Spec[10]^^.Expt_Info.Detector.ID := 2;				  end;			   end;	{else begin...}            End	{Else if Plt_Spec[10]^^.Expt_Info.Detector.spec = EDS...}            Else if Plt_Spec[10]^^.Expt_Info.Detector.spec = EELS Then		    Begin			End			Else Begin				If answermessage('In the file, Detector.spec is neither EDS nor WDS.',								 'If IT`S OK, I will EDIT Detector ID to Si EDS.',								 'If IT`S NOT OK, I will EDIT Detector ID to WDS.',							     'Remember, you can edit the Experiment Header.')				then				begin					Plt_Spec[10]^^.Expt_Info.Detector.spec := EDS;					Plt_Spec[10]^^.Expt_Info.Detector.ID := 1;				end				else begin				    Plt_Spec[10]^^.Expt_Info.Detector.spec := WDS;					Plt_Spec[10]^^.Expt_Info.Detector.ID := 0;				end;			End;		{now write the changes back to the file...}			errCode := SetFPos_err(refnum, fsFromstart, 0, '');			errCode := FSWrite_Err(refnum, bytecount, @Plt_spec[10]^^.Expt_Info,'');		  			  Displayed_Fst := Plt_spec[10]^^.Expt_Info.FirstSpec;              Displayed_Lst := Plt_spec[10]^^.Expt_Info.LastSpect;              bytecount := sizeof(Work_spectrum) - sizeof(Spectrum_Counts);              bytecount := bytecount + longint(Plt_spec[10]^^.Expt_Info.Number_of_Channels) * 4;              errCode := SetFPos_err(refnum, fsFromstart, 0, '');              errCode := FSRead_err(refnum, bytecount, (@Plt_spec[10]^^), '');              Spectrum_Counter := Displayed_Fst;              Spec_Displayed := Spectrum_Counter;              Spectrum_Full[10] := true;              CheckItem(FullMenu, A^.C_Full[10], Spectrum_Full[10]);              Refresh_ROIs;              MCA_Spectrum_Active := true;              SpecWork_has_been_Changed := true;              saved_displayed := true;	          ItsBeenAcquired := false;			  WDS_Convert_only_X_axis := TRUE;			  Plt_Spec[10]^^.SpectrumStuff.Spectrum_Info.WDS_in_eV := TRUE;				  If Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.Number_of_Elements <1			  then Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.This_is_a_standard := false;              			  IF Plt_spec[10]^^.Expt_Info.Number_of_Channels <> Spectrum_Size THEN              BEGIN                    Hilitecontrol(SiLi_512CntHdl, 0);                    Hilitecontrol(SiLi_1024CntHdl, 0);                    Hilitecontrol(SiLi_2048CntHdl, 0);                    Hilitecontrol(SiLi_4096CntHdl, 0);                    Hilitecontrol(SiLi_8192CntHdl, 0);                    FOR n := 0 TO 5 DO                      IF 256 * 2 ** n = Plt_spec[10]^^.Expt_Info.Number_of_Channels                      THEN Range_Keeper := n + 5;                    Spectrum_Size := Plt_spec[10]^^.Expt_Info.Number_of_Channels;                    New_Range := Spectrum_Size;                    ChannelMax := Spectrum_Size;                    ChannelMin := 1;                    IF New_Range = 512 THEN Hilitecontrol(SiLi_512CntHdl, 10)					ELSE IF New_Range = 1024 THEN Hilitecontrol(SiLi_1024CntHdl, 10)                    ELSE IF New_Range = 2048 THEN Hilitecontrol(SiLi_2048CntHdl, 10)					ELSE IF New_Range = 4096 THEN Hilitecontrol(SiLi_4096CntHdl, 10)				    ELSE IF New_Range = 8192 THEN Hilitecontrol(SiLi_8192CntHdl, 10);              END;              Update_Full;			  errCode := FSClose(refnum);			  errCode := FlushVol(NIL, Read_DTSA_Spec.vRefnum);          END;		END;			{if errOpen = noerr}	   UNTIL errOpen = noerr;      END;                                            { PROCEDURE ReadFromFile;}    PROCEDURE AppendDTSA;                             { Brings up Dialog Box and Opens a File }      VAR        bytecount                    : longint;        myprompt		             : str255;        mytype                       : OSType;        errCode,erropen              : OSErr;        index1                       : Integer;		ChsinSpec                    : Integer;        dEinSpec                     : real;		Outreply					 : StandardFileReply;		ref_typ						 : ARRAY [0..3] of OSType {SFTypeList};		sfPtr             			 : ConstSFTypeListPtr;		savename                     : fnamestr;		savevol         			 : integer;		save_dirID					 : longint;		        str1		   				 : str255; 		BEGIN  IF AnswerMessage(      '¥¥WARNING¥¥If the detector parameters, kV, etc. of the spectrum to save are different',	  'from the file you choose, procedures such as curve fitting and quantitation may not',	  'work correctly. If IT`S OK I will open the file to append and save work.',	  '¥¥Saving spectra taken under different conditions to the same file is dangerous.¥¥')	THEN	  BEGIN		myprompt := 'Append WORK to...';		(*REPEAT		UNTIL (GetFileName(WrtBinaryName, mytype, mytype, myprompt) = true) OR 		      (File_Cancel_Button = false);*)			  		  mytype := 'MCAf';		  ref_typ[0] :=  mytype;		  sfPtr := @ref_typ;		  StandardGetFile(NIL, 1, sfPtr, Outreply);		{¥¥New DTSA file spec¥¥}		  File_Cancel_Button := Outreply.sfGood;		  if NOT Outreply.sfGood Then exit(AppendDTSA);		  Write_DTSA_Spec := Outreply.sfFile;		IF (NOT File_Cancel_Button)		  THEN			BEGIN			  Hilitecontrol(SiLi_Control, 0);   {Lighten the button before exit}			  exit(AppendDTSA);			END		  ELSE			BEGIN			  save_work_open := true;			  Binary_VolNum_Write := In_VolRefNum;			   {¥¥¥¥...and what's supposed to define this now!?}			END;		IF ((save_work_open) AND 		   ((NOT demo_DTSA) OR 		   (Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.spare2)))		  THEN			BEGIN			  ChsinSpec := Plt_spec[10]^^.Expt_Info.Number_of_Channels;			  dEinSpec := Plt_spec[10]^^.Expt_Info.dE;			  erropen := FSpOpenDF(Write_DTSA_Spec, fsRdWrPerm, Hold_RefNum);			  			  if erropen = noerr then begin			  WrtBinaryName := Write_DTSA_Spec.name;			  InVol_volnum := Write_DTSA_Spec.vRefNum;			  InVol_DirID := Write_DTSA_Spec.parID;			  			  {The volume names in the folowing calls are all StringPtr}			  errcode := HGetVol(@savename, savevol, save_dirID);{keep track of default vol}			  errcode := HSetVol(@InVol_volname, InVol_volnum, InVol_DirID);{get name of current vol}			  errcode := HGetVol(@InVol_volname, InVol_volnum, InVol_DirID);{get name of current vol}			  errcode := HSetVol(@savename, savevol, save_dirID);{restore default vol}			  Restore_Expt_Header(Hold_RefNum);			  IF (dEinSpec <> Plt_spec[10]^^.Expt_Info.dE)				THEN				  IF (NOT AnswerMessage(				     'The ev per channel of the spectrum is different from the file.',					 'If the Work Experiment Header just has the wrong value I will continue,',					 'but if they ARE different, hit IT`S NOT OK and save to a different file.',					 'If IT`S OK I`ll continue.'))					THEN exit(AppendDTSA);			  IF (ChsinSpec > Plt_spec[10]^^.Expt_Info.Number_of_Channels)				THEN				  BEGIN					numToString(Plt_spec[10]^^.Expt_Info.Number_of_Channels, str1);					str1 := CONCAT('If IT`S OK, I will truncate the spectrum to ', str1, ' channels.');					IF (NOT AnswerMessage(					    'Warning, the number of channels in the spectrum you are saving is',						'greater then the number allowed for the file.', str1,						'If IT`S NOT OK I will exit and you can save to a different file.'))					  THEN exit(AppendDTSA);				  END;			  			  If Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.Number_of_Elements <1			  then Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.This_is_a_standard := false;			  			  errCode := SetFPos(Hold_RefNum, fsFromstart, 0);			  bytecount := sizeof(integer);			  errCode := FSRead(Hold_RefNum, bytecount, @index1);  {get last spec number}			  index1 := index1 + 1;                                {new last spec number}			  Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.Spectrum_number := index1;			  errCode := SetFPos(Hold_RefNum, fsFromstart, 0);			  errCode := FSWrite(Hold_RefNum, bytecount, @index1); {change last spec number}			  errCode := SetFPos(Hold_RefNum, fsfromLEOF, 0);			  bytecount := sizeof(Spectrum_Structure);			  errCode := FSWrite(Hold_RefNum, bytecount, @Plt_spec[10]^^.SpectrumStuff);			  bytecount := longint(Plt_spec[10]^^.Expt_Info.Number_of_Channels) * 4;			  errCode := FSWrite(Hold_RefNum, bytecount, @Plt_spec[10]^^.S);				IF errCode = NoErr				  THEN 				  begin					SpecWork_has_been_Changed := false;					ItsBeenAcquired := false;					saved_displayed := true;				  end;			  errCode := FSClose(Hold_RefNum);			  errCode := FlushVol(NIL, Write_DTSA_Spec.vRefnum);			  (*IF WrtBinaryName = RdBinaryName*)			  IF Write_DTSA_Spec.name = Read_DTSA_Spec.name				THEN				  BEGIN				     Plt_spec[10]^^.Expt_Info.LastSpect :=					 			Plt_spec[10]^^.Expt_Info.LastSpect + 1;					 Displayed_Lst := Plt_spec[10]^^.Expt_Info.LastSpect;					 Spectrum_Counter := Displayed_Lst;					 Spec_Displayed := Spectrum_Counter;				  END;			  end;		{if erropen = noerr}			END                                 { If (save_work_open) and not demo...}		  ELSE PutMessage('I`m sorry, but I can save only spectra supplied with the demo disk.', '', '', '');	  END;END;                                            { PROCEDURE AppendDTSA;}          PROCEDURE Init_Header_Information;      BEGIN        Header_Info_Window := NIL;      END;                                            {End of procedure}    PROCEDURE Close_Header_Information(whichWindow: WindowPtr; VAR theInput: TEHandle);      BEGIN        IF (Header_Info_Window <> NIL) AND (Header_Info_Window = whichWindow)          THEN            BEGIN              DisposeWindow(Header_Info_Window);              Header_Info_Window := NIL;            END;                                      {End for if (Header_Info_Window<>nil)}      END;                                            {End of procedure}    PROCEDURE Update_Header_Information(whichWindow: WindowPtr);       BEGIN        IF (Header_Info_Window <> NIL) AND (Header_Info_Window = whichWindow)          THEN            BEGIN            END;                                      {End for if (Header_Info_Window<>nil)}      END;                                            {End of procedure}    PROCEDURE Open_Header_Information(Spectrum: integer);      VAR        offset                       : integer;        Left                         : integer;        Top                          : integer;        n                            : integer;        m                            : integer;        mm                           : integer;        str,str1,str2,str3,str4,str5,str6,str7,str8   : str255; 		      BEGIN        IF (Header_Info_Window = NIL)          THEN            WITH Plt_spec[Spectrum]^^ DO              BEGIN				                Header_Info_Window := GetNewWindow(346, NIL, pointer( - 1));                SelectWindow(Header_Info_Window);                SetPort(Header_Info_Window);                Update_Header_Information(Header_Info_Window);                SetFont('Monaco', 9, []);                offset := 12;                Left := 5;                Top := 15;                n := 0;                moveto(Left, Top);				str := concat('DTSA Filename: ',Expt_Info.MCA_Filename);                DrawString(str);                n := n + 1;                moveto(Left, Top + n * offset);                DrawString(Expt_Info.Specimen_ID);                n := n + 1;                moveto(Left, Top + n * offset);                DrawString(Expt_Info.Specimen_Comment_Field);				if Expt_Info.refFile then begin				    if SpectrumStuff.Spectrum_info.theoretically_generated then str := 'Generated '					else str := 'Data acquired ';					n := n + 1;					moveto(Left, Top + n * offset);										(*SecondsToDate(SpectrumStuff.Acq_Info.Begin_Time, theDateTime);					str3 := Num_To_DateTime(theDateTime);*)										IUDatePString(SpectrumStuff.Acq_Info.Begin_Time,abbrevDate,str1,NIL);					IUTimePString(SpectrumStuff.Acq_Info.Begin_Time,False,str2,NIL);					str3 := concat(str1,' ',str2);										str := CONCAT(str, str3);					DrawString(str);				end;                n := n + 1;                moveto(Left, Top + n * offset);				str1 := Strip_Trailing_Blanks(SpectrumStuff.Spectrum_Info.Spectrum_Comment_Field);				numToString(SpectrumStuff.Spectrum_Info.Spectrum_number, str2);				str2 := Strip_Trailing_Blanks(str2);                numToString(Expt_Info.FirstSpec, str3);                str3 := Strip_Trailing_Blanks(str3);                numToString(Expt_Info.LastSpect, str4);                str4 := Strip_Trailing_Blanks(str4);				Str5 := 'Unknown';                IF Expt_Info.Detector.Spec = EDS                  THEN Str5 := 'EDS';                IF Expt_Info.Detector.ID = 1                  THEN Str5 := CONCAT('Si', ' ', Str5);                IF Expt_Info.Detector.ID = 2                  THEN Str5 := CONCAT('Ge', ' ', Str5);                IF Expt_Info.Detector.Spec = WDS                  THEN Str5 := 'WDS';                IF Expt_Info.Detector.Spec = EELS                  THEN Str5 := 'EELS';                IF (WDS_Active)                  THEN Str6 := '   Program configured for WDS.';                IF (Si_Active)                  THEN Str6 := '   Program configured for Si EDS.';                IF (Ge_Active)                  THEN Str6 := '   Program configured for Ge EDS.';                DrawString(str1);                n := n + 1;                moveto(Left, Top + n * offset);                str := CONCAT('Spectrum Number = ', str2, ' from file of ', str3, ' to ', str4,                              '.   Spectrometer: ', Str5, Str6);                DrawString(str);                n := n + 1;                moveto(Left, Top + n * offset);                str := CONCAT('Analyst: ', Expt_Info.Analyst, ',  ');                DrawString(str);                n := n + 1;                moveto(Left, Top + n * offset);				str1 := '';                if not Expt_Info.refFile then begin					RealToString(SpectrumStuff.Spectrum_Info.Take_Off_Angle, 5, 3, str1);                	str1 := concat('Take off angle = ', Strip_Trailing_Blanks(str1), '¡,');					end;                RealToString(Expt_Info.Azimuth, 5, 3, str2);                str2 := Strip_Trailing_Blanks(str2);                RealToString(Expt_Info.Elevation, 5, 3, str3);                str3 := Strip_Trailing_Blanks(str3);                str := CONCAT(str1,'  Azimuth = ', str2, '¡, and   Elevation = ', str3, '¡');                DrawString(str);                n := n + 1;                moveto(Left, Top + n * offset);                RealToString(Expt_Info.kV, 5, 3, str1);                str1 := Strip_Trailing_Blanks(str1);				str3:='';				str4:='';                if not Expt_Info.refFile then begin				   RealToString(SpectrumStuff.Acq_Info.Begin_Faraday, 5, 3, str3);				   str3 := concat(', ¥Begin Current = ',Strip_Trailing_Blanks(str3));				   RealToString(SpectrumStuff.Acq_Info.End_Faraday, 5, 3, str4);				   str4 := concat( ' nA : End Current= ',Strip_Trailing_Blanks(str4),' nA');				   end;                str := CONCAT('Beam Voltage = ', str1, ' kV',  str3, str4);                DrawString(str);                n := n + 1;                moveto(Left, Top + n * offset);				if Plt_Spec[10]^^.Expt_Info.Detector.spec = EDS then                RealToString(Expt_Info.Si_Resolution, 5, 3, str1);				if Plt_Spec[10]^^.Expt_Info.Detector.spec = WDS then                RealToString(Expt_Info.WDS_Resolution, 5, 3, str1); 				                str1 := Strip_Trailing_Blanks(str1);                RealToString(Expt_Info.Detector_Area, 5, 3, str2);                str2 := Strip_Trailing_Blanks(str2);                RealToString(Expt_Info.Detector_Thickness, 5, 3, str3);                str3 := Strip_Trailing_Blanks(str3);                str := CONCAT('¥Resolution at Mn K alpha = ', str1, ' eV,  Detector Area = ', str2,                              ' mm sq.  and Detector Thickness = ', str3, ' mm.');                DrawString(str);				if not Expt_Info.refFile then begin					n := n + 1;					moveto(Left, Top + n * offset);					RealToString(SpectrumStuff.Spectrum_Info.Spec_Detector_Distance, 5, 3, str1);					str1 := Strip_Trailing_Blanks(str1);					str := CONCAT('Specimen to detector distance = ', str1, ' mm.');					DrawString(str);			    end;                n := n + 1;                moveto(Left, Top + n * offset);                RealToString(Expt_Info.Be_Thickness, 5, 5, str1);                str1 := Strip_Trailing_Blanks(str1);                RealToString(Expt_Info.Si_Thickness, 5, 5, str2);                str2 := Strip_Trailing_Blanks(str2);                RealToString(Expt_Info.Au_Thickness, 5, 5, str3);                str3 := Strip_Trailing_Blanks(str3);                RealToString(Expt_Info.Ice_Thickness, 5, 5, str4);                str4 := Strip_Trailing_Blanks(str4);                RealToString(Expt_Info.C_Thickness, 5, 5, Str5);                Str5 := Strip_Trailing_Blanks(Str5);                RealToString(Expt_Info.Al_Thickness, 5, 5, Str6);                Str6 := Strip_Trailing_Blanks(Str6);                RealToString(Expt_Info.BN_Thickness, 5, 5, str7);                str7 := Strip_Trailing_Blanks(str7);                RealToString(Expt_Info.SiN_Thickness, 5, 5, str8);                str8 := Strip_Trailing_Blanks(str8);                str := CONCAT('Detector Components : Be = ', str1, ' Dead zone = ', str2, ' µm, Au coating = ', str3,                              ' µm, Ice = ', str4, ' µm');                DrawString(str);                n := n + 1;                moveto(Left, Top + n * offset);                str := CONCAT('                     ', ' C = ', Str5, ' µm, Al = ', Str6, ' µm, BN = ', str7,                              ' µm, SiN = ', str8, ' µm');                DrawString(str);                RealToString(Expt_Info.Quantum, 5, 5, Str5);                Str5 := Strip_Trailing_Blanks(Str5);                RealToString(Expt_Info.Diamond, 5, 5, Str6);                Str6 := Strip_Trailing_Blanks(Str6);                RealToString(Expt_Info.Mylar, 5, 5, str7);                str7 := Strip_Trailing_Blanks(str7);                n := n + 1;                moveto(Left, Top + n * offset);                str := CONCAT('                     ', ' Quantum = ', Str5, ' µm, Diamond = ', Str6, ' µm, Mylar = ',                              str7, ' µm');                DrawString(str);                RealToString(Expt_Info.Moxtek, 5, 5, Str5);                Str5 := Strip_Trailing_Blanks(Str5);                RealToString(Expt_Info.Paralene, 5, 5, str6);                str6 := Strip_Trailing_Blanks(str6);                n := n + 1;                moveto(Left, Top + n * offset);                str := CONCAT('                     ', ' Moxtek = ', Str5, ' µm, Paralene = ', Str6, ' µm');                DrawString(str);                n := n + 1;                moveto(Left, Top + n * offset);                numToString(Expt_Info.Number_of_Channels, str1);                str1 := Strip_Trailing_Blanks(str1);                RealToString(Expt_Info.dE, 5, 3, str2);                str2 := Strip_Trailing_Blanks(str2);                RealToString(Expt_Info.Energy_Intercept, 5, 2, str3);                str3 := Strip_Trailing_Blanks(str3);                RealToString(Expt_Info.Energy_Slope, 5, 2, str4);                 str := CONCAT('¥Number of Channels = ', str1, ', ¥eV/Channel = ', str2, ', Energy Intercept = ', str3,                              ', and Slope = ', str4);                DrawString(str);				if not Expt_Info.refFile then begin				   n := n + 1;				   moveto(Left, Top + n * offset);				   RealToString(SpectrumStuff.Acq_Info.Live_Time, 5, 3, str1);				   str1 := Strip_Trailing_Blanks(str1);				   RealToString(SpectrumStuff.Acq_Info.Real_Time, 5, 3, str2);				   str2 := Strip_Trailing_Blanks(str2);				   str := CONCAT('¥Live Time = ', str1, ' Secs,  Real Time = ', str2, ' Secs');				   DrawString(str);					n := n + 1;					moveto(Left, Top + n * offset);										(*SecondsToDate(SpectrumStuff.Acq_Info.Begin_Time, theDateTime);					str3 := Num_To_DateTime(theDateTime);*)										IUDatePString(SpectrumStuff.Acq_Info.Begin_Time,abbrevDate,str1,NIL);					IUTimePString(SpectrumStuff.Acq_Info.Begin_Time,False,str2,NIL);					str3 := concat(str1,' ',str2);					str := CONCAT('Acquisition Started : ', str3);					DrawString(str);						n := n + 1;					moveto(Left, Top + n * offset);					RealToString(SpectrumStuff.Spectrum_Info.Minimum_Counts, 5, 3, str1);					str1 := Strip_Trailing_Blanks(str1);					RealToString(SpectrumStuff.Spectrum_Info.Maximum_Counts, 5, 3, str2);					str2 := Strip_Trailing_Blanks(str2);					str := CONCAT('Min Counts = ', str1, ', Max Counts = ', str2);					DrawString(str);						n := n + 1;					moveto(Left, Top + n * offset);					IF SpectrumStuff.Spectrum_Info.Theoretically_Generated					  THEN str1 := 'True'					  ELSE str1 := 'False';					IF SpectrumStuff.Spectrum_Info.this_is_a_standard					  THEN str2 := 'True'					  ELSE str2 := 'False';					IF SpectrumStuff.Spectrum_Info.BkgSubtracted					  THEN str3 := 'True'					  ELSE str3 := 'False';					str := CONCAT('Theoretically Generated = ', str1, ',  Spectrum is a Standard = ', str2,								  ',  BackGround Subtracted = ', str3);					DrawString(str);						n := n + 1;					moveto(Left, Top + n * offset);					str1 := Strip_Trailing_Blanks(SpectrumStuff.Spectrum_Info.Spectrum_Class);					str := CONCAT('"Class": ', str1);					DrawString(str);						n := n + 1;					moveto(Left, Top + n * offset);					RealToString(SpectrumStuff.Acq_Info.X_Position, 5, 3, str1);					str1 := Strip_Trailing_Blanks(str1);					RealToString(SpectrumStuff.Acq_Info.Y_Position, 5, 3, str2);					str2 := Strip_Trailing_Blanks(str2);					RealToString(SpectrumStuff.Spectrum_Info.X_Tilt, 5, 2, str3);					str3 := Strip_Trailing_Blanks(str3);					RealToString(SpectrumStuff.Spectrum_Info.Y_Tilt, 5, 2, str4);					str4 := Strip_Trailing_Blanks(str4);					str := CONCAT('X position = ', str1, ', Y position = ', str2, ', X tilt = ', str3, '¡', ', Y tilt = ',								  str4, '¡');					DrawString(str);	 					n := n + 1;					moveto(Left, Top + n * offset);					RealToString(SpectrumStuff.Spectrum_Info.Specimen_Thickness*1E7, 5, 1, str1);					str1 := Strip_Trailing_Blanks(str1);					RealToString(SpectrumStuff.Spectrum_Info.Specimen_Density, 5, 3, str2);					str2 := Strip_Trailing_Blanks(str2);					RealToString(SpectrumStuff.Spectrum_Info.Average_Z, 5, 4, str3);					str3 := Strip_Trailing_Blanks(str3);						str := CONCAT('Specimen Thickness = ', str1, ' nm', ',   Specimen Density = ', str2, ' gm/cc',								  ',   Average Z = ', str3);					DrawString(str);					n := n + 1;				   moveto(Left, Top + n * offset);				   str := ' Atomic Number       Wt Fr. &  Valence          Atomic Number        Wt Fr. &  Valence';				   DrawString(str);   				   m := n + 1;				   FOR mm := 1 TO 10 DO					 BEGIN					   IF SpectrumStuff.Spectrum_Info.Element_Info[mm].Atomic_Number = 0						 THEN exit(Open_Header_Information);					   IF SpectrumStuff.Spectrum_Info.Element_Info[mm].Atomic_Number < 10						 THEN str7 := '                ' ELSE str7 := '               ';					   n := n + 1;					   moveto(Left, Top + n * offset);					   numToString(SpectrumStuff.Spectrum_Info.Element_Info[mm].Atomic_Number, str1);					   RealToString(SpectrumStuff.Spectrum_Info.Element_Info[mm].Weight_Fraction, 5, 5, str2);					   RealToString(SpectrumStuff.Spectrum_Info.Element_Info[mm].Valence, 5, 5, str3);					   str2 := CONCAT(str2, '   ', str3);					   str := CONCAT('    ', str1, str7, str2);					   DrawString(str);					 END;				   FOR mm := 11 TO 15 DO					 BEGIN					   IF SpectrumStuff.Spectrum_Info.Element_Info[mm].Atomic_Number = 0						 THEN exit(Open_Header_Information);					   moveto(Left + 310, Top + m * offset);					   m := m + 1;					   numToString(SpectrumStuff.Spectrum_Info.Element_Info[mm].Atomic_Number, str1);					   RealToString(SpectrumStuff.Spectrum_Info.Element_Info[mm].Weight_Fraction, 5, 5, str2);					   RealToString(SpectrumStuff.Spectrum_Info.Element_Info[mm].Valence, 5, 5, str3);					   str2 := CONCAT(str2, '   ', str3);					   str := CONCAT(str1, str7, str2);					   DrawString(str);					 END;				end;	{if not Expt_Info.refFile...}              END                                     { if (Header_Info_Window<>nil)...with Plt_Spec[10]^^.Expt_Info...}          ELSE SelectWindow(Header_Info_Window);      END; { Procedure Open_Header_Information}  {$S Tools3}    PROCEDURE Do_Header_Information(myEvent: EventRecord; VAR theInput: TEHandle);      VAR        code                         : integer;        whichWindow                  : WindowPtr;        MyPt                         : Point;        theControl                   : ControlHandle;      BEGIN        IF (Header_Info_Window <> NIL)          THEN            BEGIN              code := FindWindow(myEvent.where, whichWindow); {Get where in window and which window}              IF (myEvent.what = MouseDown) AND (Header_Info_Window = whichWindow)                THEN                  BEGIN                    MyPt := myEvent.where;                    WITH Header_Info_Window^.portBits.bounds DO {Make it relative}                      BEGIN                        MyPt.h := MyPt.h + Left;                        MyPt.v := MyPt.v + Top;                      END;                  END;              IF (Header_Info_Window = whichWindow) AND (code = inContent)                THEN                  BEGIN                    code := FindControl(MyPt, whichWindow, theControl);                    IF (code <> 0)                      THEN code := TrackControl(theControl, MyPt, NIL);                  END;                                {End for if (Header_Info_Window=whichWindow)}            END;                                      {End for if (Header_Info_Window<>nil)}      END;                                            {End of procedure}    {=================================}END.