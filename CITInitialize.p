unit CITInitialize;interface	uses  QuickDraw, Types, OSUtils, ToolUtils, Timer, Errors, Menus, Files, Lists, Memory,   Packages, Printing, StandardFile, fenv, fp {SANE}, SegLoad, Retrace,  PasLibIntf, Spectrum_Structures, Declarations, INITIALIZE, Global_Functions ; 	const		ERFP = 0.3275911;		VISIBLE = true;		INVISIBLE = false;		GOAWAY = true;	var		refnum: integer;		errCode: OSErr;		thumbvalue: integer;			theMouseLocation: Point;		Finished: Boolean;		ErrorNum: OSErr;           {used by functions returning errors}		Reply: SFReply;		SPtr: StringPtr;	    delayend: Longint;         {needed for delay procedure}		delayticks: integer;		counter: integer; 	(*type		MAC_K = record				Data: array[4..40, 1..95] of real {double_t};			end;		MAC_KPtr = ^MAC_K;		MAC_KHndl = ^MAC_KPtr;	var		MAC_K_Handle: MAC_KHndl;	type		MAC_L = record				Data: array[22..92, 1..95] of real {double_t};			end;		MAC_LPtr = ^MAC_L;		MAC_LHndl = ^MAC_LPtr;	var		MAC_L_Handle: MAC_LHndl;	type		MAC_M = record				Data: array[75..95, 1..95] of real {double_t};			end;		MAC_MPtr = ^MAC_M;		MAC_MHndl = ^MAC_MPtr;	var		MAC_M_Handle: MAC_MHndl;*)	 	type		AHO = record		F0: array[1..20] of real {double_t}; { }		C: array[1..20] of real {double_t}; { Concentration }		E: array[1..20] of real {double_t}; { Abs corr of sample }		W: array[1..20] of real {double_t}; { Abs corr of pure element }		IT: array[1..20] of INTEGER; { code num for element not analyzed }		U: array[1..20] of real {double_t}; { Overvoltage }		U0: array[1..20] of real {double_t}; { Overvoltage or ten ie limited overvoltage }		Y: array[1..20] of real {double_t}; { } 	    ZZZ: array[1..20] of real {double_t}; { type double_t of atomic number }		STP: array[1..20] of real {double_t}; { Stopping power of sample }		BKS: array[1..20] of real {double_t}; { Backscatter factor of sample }		PHI: array[1..20] of real {double_t}; { integral of phi-rho-z, dz }		JM: array[1..20] of real {double_t};		JU: array[1..20] of real {double_t}; { term in love scott at num corr }		GU: array[1..20] of real {double_t}; { term in love scott at num corr }		HB: array[1..20] of real {double_t}; { backscatter factor for element i } 		ERF: array[1..5] of real {double_t}; { constant in polynom sol to err funct }		RI: array[1..20] of real {double_t}; { jump factor for element I }		Fluor: array[1..20] of real {double_t}; { Fraction of fluorescence to primary radiation}						ILO: array[1..3] of INTEGER; { ilo & ihi are lo & hi z's in mo/rho tables }		IHI: array[1..3] of INTEGER;		INM: array[1..3] of INTEGER; { is # of els in table }		IVL: array[1..20] of Integer; { # of O atoms for cation }		Standard_Comp_Code: array[1..20] of Integer;		Name_of_Standard: array[1..20] of Str255;		IMR: array[1..8] of INTEGER;		Line_Name: array[1..3] of string[3];		Edge_Name: array[1..9] of string[4];		IPD: array[1..4] of INTEGER;		EM                            : ARRAY [1..20] OF real {double_t}; 		ZIPI                          : ARRAY [1..20] OF real {double_t};		XP                            : ARRAY [1..20, 1..20] OF real {double_t};		PZ                            : ARRAY [1..20, 1..20] OF real {double_t};		PZ1                           : array[1..20] of real {double_t}; { constant in love scott abs corr }		DP                            : ARRAY [1..3] OF real {double_t}; 		PP                            : ARRAY [1..3] OF real {double_t};			end;		AHOPtr = ^AHO;		AHOHndl = ^AHOPtr;	var		G: AHOHndl;	type		AHO2 = record		OM: array[1..3, 1..20] of real {double_t}; { Fluor yield for KLM lines }		F: array[1..4, 1..20] of real {double_t}; { Std & Sample Bkgs & Pk Intensities }		G: array[1..3, 1..20] of real {double_t}; { Line Energies }		O: array[1..9, 1..20] of real {double_t}; { E crits for all edges }		P: array[1..20, 1..20] of real {double_t}; {absorber}										{emitter mass absorption coeffs}		IQ: array[1..20, 1..20] of INTEGER; { code factor for fluor }		R: array[1..20, 1..20] of real {double_t}; { Backscatter factor }		S: array[1..20, 1..20] of real {double_t}; { Stopping power }			end;		AHO2Ptr = ^AHO2;		AHO2Hndl = ^AHO2Ptr;	var		G2: AHO2Hndl;	type		AHO3 = record		FP: array[1..2, 1..20, 1..20] of real {double_t}; { in fluor corr }		OMJ: array[1..20, 1..20] of real {double_t}; { fluor yield for i by j }		X: array[1..20, 1..20] of real {double_t}; { in fluor corr }		PIJ: array[1..20, 1..20] of real {double_t}; { in fluor corr }		El_Std_Name: array[1..20] of Str255;		A: array[1..20] of real {double_t}; { At num corr for sample }			end;		AHO3Ptr = ^AHO3;		AHO3Hndl = ^AHO3Ptr;	var		G3: AHO3Hndl;	type		AHO4 = record		B: array[1..20] of real {double_t}; { Atomic weights}		KSTD: array[1..20] of real {double_t}; { KVal of Std relative to pure element }		KSMP: array[1..20] of real {double_t}; { KVal of sample relative to std }		STDZAF: array[1..20] of real {double_t}; { Z베벥 for std }		HH: array[1..20] of real {double_t}; { Backscatter coefficients }		EC: array[1..20] of real {double_t}; { E Crits for anal line}		K: array[1..20] of real {double_t}; { KVal of samp relative to pure element }		IL: array[1..20] of INTEGER; { Line code number for element K=1, 2=L etc} 		GR1: array[1..20] of real {double_t}; { Gravimetric factor }		CNEW: array[1..20] of real {double_t}; { Estimate of concentration in iteration step }			end;		AHO4Ptr = ^AHO4;		AHO4Hndl = ^AHO4Ptr;	var		G4: AHO4Hndl;	type		CoS_R = record				v: array[1..20, 1..20] of real {double_t};			end;		CoSPtr = ^CoS_R;		CoSHndl = ^CoSPtr;	var		CoS_H: CoSHndl;	var {본본본본본본본본본본본본본본본}			E_Range        : Array [1..20]	of real {double_t};		Dia            : Array [1..12]	of real {double_t};	    PtcRho, PtcJ9, PtcX1,J9, X1, pRHO  : real {double_t};		IMD            : Array[1..6] of Integer;		IPtcD, IPtcM, IMOD, IDIAM, IPTC  : Integer;		Dia1           : Array[1..12] of real {double_t};	    IDia1           : Array[1..12] of Integer;		IMD1            : Array[1..6] of Integer;		IMN             : Integer;		    Manual_Mode   : Boolean;		TimesThrough: integer;		Current_File: str255;		All_Done_in_File: Boolean;		All_Done_Folks: Boolean;		Run_Data_Now: Boolean;		Setup_File_Input: Boolean;		Ox_Norm: real {double_t};		ID_Name: Str255;		I_NEW: Integer;		ICOR: Integer;		IMAC_Input: Boolean;		Particle_Active: Boolean;		PhiRhoZ_Active: Boolean;		{IREAD: INTEGER;}		Header: string[80];		SUMOX1, SCAT, CAT, SUMOX2: real {double_t};		ICCAT: INTEGER;		RCD, KNEW, ALPHA: real {double_t};		ICHOICE: INTEGER; 		ERFT: real {double_t};		ERF_C: real {double_t};		ERFX: real {double_t};		Z_SMP: real {double_t};		H_SMP: real {double_t};		Phi_zero: real {double_t};		U_zero: real {double_t};		MIP_SMP: real {double_t};		M7: real {double_t};		NCAT: real {double_t};		N7: real {double_t};		{IDummy: INTEGER;}		M9: real {double_t};		INIT: INTEGER;		st: string[1]; 		NoOp: real {double_t};		I5: INTEGER;		XCoord, YCoord: real {double_t};		IN9, IN8: INTEGER;		N8: real {double_t};				TxtFile: Text;	{ 	File_Name: str255;  }	 			TxtFile1: Text;		File_Name1: fnamestr; 	 			Out_TxtFile: Text;	{	Out_File_Name: str255; }				Out_TxtFile1: Text;	{	Out_File_Name1: str255; }				Title: string[80];		ELEMSTD: Str255;		IM2, ISTAGE, ICPH: INTEGER;		ICPH1, ICPH2: INTEGER;		M3, M4: real {double_t};		Num_Oxs: real {double_t};		IYN: INTEGER; { 1= yes, 0= no }		IPRN: INTEGER; { choice of printout mode }		IZAF: INTEGER; { are ZAF factors printed 1=yes 0=no}		INORM: INTEGER; { is data to be normalized to 100% }		ILPRN: INTEGER; { is data to be immediatly printed on printer }		IFirstRun: INTEGER; { for comm prog is this the 1st anal. ie for headers }		IRepro: INTEGER; { is prog standalone mode }		IBSC: INTEGER; { code # for bs factor used }		IMIP: INTEGER; { code # for mean ionization factor used }		IPHI: INTEGER; { code # for phi zero used }		IABS: INTEGER; { code # for absorption correction used }		IZED: INTEGER; { code # for atomic number correction used }		IERE: INTEGER; { code # for electron retardation used }		SPI: real {double_t};		IOLDF: INTEGER; { code # for if mu/rho needs to be changed }		{I, I1, I2,} I8, I9: INTEGER; { Counters }		IA: INTEGER; { code for dont print mu/rho }		IB: INTEGER; { code for print out ZAF corrs }		IMAC: INTEGER; { code for mu/rho from manual input rather than file }		ICAT: INTEGER;		ILIN: INTEGER;		IKEL: INTEGER;		ICEL: INTEGER;		ICOX: INTEGER;		E0: real {double_t};    { Accelerating Potential }		T0: real {double_t};    { Takeoff angle in degrees }		I_N: INTEGER; { Number of elements in sample }		T: real {double_t};    { Takeoff angle in radians }		T1: real {double_t};    { Cosecant of Takeoff angle }		N: real {double_t};		N1: real {double_t};		IN1: INTEGER;		ISTP: INTEGER;		IBKS: INTEGER;		IFLU: INTEGER;		IICS: Integer;		K_save: array[1..20] of real;				P_Model: array[1..6] of STRING[35];	procedure Initialize_World;	procedure Initialize_Correction_List;implementation{$S Initialize1_a}	procedure Initialize_Correction_List;	begin		IABS := 9; 		ISTP := 4;		IBKS := 4;		IMIP := 1;		IBSC := 2;		IPHI := 2;		IICS := 0;		IERE := 0;		IFLU := 1;		IMAC := 1;		ICOR := 1;		IMAC_Input := False;	end;	procedure Initialize_World;		var			mm, nn, i: integer;	begin        Test_a_Handle(Handle(G),'G in CITSZAF');		G := AHOHndl(NewHandle(SizeOf(AHO)));		if FreeMem < SizeOf(AHO) then			begin				PutMessage('Not enough memory available to run program at 2', '', '', '');				Halt;			end;		MoveHHi(Handle(G));		HLock(Handle(G));        Test_a_Handle(Handle(G2),'G2 in CITSZAF');		G2 := AHO2Hndl(NewHandle(SizeOf(AHO2)));		if FreeMem < SizeOf(AHO2) then			begin				PutMessage('Not enough memory available to run program at 2', '', '', '');				Halt;			end;		MoveHHi(Handle(G2));		HLock(Handle(G2));        Test_a_Handle(Handle(G3),'G3 in CITSZAF');		G3 := AHO3Hndl(NewHandle(SizeOf(AHO3)));		if FreeMem < SizeOf(AHO3) then			begin				PutMessage('Not enough memory available to run program at 2', '', '', '');				Halt;			end;		MoveHHi(Handle(G3));		HLock(Handle(G3));        Test_a_Handle(Handle(G4),'G4 in CITSZAF');		G4 := AHO4Hndl(NewHandle(SizeOf(AHO4)));		if FreeMem < SizeOf(AHO4) then			begin				PutMessage('Not enough memory available to run program at 2', '', '', '');				Halt;			end;		MoveHHi(Handle(G4));		HLock(Handle(G4));		Initialize_Correction_List;		SPI := SQRT(pi) / 2;        Test_a_Handle(Handle(CoS_H),'CoS_H in CITSZAF');		CoS_H := CoSHndl(NewHandle(SizeOf(CoS_R)));		MoveHHi(Handle(CoS_H));		HLock(Handle(CoS_H));		 		TimesThrough := 0;		Run_Data_Now := False;		All_Done_in_File := False;		All_Done_Folks := False;		Ox_Norm := 24.0;		Num_Oxs := Ox_Norm;		NCAT := 0;		Setup_File_Input := False;		 		ID_Name := 'Put ID Name or Number Here ';		Particle_Active := False;				Manual_Mode := FALSE;		E0 := {Num2Extended} (Plt_spec[10]^^.Expt_Info.kV);		T0 := {Num2Extended} (Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.Take_Off_Angle);        		PtcRho := 1.0;		PtcJ9 := 1.0;		PtcX1  := 0.00001;		IptcD  := 1;		IPtcM  := 1;		DIA[1] := 10000;		IMD[1] := 1;		IDIAM := 1;		IMOD := 1;		IPtc := 0;        Dia1[1] := 10000;		Dia1[2] := 0.5;		Dia1[3] := 1.0;		Dia1[4] := 2.0;		Dia1[5] := 3.0;		Dia1[6] := 4.0;		Dia1[7] := 5.0;		Dia1[8] := 7.5;		Dia1[9] := 10.0;		Dia1[10] := 12.5;		Dia1[11] := 15.0;		Dia1[12] := 20.0;				IDia1[1] := 1;		for i := 2 to 12 do IDia1[i] := 0;				IMD1[1] := 1;		for i := 2 to 6 do IMD1[i] := 0;				P_Model[1] := 'Thin Film';		P_Model[2] := 'Rectangular Prism Particle';		P_Model[3] := 'Tetragonal Prism Particle';		P_Model[4] := 'Triangular Prism Particle';		P_Model[5] := 'Square Pyramid Prism Particle';		P_Model[6] := 'Side Scatter Corrected Particle';				I_N := 0;		IN1 := 0;		I_New := 0;		for nn := 1 to 20 do			begin				A^.IZ[nn] := 0 ;				G4^^.IL[nn] := 0;				A^.GR[nn] :=  0.0 ;				G4^^.K[nn] := 0.0;				K_save[nn] := 0.0;				G^^.C[nn] := 0.0;				G^^.U[nn] := 1.0;				G4^^.KSTD[nn] := 1.0;				G4^^.STDZAF[nn] := 1.0;				G^^.IT[nn] := 0;				G2^^.F[1, nn] := 0.0;				G2^^.F[2, nn] := 0.0;				G2^^.F[3, nn] := 0.0;				G2^^.F[4, nn] := 0.0;			end;		IA := 0;		IB := 0;		IPRN := 0;		IZAF := 0;		INORM := 0;		IRepro := 0;		IN8 := 1;		for nn := 1 to 20 do			begin				for mm := 1 to 20 do					begin						CoS_H^^.v[nn, mm] := 0.0;					end;				CoS_H^^.v[nn, nn] := 1.0;				G^^.Standard_Comp_Code[nn] := 9;				G^^.Name_of_Standard[nn] := 'Pure Element'; {This gets tested for so dont change }			end;		st := ' ';		SPI := SQRT(pi) / 2;		IYN := 0;                     { 1= yes, 0= no }		IPRN := 0;                    { choice of printout mode }		IZAF := 1;                    { are ZAF factors printed 1=yes 0=no}		INORM := 0;                   { is data to be normalized to 100% }		ILPRN := 0;                   { is data to be immediatly printed on printer }		IFirstRun := 1;               { for comm prog is this the 1st anal. ie for headers }		IRepro := 0;                  { is prog standalone mode 0=no, 1=yes, 2=yes and read in new corr's }		ICAT := 0;                    { Initialize printout codes for compressed format }		ILIN := 0;		ICOX := 0;		ICEL := 0;		IKEL := 0;		G^^.ILO[1] := 4;                  { Lo & Hi Z for KL&M Mu/rho coeff's & # of els in table }		G^^.IHI[1] := 40;		G^^.INM[1] := 37;		G^^.ILO[2] := 22;		G^^.IHI[2] := 92;		G^^.INM[2] := 71;		G^^.ILO[3] := 72;		G^^.IHI[3] := 95;		G^^.INM[3] := 24;		G^^.Line_Name[1] := 'Ka';		G^^.Line_Name[2] := 'La';		G^^.Line_Name[3] := 'Ma';		G^^.Edge_Name[1] := 'K';		G^^.Edge_Name[2] := 'LI';		G^^.Edge_Name[3] := 'LII';		G^^.Edge_Name[4] := 'LIII';		G^^.Edge_Name[5] := 'MI';		G^^.Edge_Name[6] := 'MII';		G^^.Edge_Name[7] := 'MIII';		G^^.Edge_Name[8] := 'MIV';		G^^.Edge_Name[9] := 'MV';		if IRepro = 2 then                        { Philibert, Duncumb-Reed Factors as alternate default }			begin				IBSC := 1;              { code # for bs factor used }				IMIP := 1;              { code # for mean ionization factor used }				IPHI := 1;              { code # for phi zero used }				IABS := 1;              { code # for absorption correction used }				IZED := 1;              { code # for atomic number correction used }			end;		IOLDF := 1;		G^^.ERF[1] := 0.254829592;		G^^.ERF[2] := -0.284496736;		G^^.ERF[3] := 1.421413741;		G^^.ERF[4] := -1.453152027;		G^^.ERF[5] := 1.061405429;	end; { intialize the world }end.