UNIT ORTEC_5000_Plug;INTERFACEUSES	Types, QuickDraw, Memory, fp, StandardFile, GestaltEqu, Errors, Files,	ToolUtils, {PascalA4,} FilePlugIns;const		__procinfo : longint = $3F80;{$Main}PROCEDURE	ENTRYPOINT(message:Integer; VAR InPtr:IOPlugPtr; VAR theResult:OSerr);IMPLEMENTATION{$IFC NOT POWERPC}uses PascalA4;{$ENDC}PROCEDURE ORTEC_5000(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);FORWARD;PROCEDURE DoAbout(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);FORWARD;PROCEDURE DoOpen(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);FORWARD;PROCEDURE DoWrite(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);FORWARD;(*PROCEDURE VAX_TCnvtMacReal(SPtrAry,DPtrAry:Ptr; NumSamples,BitsPSample:LONGINT);EXTERNAL;PROCEDURE VAX_TCnvtMacInt(SPtrAry,DPtrAry:Ptr; NumSamples,BitsPSample:LONGINT);EXTERNAL;*)PROCEDURE 	ENTRYPOINT{(message:Integer; VAR InPtr:IOPlugPtr; VAR theResult:OSErr)};		{ Main dispatching routine.  Initializes and sets up the global variables,	}		{		and performs the operation specified by the message. 				}VAR	firstTime	: BOOLEAN;	OldA4		: Longint;BEGIN{$IFC NOT POWERPC}	oldA4 := SetCurrentA4();	RememberA4();{$ENDC}	theResult:=noErr;	firstTime:=(InPtr=NIL);					{ See if this is the first time called }	IF firstTime THEN BEGIN						{ If so, allocate and initialize a data area }		InPtr:= IOPlugPtr(NewPtrClear(sizeof(IOPlug)));		IF (InPtr=NIL) THEN BEGIN			debugstr('memFullErr');			theResult:=memFullErr;{$IFC NOT POWERPC}	oldA4 := SetA4(oldA4);{$ENDC}			EXIT(ENTRYPOINT);		END;				END;		CASE message OF					{ Perform the requested operation }		fileAbout		:DoAbout(InPtr, theResult);		ImpFile			:ORTEC_5000(InPtr, theResult);		ExpFile			:DoWrite(InPtr, theResult);		OpenInPlug		:DoOpen(InPtr, theResult);		OpenExPlug		:DoOpen(InPtr, theResult);		END; {CASE message}		{$IFC NOT POWERPC}	oldA4 := SetA4(oldA4);{$ENDC}END;PROCEDURE DoAbout(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);	Begin	End;	PROCEDURE DoOpen(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);	Begin		InPtr^.PlugInName:='ORTEC 5000 Binary';		{Debugstr('Inside of ORTEC_5000 - Do Open');}		theResult := noErr;	End;	PROCEDURE DoWrite(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);	Begin	End;PROCEDURE SWBYTE(VAR value	: longint);   VAR	temp1, temp2	: integer;		BEGIN		temp1 := LoWord({BSL}BitShift(value, 8));		temp2 := LoWord({BSR}BitShift(value, -8));		value := BitOR(temp1, temp2);		value := BitAND(value, $0000FFFF);	END;	PROCEDURE ORTEC_5000(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);  TYPE     { Total header seems to be 1024 bytes, from example spectra provided by Larry            Cook}    HNURecPtr                     = ^HNURec;    HNURec                        =      RECORD        LabelPart                     : PACKED ARRAY [0..255] OF byte;        FillerPart                    : ARRAY [1..494] OF integer;      END;    LabelPart                     = PACKED ARRAY [0..255] OF byte;    InfoPart                      = PACKED ARRAY [0..255] OF byte;        VAR		Indx, nn, counter, kk         : integer;		refnum                        : integer;		hnuInfolDum                   : InfoPart;		hnuLabelDum                   : LabelPart;		HNUReal                       : real;		HNUinteger                    : integer;		HNUPtr                        : HNURecPtr;	  	errCode                       : integer;		bytecount                     : longint;		LValue                        : longint;		TopWord                       : longint;		BottomWord                    : longint;    BEGIN		refnum := InPtr^.Rd_Refnum;		{Debugstr('Inside of ReadTracorFile');}		InPtr^.Specimen_Comment_Field := '';	      { but for now brute force read in what is obvious }      bytecount := 39;      errCode := FSRead(refnum, bytecount, @hnuLabelDum[1]);      hnuLabelDum[0] := 39; { Set the string length }      errCode := SetFPos(refnum, fsFromstart, 44);      bytecount := 26;      errCode := FSRead(refnum, bytecount, @hnuInfolDum[1]);      hnuInfolDum[0] := 26; { Set the string length }      InPtr^.Specimen_Comment_Field := CONCAT(str255(hnuLabelDum), ', ', str255(hnuInfolDum)); (*{ Play around and see what else we can get }           bytecount := 4;           errCode := SetFPos_err(refnum, fsFromstart, 40, '');           errCode := FSRead(refnum, bytecount, @HNUinteger);           Vax_TcnvtMacInt(@HNUinteger, @HNUinteger, 2, 16);           Numtostring(HNUinteger,str1); { еееееееее   number of channels is here еееееееееее}      for nn := 40 to 512 do      begin           bytecount := 4;           errCode := SetFPos_err(refnum, fsFromstart, nn, '');           errCode := FSRead(refnum, bytecount, @HNUReal);           Vax_TcnvtMacReal(@HNUReal, @HNUReal, 2, 32); {FP convert on REAL}           Realtostring(HNUReal,10,4,str1);           bytecount := 4;           errCode := SetFPos_err(refnum, fsFromstart, nn, '');           errCode := FSRead(refnum, bytecount, @HNUInteger);           Vax_TcnvtMacInt(@HNUinteger, @HNUinteger, 2, 16);           Numtostring(HNUinteger, str2);          Numtostring(nn, str3);           putmessage(str1,str2,str3,'');      end;*)      { еееее Now, pick up the spectrum }      bytecount := 4;      Indx := 0;      errCode := SetFPos(refnum, fsFromstart, 1024); { move past header }      REPEAT        Indx := Indx + 1;        errCode := FSRead(refnum, bytecount, @LValue);        TopWord := 0;        BottomWord := 0;        TopWord := HiWord(LValue);        BottomWord := LoWord(LValue);        TopWord := BitAND(TopWord, $0000FFFF);        BottomWord := BitAND(BottomWord, $0000FFFF);       (* Vax_TcnvtMacInt(@TopWord, @TopWord, 2, 16);        Vax_TcnvtMacInt(@BottomWord, @BottomWord, 2, 16);*)                SWBYTE(TopWord);        SWBYTE(BottomWord);        BottomWord := BitAND(BottomWord, $000000FF); { mask off the color byte }        { BottomWord  now has the Most Signifigant Digits }        BottomWord := {BSL}BitShift(BottomWord, 16); { shiftum left a word }        LValue := BitOR(BottomWord, TopWord); { combine um }        InPtr^.Spec_cts[Indx] := LValue; { assignum }      UNTIL errCode = eoferr;	  InPtr^.LastChannel := Indx;	  InPtr^.Number_of_Channels := Indx;	  (*DisposePtr(Ptr(HNUPtr));*)	  theResult := noErr;    END; { ORTEC HNU 5000 }END.