 {[j=30/55,:+,u+,r+,o=120,k+,n+,#+,v+,q+,b+]}{[f-]} {*********************************} UNIT MENUS_D;{*********************************}{**********************************} INTERFACE {**********************************} USES QuickDraw, QuickdrawText, Types, OSUtils, ToolUtils, Timer, Errors, Menus, Files, Lists, Memory, Devices, TextEdit,   Packages, Printing, StandardFile, Resources, PasLibIntf, fenv, fp, SegLoad, Retrace, Dialogs, Windows, TextUtils, Finder, Controls, Spectrum_Structures, Declarations, INITIALIZE, Global_Functions, Utilities,  SANDIA,  Physics, Physics_Windows, BG_Correct, MathWin, CurveFit, Simplexer, QC_eds, Linear_Least_Squares, Xray_Energies, Hall, SiLiWin, Calibrate, Choices, Tools, xray, CliffLor,  connect, Zaf, {Automation,} Qual_scan, FilePlugins {RLM}, AcquirePlugIns;{SDD} PROCEDURE Init_My_Menus;PROCEDURE Handle_My_Menu(VAR doneFlag: boolean; theMenu, theItem: Integer;                           VAR theInput: TEHandle);   Procedure ClearWork;procedure D_XIS; procedure D_Per_Tab_Buttons; {******************************} IMPLEMENTATION {**********************************}{$S MENUSD}VAR theElement	: integer;bytecount	: Longint; {[f+]} Procedure ClearWork;var nn : integer;Begin   if AnswerMessage('Are you sure you want to clear the WORK spectrum???',					'This operation erases the channel contents, but leaves',					'the header information intact.','') then	begin	 For nn := 1 to Maximum_Channels do Plt_Spec[10]^^.S[nn] := 0.0;	 Plt_Spec[10]^^.SpectrumStuff.Spectrum_Info.Maximum_Counts := zero;	 Plt_Spec[10]^^.SpectrumStuff.Spectrum_Info.Minimum_Counts := zero;	 Refresh_ROIs;	 Update_Full;	 SpecWork_has_been_Changed := True;	 end;end;	Procedure Auto_Run;	VAR	refnum,errCode,Index : integer;	save_resids			 : boolean;	begin			  If (Simplex_Active) then Begin				  CompareGen_To_Work(theBGRec); 				  IF (SiLi_Response_Calculated = False) { if a new spectrum in work...}				  THEN BEGIN	{putmessage('do GenFromWork','and Detector_efficiency','','');}					GenFromWork(theBGRec);	{gets theGenRec values from Work }					Detector_efficiency(theBGRec,SiLi_Response_Calculated);				  END;			  End;                  IF ((LLSQ_active) OR (Simplex_active)) THEN                    BEGIN					  errCode := FSpOpenDF(Read_DTSA_Spec, fsRdWrPerm, refnum);					  RdBinaryName := Read_DTSA_Spec.name;                      IF errCode <> noErr THEN                        BEGIN                          putmessage('еееееее A file error just ocurred еееееее',                                     'You probably do not have an MCA file of spectra active',                                     'and ready to be batch fit.', '');                          Update_Full;                          exit(Auto_Run);                        END                      ELSE                        BEGIN                          errCode := FSClose(refnum);                          errCode := FlushVol(NIL, Read_DTSA_Spec.vRefNum);                        END;                      IF Elements_Chosen = FALSE THEN                        BEGIN                          putmessage('You have not chosen any elements to fit.', 'Do that now.', '', '');                          exit(Auto_Run);                          {D_Simplex_Elements;}                        END;                      					  is_batch := true;	{...here for MakeBinaryResults}				   IF (NOT MCA_File_Boolean) THEN MakeBinaryResults; { see curvefit}				   IF (MCA_File_Boolean) then			       BEGIN                     { Sets MCA_File_Boolean true if successful }                      errCode := FSOpen(MCA_ResultsName, MCA_Results_VolNum, refnum);                      errCode := setfpos(refnum, fsFromstart, 0);                      bytecount := 1;                      errCode := FSWrite(refnum, bytecount, @Is_Batch);                      errCode := FSClose(refnum);                      errCode := FlushVol(NIL, MCA_Results_VolNum);                       				   FOR Index := 1 TO 10 DO				   BEGIN					 Spectrum_Full[Index] := False;					 CheckItem(FullMenu, A^.C_Full[Index], Spectrum_Full[Index]);				   END;				                         Spectrum_Full[10] := True;                      CheckItem(FullMenu, A^.C_Full[10], Spectrum_Full[10]);                    (*  Spectrum_Full[9] := True;                      CheckItem(FullMenu, A^.C_Full[9], Spectrum_Full[9]);                      Spectrum_Full[1] := True;                      CheckItem(FullMenu, A^.C_Full[1], Spectrum_Full[1]);	*)                      {Auto_Scale_Display := FALSE;}                       			      if answermessage('You may save a spectrum file of residuals.',				  				   'If IT`S OK, I will create a DTSA file for them.',				  				   'You must select a file after the first spectrum is finished.',								   'If IT`S NOT OK, no file will be saved.')				  then				  	save_resids := TRUE				  else				  	save_resids := FALSE;                                           Spectrum_Counter := 0;					  BigAutoFitExit := FALSE;    			FOR Index := Plt_Spec[10]^^.Expt_Info.FirstSpec TO						 Plt_Spec[10]^^.Expt_Info.LastSpect DO                      BEGIN 		{For Index := ...}                          Fit_Invisibly := True;                          bytecount := sizeof(Expt_InfoRec) + sizeof(Plot_infoRec) +						  			   LongInt(Spectrum_Counter) * ( sizeof(Spectrum_Structure) + 						  			   4 * LongInt(Plt_Spec[10]^^.Expt_Info.Number_of_Channels) );                          Spectrum_Counter := Spectrum_Counter + 1; {# of spectrum displayed}                          Spec_Displayed := Index;						  errCode := FSpOpenDF(Read_DTSA_Spec, fsRdWrPerm, refnum);						  RdBinaryName := Read_DTSA_Spec.name;                          IF errCode <> noErr THEN                            BEGIN                              putmessage('еееееее A file error just ocurred еееееее',                                         'Something happened to the DTSA file to batch fit.', '', '');                              Update_Full;                              exit(Auto_Run);                            END                          ELSE                            BEGIN                              Restore_Expt_Header(refnum);                              errCode := setfpos(refnum, fsFromstart, bytecount);                              bytecount := sizeof(Spectrum_Structure);                              errCode := FSRead(refnum, bytecount, @Plt_Spec[10]^^.SpectrumStuff);                              bytecount := LongInt(Plt_Spec[10]^^.Expt_Info.Number_of_Channels) * 4;                              errCode := FSRead(refnum, bytecount, @Plt_Spec[10]^^.S);                            END;                          errCode := FSClose(refnum);                          errCode := FlushVol(NIL, Read_DTSA_Spec.vRefNum);										IF (BigAutoFitExit) or (Interrupted) THEN							BEGIN                              Fit_Invisibly := FALSE;							  BigAutoFitExit := FALSE;							  Update_Full;                              exit(Auto_Run);							END;		                           (*  Spectrum_Full[1] := FALSE;                          CheckItem(FullMenu, A^.C_Full[1], Spectrum_Full[1]);                          Spectrum_Full[9] := FALSE;                          CheckItem(FullMenu, A^.C_Full[9], Spectrum_Full[9]);	*)                          Update_Full;                          						  					   is_batch := TRUE;{ set above...does something change this???}  						  					   IF (ZAF_Run) THEN						 IF (ZAF_Record^^.Num_Fit_Peaks > 0) THEN						   analysis_result^^.Fit_params.Number_of_Peaks := ZAF_Record^^.Num_Fit_Peaks;  					   is_batch := TRUE;	{why again?? Because Do_A_Fit used to set it false?}					   Do_A_Fit;            {sets Results_added to False, calls quant routine;					   						 increments num_of_fits; num_of_fits set to 0 when a new file											 is named in D_results_options. Only when it is 1, are column											 headers written in the spreadsheet}					   					   WriteBinaryResults;	{does not change results_added}					   num_of_fits := num_of_fits + 1;					   						{for WriteFitResults: set 0 in D_Results_Options,										     otherwise incremented only in Add_a_fit}                       IF (Hall_active) then WritetoHall;					   IF (Cliff_Lorimer_Active) then WritetoCL;	{write to binary}					   IF (Plain_boolean and Plain_Options) OR (Spread_Boolean) THEN                         WriteFitResults; {write only one}						SpecWork_has_been_Changed := True;					  IF save_resids then begin						IF (Index = Plt_spec[10]^^.Expt_Info.FirstSpec) THEN							WriteToFile(9)							{еее2/7/96 select the spectrum to writeеее}						ELSE IF (File_Cancel_Button = True) THEN							WorkSpectrum_To_Disk(9);					   end; 					 END; { For Index := Plt_spec[10]^^.Expt_Info.FirstSpec... }                      Fit_Invisibly := FALSE;                      {we are finished with this file so set all the file booleans false					   ...can always open old fit to append but the text files will not					   open to append}                      MCA_OptionsBoolean := FALSE;                      MCA_File_Boolean := FALSE;                      Plain_boolean := FALSE; {so can't accidently append}                    { Plain_Options stays T so can see the file without rewriting}                      Spread_Boolean := FALSE;					  results_added := true;	{ for See_a_fit in SiliWin}                      Update_Full;                      Mouse_Active_Window;					END;	{IF (MCA_File_Boolean) ...}                  END { if LLSQ_active ...Simplex_active...}                  ELSE                  BEGIN                      BeepBeep;                      putmessage('You cannot Auto Run unless either MLLSQ or SIMPLEX is setup.', '', '', '');                  END;                  ChangeCursor(ArrowC);				  		 end;		{Auto_Run}				  	Procedure Qual_Run;			{Qual_DTSA_True}	VAR		refnum,errCode,Index, Initial_File 			: integer;		fndrInfo                      				: FInfo;	begin		if not dummy_boolean then 		begin			ReadFromFile;			IF (File_Cancel_Button = false) THEN exit(Qual_Run);		end;					  CompareGen_To_Work(theBGRec); 					  IF (SiLi_Response_Calculated = False) { if a new spectrum in work...}					  THEN BEGIN						GenFromWork(theBGRec);	{gets theGenRec values from Work }						Detector_efficiency(theBGRec,SiLi_Response_Calculated);					  END;	{еееCreate and Open an Excel file for the resultsеее}						OutName := 'Qual_Results.Exel';						if ((CreateFile(OutName, 'Name an Exel File:') = True) OR							   (File_Cancel_Button = False)) then;						IF File_Cancel_Button = false THEN exit(Qual_Run);																	  SpreadName := OutName;					  Spread_volnum := Out_VolRefNum;					  errCode := getvol(Save_Volume_Name, save_vol);					  errCode := setvol(NIL, Spread_volnum);					  Rewrite(Spread, Spreadname);					  Rewrite(Spread);					  fndrInfo.fdcreator := 'XCEL'; { EXEL spreadsheet }					  fndrInfo.fdtype := 'TEXT';					  fndrInfo.fdFlags := $0;					  errCode := setfinfo(Spreadname, Spread_volnum, fndrInfo);					  IF errCode <> noErr THEN					  begin					    putmessage('setFinfo error just occured', 'in trying to set file info for "Exelname"', '', '');						Close(Spread);						exit(Qual_Run);					  end;					                        Spectrum_Full[9] := True;                      CheckItem(FullMenu, A^.C_Full[9], Spectrum_Full[9]);                      Auto_Scale_Display := FALSE;                      					  if Qual_DTSA_True = true then write_qual_Header;					                         Index := 0; 					 { BigAutoFitExit := FALSE;}					  Qual_Incomplete := FALSE;    				  Halt_Qual := false;					  Initial_File := Spec_Displayed;					Spectrum_Counter := Spec_Displayed -1;					REPEAT                                               Fit_Invisibly := True;                          bytecount := sizeof(Expt_InfoRec) + sizeof(Plot_infoRec) +						  			   LongInt(Spectrum_Counter) * ( sizeof(Spectrum_Structure) + 						  			   4 * LongInt(Plt_Spec[10]^^.Expt_Info.Number_of_Channels) );                          Spectrum_Counter := Spectrum_Counter + 1; {# of spectrum displayed}						  						  Spec_Displayed := Spectrum_Counter;						  errCode := FSpOpenDF(Read_DTSA_Spec, fsRdWrPerm, refnum);						  RdBinaryName := Read_DTSA_Spec.name;                          IF errCode <> noErr THEN                            BEGIN                              putmessage('еееееее A file error just ocurred еееееее',                                         'Something happened to the DTSA file to batch fit.', '', '');							  Close(Spread);                              Update_Full;                              exit(Qual_Run);                            END                          ELSE                            BEGIN                              Restore_Expt_Header(refnum);                              errCode := setfpos(refnum, fsFromstart, bytecount);                              bytecount := sizeof(Spectrum_Structure);                              errCode := FSRead(refnum, bytecount, @Plt_Spec[10]^^.SpectrumStuff);                              bytecount := LongInt(Plt_Spec[10]^^.Expt_Info.Number_of_Channels) * 4;                              errCode := FSRead(refnum, bytecount, @Plt_Spec[10]^^.S);							                              END;                          errCode := FSClose(refnum);                          (*errCode := FlushVol(NIL, Read_DTSA_Spec.vRefNum);*)										IF (BigAutoFitExit) or (Interrupted) THEN							BEGIN                              Fit_Invisibly := FALSE;							 { BigAutoFitExit := FALSE;}							  Close(Spread);							  Update_Full;                              exit(Qual_Run);							END;		                             Spectrum_Full[9] := FALSE;                          CheckItem(FullMenu, A^.C_Full[9], Spectrum_Full[9]);                          Update_Full;						 Main_Qual(Initial_File);						 						 Index := Index +1;						 if (Qual_Incomplete = true) then						  begin						   Index := Index - 1;						   (*WriteQualResults(Index);*)						   Halt_Qual := true;						  end;							   					  UNTIL ((Spectrum_Counter = Plt_Spec[10]^^.Expt_Info.LastSpect) OR (Halt_Qual = true)); 					  if Qual_DTSA_True = false then					  					  		WriteQualResults(Index);					  Qual_DTSA_True := false;					  Close(Spread);					  errCode := FlushVol(NIL, Spread_volnum);					 errCode := setvol(Save_Volume_Name, save_vol);					                        Fit_Invisibly := FALSE;                      {we are finished with this file so set all the file booleans false}                      MCA_OptionsBoolean := FALSE;                      MCA_File_Boolean := FALSE;                      Plain_boolean := FALSE; {tells write fit results to make a Plain, already done}                      { Plain_Options := false;} {says a plain file was named in D_results_options}                      Spread_Boolean := FALSE;                      Update_Full;                      Mouse_Active_Window;                  ChangeCursor(ArrowC);				  end;		{Qual_Run}    PROCEDURE Ref_Help;    VAR      tempRect                     : Rect;                  offset                       : integer;	  Left                         : integer;	  Top                          : integer;      n                            : integer;	  G_Help                       : DialogPtr;      itemHit                      : integer;      DType                         : Integer;      DItem                         : Handle;	  ExitDialog                    : Boolean;	  str : str255;    CONST      G_Accept                      = 1;	  BEGIN                                              G_Help := GetNewDialog(433, NIL, POINTER( - 1));ShowWindow(G_Help);SelectWindow(G_Help);SetPort(G_Help);OutlineButton(G_Help, 1, 16); { outline the OK button }SetFont('Monaco', 9, []);offset := 12;Left := 5;Top := 15;		   n := 0;	  moveto(Left,Top);DrawString('The quality of the LLSQ fitting depends on high count zero background references.');	  n := n+1; moveto(Left,Top + n*offset);str := 'A reference is a spectrum segment that encompasses a complete family of lines for one element only';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'and has no background contribution. A reference is usually obtained from a statistically good spectrum';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'which has been background subtracted. ';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'To make a reference, acquire a spectrum with very high counts and at least one family of';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'characteristic lines with no overlap from another element. ';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'Carefully Background Subtract (Math, Main Menu) the spectrum in the region of the family.';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'Rotate Results to Work. Select the segment of the spectrum to be saved as a reference using Peak Wipe';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'in the ROI Window: include a few zero count channels on either side of the family.';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'You may select all non-overlapped families that have approximately ZERO residual background.';DrawString(str); n := n+1; moveto(Left,Top + n*offset); str := 'Be sure both Headers for the spectrum are correct because they are saved in a new reference file.';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'Select NEW FILEin MLLSQ REFERENCES under FILE in the MAIN MENU. Name the File and check the elements';DrawString(str); n := n+1; moveto(Left,Top + n*offset); str := 'for which you have selected spectrum segments to be references. The program will save each segment';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'with the family name, ie CuK, CuL.';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'To examine the references in a file, select Display Ref under MLLSQ REFS.';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'Either supply a family name (CuK, U M) or select Scan File. Once a reference is displayed you can ';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'step through the file using the Spectrum Number arrows.';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'To add references to a file, prepare the segments to be saved and select ADD REF from MLLSQ REFERENCES.';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'Only spectrum segments with kV and resolution ▒ 5% of the file header values can be added to the file.';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'If a reference for a family is already in the file, it will be displayed in RESULTS and';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'you will be prompted to keep it or replace it with the new spectrum segment.';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'Only the Spectrum Header is saved for each reference added to a Reference File.';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'The ML LST SQ fitting procedure will search only five files for the references it needs so it is most';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'efficient to store all references for a particular type of analysis in one file. For example';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'make a file of all references required for analysis of spectra from biological specimens; make another';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'file for spectra from steels. ';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'You can treat references from one file like spectrum segments and save them to another file with the';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'same kV and resolution.';DrawString(str); n := n+1; moveto(Left,Top + n*offset);REPEAT  ModalDialog(NIL, itemHit);  GetDialogItem(G_Help, itemHit, DType, DItem, tempRect);  IF (itemHit = G_Accept) THEN	BEGIN	  ExitDialog := True;	END;UNTIL ExitDialog;		            DisposeDialog(G_Help);			BeginUpdate(BackPlane);			DrawAxesFull;			Update_Full;			EndUpdate(BackPlane);		    UpDate_SiLi_Window(SiLiWindow) ;END;                                              {End of Ref_Help procedure}  PROCEDURE Lookup_Xtal;    CONST      I_ACCEPT                      = 1;      I_Cancel                      = 2;      I_MYR                         = 3;      I_NaCl                        = 4;      I_KAP                         = 5;      I_RAP                         = 6;      I_TAP                         = 7;      I_PET                         = 8;      I_LiF                         = 9;      I_LOD                         = 10;      I_LDE1                        = 11;      I_V_C                         = 12;      I_MoB4C                       = 13;      I_SiO2_1011                   = 14;      I_SiO2_1010                   = 15;      I_Si                          = 16;      I_Graphite                    = 17;      I_Pb_Stearate                 = 18;      I_Mica                        = 19;      I_EDDT                        = 20;      I_User1                       = 21;      I_User2                       = 22;    VAR      ExitDialog                    : boolean;      GetSelection                  : DialogPtr;      tempRect                      : Rect;      DType                         : Integer;      Index	                        : Integer;      DItem                         : Handle;      CItem			                : controlhandle;      itemHit                       : Integer;      cSize                         : Point;      str  : str255;	      PROCEDURE Refresh_Dialog;      VAR        rTempRect                     : Rect;      BEGIN        SetPort(GetSelection);        rTempRect := tempRect;        {Draw a rectangle, Rectangle2  }        PenSize(3, 3);        SetRect(tempRect, 5, 270, 425, 420);        FrameRect(tempRect);        PenSize(1, 1);        tempRect := rTempRect;      END;    BEGIN      GetSelection := GetNewDialog(406, NIL, POINTER( - 1));	  CenterDialog(GetSelection, TRUE, cSize);			{еееnew RLMеее}      ShowWindow(GetSelection);      SelectWindow(GetSelection);      SetPort(GetSelection);      OutlineButton(GetSelection, 1, 16); { outline the accept button }      {ееееееееееSetup initial conditionsеееееееееееее}      GetDialogItem(GetSelection, I_LiF, DType, DItem, tempRect);      IF WDS_Two_d = WDS_MYR THEN GetDialogItem(GetSelection, I_MYR, DType, DItem, tempRect);      IF WDS_Two_d = WDS_NaCl THEN GetDialogItem(GetSelection, I_NaCl, DType, DItem, tempRect);      IF WDS_Two_d = WDS_KAP THEN GetDialogItem(GetSelection, I_KAP, DType, DItem, tempRect);      IF WDS_Two_d = WDS_RAP THEN GetDialogItem(GetSelection, I_RAP, DType, DItem, tempRect);      IF WDS_Two_d = WDS_TAP THEN GetDialogItem(GetSelection, I_TAP, DType, DItem, tempRect);      IF WDS_Two_d = WDS_PET THEN GetDialogItem(GetSelection, I_PET, DType, DItem, tempRect);      IF WDS_Two_d = WDS_LiF THEN GetDialogItem(GetSelection, I_LiF, DType, DItem, tempRect);      IF WDS_Two_d = WDS_LOD THEN GetDialogItem(GetSelection, I_LOD, DType, DItem, tempRect);      IF WDS_Two_d = WDS_LDE1 THEN GetDialogItem(GetSelection, I_LDE1, DType, DItem, tempRect);      IF WDS_Two_d = WDS_V_C THEN GetDialogItem(GetSelection, I_V_C, DType, DItem, tempRect);      IF WDS_Two_d = WDS_MoB4C THEN GetDialogItem(GetSelection, I_MoB4C, DType, DItem, tempRect);      IF WDS_Two_d = WDS_SiO2_1011 THEN GetDialogItem(GetSelection, I_SiO2_1011, DType, DItem, tempRect);      IF WDS_Two_d = WDS_SiO2_1010 THEN GetDialogItem(GetSelection, I_SiO2_1010, DType, DItem, tempRect);      IF WDS_Two_d = WDS_Si THEN GetDialogItem(GetSelection, I_Si, DType, DItem, tempRect);      IF WDS_Two_d = WDS_Graphite THEN GetDialogItem(GetSelection, I_Graphite, DType, DItem, tempRect);      IF WDS_Two_d = WDS_Pb_Stearate THEN GetDialogItem(GetSelection, I_Pb_Stearate, DType, DItem, tempRect);      IF WDS_Two_d = WDS_Mica THEN GetDialogItem(GetSelection, I_Mica, DType, DItem, tempRect);      IF WDS_Two_d = WDS_EDDT THEN GetDialogItem(GetSelection, I_EDDT, DType, DItem, tempRect);      IF WDS_Two_d = WDS_User1 THEN GetDialogItem(GetSelection, I_User1, DType, DItem, tempRect);      IF WDS_Two_d = WDS_User2 THEN GetDialogItem(GetSelection, I_User2, DType, DItem, tempRect);      SetControlValue(controlhandle(DItem), 1);      GetDialogItem(GetSelection, 25, DType, DItem, tempRect);      RealToString(WDS_Two_d, 5, 5, str);      SetDialogItemText(DItem, str);      Refresh_Dialog;      ExitDialog := FALSE;      REPEAT        ModalDialog(NewModalFilterProc(@DefaultFilter), itemHit);        GetDialogItem(GetSelection, itemHit, DType, DItem, tempRect);        CItem := controlhandle(DItem);        {Handle it real time}        IF (itemHit = I_ACCEPT) THEN          BEGIN            ExitDialog := True;            Refresh_Dialog;          END;        IF (itemHit = I_Cancel) THEN          BEGIN            DisposeDialog(GetSelection);            Mouse_Active_Window;            exit(Lookup_Xtal);          END;        IF (itemHit >= I_MYR) AND (itemHit <= I_User2) THEN          BEGIN            FOR Index := I_MYR TO I_User2 DO              BEGIN                GetDialogItem(GetSelection, Index, DType, DItem, tempRect);                SetControlValue(controlhandle(DItem), 0);              END;            SetControlValue(CItem, 1);            IF itemHit = I_MYR THEN WDS_Two_d := WDS_MYR;            IF itemHit = I_NaCl THEN WDS_Two_d := WDS_NaCl;            IF itemHit = I_KAP THEN WDS_Two_d := WDS_KAP;            IF itemHit = I_RAP THEN WDS_Two_d := WDS_RAP;            IF itemHit = I_TAP THEN WDS_Two_d := WDS_TAP;            IF itemHit = I_PET THEN WDS_Two_d := WDS_PET;            IF itemHit = I_LiF THEN WDS_Two_d := WDS_LiF;            IF itemHit = I_LOD THEN WDS_Two_d := WDS_LOD;            IF itemHit = I_LDE1 THEN WDS_Two_d := WDS_LDE1;            IF itemHit = I_V_C THEN WDS_Two_d := WDS_V_C;            IF itemHit = I_MoB4C THEN WDS_Two_d := WDS_MoB4C;            IF itemHit = I_SiO2_1011 THEN WDS_Two_d := WDS_SiO2_1011;            IF itemHit = I_SiO2_1010 THEN WDS_Two_d := WDS_SiO2_1010;            IF itemHit = I_Si THEN WDS_Two_d := WDS_Si;            IF itemHit = I_Graphite THEN WDS_Two_d := WDS_Graphite;            IF itemHit = I_Pb_Stearate THEN WDS_Two_d := WDS_Pb_Stearate;            IF itemHit = I_Mica THEN WDS_Two_d := WDS_Mica;            IF itemHit = I_EDDT THEN WDS_Two_d := WDS_EDDT;            IF itemHit = I_User1 THEN WDS_Two_d := WDS_User1;            IF itemHit = I_User2 THEN WDS_Two_d := WDS_User2;          END;        GetDialogItem(GetSelection, 25, DType, DItem, tempRect);        RealToString(WDS_Two_d, 5, 5, str);        SetDialogItemText(DItem, str);      UNTIL ExitDialog;      { For the JEOL  mm := 280 / ( WDS_Two_d ) * n * Lamda and E(eV) := 3471440/(WDS_Two_d * mm);  }      DisposeDialog(GetSelection);      Mouse_Active_Window;    END;  PROCEDURE D_XIS;        CONST      I_ACCEPT                      = 1;      I_spare2                      = 2;      I_spare1                      = 3;      I_keV                         = 4;      I_mm                          = 5;      I_angstroms                   = 6;      I_two_Theta                   = 7;      I_O                           = 8;      I_N                           = 9;      I_M                           = 10;      I_L                           = 11;      I_K                           = 12;      I_Satelites                   = 13;      I_Edges                       = 14;      I_Lines                       = 15;      Val_1                         = 54;             { top box for values on the left side 54-16}      Search_Top                    = 55;             { top box for values on the right side }      Search_Bot                    = 85;      I_Valence                     = 94;      I_Weight                      = 93;      I_Density                     = 92;      I_Element                     = 96;      I_Center                      = 88;             { enter the center value text box}      I_Look_up_Xtal                = 95;      I_Up_One                      = 97;      I_Down_One                    = 98;      I_LookUp                      = 99;      I_Up_10                       = 100;      I_Down_10                     = 101;    VAR      ExitDialog                    : boolean;      GetSelection                  : DialogPtr;      tempRect                      : Rect;      DType                         : Integer;      Index                         : Integer;      DItem                         : Handle;      CItem			                : controlhandle;      sTemp                         : Str255;      itemHit                       : Integer;      nn	                     	: Integer;      lo_index, hi_index		    : Integer;      Center_Value                  : real {double_t};      Search_Results                : ARRAY [1..31] OF Real;      Search_String                 : ARRAY [1..31] OF Str255;      En_Label                      : ARRAY [ - 16..127] OF STRING[6];      string2,str,str1,str2         : Str255;      values                        : ARRAY [1..38] OF Str255;	  LisShift						: Boolean;	  Cent_v						: Integer;	  where							: Point;	      PROCEDURE LoadString(Value, weight: Real; VAR Strng1, Strng2: Str255);      BEGIN { 3=kV, 4=mm, 5=A, 6=Sin_theta}        {mm := 280 / ( WDS_Two_d ) * n * Lamda}        IF Value <= 0 THEN Strng1 := ''        ELSE          BEGIN            IF Choice_of_Units = 3 THEN RealToString(Value, 5, 4, Strng1)            ELSE              IF Choice_of_Units = 5 THEN RealToString(12398 / Value, 5, 4, Strng1)              ELSE                IF Choice_of_Units = 4 THEN RealToString(280 / (WDS_Two_d) * 12398 / Value, 5, 4, Strng1)                ELSE IF Choice_of_Units = 6 THEN RealToString((12398 / Value) / (WDS_Two_d), 5, 4, Strng1);            IF (Choice_of_Units = 4) OR (Choice_of_Units = 6) THEN              IF ((12398 / Value) / (WDS_Two_d) < 0.25) OR ((12398 / Value) / (WDS_Two_d) > 0.95) THEN                Strng1 := 'Out of Range';          END;        IF (Value <= 0) OR (weight <= 0) THEN Strng2 := ''        ELSE          BEGIN            RealToString(weight, 5, 5, Strng2);          END;        Strng1 := Strip_Trailing_Blanks(Strng1);        Strng2 := Strip_Trailing_Blanks(Strng2);      END;{$S MENUS1}    PROCEDURE DrawLeftStuff;            VAR        nn, ij     : Integer;			PROCEDURE Choice_of_Display_1; { To make the stupid compiler happy, break it up }			VAR nn, ii : integer;              BEGIN              	ii := 100;                FOR nn := 1 TO 38 DO                  values[nn] := '';                FOR nn := 1 to 35 DO begin                	ii := ii + 1;                	LoadString(eV_Line[ii], Wt_Line[ii], str1, str2);                	values[nn] := CONCAT(Nm_Line[ii],'  : ', str1, '    ', str2);                end;                 for nn := 1 to 35 do                 values[nn] := Strip_Trailing_Blanks(values[nn]);              END;       BEGIN { Main Procedure }        IF Choice_of_Family = 3 THEN { еMе }          BEGIN            IF Choice_of_Display = 3 THEN {1=Sats,2=edges,3=Lines}              BEGIN              	ij := 75;                FOR nn := 1 TO 38 DO                  values[nn] := '';                for nn := 1 to 21 do begin                  ij := ij - 1;	              LoadString(eV_Line[ij], Wt_Line[ij], str1, str2);	              values[nn] := CONCAT(Nm_Line[ij],' :', str1, chr(9), str2);                end;                FOR nn := 1 TO 21 DO                  values[nn] := Strip_Trailing_Blanks(values[nn]);				               END;            IF Choice_of_Display = 2 THEN {1=Sats,2=edges,3=Lines}              BEGIN                FOR nn := 1 TO 38 DO                  values[nn] := '';                LoadString(A^.edge[5], A^.edge[2], str1, str2);                values[1] := CONCAT('MI EDGE   : ', str1);                LoadString(A^.edge[6], A^.edge[3], str1, str2);                values[2] := CONCAT('MII EDGE  : ', str1);                LoadString(A^.edge[7], A^.edge[4], str1, str2);                values[3] := CONCAT('MIII EDGE : ', str1);                LoadString(A^.edge[8], A^.edge[5], str1, str2);                values[4] := CONCAT('MIV EDGE  : ', str1);                LoadString(A^.edge[9], A^.edge[6], str1, str2);                values[5] := CONCAT('MV EDGE   : ', str1);                FOR nn := 1 TO 5 DO                  values[nn] := Strip_Trailing_Blanks(values[nn]);              END;            IF Choice_of_Display = 1 THEN {1=Sats,2=edges,3=Lines}              BEGIN              	ij := 135;                FOR nn := 1 TO 38 DO                  values[nn] := '';                for nn := 1 to 8 do begin                  ij := ij + 1;	              LoadString(eV_Line[ij], Wt_Line[ij], str1, str2);	              values[nn] := CONCAT(Nm_Line[ij],' :', str1, chr(9), str2);                end;                for nn := 1 to 8 do                values[nn] := Strip_Trailing_Blanks(values[nn]);              END;          END; {if Choice_of_Family = 3}        IF Choice_of_Family = 5 THEN { еKе }          BEGIN            IF Choice_of_Display = 3 THEN {1=Sats,2=edges,3=Lines}              BEGIN              	ij := 0;                FOR nn := 1 TO 38 DO                  values[nn] := '';                for nn := 1 to 7 do begin                  ij := ij + 1;	              LoadString(eV_Line[ij], Wt_Line[ij], str1, str2);	              values[nn] := CONCAT(Nm_Line[ij],' :', str1, chr(9), str2);                end;                FOR nn := 1 TO 7 DO                  values[nn] := Strip_Trailing_Blanks(values[nn]);              END;                          IF Choice_of_Display = 2 THEN {1=Sats,2=edges,3=Lines}              BEGIN                FOR nn := 1 TO 38 DO                  values[nn] := '';                LoadString(A^.edge[1], A^.edge[1], str1, str2);                values[1] := CONCAT('K edge : ', str1);              END;            IF Choice_of_Display = 1 THEN {1=Sats,2=edges,3=Lines}              BEGIN              	ij := 76;                FOR nn := 1 TO 38 DO                  values[nn] := '';                for nn := 1 to 24 do begin                  ij := ij + 1;	              LoadString(eV_Line[ij], Wt_Line[ij], str1, str2);	              values[nn] := CONCAT(Nm_Line[ij],' :', str1, chr(9), str2);                end;                FOR nn := 1 TO 24 DO                  values[nn] := Strip_Trailing_Blanks(values[nn]);              END;          END; {if Choice_of_Family = 5}        IF Choice_of_Family = 4 THEN { еLе }          BEGIN            IF Choice_of_Display = 3 THEN {1=Sats,2=edges,3=Lines}              BEGIN              	ij := 41;                FOR nn := 1 TO 38 DO                  values[nn] := '';                for nn := 1 to 11 do begin                  ij := ij + 1;	              LoadString(eV_Line[ij], Wt_Line[ij], str1, str2);	              values[nn] := CONCAT(Nm_Line[ij],' :', str1, chr(9), str2);                end;                ij := 144;                nn := 12;	              LoadString(eV_Line[ij], Wt_Line[ij], str1, str2);	              values[nn] := CONCAT(Nm_Line[ij],' :', str1, chr(9), str2);                ij := 7;                for nn := 13 to 24 do begin                  ij := ij + 1;	              LoadString(eV_Line[ij], Wt_Line[ij], str1, str2);	              values[nn] := CONCAT(Nm_Line[ij],' :', str1, chr(9), str2);                end;                ij := 20;                for nn := 25 to 31 do begin                  ij := ij + 1;	              LoadString(eV_Line[ij], Wt_Line[ij], str1, str2);	              values[nn] := CONCAT(Nm_Line[ij],' :', str1, chr(9), str2);                end;                ij := 28;                for nn := 32 to 38 do begin                  ij := ij + 1;	              LoadString(eV_Line[ij], Wt_Line[ij], str1, str2);	              values[nn] := CONCAT(Nm_Line[ij],' :', str1, chr(9), str2);                end;				      (*       ееееееееееееее RAN OUT OF REAL ESTATE 			drops one more line also			            eV_L2P2;            Weight_L2P2;            eV_L3N2;            Weight_L3N2;                  eV_L3N3;            Weight_L3N3;                  eV_L3O2;            Weight_L3O2;                  eV_L3O3;            Weight_L3O3;                  eV_L3P1;            Weight_L3P1;                        eV_LG4p;      *)                FOR nn := 1 TO 38 DO                  values[nn] := Strip_Trailing_Blanks(values[nn]);              END;            IF Choice_of_Display = 2 THEN {1=Sats,2=edges,3=Lines}              BEGIN                FOR nn := 1 TO 38 DO                  values[nn] := '';                LoadString(A^.edge[2], A^.edge[2], str1, str2);                values[1] := CONCAT('LI EDGE   : ', str1);                LoadString(A^.edge[3], A^.edge[3], str1, str2);                values[2] := CONCAT('LII EDGE  : ', str1);                LoadString(A^.edge[4], A^.edge[4], str1, str2);                values[3] := CONCAT('LIII EDGE : ', str1);                FOR nn := 1 TO 3 DO                  values[nn] := Strip_Trailing_Blanks(values[nn]);              END;			  			  			  			              IF Choice_of_Display = 1 THEN Choice_of_Display_1; {1=Sats,2=edges,3=Lines}			          END; {if Choice_of_Family = 4}		          IF Choice_of_Family = 2 THEN { еNе }          BEGIN            IF Choice_of_Display = 3 THEN {1=Sats,2=edges,3=Lines}              BEGIN                FOR nn := 1 TO 38 DO                  values[nn] := '';                LoadString(eV_Line[75], Wt_Line[75], str1, str2);                values[ 1] := CONCAT(Nm_Line[75],'  : ', str1, '    ', str2);                LoadString(eV_Line[76], Wt_Line[76], str1, str2);                values[ 2] := CONCAT(Nm_Line[76],'  : ', str1, '    ', str2);              END;            IF Choice_of_Display = 2 THEN {1=Sats,2=edges,3=Lines}              BEGIN                FOR nn := 1 TO 38 DO                  values[nn] := '';                LoadString(A^.edge[10], A^.edge[10], str1, str2);                values[1] := CONCAT('Nl edge   : ', str1);                LoadString(A^.edge[11], A^.edge[11], str1, str2);                values[2] := CONCAT('Nll edge  : ', str1);                LoadString(A^.edge[12], A^.edge[12], str1, str2);                values[3] := CONCAT('Nlll edge : ', str1);                LoadString(A^.edge[13], A^.edge[13], str1, str2);                values[4] := CONCAT('NlV edge  : ', str1);                LoadString(A^.edge[14], A^.edge[14], str1, str2);                values[5] := CONCAT('NV edge   : ', str1);                LoadString(A^.edge[15], A^.edge[15], str1, str2);                values[6] := CONCAT('NVl edge  : ', str1);                LoadString(A^.edge[16], A^.edge[16], str1, str2);                values[7] := CONCAT('NVll edge : ', str1);              END;		  END;		IF Choice_of_Family = 1 THEN { еOе }          BEGIN            IF Choice_of_Display = 2 THEN {1=Sats,2=edges,3=Lines}              BEGIN                FOR nn := 1 TO 38 DO                  values[nn] := '';                LoadString(A^.edge[17], A^.edge[17], str1, str2);                values[1] := CONCAT('Ol edge : ', str1);			  END;		  END;        FOR nn := 1 TO 38 DO          BEGIN            GetDialogItem(GetSelection, Val_1 - nn + 1, DType, DItem, tempRect);            SetDialogItemText(DItem, values[nn]);          END;        GetDialogItem(GetSelection, I_Element, DType, DItem, tempRect);        numToString(theElement, str);        str := CONCAT(A^.Sym[theElement], '  ', str);        SetDialogItemText(DItem, str);        GetDialogItem(GetSelection, I_Density, DType, DItem, tempRect);        RealToString(Element_Density, 5, 3, str);        SetDialogItemText(DItem, str);        GetDialogItem(GetSelection, I_Weight, DType, DItem, tempRect);        RealToString(Atomic_Weight, 5, 3, str);        SetDialogItemText(DItem, str);        GetDialogItem(GetSelection, I_Valence, DType, DItem, tempRect);        {numToString(  , Str);}        str := 'xx';        SetDialogItemText(DItem, str);      END; { DrawLeftStuff }    PROCEDURE Refresh_Dialog;            VAR        rTempRect                     : Rect;        nn                            : Integer;      BEGIN        SetPort(GetSelection);        rTempRect := tempRect;        tempRect := rTempRect;        FOR nn := 1 TO 38 DO values[nn] := '';        DrawLeftStuff;         FOR nn := Search_Top TO Search_Bot DO          BEGIN            GetDialogItem(GetSelection, nn, DType, DItem, tempRect);            SetDialogItemText(DItem, Search_String[nn - Search_Top + 1]);          END;        GetDialogItem(GetSelection, I_Element, DType, DItem, tempRect);        numToString(theElement, str);        str := CONCAT(A^.Sym[theElement], '  ', str);        SetDialogItemText(DItem, str);        GetDialogItem(GetSelection, I_Density, DType, DItem, tempRect);        RealToString(Element_Density, 5, 3, str);        SetDialogItemText(DItem, str);        GetDialogItem(GetSelection, I_Weight, DType, DItem, tempRect);        RealToString(Atomic_Weight, 5, 3, str);        SetDialogItemText(DItem, str);        GetDialogItem(GetSelection, I_Valence, DType, DItem, tempRect);        {numToString(  , Str);}        str := 'xx';        SetDialogItemText(DItem, str);      END; {procedure Refresh_Dialog}    PROCEDURE Look_it_up;            VAR        Index                         : Integer;        nn                            : Integer;        indexer                       : Integer;      BEGIN (*    { 3=kV, 4=mm, 5=A, 6=Sin_theta, mm := 280 / ( WDS_Two_d ) * n * Lamda}           if Choice_of_Units = 3 then     RealToString(Value,7,4,Strng1) else    if Choice_of_Units = 5 then     RealToString(12398/Value,7,4,Strng1) else    if Choice_of_Units = 4 then     RealToString(280 / ( WDS_Two_d ) * 12398/Value,7,4,Strng1) else    if Choice_of_Units = 6 then     RealToString((12398/Value) / ( WDS_Two_d ),7,4,Strng1);    if (Choice_of_Units=4) or (Choice_of_Units=6) then       if ((12398/Value) / ( WDS_Two_d ) < 0.25) or        ((12398/Value) / ( WDS_Two_d ) > 0.95) then       Strng1 := 'Out of Range';             *)		        IF Center_Value <> 0.0 THEN          BEGIN		   IF NOT LisShift then begin            FOR Index := 1 TO 4668 DO              BEGIN                IF (EnSer_Handle^^.Energy[Index] > Center_Value) THEN                  BEGIN                    lo_index := Index - 15;                    IF (lo_index < 1) THEN lo_index := 1;					IF (lo_index > 4572) THEN lo_index := 4572;					hi_index := Index + 15;                    IF (hi_index > 4668) THEN hi_index := 4668;					IF (hi_index < 31) THEN hi_index := 31;                    FOR nn := lo_index TO hi_index DO                      BEGIN                        indexer := nn - lo_index + 1;                        IF (indexer < 1) THEN indexer := 1;                        IF (indexer > 31) THEN indexer := 31;                        RealToString(EnSer_Handle^^.Energy[nn], 5, 1, Search_String[indexer]);                        {numtostring(EnSer_Handle^^.line[nn],str1);}                        numToString(EnSer_Handle^^.AtNo[nn], string2);                        Search_String[indexer] := CONCAT(Search_String[indexer], chr(9), A^.Sym[EnSer_Handle^^.AtNo[nn]],                                                         chr(9), chr(9), string2, chr(9), chr(9), En_Label[                                                         EnSer_Handle^^.line[nn]]);                      END;                    leave;                  END;              END;		END		ELSE begin			FOR nn := lo_index TO hi_index DO			  BEGIN				indexer := nn - lo_index + 1;				IF (indexer < 1) THEN indexer := 1;				IF (indexer > 31) THEN indexer := 31;				RealToString(EnSer_Handle^^.Energy[nn], 5, 1, Search_String[indexer]);				{numtostring(EnSer_Handle^^.line[nn],str1);}				numToString(EnSer_Handle^^.AtNo[nn], string2);				Search_String[indexer] := CONCAT(Search_String[indexer], chr(9), A^.Sym[EnSer_Handle^^.AtNo[nn]],												 chr(9), chr(9), string2, chr(9), chr(9), En_Label[												 EnSer_Handle^^.line[nn]]);			  END;			  LisShift := false;		end;            FOR Index := Search_Top TO Search_Bot DO              BEGIN                GetDialogItem(GetSelection, Index, DType, DItem, tempRect);                SetDialogItemText(DItem, Search_String[Index - Search_Top + 1]);              END;          END        ELSE          BEGIN            putmessage('You must enter an energy value in eV that you which to',                       'search around for any potential interferences', '', '');            Refresh_Dialog;          END;      END; { Look_it_up; }    BEGIN      GetSelection := GetNewDialog(405, NIL, POINTER( - 1));	  CenterDialog(GetSelection, TRUE, where);			{еееnew RLMеее}      ShowWindow(GetSelection);      SelectWindow(GetSelection);      SetPort(GetSelection);	  OutlineButton(GetSelection, 1, 16); { outline the accept button }      {еSetup initial conditionsе}      GetDialogItem(GetSelection, I_Element, DType, DItem, tempRect);      numToString(theElement, str);      str := CONCAT(A^.Sym[theElement], ' ', str);      SetDialogItemText(DItem, str);      GetDialogItem(GetSelection, I_Density, DType, DItem, tempRect);      RealToString(Element_Density, 5, 3, str);      SetDialogItemText(DItem, str);      GetDialogItem(GetSelection, I_Weight, DType, DItem, tempRect);      RealToString(Atomic_Weight, 5, 3, str);      SetDialogItemText(DItem, str);      GetDialogItem(GetSelection, I_Valence, DType, DItem, tempRect);      {numToString(  , Str);}      str := 'xx';      SetDialogItemText(DItem, str);      GetDialogItem(GetSelection, Choice_of_Units + I_spare2 - 1, DType, DItem, tempRect);      SetControlValue(controlhandle(DItem), 1);      GetDialogItem(GetSelection, Choice_of_Family + I_O - 1, DType, DItem, tempRect);      SetControlValue(controlhandle(DItem), 1);      GetDialogItem(GetSelection, Choice_of_Display + I_Satelites - 1, DType, DItem, tempRect);      SetControlValue(controlhandle(DItem), 1);      GetDialogItem(GetSelection, I_Center, DType, DItem, tempRect);      SetDialogItemText(DItem, '0.0');      ExitDialog := FALSE;      Center_Value := 0.0;      En_Label[ - 13] := 'KA1';      En_Label[ - 12] := 'KA2';      En_Label[ - 11] := 'KB1';      En_Label[ - 10] := 'KB2';      En_Label[ - 9] := 'KB3';      En_Label[ - 8] := 'KB4';      En_Label[ - 7] := 'KB5';      En_Label[ - 6] := 'L1-M1';      En_Label[ - 5] := 'L1-N1';      En_Label[ - 4] := 'L1-N4';      En_Label[ - 3] := 'L1-O1';      En_Label[ - 2] := 'L1-O4';      En_Label[ - 1] := 'L2-M2';      En_Label[0] := 'L2-M5';      En_Label[1] := 'L2-N2';      En_Label[2] := 'L2-N3';      En_Label[3] := 'L2-N5';      En_Label[4] := 'L2-O2';      En_Label[5] := 'L2-O3';      En_Label[6] := 'L2-P2';      En_Label[7] := 'L3-N2';      En_Label[8] := 'L3-N3';      En_Label[9] := 'L3-O2';      En_Label[10] := 'L3-O3';      En_Label[11] := 'L3-P1';      En_Label[12] := 'LA1';      En_Label[13] := 'LA2';      En_Label[14] := 'LB1';      En_Label[15] := 'LB10';      En_Label[16] := 'LB15';      En_Label[17] := 'LB17';      En_Label[18] := 'LB2';      En_Label[19] := 'LB3';      En_Label[20] := 'LB4';      En_Label[21] := 'LB5';      En_Label[22] := 'LB6';      En_Label[23] := 'LB7';      En_Label[24] := 'LB9';      En_Label[25] := 'LG1';      En_Label[26] := 'LG11';      En_Label[27] := 'LG3';      En_Label[28] := 'LG4';      En_Label[29] := 'LG4`';      En_Label[30] := 'LG5';      En_Label[31] := 'LG6';      En_Label[32] := 'LG8';      En_Label[33] := 'Ll';      En_Label[34] := 'Ln';      En_Label[35] := 'Ls';      En_Label[36] := 'Lt';      En_Label[37] := 'Lu';      En_Label[38] := 'Lv';      En_Label[39] := 'M1-N2';      En_Label[40] := 'M1-N3';      En_Label[41] := 'M2-M4';      En_Label[42] := 'M2-N1';      En_Label[43] := 'M2-N4';      En_Label[44] := 'M3-M4';      En_Label[45] := 'M3-M5';      En_Label[46] := 'M3-N1';      En_Label[47] := 'M3-N4';      En_Label[48] := 'M3-O1';      En_Label[49] := 'M3-O4';      En_Label[50] := 'M3-O5';      En_Label[51] := 'M4-N3';      En_Label[52] := 'M4-O2';      En_Label[53] := 'M5-O3';      En_Label[54] := 'MA1';      En_Label[55] := 'MA2';      En_Label[56] := 'MB';      En_Label[57] := 'M2-O4';      En_Label[58] := 'MG';      En_Label[59] := 'MZ1';      En_Label[60] := 'MZ2';      En_Label[61] := 'N4-N6';      En_Label[62] := 'N5-N6';      En_Label[63] := 'SKA';      En_Label[64] := 'SKA3';      En_Label[65] := 'SKA3`';      En_Label[66] := 'SKA3``';      En_Label[67] := 'SKA4';      En_Label[68] := 'SKA5';      En_Label[69] := 'SKA6';      En_Label[70] := 'SKA7';      En_Label[71] := 'SKA8';      En_Label[72] := 'SKA9';      En_Label[73] := 'SKA`';      En_Label[74] := 'SKA``';      En_Label[75] := 'SKB';      En_Label[76] := 'SKB10';      En_Label[77] := 'SKB6';      En_Label[78] := 'SKB7';      En_Label[79] := 'SKB8';      En_Label[80] := 'SKB9';      En_Label[81] := 'SKB`';      En_Label[82] := 'SKB``';      En_Label[83] := 'SKBN';      En_Label[84] := 'SKBX';      En_Label[85] := 'SKBа4';      En_Label[86] := 'SKBа5';      En_Label[87] := 'SLA1аZ';      En_Label[88] := 'SLA2`';      En_Label[89] := 'SLA3';      En_Label[90] := 'SLA3аZ';      En_Label[91] := 'SLA4';      En_Label[92] := 'SLA5';      En_Label[93] := 'SLA6';      En_Label[94] := 'SLA7';      En_Label[95] := 'SLA8';      En_Label[96] := 'SLA9';      En_Label[97] := 'SLAA';      En_Label[98] := 'SLA`';      En_Label[99] := 'SLAS';      En_Label[100] := 'SLAаIX';      En_Label[101] := 'SLAаX';      En_Label[102] := 'SLAаY';      En_Label[103] := 'SLB14';      En_Label[104] := 'SLB1``';      En_Label[105] := 'SLB1а4';      En_Label[106] := 'SLB2а1';      En_Label[107] := 'SLB2а2';      En_Label[108] := 'SLB2а3';      En_Label[109] := 'SLB2а4';      En_Label[110] := 'SLB2а5';      En_Label[111] := 'SLB2а7';      En_Label[112] := 'SLB2аA';      En_Label[113] := 'SLB2аB';      En_Label[114] := 'SLB2аC';      En_Label[115] := 'SLB5а1';      En_Label[116] := 'SLB5а2';      En_Label[117] := 'SLG10';      En_Label[118] := 'SLG1`';      En_Label[119] := 'SLG2`';      En_Label[120] := 'SLG2``';      En_Label[121] := 'SLG9';      En_Label[122] := 'SMAа1';      En_Label[123] := 'SMAа2';      En_Label[124] := 'SMAа3';      En_Label[125] := 'SMAа4';      En_Label[126] := 'SMB1';      En_Label[127] := 'SMB2';      En_Label[ - 14] := 'SMB3';      En_Label[ - 15] := 'SMG`';	  En_Label[ - 16] := 'LG2`';	        FOR nn := 1 TO 31 DO        Search_Results[nn] := nn;      FOR nn := 1 TO 31 DO        BEGIN          Search_String[nn] := '';        END;      Refresh_Dialog;	  OutlineButton(GetSelection, 1, 16); { outline the accept button }      REPEAT        ModalDialog(NIL, itemHit);        GetDialogItem(GetSelection, itemHit, DType, DItem, tempRect);        CItem := controlhandle(DItem);        IF (itemHit = I_Center) THEN          BEGIN            GetDialogItem(GetSelection, I_Center, DType, DItem, tempRect);            GetDialogItemText(DItem, sTemp);            Center_Value := MyStr2Num(sTemp);          END;        IF (itemHit = I_Up_10) THEN          BEGIN			lo_index := lo_index + 10;			hi_index := hi_index + 10;			IF (lo_index < 1) THEN lo_index := 1;			IF (lo_index > 4572) THEN lo_index := 4572;			IF (hi_index > 4668) THEN hi_index := 4668;			IF (hi_index < 31) THEN hi_index := 31;			Cent_v := lo_index+15;			if Cent_v > 4588 then Cent_v := 4588;			Center_Value := EnSer_Handle^^.Energy[Cent_v];            GetDialogItem(GetSelection, I_Center, DType, DItem, tempRect);            RealToString(Center_Value, 5, 2, sTemp);            SetDialogItemText(DItem, sTemp);			LisShift := true;            Look_it_up;          END;        IF (itemHit = I_Down_10) THEN          BEGIN			lo_index := lo_index - 10;			hi_index := hi_index - 10;			IF (lo_index < 1) THEN lo_index := 1;			IF (lo_index > 4572) THEN lo_index := 4572;			IF (hi_index > 4668) THEN hi_index := 4668;			IF (hi_index < 31) THEN hi_index := 31;			Cent_v := lo_index+15;			if Cent_v < 1 then Cent_v := 1;						Center_Value := EnSer_Handle^^.Energy[Cent_v];            GetDialogItem(GetSelection, I_Center, DType, DItem, tempRect);            RealToString(Center_Value, 5, 2, sTemp);            SetDialogItemText(DItem, sTemp);			LisShift := true;            Look_it_up;          END;        IF (itemHit = I_LookUp) THEN          BEGIN		    LisShift := false;            Look_it_up;          END;        IF (itemHit = I_Down_One) THEN          BEGIN            theElement := theElement - 1;            IF theElement < 3 THEN theElement := 3;            Get_Energies(theElement);            DrawLeftStuff;          END;        IF (itemHit = I_Up_One) THEN          BEGIN            theElement := theElement + 1;            IF theElement > 95 THEN theElement := 95;            Get_Energies(theElement);            DrawLeftStuff;          END;        IF (itemHit = I_Look_up_Xtal) THEN          BEGIN            Lookup_Xtal;            Refresh_Dialog;			OutlineButton(GetSelection, 1, 16); { outline the accept button }          END;        IF (itemHit = I_ACCEPT) THEN          BEGIN            ExitDialog := True;          END;        IF (itemHit >= I_spare2) AND (itemHit <= I_two_Theta) THEN          BEGIN            FOR Index := I_spare2 TO I_two_Theta DO              BEGIN                GetDialogItem(GetSelection, Index, DType, DItem, tempRect);                SetControlValue(controlhandle(DItem), 0);              END;            SetControlValue(CItem, 1);            Choice_of_Units := itemHit - I_spare2 + 1; { 3=kV, 4=mm, 5=A, 6=Sin_theta}            DrawLeftStuff;          END;        IF (itemHit >= I_O) AND (itemHit <= I_K) THEN          BEGIN            FOR Index := I_O TO I_K DO              BEGIN                GetDialogItem(GetSelection, Index, DType, DItem, tempRect);                SetControlValue(controlhandle(DItem), 0);              END;            SetControlValue(CItem, 1);            Choice_of_Family := itemHit - I_O + 1; {1=O,2=N,3=M,4=L,5=K}            DrawLeftStuff;          END;        IF (itemHit >= I_Satelites) AND (itemHit <= I_Lines) THEN          BEGIN            FOR Index := I_Satelites TO I_Lines DO              BEGIN                GetDialogItem(GetSelection, Index, DType, DItem, tempRect);                SetControlValue(controlhandle(DItem), 0);              END;            SetControlValue(CItem, 1);            Choice_of_Display := itemHit - I_Satelites + 1; {1=Sats,2=edges,3=Lines}            DrawLeftStuff;          END;      UNTIL ExitDialog;      tempRect := GetSelection^.portRect;      DisposeDialog(GetSelection);      FillWhiteSpace(tempRect);    END;  PROCEDURE D_Per_Tab_Buttons;        CONST      I_ACCEPT                      = 1;      I_H                           = 2;              { the rest of the element button numbers are in between H & Am }      I_Am                          = 96;      I_Clear_All                   = 97;      I_Help                        = 98;      I_Clear_Last                  = 99;    VAR      ExitDialog                    : boolean;      GetSelection                  : DialogPtr;      tempRect                      : Rect;      DType                         : Integer;      DItem                         : Handle;      itemHit                       : Integer;	  where							: point;    BEGIN      GetSelection := GetNewDialog(404, NIL, POINTER( - 1));	  CenterDialog(GetSelection, TRUE, where);			{еееnew RLMеее}      ShowWindow(GetSelection);      SelectWindow(GetSelection);      SetPort(GetSelection);	  OutlineButton(GetSelection, 1, 16); { outline the accept button }      ExitDialog := FALSE;      REPEAT        ModalDialog(NIL, itemHit);        GetDialogItem(GetSelection, itemHit, DType, DItem, tempRect);        IF (itemHit >= I_H) AND (itemHit <= I_Am) THEN          BEGIN            theElement := itemHit - (I_H - 1);			Xray_Data_Request := True;            Get_Energies(theElement);            D_XIS;			OutlineButton(GetSelection, 1, 16);          END;        IF (itemHit = I_ACCEPT) THEN          BEGIN            ExitDialog := True;          END;      UNTIL ExitDialog;	  Xray_Data_Request := false;      DisposeDialog(GetSelection);      SetFont('Chicago', 12, []); { The System Font }    END; {End of procedure xis}	PROCEDURE SavePrintRecord(thePrintRecord: THPrint; theResFile: INTEGER);(* SavePrintRecord																  	*)(*  This procedure is responsible for saving a print record into the resource fork. *)(* On entry, the print record should be initialized, and the resource file should   *)(* be open with permission to write.												*)VAR	currentResFile:	INTEGER;	existingResHdl:	Handle;	newResHdl:		Handle;	theError:		OSErr;	str          : str255;BEGIN	currentResFile := CurResFile;  	UseResFile(theResFile);	theError := ResError; 	if theError = rmvResFailed then str := 'RemoveResource failed';	if theError = resNotFound then str := 'resource not found';	if theError = resFNotFound then str := 'resource file not found';	if theError = addResFailed then str := 'AddResource failed';	IF theError <> noErr THEN 	   begin	     putmessage('There was an error in trying to save the Printing Record.',	                                     'The error was:',str,'at 1'); 	     UseResFile(currentResFile);		 exit(SavePrintRecord);	   end;	  		existingResHdl := GetResource(gPRResType, gPRResID);		IF existingResHdl <> NIL THEN BEGIN			RemoveResource(existingResHdl);			theError := ResError; 			if theError = rmvResFailed then str := 'RemoveResource failed';			if theError = resNotFound then str := 'resource not found';			if theError = resFNotFound then str := 'resource file not found';			if theError = addResFailed then str := 'AddResource failed';			IF theError <> noErr THEN 			   begin				 putmessage('There was an error in trying to save the Printing Record.',												 'The error was:',str,'at 2'); 	             UseResFile(currentResFile); 				 exit(SavePrintRecord);			   end;	 			IF theError = noErr THEN BEGIN				H_UnLock_Dispose(existingResHdl,' in Menus_D');				UpdateResFile(theResFile);			END;		END; 		IF theError = noErr THEN BEGIN			newResHdl := Handle(thePrintRecord);			theError := HandToHand(newResHdl);			IF theError = noErr THEN BEGIN				AddResource(newResHdl, gPRResType, gPRResID, gPRResName);				theError := ResError;				if theError = rmvResFailed then str := 'RemoveResource failed';				if theError = resNotFound then str := 'resource not found';				if theError = resFNotFound then str := 'resource file not found';				if theError = addResFailed then str := 'AddResource failed';				IF theError <> noErr THEN 				   begin					 putmessage('There was an error in trying to save the Printing Record.',													 'The error was:',str,'at 2');                     UseResFile(currentResFile);					 exit(SavePrintRecord);				   end;	 				IF theError = noErr THEN UpdateResFile(theResFile);				theError := ResError;				if theError = rmvResFailed then str := 'RemoveResource failed';				if theError = resNotFound then str := 'resource not found';				if theError = resFNotFound then str := 'resource file not found';				if theError = addResFailed then str := 'AddResource failed';				IF theError <> noErr THEN 				   begin					 putmessage('There was an error in trying to save the Printing Record.',													 'The error was:',str,'at 2'); 	                 UseResFile(currentResFile);					 exit(SavePrintRecord);				   end;	 			END;		END;    	UseResFile(currentResFile);END;   PROCEDURE Init_My_Menus;    CONST      Menu1                         = 201;            { Apple }      Menu2                         = 202;            { File }	  Menu2a                        = 228;            { File Import (for hier lists) }	  Menu2b                        = 229;            { File Export (for hier lists) }      Menu3                         = 204;            { Analysis }      Menu4                         = 203;            { Generate }      Menu5                         = 205;            { Math }      Menu6                         = 206;            { Headers }      Menu7                         = 207;            { Display }      Menu10                        = 210;            { Show Header }	  Menu17						= 152;		  	  { Acquisition (for main menu bar)}	  Menu17a						= 128;		  	  { Acquisition Setup (for hier lists)}	  Menu17b						= 129;		  	  { Acquisition Select(for hier lists)}	  Menu18					    = 153;			  { Edit }      Menu11                        = 11;             { Ml references hier list }      Menu9                         = 13;             { Old Fit File Hier List }      Menu12                        = 12;      Menu13                        = 20;             { ZAF hier list }	  Menu14						= 15;			  { Label Font Sizes }	  Menu15						= 1;			  { Label Font Sizes }	  Menu16                        = 21;             { CITZAF hier list }	  Menu20						= 22;			  { Stdlss hier list }	  Menu23						= 23;			  { Qual output choice }	  Menu24						= 24;			  { Qual output choice }	  Menu25						= 25;			  { QC menu }	  Menu26						= 26;			  { Hall menu }    BEGIN      ClearMenuBar;      SetFont('Chicago', 12, []); { The System Font }      MainMenu := GetMenu(Menu1);      AppendResMenu(MainMenu, 'DRVR'); {Add in DAs}      InsertMenu(MainMenu, 0);      AppleMenu := MainMenu;      {   File  }      ManageMenu := GetMenu(Menu2);      InsertMenu(GetMenu(Menu2a), -1);      InsertMenu(GetMenu(Menu2b), -1);      InsertMenu(ManageMenu, 0);	  	  { Edit }      ManageMenu := GetMenu(Menu18);      InsertMenu(ManageMenu, 0);	        {   Analysis  }      MainMenu := GetMenu(Menu3);      InsertMenu(MainMenu, 0);      {   Generate  }      MainMenu := GetMenu(Menu4);      InsertMenu(MainMenu, 0);      {   Math  }      MainMenu := GetMenu(Menu5);      InsertMenu(MainMenu, 0);      {   Headers  }      MainMenu := GetMenu(Menu6);      InsertMenu(MainMenu, 0);      {   Display  }      FullMenu := GetMenu(Menu7);      InsertMenu(FullMenu, 0);      {   Acquisition  }      InsertMenu(GetMenu(Menu17a), -1);      InsertMenu(GetMenu(Menu17b), -1);      InsertMenu(GetMenu(Menu17), 0);      {This menu is  Ml References choices  }      M_Ml_References := GetMenu(Menu11);      InsertMenu(M_Ml_References, - 1);      {This menu is  Old Fit File choices  }      M_Old_Fit_File := GetMenu(Menu9);      InsertMenu(M_Old_Fit_File, - 1);      {This menu is  MCA Setups choices  }      M_MCA_Setups := GetMenu(Menu12);      InsertMenu(M_MCA_Setups, - 1);      {This menu is  MCA ZAF choices  }      M_Standards_Files := GetMenu(Menu13);      InsertMenu(M_Standards_Files, - 1);      {This menu is  Label Font Sizes  }      M_Label_Fonts := GetMenu(Menu14);      InsertMenu(M_Label_Fonts, - 1);      {This menu is  Cliff-Lorimer choices  }      M_CliffLorimer := GetMenu(Menu15);      InsertMenu(M_CliffLorimer, - 1);	        {This menu is  MCA CITZAF choices  }      M_CITZAF := GetMenu(Menu16);      InsertMenu(M_CITZAF, - 1);	        {This menu is  Show Header choices }      M_Show_Header := GetMenu(Menu10);      InsertMenu(M_Show_Header, - 1);	  	              {This menu is  Stdlss choices }      M_Stdlss := GetMenu(Menu20);      InsertMenu(M_Stdlss, - 1);        {This menu is  Qual output choices }      M_Qual_out1 := GetMenu(Menu23);      InsertMenu(M_Qual_out1, - 1);       {This menu is  Qual output choices }      M_Qual_out2 := GetMenu(Menu24);      InsertMenu(M_Qual_out2, - 1);             {This menu is  QC choices }      M_QC := GetMenu(Menu25);      InsertMenu(M_QC, - 1);       {This menu is  Hall choices }      M_Hall_Analysis := GetMenu(Menu26);      InsertMenu(M_Hall_Analysis, - 1);            DrawMenuBar;    END; {End of procedure Init_My_Menus}{$S MENUS2}  {[f-]}  PROCEDURE Handle_My_Menu(VAR doneFlag: boolean; theMenu, theItem: Integer;                           VAR theInput: TEHandle);       CONST      L_Apple                       = 201;            {Menu list}      C_About_MCA                   = 1;      L_Manage                      = 202;            {Menu list}      C_Get_MCASpectrum_from_Disk   = 1;      C_Save_MCASpectrum_to_Disk    = 2;      C_Append_Spectrum_to_Disk     = 3;	                   { -------------4}	  C_Import_Files 		        = 5;	  		L_ImportPlugins			= 228;	{Menu ID for import}	  C_Export_Files				= 6;	  		L_ExportPlugins			= 229;	{Menu ID for export}      C_Save_Spreadsheet            = 7;	                   { -------------8}	  C_Ml_References               = 9;    	  L_Ml_References              = 11;			C_New_File                    = 1;			C_Add_Ref                     = 2;			C_Display_Ref                 = 3;			C_Flowchart                   = 4;			C_RefHelp                     = 5;				  C_Open_OldFit_File		    = 10;    	  L_Old_Fit                     = 13;		  	C_Rename					  = 1;			C_Output					  = 2;			C_Show						  = 3;			C_Append					  = 4;	  					{ е				11}	                   { -------------12}	  C_MCA_Setups		            = 13;    	  L_MCA_Setups                 = 12;			C_Save_Setup_toDisk           = 1;			C_Get_Setup_FromDisk          = 2;			C_Save_Setup_2                = 3;			C_Get_Setup_2                 = 4;			C_Save_Setup_3                = 5;			C_Get_Setup_3                 = 6;            Setup_Help   				  = 7;	                   { -------------14}      C_Plot_Symbols                = 15;      C_Label_Fonts                 = 16; 	  	  L_Label_Fonts				  = 15;		    C_9							= 1;			C_10						= 2;			C_12						= 3;			C_14						= 4;			C_18						= 5;			C_24						= 6;				                   { -------------17}      C_Show_active_DTSA_files      = 18;	                   { -------------19}	  C_PrinterSetup                = 20;	  C_PrintSpectra                = 21;	  C_PrintAllSpectra             = 22;	  C_FileofHeaders               = 23;	  C_Quit                        = 24;	  	        L_Generate                    = 203;            {Menu list}      C_Peaks_Manually              = 1;	                  { ------------- 2}      C_Noise_Spectra               = 3;	                  { ------------- 4}      C_Thin_Spectrum               = 5;	                    C_Bulk_Spectrum               = 6;	                  { ------------- 7}	  C_Last_Gen_to_Work            = 8;	  	  L_Edit						= 153;            {Menu list}	  	C_Undo						= 1;		                { ------------- 2}		C_Cut						= 3;		C_Copy						= 4;		C_Paste						= 5;		                { ------------- 6}		C_Clear						= 7;		      L_Analysis                     = 204;            {Menu list, now Analysis}      C_ZAF_Menu              = 1;	      L_ZAF_submenu             = 20;			C_ZAF_Create_File              = 1;			C_Review_std_file           = 2;			                 { -------------3}			C_ZAF          				   = 4;			C_ZAF_Flowchart       		   = 5;                      { ------------- 2}	  C_CliffLorimer                = 3;	   	L_CliffLorimer 			        = 1;			C_KFactors						= 1;			C_KFile							= 2;			C_Setup							= 3;			C_Results						= 4;			C_CLOutput						= 5;			C_Help					   		= 6;      C_Standardless_Miracle        = 4;	  	L_Stdlss_submenu			= 22;			C_Do_Standardless		= 1;			C_Stdlss_Flowchart		= 2;	                  { ------------- 5}      C_Hall_Analysis                  = 6;	   	L_Hall_Analysis 				 = 26;			C_HallQuant						= 1;			C_HallFile						= 2;			C_HallSetup						= 3;			C_HallHelp						= 4;	                  { ------------- 7}      C_Curve_Fit_Auto_Run          = 8;		{***11/18/92***}	                  { ------------- 9}      C_Qual_Analysis               = 10;		{***10/12/94***}	  	L_Qual_output_1				= 23;		{***5/19/95***}			C_Title_1				= 1;							{ ------------- 2}			C_All_Lines_1			= 3;			C_DTSA_Set_1			= 4;		      C_Qual_Work              		= 11;		{***10/12/94***}	  	L_Qual_output_2				= 24;		{***5/19/95***}			C_Title_2				= 1;							{ ------------- 2}			C_All_Lines_2			= 3;			C_DTSA_Set_2			= 4;			                  { ------------- 12}	  C_CITZAF_Menu                  = 13;	      L_CITZAF_submenu           = 21;			C_CITZAF_Create_File     = 1;			C_CITZAF_Review_std_file = 2;			                 { -------------3}			C_CITZAF          		 = 4;			C_CITZAF_Flowchart       = 5;                      { ------------- 2}	  	  C_EyeChi                      = 14;	  C_EDS_QC                      = 15;	  	L_EDS_QC					= 25;	  		C_Setup_QC				= 1;	  		C_Run_QC				= 2;	                  { ------------- 16}	  C_Deactivate                  = 17;	        L_Math                        = 205;            {Menu list}      C_Clear_Work                  = 1;      C_Clear_Results               = 2;	  C_Clear_ALL                   = 3;	  C_Add_Work_To_Results         = 4;      C_Add_Poisson_Noise_to_Work   = 5;      C_Measure_Beam_Energy         = 6;      C_WDS_to_EDS                  = 7;                      { ------------- 8}      C_Smooth                      = 9;      C_Digital_Filter              = 10;	  C_Remove_Background           = 11;      C_Compare_Wk_to_R             = 12; 	                  { ------------- 13}				        C_Strip_Escapes          		= 14;                       { -------------15}      C_Show_Detector_Response      = 16;      C_Replace_Response_by_Wk      = 17;	  C_Calculate_Response_NOW      = 18;      C_3                           = 19;	  C_X_Ray_DataBase              = 20;         C_4                           = 21;	        L_Parameters                  = 206;            {Menu list}      C_Experiment_Header           = 1;	  C_Spectrum_Header             = 2;                       { -------------3}	  	  C_Show_Headers				= 4;	  	L_Show_Headers				= 210;			C_Work					=   10;			C_HResults				=   9;			C_H1					=   1;			C_H2					=   2;			C_H3					=   3;			C_H4					=   4;			C_H5					=   5;			C_H6					=   6;			C_H7					=   7;			C_H8					=   8;							        L_Full                        = 207;            {Menu list}      { The others in this list are global arrays }      Clear_Full                    = 11;	  {SDD}  L_Acquisition				= 152;				{ Menu list								}{SDD}   C_AssignBuffers				= 1;				{ Assign Acquisition Plugin Hardware to DTSA buffers }{SDD}   C_SetupHardware				= 2;				{ Setup Acquisition Plugin Hardware		}{SDD}		L_SetupAcqPlugins		= 128;{SDD}   C_SelectHardware			= 3;				{ Select Acquisition Plugin Hardware	}{SDD}		L_SelectAcqPlugins		= 129;{SDD}   C_Stop						= 5;				{ Stop Acquisition						}{SDD}   C_Resume					= 6;				{ Resume Acquisition					}{SDD}   C_Start						= 7;				{ Start Acquisition Hardware			}{SDD}   C_StopAll					= 9;				{ Stop All Acquisition Hardware			}{SDD}   C_ResumeAll					= 10;				{ Resume All Acquisition Hardware		}{SDD}   C_StartAll					= 11;				{ Start All Acquisition					}{SDD}   C_Automation				= 13;      {L_Show_Header                 = 210;}            {Menu list}{[f+]}        VAR      C_SPick                       : ARRAY [1..10] OF Integer;      DNA                           : Integer;        {For opening DAs}      BoolHolder,ref_bool           : boolean;        {For SystemEdit result}      DAName                        : Str255;      Index                         : Integer;      mm                            : Integer;      nn                            : Integer;      errCode                       : Integer;      refnum, nindex                : Integer;      bytecount                     : LongInt;      err,theError                  : OSErr; 	  fndrInfo                      : FInfo;	  savename,saveplain,savespread: fnamestr;	  savevol,saveplainvol,savespreadvol			: integer;	  save_plain,save_spread	    : boolean;	  TempR                         : Real;      str,str1,str2,str5   			: str255;{SDD} bErr				   			: Boolean; 			PROCEDURE Make_File_of_Headers;			VAR index, nn    : Integer;                BEGIN 				if not MCA_Spectrum_Active then				begin				 putMessage('There is no active DTSA file of spectra to process!','','','');				 exit(Handle_My_Menu);				end;				  				  str := CONCAT(RdBinaryName,'.HeaderInfo');				  PlainName := str; 				  				  if (CreateFile(PlainName, 'Name a File to Receive Headers') = true) OR (File_Cancel_Button = false) then;				  IF (File_Cancel_Button = false) THEN exit(Handle_My_Menu); 				  err := getvol(Save_Volume_Name,save_vol);	{ save current volume info}				  err := setvol(NIL, Out_VolRefNum);{Out_VolRefNum defined in CreateFile}   				  Rewrite(Plain, PlainName); {...on the volume Out_VolRefNum } 				  fndrInfo.fdcreator := 'MSWD';				  fndrInfo.fdtype := 'TEXT';				  fndrInfo.fdFlags := $0;				  err := setfinfo(PlainName, Out_VolRefNum, fndrInfo);				  			 WITH Plt_spec[10]^^, SpectrumStuff, Acq_Info, Spectrum_Info, Expt_Info			 DO BEGIN	  				writeln(plain, 'Analyst: ', Analyst);				writeln(plain, 'Specimen_ID: ', Specimen_ID);				writeln(plain, ' DTSA Filename =  ', MCA_Filename);				writeln(plain, 'Experiment Comments: ', Specimen_Comment_Field);				writeln(plain, ' Beam keV =  ', KV: 6: 3);				if Plt_Spec[10]^^.Expt_Info.Detector.spec = EDS then				 writeln(plain, ' Mn FWHM (eV) =  ', Si_Resolution: 6: 3);				if Plt_Spec[10]^^.Expt_Info.Detector.spec = WDS then				 writeln(plain, ' WDS FWHM (eV) =  ', WDS_Resolution: 6: 3);				writeln(plain, '  eV/Channel =  ', dE: 6: 3);				writeln(plain, '  Calibration y intercept =  ', Energy_Intercept: 6: 3);				writeln(plain, '  Calibration slope =  ', Energy_Slope: 6: 3);				writeln(plain, '  Number of assigned channels =  ', Number_of_Channels: 6 );				writeln(plain, '  detector ID =  ', detector.ID: 6 );				writeln(plain, '  First Spectrum in file =  ', FirstSpec: 6 );				writeln(plain, '  Last Spectrum in File =  ', LastSpect: 6 );			 				 writeln(plain, ' Si(Li) Dead Zone (um) = ', Si_Thickness: 6: 3);				 writeln(plain, ' Detector Tilt = ', Detector_Tilt: 6: 3);				 writeln(plain, ' Detector Thickness (mm) =', chr(9),Detector_Thickness: 6: 3);				 writeln(plain, ' Detector Area (sq. mm) =', chr(9),Detector_Area: 6: 3);				 writeln(plain, ' Detector-Specimen distance (mm) =', chr(9),Spec_Detector_Distance: 6: 3);				 IF C_Thickness   > 0.0 THEN writeln(plain, ' Carbon Window Component =',chr(9), C_Thickness: 6: 3);				 IF Diamond       > 0.0 THEN writeln(plain, ' Diamond Window Thickness =',chr(9), Diamond: 6: 3);				 IF Ice_Thickness > 0.0 THEN writeln(plain, ' Ice (as Oxygen) =', chr(9),Ice_Thickness: 6: 3);				 IF Al_Thickness  > 0.0 THEN writeln(plain, ' Al coating =', chr(9),Al_Thickness: 6: 3);				 IF Be_Thickness  > 0.0 THEN writeln(plain, ' Be Thickness =', chr(9),Be_Thickness: 6: 3);				 IF Au_Thickness  > 0.0 THEN writeln(plain, ' Au Thickness =', chr(9),Au_Thickness: 6: 3);				 IF Mylar         > 0.0 THEN writeln(plain, ' Mylar Thickness =',chr(9), Mylar: 6: 3);				 IF Moxtek        > 0.0 THEN writeln(plain, ' Moxtek Thickness =',chr(9), Moxtek: 6: 3);				 IF Paralene      > 0.0 THEN writeln(plain, ' Paralene Thickness =',chr(9), Paralene: 6: 3);				 IF Quantum       > 0.0 THEN writeln(plain, ' Quantum Window Thickness =', chr(9),Quantum: 6: 3);				 IF BN_Thickness  > 0.0 THEN writeln(plain, ' BN Thickness =', chr(9), BN_Thickness: 6: 3); 				 IF SiN_Thickness > 0.0 THEN writeln(plain, ' Si3N4 Thickness =', chr(9), SiN_Thickness: 6: 3); 				 writeln(plain, ' Elevation Angle =  ', elevation: 6: 3);				 writeln(plain, ' Azimuth Angle =  ', azimuth: 6: 3);				 writeln(Plain);				 writeln(Plain);						errCode := FSpOpenDF(Read_DTSA_Spec, fsRdWrPerm, Hold_RefNum);		RdBinaryName := Read_DTSA_Spec.name;		err := setfpos (Hold_RefNum, fsFromstart, 0 );		Spectrum_counter := 0;		For Index := Plt_spec[10]^^.Expt_Info.FirstSpec to 					 Plt_spec[10]^^.Expt_Info.LastSpect  do		begin		SpinCursor;  		ByteCount := longint(Spectrum_Counter) * ( sizeof(Spectrum_Structure) +					 Longint(Plt_spec[10]^^.Expt_Info.Number_of_Channels) * 4 ) +					 sizeof(Expt_InfoRec) + sizeof(Plot_infoRec);		Spectrum_Counter := Spectrum_Counter +1; {# of spectrum info being written}		err := setfpos (Hold_RefNum,fsfromStart,bytecount );		bytecount := sizeof(Spectrum_Structure);		err := FSread (Hold_RefNum, bytecount, @Plt_Spec[10]^^.SpectrumStuff );		bytecount := Longint(Plt_spec[10]^^.Expt_Info.Number_of_Channels) * 4;		err := setfpos (Hold_RefNum, fsFromMark, bytecount );				  		numToString(Spectrum_Number, Str1);		IF Spectrum_Comment_Field = '' then str := CONCAT(Str1, ': No Comments')		ELSE str := CONCAT(Str1, ':   ', Spectrum_Comment_Field);		writeln(Plain, str);		IF (Spectrum_Class = '') or		   (Spectrum_Class = ' ') or		   (Spectrum_Class = '  ') or		   (Spectrum_Class = '   ') 		   then Str1 := 'Spectrum class: Empty.' 		ELSE Str1 := concat('Spectrum class: ',Spectrum_Class);		writeln(Plain, str1);		str5 := ' '; 		IF (Theoretically_Generated) THEN Str5 :=  ' Spectrum was generated; ' ;		IF (This_is_a_Standard) THEN Str5 := CONCAT(' Spectrum is a standard; ',str5);        IF (BkgSubtracted) THEN Str5 := CONCAT(' Spectrum was Background Subtracted; ',str5);		if ( Theoretically_Generated ) or 		   ( This_is_a_Standard ) or 		   ( BkgSubtracted ) then writeln(Plain, Str5);         SecondsToDate(Begin_Time,theDateTime);          writeln(Plain, ' The begin date and time were: ', DTRec2Str ); 				writeln(Plain, ' Live and Real Time: ', Live_Time: 6,'   ',Real_Time: 6);		writeln(Plain, ' Begin and End Faraday Current =  ', 						  Begin_Faraday: 6: 3,'   ',End_Faraday: 6: 3); 						          writeln(Plain, ' Min and Max Counts: ', Minimum_Counts,'   ',Maximum_Counts);        writeln(Plain, ' X Ray Take Off Angle: ', Take_Off_Angle:6:2,' degrees' );		str1 := '';		str2 := '';        if Specimen_Thickness <> 0 then Realtostring(Specimen_Thickness,5,4,str1);		if Specimen_Density <> 0 then Realtostring(Specimen_Density,5,2,str2);		if (Specimen_Thickness <> 0) or 		   (Specimen_Density <> 0) then 			str := CONCAT('Specimen Thickness is: ',str1,' and the Density is: ',str2);        writeln(Plain, str);				writeln(Plain, ' Spectrum_Type: ', Spectrum_Type );		writeln(Plain, ' X and Y Position: ', X_Position:6:2, '   ',Y_Position:6:2);				writeln(Plain, ' X and Y Tilt: ', X_Tilt:6:2, '   ',Y_Tilt:6:2, ' Degrees' );		writeln(Plain, ' Average Atomic Number: ', Average_Z:5:3 );		writeln(Plain, ' Number of Elements: ', Number_of_Elements );		for nn := 1 to 15 do 		 begin		  if (Element_Info[nn].Atomic_Number <> 0) then		  begin			writeln(Plain, 'Z', chr(9),'Wt. Fr.', chr(9),'Valence' );			leave;		  end;		 end;		for nn := 1 to 15 do 		 begin		  if (Element_Info[nn].Atomic_Number <> 0) then		  writeln(Plain,Element_Info[nn].Atomic_Number:2, 				  chr(9),Element_Info[nn].Weight_Fraction:7:6,				  chr(9),Element_Info[nn].Valence:5:3 );		 end;		(*		 					Plt_spec[10]^^.SpectrumStuff.Acq_Info.Slow_Channel_Counts					Plt_spec[10]^^.SpectrumStuff.Acq_Info.Medium_Channel_Counts					Plt_spec[10]^^.SpectrumStuff.Acq_Info.Fast_Channel_Counts					Plt_spec[10]^^.SpectrumStuff.Acq_Info.Begin_Time					  Plt_Spec[10]^^.SpectrumStuff.Acq_Info.Probed_Area		  		*)				writeln(Plain);					 end; { For Index := Plt_spec[10]^^.Expt_Info.FirstSpect to 										Plt_spec[10]^^.Expt_Info.LastSpect }	    end; { with }								err := FSClose(Hold_RefNum); { the MCA file being read }				err := FlushVol(NIL, Read_DTSA_Spec.vRefNum);  { the MCA vol being read }				ChangeCursor(ArrowC);				{PLFlush(plain);}								close(plain);				err := FlushVol(NIL, Out_VolRefNum);  { the vol header file written to }		        err := setvol(Save_Volume_Name,save_vol);	{restore the original volume}   END; { PROCEDURE Make_File_of_Headers;  }    BEGIN {Start of MAIN procedure}      HiliteMenu(theMenu);      FOR Index := 1 TO 10 DO        C_SPick[Index] := Index;      CASE theMenu OF {Do selected menu list}        L_Old_Fit:          BEGIN		  CASE theItem OF              C_Rename:                BEGIN                  mytype := 'MCAb';                  myprompt := 'Rename Binary Results';                  REPEAT                  UNTIL (GetFileName(MCA_ResultsName, mytype, mytype, myprompt) = True) OR (File_Cancel_Button = FALSE);         		  {...In_VolRefNum is vol refnum from GetFileName,				      Out_VolRefNum is vol refnum from Create}                  IF (File_Cancel_Button) THEN                    BEGIN                      if (CreateFile(Outname, 'The new name is') = True) OR (File_Cancel_Button = FALSE) then;                      IF (File_Cancel_Button) THEN                        BEGIN						  errCode := GetFInfo(Outname,Out_VolRefNum,fndrInfo);						  mm := fndrInfo.fdFldr; {get folder}						  errCode := GetFInfo(MCA_ResultsName,In_VolRefNum,fndrInfo);						  fndrInfo.fdFldr := mm;	{...to change to new folder}						  errCode := rename(MCA_ResultsName, In_VolRefNum, Outname);						  errCode := SetFInfo(Outname,In_VolRefNum,fndrInfo);                          errCode := FlushVol(NIL, In_VolRefNum);                        END;                    END;                END;              C_Output:	{Lose information about asciis 'open' when this is called}                BEGIN				  mytype := 'MCAb';				  myprompt := 'Fit File for Ascii output?';				  IF (MCA_File_Boolean) then				  begin					savename := MCA_ResultsName;					savevol := MCA_Results_VolNum;				  end;				  REPEAT				  UNTIL (GetFileName(MCA_ResultsName, mytype, mytype, myprompt) = True) OR 						(File_Cancel_Button = False);				  If (File_Cancel_Button) then				  Begin					IF (not MCA_File_Boolean) then					begin					  savename := MCA_ResultsName;					  savevol := MCA_Results_VolNum;					end;					If Plain_Options then					begin					  saveplain := PlainName;					  saveplainvol := Plain_VolNum;					  save_Plain := Plain_Options;					end;					If spread_boolean then					begin					  savespread := spreadName;					  savespreadvol := spread_VolNum;					  save_spread := spread_boolean;					end;					MCA_Results_VolNum := In_VolRefNum; 					binary_choice := FALSE; { so 'name the DTSA file' is not active}					D_Results_Options; {if...sets Plain_boolean=Plain_Options=T,					                    num_of_fits to 0!!!}					do_ascii := true;	{so write the whole file}					IF (Plain_boolean) OR (Spread_Boolean)					  THEN WriteFitResults;					do_ascii := FALSE;										IF savename <> MCA_ResultsName then					begin {in case we were doing an ascii add fit file}					  MCA_ResultsName := savename;					  MCA_Results_VolNum := savevol;					   If save_Plain then					   begin						 PlainName := saveplain;						 Plain_VolNum := saveplainvol;						 Plain_Options := save_Plain;					   end else begin					   	 Plain_boolean := FALSE;						 Plain_Options := FALSE;					   end;					   If save_spread then					   begin						 spreadName := savespread;						 spread_VolNum := savespreadvol;						 spread_boolean := save_spread;					   end else Spread_Boolean := FALSE;					END;					(*Putmessage(MCA_ResultsName,'is active.','Any ascii output is too.','');*)				  end;                END;              C_Show:	{keep info about asciis that are active}                BEGIN                  mytype := 'MCAb';                  myprompt := 'Show Fit File:';				  IF (MCA_File_Boolean) then				  begin					savename := MCA_ResultsName;					savevol := MCA_Results_VolNum;				  end;				  File_Cancel_Button := true;                  REPEAT                  UNTIL (GetFileName(MCA_ResultsName, mytype, mytype, myprompt) = True) OR				  		(File_Cancel_Button = FALSE);	{...cancel button  selected}                  IF (File_Cancel_Button) THEN                  BEGIN					  IF (not MCA_File_Boolean) then					  begin						savename := MCA_ResultsName;						savevol := MCA_Results_VolNum;					  end;                      MCA_Results_VolNum := In_VolRefNum;					 {if Plain_boolean and plain_options a plain file is					   being written to, if Plain_Options one can be reviewed ...					   WriteFitResults saves/restores the plain and spread booleans}					  save_Plain := false;					  If Plain_Options then					  begin						saveplain := PlainName;						saveplainvol := Plain_VolNum;						save_Plain := Plain_Options;					  end;					  Plain_Options := False; {so writeFitResults makes a default ascii display file}					  save_spread := spread_boolean;					  spread_boolean := false;					  see_fit := true; {writefitresults: write only whole acsii;					                    spreadsheet vals are not changed}					  WriteFitResults;{saves, sets booleans, restores saved}					  see_fit := false;					  ReviewFitResults(PlainName, Plain_VolNum);					  Plain_Options := save_Plain;					  spread_boolean := save_spread; {nothing done to name}					  If Plain_options {restore the previous plain file for whatever}					  then begin						PlainName := saveplain;						Plain_VolNum := saveplainvol;					  end;                    END;				  MCA_ResultsName := savename;				  MCA_Results_VolNum :=  savevol;                END; { C_Show:}              C_Append:                BEGIN                  mytype := 'MCAb';                  myprompt := 'Append binary Fit File:';                  REPEAT                  UNTIL (GetFileName(MCA_ResultsName, mytype, mytype, myprompt)) OR				        (File_Cancel_Button = FALSE);                  IF (File_Cancel_Button) THEN                    BEGIN					  Putmessage('Text files will not be appended.','Use Output Options under Fit Files',								 'to make new text/spreadsheet files for',MCA_ResultsName);                       BoolHolder := Hall_active;                (*   Hall_active := FALSE;*){WHY??? What if we've setup a Hall for the workfile?											 Make_Hall must be T also to write a Hall file}                      binary_choice := FALSE; { so 'name the DTSA file' is not active}                      MCA_Results_VolNum := In_VolRefNum;                      MCA_OptionsBoolean := FALSE; { we did not pick MCA name in MCA output options }                      MCA_File_Boolean := True; { the MCA file is selected }                      Plain_Options := FALSE;                       Plain_boolean := FALSE; 					  Spread_boolean := FALSE;					  num_of_fits := 1;	{this is incremented in Do_a_fit; spreadsheet col headers					  					  are written only when it is 1}                      Mouse_Active_Window;                    END;                END; { C_Append:}              END; { case }          END; { L_Old_Fit: }        L_Ml_References:          BEGIN            CASE theItem OF              C_New_File:                BEGIN                   append_ref := FALSE;				  if display_ref then ref_bool:= true else ref_bool := false;                  display_ref := FALSE;                   DoReferences;				  display_ref := ref_bool;                  Mouse_Active_Window; {finds the FrontWindow, sets (FW)Active true}                  UpDate_SiLi_Window(SiLiWindow); {the call makes SiLiWindow the whichwindow}                END;              C_Add_Ref:                BEGIN                   append_ref := True;				  if display_ref then ref_bool:= true else ref_bool := false;                  display_ref := FALSE;                   DoReferences;				  display_ref := ref_bool;                  Mouse_Active_Window; {finds the FrontWindow, sets (FW)Active true}                  UpDate_SiLi_Window(SiLiWindow); {the call makes SiLiWindow the whichwindow}                END;              C_Display_Ref:                BEGIN                  append_ref := FALSE;                  display_ref := True;                 { MCA_Spectrum_Active := FALSE;} {this should go in DoReferences...}                  DoReferences;                   {Mouse_Active_Window;} {finds the FrontWindow, sets (FW)Active true}                  UpDate_SiLi_Window(SiLiWindow); {the call makes SiLiWindow the whichwindow}                END;              C_Flowchart:                BEGIN                  Flow_chart(436);                END;              C_RefHelp:                BEGIN                  Ref_Help;                END;              OTHERWISE                BEGIN                END;              END;          END;        L_MCA_Setups:          BEGIN            CASE theItem OF              C_Save_Setup_toDisk:                BEGIN                  Write_Preferences; { tools }                  Update_Full;                  Mouse_Active_Window;                  { Update_Full;}                END;              C_Get_Setup_FromDisk:                BEGIN                  Get_Preferences;                  Mouse_Active_Window;                END;              C_Save_Setup_2:                BEGIN                  Pref_Name := 'Prefs1';                  SavePreferences;                  Mouse_Active_Window;                END;              C_Get_Setup_2:                BEGIN                  Pref_Name := 'Prefs1';                  GetPreferences;                  { Mouse_Active_Window;}                END;              C_Save_Setup_3:                BEGIN                  Pref_Name := 'Prefs2';                  SavePreferences;                  { Mouse_Active_Window;}                END;              C_Get_Setup_3:                BEGIN                  Pref_Name := 'Prefs2';                  GetPreferences;                  Mouse_Active_Window;                END;              Setup_Help:                BEGIN                  putmessage('A "Preference" File stores values for most DTSA variables: colors, kV, etc.',				             'These values are saved to "Preferences.MCA" every time you exit the program and',                              'read back when the program starts. Current values may be saved or read at any',                             'time to or from files you name or default files named "Prefs1" and "Prefs2".');                END;              END;          END;        L_ZAF_submenu:          BEGIN            CASE theItem OF              C_ZAF_Flowchart:                BEGIN                  Flow_chart(437);                END;              C_ZAF_Create_File:                BEGIN                  IF NOT ZAF_Active THEN                    BEGIN                      ZAF_Active := True;                      Hall_active := FALSE;                      ZAF_Run := FALSE;                      Whole_Cell_Active := FALSE;					  IF (Cliff_Lorimer_Active) then begin                      						 H_UnLock_Dispose(Handle(CL_Output),'CL_Output in Menus_D');                      	 Cliff_Lorimer_Active := FALSE;					  end;                      Standardless_Active := FALSE;					  CitZAF_Active       := FALSE;                      Mouse_Active_Window;					  Test_a_Handle(Handle(ZAF_Record),'ZAF_Record, in C_ZAF_Create_File: in menus.p');                      ZAF_Record := ZAF_fullHdl(NewHandle(sizeof(ZAF_full)));                      IF FreeMem < sizeof(ZAF_full) THEN                        BEGIN                          putmessage('Not enough memory available to run program at ZAF_Setup', '', '', '');                          Halt;                        END;                      ReserveMem(sizeof(ZAF_Record)); { Reserve memory near the beginning of heap }                      HLock(Handle(ZAF_Record));                    END; { if not ZAF_Active then... }                  D_Add_standard;                END;              C_Review_std_file:                BEGIN					Review_standard;                END;              C_ZAF:                BEGIN				(*IF (NOT Simplex_active) AND (NOT LLSQ_active) THEN				  BEGIN					BeepBeep;					Putmessage('You have not chosen and setup a fitting procedure.',							   'Setup either Linear Least Squares (LLSQ) or the Simplex', 							   'before doing quantitative analysis.', '');					Fit_Invisibly := False;					exit(Handle_My_Menu);				  END; *)                 				                  IF NOT ZAF_Active THEN                    BEGIN                      ZAF_Active := True;                      Hall_active := FALSE;                      Whole_Cell_Active := FALSE;					  IF (Cliff_Lorimer_Active) then begin                      						 H_UnLock_Dispose(Handle(CL_Output),'CL_Output in Menus_D');                      	 Cliff_Lorimer_Active := FALSE;					  end;                      Standardless_Active := FALSE;					  CitZAF_Active       := FALSE;                      Mouse_Active_Window;					  Test_a_Handle(Handle(ZAF_Record),'ZAF_Record, in L_Analysis: in menus.p');                      ReserveMem(sizeof(ZAF_full));                      ZAF_Record := ZAF_fullHdl(NewHandle(sizeof(ZAF_full))); { @## bob's for ZAF }                      IF FreeMem < sizeof(ZAF_full) { @## bob's for ZAF }                         THEN                        BEGIN                          putmessage('Not enough memory available to run program at ZAF_Setup', '', '', '');                          Halt;                        END;                      MoveHHi(Handle(ZAF_Record));                      HLock(Handle(ZAF_Record));                      ZAF_Record^^.Num_Fit_Peaks := 0;                    END; { if not ZAF_Active then... }                  D_DialZAF;                END;              END;          END; { L_ZAF_submenu.... }		  					L_Qual_output_1:			BEGIN			  CASE theItem OF			  	C_Title_1:			  	  BEGIN			  	  	putmessage('Choose one of the two spreadsheet options appearing below in this menu.',			  	  			   '"All Lines found" will make a spreadsheet with a column for EVERY line found ',			  	  			   'in the spectrum file. "DTSA Subset" will make a spreadsheet with only one ',			  	  			   'or two columns for EACH ELEMENT found in the spectrum file.');			  	  			  	  END;			    C_All_Lines_1:				  BEGIN				  	Qual_DTSA_True := false;				    dummy_boolean := false;				    Spec_Displayed := 1; 				    Qual_Run;				  END;				C_DTSA_Set_1:				  BEGIN				  	Qual_DTSA_True := true;				    dummy_boolean := false;				    Spec_Displayed := 1; 				    Qual_Run;									  END;			  END;		{CASE theItem OF}			END;		L_Qual_output_2:			BEGIN			  CASE theItem OF			  	C_Title_2:			  	  BEGIN			  	  	putmessage('Choose one of the two spreadsheet options appearing below in this menu.',			  	  			   '"All Lines found" will make a spreadsheet with a column for EVERY line found ',			  	  			   'in the spectrum file. "DTSA Subset" will make a spreadsheet with only one ',			  	  			   'or two columns for EACH ELEMENT found in the spectrum file.');			  	  			  	  END;			    C_All_Lines_2:				  BEGIN				  	Qual_DTSA_True := false;				    If MCA_Spectrum_Active then					  begin						dummy_boolean := true;						Qual_Run;					  end				    else if answermessage('There is no DTSA file open to qual.',							   		'If IT`S OK I`ll let you pick a file to qual.',							   		'If IT`S NOT OK, please use Peak ID to qual',							   		'only the displayed spectrum.')					  then begin							dummy_boolean := false;							Qual_Run;					 end;				  END;				C_DTSA_Set_2:				  BEGIN				  	Qual_DTSA_True := true;				    If MCA_Spectrum_Active then					  begin						dummy_boolean := true;						Qual_Run;					  end				    else if answermessage('There is no DTSA file open to qual.',							   		'If IT`S OK I`ll let you pick a file to qual.',							   		'If IT`S NOT OK, please use Peak ID to qual',							   		'only the displayed spectrum.')					  then begin							dummy_boolean := false;							Qual_Run;					 end;									  END;			  END;		{CASE theItem OF}			END;		  		L_Stdlss_submenu:		  BEGIN		    CASE theItem OF			  C_Do_Standardless:			    BEGIN				IF (NOT Simplex_active) AND (NOT LLSQ_active) THEN				  BEGIN					BeepBeep;					Putmessage('You have not chosen and setup a fitting procedure.',							   'Setup either Linear Least Squares (LLSQ) or the Simplex', 							   'before doing quantitative analysis.', '');					Fit_Invisibly := False;					exit(Handle_My_Menu);				  END;                                    IF NOT ZAF_Active THEN                    BEGIN                      ZAF_Active := True;                       Hall_active := FALSE;                      Whole_Cell_Active := FALSE;					  IF (Cliff_Lorimer_Active) then begin                      						 H_UnLock_Dispose(Handle(CL_Output),'CL_Output in Menus_D');                      	 Cliff_Lorimer_Active := FALSE;					  end;                      Standardless_Active := True;					  CitZAF_Active       := FALSE;					  Test_a_Handle(Handle(ZAF_Record),'ZAF_Record, in C_Standardless_Miracle: in menus.p');                      ZAF_Record := ZAF_fullHdl(NewHandle(sizeof(ZAF_full))); { @## bob's for ZAF }                      IF FreeMem < sizeof(ZAF_full) { @## bob's for ZAF }                         THEN                        BEGIN                          putmessage('Not enough memory available to run program at ZAF_Setup', '', '', '');                          Halt;                        END;                      MoveHHi(Handle(ZAF_Record));                      HLock(Handle(ZAF_Record));                      ZAF_Record^^.Num_Fit_Peaks := 0;                    END; { if not ZAF_Active then... }                  start_stdless;								END;			  C_Stdlss_Flowchart:			    BEGIN				  Flow_chart(439);				END;			END;  { CASE }		  END;  { L_Stdlss_submenu }		          L_CITZAF_submenu:          BEGIN            CASE theItem OF              C_ZAF_Flowchart:                BEGIN                  {Flow_chart(437);}                END;              C_CITZAF_Create_File:                BEGIN                  IF NOT ZAF_Active THEN                    BEGIN                      ZAF_Active := True;                      Hall_active := FALSE;                      ZAF_Run := FALSE;                      Whole_Cell_Active := FALSE;					  IF (Cliff_Lorimer_Active) then begin                      						 H_UnLock_Dispose(Handle(CL_Output),'CL_Output in Menus_D');                      	 Cliff_Lorimer_Active := FALSE;					  end;                      Standardless_Active := FALSE;					  CitZAF_Active       := FALSE;                      Mouse_Active_Window;					  Test_a_Handle(Handle(ZAF_Record),'ZAF_Record, in C_ZAF_Create_File: in menus.p');                      ZAF_Record := ZAF_fullHdl(NewHandle(sizeof(ZAF_full)));                      IF FreeMem < sizeof(ZAF_full) THEN                        BEGIN                          putmessage('Not enough memory available to run program at ZAF_Setup', '', '', '');                          Halt;                        END;                      ReserveMem(sizeof(ZAF_Record)); { Reserve memory near the beginning of heap }                      HLock(Handle(ZAF_Record));                    END; { if not ZAF_Active then... }                  D_Add_standard;                END;              C_CITZAF_Review_std_file:                BEGIN					Review_standard;                END;              C_CITZAF:                BEGIN								if not CitZAF_Active then		         begin				 First_Time                   := True;{ allows only one pass thru setup stuff}				 CIT_Initialized              := False;				 Close_CITZAF;				 ZAF_Active                   := False;				 Hall_Active                  := False;				 Whole_Cell_Active            := False;				  IF (Cliff_Lorimer_Active) then begin                      					 H_UnLock_Dispose(Handle(CL_Output),'CL_Output in Menus_D');					 Cliff_Lorimer_Active := FALSE;				  end; 				 Standardless_Active          := False;				 CitZAF_Active                := TRUE;				 Mouse_Active_Window;				 Test_a_Handle(Handle(ZAF_Record),'ZAF_Record in C_CITZAF in menus.p');				 ReserveMem(SizeOf(ZAF_full));				 ZAF_Record := ZAF_fullHdl(NewHandle(SizeOf(ZAF_full)));	                  IF FreeMem < SizeOf(ZAF_full)								 				 THEN				   BEGIN					 PutMessage('Not enough memory available to run program at ZAF_Setup',					            '', '', '');					 Halt;				   END;				 	MoveHHi(Handle(ZAF_Record));   					HLock(Handle(ZAF_Record));					ZAF_Record^^.Num_Fit_Peaks := 0;				 end; { if not CitZAF_Active then... }				 CIT_Unanalyzed_Element;                END;              END;          END; { L_CITZAF_submenu.... }          				  	L_EDS_QC:          BEGIN            CASE theItem OF	  		C_Setup_QC:	  			BEGIN	  				Setup_the_QC;	{dialog ID = 138}	  			END;	  		C_Run_QC:	  			BEGIN	  				Run_the_QC;		{dialog ID = 137}	  			END;	  		END;  { CASE }	  	  END;	{L_EDS_QC_submenu.... }		  {CheckItem(MenuHandle theMenu,short item,Boolean checked)}		  		L_Label_Fonts:			BEGIN			  CASE theItem OF			    C_9:				  begin				    LabelSize := 9;					for nindex := 1 to 6 do CheckItem(M_Label_Fonts,nindex,false);					CheckItem(M_Label_Fonts,theItem,true);				  end;				C_10:				  begin				    LabelSize := 10;					for nindex := 1 to 6 do CheckItem(M_Label_Fonts,nindex,false);					CheckItem(M_Label_Fonts,theItem,true);									  end;			    C_12:				  begin				    LabelSize := 12;					for nindex := 1 to 6 do CheckItem(M_Label_Fonts,nindex,false);					CheckItem(M_Label_Fonts,theItem,true);				  end;			    C_14:				  begin				    LabelSize := 14;					for nindex := 1 to 6 do CheckItem(M_Label_Fonts,nindex,false);					CheckItem(M_Label_Fonts,theItem,true);				  end;			    C_18:				  begin				    LabelSize := 18;					for nindex := 1 to 6 do CheckItem(M_Label_Fonts,nindex,false);					CheckItem(M_Label_Fonts,theItem,true);				  end;			    C_24:				  begin				    LabelSize := 24;					for nindex := 1 to 6 do CheckItem(M_Label_Fonts,nindex,false);					CheckItem(M_Label_Fonts,theItem,true);				  end;				END;  { CASE }				Update_Full;			END; { L_Label_Fonts.... }		L_Show_Headers:			BEGIN				FOR Index := 1 TO 10 DO				IF theItem = C_SPick[Index] THEN				BEGIN					IF Header_Info_Window <> NIL THEN					BEGIN						DisposeWindow(Header_Info_Window);						Header_Info_Window := NIL;					END;					IF Index = 1 THEN mm := 10					ELSE IF Index = 2 THEN mm := 9					ELSE mm := Index - 2;					Open_Header_Information(mm);				END;	{ FOR Index := 1 TO 10...}			END;	{CASE theMenu OF is the master case...}        L_CliffLorimer:          BEGIN            CASE theItem OF              C_KFactors:                BEGIN					CLKfact;                END;              C_KFile:                BEGIN					CLKFile;                END;               C_Setup:                BEGIN				    beepbeep;					D_DialCL;                END;              C_Results:                BEGIN					CLResults(false);{then show_one in CL is false}                END;			  C_CLOutput:                BEGIN				    Do_CLOutput := true;					CLOutput;                END;              C_Help:                BEGIN				    CLHelp;                END;            END;        END;                L_Hall_Analysis:          BEGIN            CASE theItem OF              C_HallQuant:                BEGIN					D_DialHall;                END;              C_HallFile:                BEGIN					Show_Hall;                END;               C_HallSetup:                BEGIN					Show_HallSetup;                END;              C_HallHelp:                BEGIN					Hall_Help;                END;            END;	{Case...}        END;	{LHallAnalysis}        L_Apple:          BEGIN            CASE theItem OF {Handle all commands in this menu list}              C_About_MCA:                BEGIN                   Show_About;		{in Tools}				   CompactMemory;				   Show_Disclaimer;		{in Tools}				 END;              OTHERWISE {DAs}                BEGIN {Start of Otherwise}                  GetPort(GrafPtr(SavePort));                  GetMenuItemText(AppleMenu, theItem, DAName); {Get the name of the DA selected}                  DNA := OpenDeskAcc(DAName); {Open the DA selected}                  SetPort(GrafPtr(SavePort));                END; {End of Otherwise}              END; {End of item case}          END; {End for this list}{RLM}	L_ImportPlugins:BEGIN (*{RLM}		CheckItem(GetMenu(228),gImpCurrentPlugIn,FALSE);{RLM}		gImpCurrentPlugIn:=theItem;{RLM}		CheckItem(GetMenu(228),gImpCurrentPlugIn,TRUE); *){RLM}		IF (CFilePlugIns(ImpFile,theItem)) then begin{RLM}		Refresh_ROIs;{RLM}		Update_Full;{RLM}		end;			{RLM}   END; {L_ImportPlugins}{RLM}	L_ExportPlugins:BEGIN (*{RLM}		CheckItem(GetMenu(229),gExpCurrentPlugIn,FALSE);{RLM}		gExpCurrentPlugIn:=theItem;{RLM}		CheckItem(GetMenu(229),gExpCurrentPlugIn,TRUE); *){RLM}		IF (CFilePlugIns(ExpFile,theItem)) then begin{RLM}		Refresh_ROIs;{RLM}		Update_Full;{RLM}		end;{RLM}   END; {L_ExportPlugins}        L_Manage:          BEGIN            CASE theItem OF {Handle all commands in this menu list}              C_Get_MCASpectrum_from_Disk:                BEGIN                  display_ref := FALSE;                  ReadFromFile;                  CompareGen_To_Work(theBGRec); { theGenRec has what made the current response function }				  IF Calibrate_Energy_Scale then begin					if File_Calibration = true then begin						Cal_vals.Energy_Slope := Plt_Spec[10]^^.Expt_Info.Energy_Slope;						Cal_vals.Energy_Intercept := Plt_Spec[10]^^.Expt_Info.Energy_Intercept;						DrawLeftHL;						Markers;					  end					 else begin					 	if ((Cal_vals.Energy_Slope <> Plt_Spec[10]^^.Expt_Info.Energy_Slope) OR							(Cal_vals.Energy_Intercept <> Plt_Spec[10]^^.Expt_Info.Energy_Intercept)) then begin								putmessage('The calibration MUST be checked!',									'The Calibration data stored with these spectra do NOT agree',									'with the the current Calibration data.',									'You should click CALIBRATE and select the appropriate data.');						end;					  end;					end;                  Mouse_Active_Window;                END;              C_Save_MCASpectrum_to_Disk:                BEGIN                  Plt_spec[10]^^.Expt_Info.spare2 := false;                    WriteToFile(10);							{еее2/7/96 select the spectrum to writeеее}                  Mouse_Active_Window;                  IF Ready_to_Save_WDS THEN                    BEGIN                      Plt_Spec[10]^^.Expt_Info.Number_of_Channels := WDS_ChanNum_Holder;                      Ready_to_Save_WDS := FALSE;                    END;                 END;              C_Append_Spectrum_to_Disk:                BEGIN                  AppendDTSA;                END;              C_Save_Spreadsheet:                BEGIN                  ASCII_Out_finished := FALSE;                  D_ASCII_FORMAT;                END;              C_MCA_Setups:                BEGIN                  {Link to a hier menu}                END;              C_Plot_Symbols:                BEGIN                  D_Plot_Symbols;                  Mouse_Active_Window;                END;              C_Label_Fonts:                BEGIN                  putmessage('Not active in this version. This feature will "Simplify" the',                             'program by hiding all the advanced features.', '', '');                  CheckItem(ManageMenu, Expert_Mode, Expert); { Un Check }                END;              C_Show_active_DTSA_files: {ееShow active DTSA files}                BEGIN                  putmessage('The DTSA file active for reading is:', Read_DTSA_Spec.name,                             'The active file for saving into is:', Write_DTSA_Spec.name);                END;                C_PrinterSetup:                BEGIN                  GetPort(GrafPtr(SavePort));                  PrOpen;				  theError := PrError;				   IF theError <> noErr THEN PrClose; { Close the Printing Manager before attempting to report the error.}					  numtostring(theError,str1);					  str := 'Unknown Error';					 if theError = -1  then str := 'saving print file';					 if theError = -17 then str := 'unimplemented control instruction';					 if theError = -27 then str := 'I/O error';					 if theError = -108 then str := 'not enough room in heap zone';					 if theError = 128 then str := 'application or user requested abort';					 if theError = -4101  then str := 'Printer not found or closed';					 if theError = -4100  then str := 'Connection just closed';					 if theError = -4099  then str := 'Write request too big ';					 if theError = -4098  then str := 'Request already active';					 if theError = -4097  then str := 'Bad connection refnum';					 if theError = -4096  then str := 'No free CCBs (Connect Control Blocks) available';					 if theError = -8133  then str := 'PostScript error occurred during transmission';					 if theError = -8132  then str := 'Timeout occured.';				  IF theError <> noErr THEN putmessage('There was trouble getting a print record at 4, the message was:',							 str,'The number was',str1);				  IF theError = noErr THEN                    BEGIN                      IF NOT PrStlDialog(thePrRec) THEN                        BEGIN                          HiliteMenu(0);                          exit(Handle_My_Menu);                        END;                      IF NOT PrJobDialog(thePrRec) THEN                        BEGIN                          HiliteMenu(0);                          exit(Handle_My_Menu);                        END;						 { SavePrintRecord(thePrRec, MCA_Home_Res_RefNum); } 						  PrintStuff; 						  Mouse_Active_Window;						  ChangeCursor(ArrowC);                     END;				  PrClose;	                  SetPort(GrafPtr(SavePort));                  Mouse_Active_Window;				  ChangeCursor(ArrowC);                 END;              C_PrintSpectra:                BEGIN				  PrOpen;	                  PrintStuff;				  PrClose;	                  Mouse_Active_Window;				  ChangeCursor(ArrowC);                END;              C_PrintAllSpectra:                BEGIN                  abort_x := FALSE; { For the cntl "." exit test logic }                  UnCheck_AllSpectra;                  Spectrum_Full[10] := True;                  CheckItem(FullMenu, A^.C_Full[10], Spectrum_Full[10]);                  Spectrum_Counter := 0;                  FOR Index := Plt_Spec[10]^^.Expt_Info.FirstSpec TO Plt_Spec[10]^^.Expt_Info.LastSpect DO                    BEGIN                      bytecount := longint(Spectrum_Counter) * (sizeof(Spectrum_Structure) + LongInt(Plt_Spec[10]^^.Expt_Info.                                   Number_of_Channels) * 4) + sizeof(Expt_InfoRec) + sizeof(Plot_infoRec);                      Spectrum_Counter := Spectrum_Counter + 1; {# of spectrum displayed}					  		errCode := FSpOpenDF(Read_DTSA_Spec, fsRdWrPerm, refnum);							RdBinaryName := Read_DTSA_Spec.name;                      IF errCode <> noErr THEN                        BEGIN                          BeepBeep;                          putmessage('An MCA File of Spectra has not been read from disk, or', 'created by the program'                                     , '', '');                          HiliteMenu(0);						  ChangeCursor(ArrowC);                          exit(Handle_My_Menu);                        END                      ELSE                        BEGIN                          errCode := setfpos(refnum, fsFromstart, bytecount);                          bytecount := sizeof(Spectrum_Structure);                          errCode := FSRead(refnum, bytecount, @Plt_Spec[10]^^.SpectrumStuff);                          bytecount := LongInt(Plt_Spec[10]^^.Expt_Info.Number_of_Channels) * 4;                          errCode := FSRead(refnum, bytecount, @Plt_Spec[10]^^.S);                        END;                      errCode := FSClose(refnum);                      errCode := FlushVol(NIL, Read_DTSA_Spec.vRefNum);                      IF abort_x = True THEN exit(Handle_My_Menu); { allows cntl "." out of this loop}                      abort_x := Interrupted;                      Update_Full;                      OffScreen_2_OnScreen;                      IF abort_x = True THEN exit(Handle_My_Menu);                  PrOpen;	                  PrintStuff;				  PrClose;	                    END; { For Index := Plt_spec[10]^^.Expt_Info.FirstSpect to Plt_spec[10]^^.Expt_Info.LastSpect }                  Mouse_Active_Window;				  ChangeCursor(ArrowC);                END;               C_FileofHeaders: Make_File_of_Headers;			  			                 C_Quit:                BEGIN                  doneFlag := True;				  Pref_Name:= 'Preferences.MCA';				  Pref_VolNum := 0;				  SavePreferences;                 END;				              OTHERWISE                BEGIN                END;              END; {End of item case}          END; {End for this list}		L_Edit:		  BEGIN		  	CASE theItem OF			  C_Undo:			    BEGIN								END;			  C_Cut:			    BEGIN								END;			  			  C_Copy:			    BEGIN								END;			  			  C_Paste:			    BEGIN								END;			  			  C_Clear:			    BEGIN								END;			  			              END; {End of item case}		  		  END; {End for this list}        L_Generate:          BEGIN            BoolHolder := SystemEdit(theItem - 1); {Do DA editing}			IF NOT (BoolHolder) THEN {If not a DA then we get it}              BEGIN                CASE theItem OF                  C_Peaks_Manually:                    BEGIN                      D_Peak_Information;					  Update_Full;                    END;                  C_Noise_Spectra:                    BEGIN                      D_Noise_Spectra;                      Mouse_Active_Window;					  Update_Full;                    END;                  C_Thin_Spectrum:                    BEGIN					  BG_Active := FALSE;                       Running_Thin_Mode := True;                      Running_Bulk_Mode := FALSE;                      D_Generate_Input;                      IF Quick_Exit = FALSE THEN                        BEGIN                          If Thin_Wk_Choice > 0 then Spectrum_Choice(Thin_Wk_Choice, 10);                          If Thin_Rslt_Choice > 0 then Spectrum_Choice(Thin_Rslt_Choice, 9);                          If Thin_S1_Choice > 0 then Spectrum_Choice(Thin_S1_Choice, 1);                          If Thin_S2_Choice > 0 then Spectrum_Choice(Thin_S2_Choice, 2);                          If Thin_S3_Choice > 0 then Spectrum_Choice(Thin_S3_Choice, 3);                          If Thin_S4_Choice > 0 then Spectrum_Choice(Thin_S4_Choice, 4);                          If Thin_S5_Choice > 0 then Spectrum_Choice(Thin_S5_Choice, 5);                          If Thin_S6_Choice > 0 then Spectrum_Choice(Thin_S6_Choice, 6);                          If Thin_S7_Choice > 0 then Spectrum_Choice(Thin_S7_Choice, 7);                          If Thin_S8_Choice > 0 then Spectrum_Choice(Thin_S8_Choice, 8);                        END;                        Update_Full;                    END;                  C_Bulk_Spectrum:                    BEGIN                      Running_Thin_Mode := FALSE;                      Running_Bulk_Mode := True;					  BG_Active := FALSE;                       D_Generate_Input;                       IF Quick_Exit = FALSE THEN                        BEGIN                          If Bulk_Wk_Choice > 0 then Spectrum_Choice(Bulk_Wk_Choice, 10);                          If Bulk_Rslt_Choice > 0 then Spectrum_Choice(Bulk_Rslt_Choice, 9);                          If Bulk_S1_Choice > 0 then Spectrum_Choice(Bulk_S1_Choice, 1);                          If Bulk_S2_Choice > 0 then Spectrum_Choice(Bulk_S2_Choice, 2);                          If Bulk_S3_Choice > 0 then Spectrum_Choice(Bulk_S3_Choice, 3);                          If Bulk_S4_Choice > 0 then Spectrum_Choice(Bulk_S4_Choice, 4);                          If Bulk_S5_Choice > 0 then Spectrum_Choice(Bulk_S5_Choice, 5);                          If Bulk_S6_Choice > 0 then Spectrum_Choice(Bulk_S6_Choice, 6);                          If Bulk_S7_Choice > 0 then Spectrum_Choice(Bulk_S7_Choice, 7);                          If Bulk_S8_Choice > 0 then Spectrum_Choice(Bulk_S8_Choice, 8);                        END;                        Update_Full;                    END;                  C_Last_Gen_to_Work:                    BEGIN                      IF ( Composite_P^[100] = 0.0) THEN                        BEGIN                          putmessage('There is no generated spectrum available to load', '', '', '');                          exit(Handle_My_Menu);                        END; 					  BlockMove(@Composite_P^,@Plt_Spec[10]^^.S,SizeOf(Plt_Spec[10]^^.S));                      Update_max_min(10);                      Update_Full;                    END;                  OTHERWISE {Send to a DA}                    BEGIN {Start of the Othersize}                    END; {End of Otherwise}                  END; {End of item case}              END; {End of not BoolHolder}          END; {End for this list}        L_Analysis: {ее Now Analysis }          BEGIN				            CASE theItem OF {Handle all commands in this menu list}						C_ZAF_Menu:                BEGIN				  {Link to a hier menu}                END;             C_CliffLorimer:                BEGIN				  {Link to a hier menu}                END;              C_Standardless_Miracle:                BEGIN				  {Link to a hier menu}                END;              C_Hall_Analysis:                BEGIN				{Link to a hier menu 9/96}			   (* IF ZAF_Active THEN                  H_UnLock_Dispose( Handle(ZAF_Record),'ZAF_Record in C_Hall_Analysis in menus.p' );                  				  ZAF_Active := FALSE;                  Whole_Cell_Active := FALSE;				  IF (Cliff_Lorimer_Active) then begin                      					 H_UnLock_Dispose(Handle(CL_Output),'CL_Output xx');					 Cliff_Lorimer_Active := FALSE;				  end;                  Standardless_Active := FALSE;				  CitZAF_Active       := FALSE;                  D_DialHall;                  Mouse_Active_Window;*)                END;							  C_Curve_Fit_Auto_Run:		{***11/18/92***}                BEGIN				  Auto_Run;                END; {C_Curve_Fit_Auto_Run}							  C_Qual_Analysis:	{Link to a hier menu L_Qual_output_1}	{ееееcheck thisееее}                BEGIN				 { dummy_boolean := false;				  Spec_Displayed := 1; 				  Qual_Run;}                END;			  							  C_Qual_Work:	{Link to a hier menu L_Qual_output_2}	{ееееcheck thisееее}                BEGIN				 { If MCA_Spectrum_Active then				  begin				  	dummy_boolean := true;					Qual_Run;				  end				  else if answermessage('There is no DTSA file open to qual.',							   		'If IT`S OK I`ll let you pick a file to qual.',							   		'If IT`S NOT OK, please use Peak ID to qual',							   		'only the displayed spectrum.')				  then begin						dummy_boolean := false; 				  		Qual_Run;				  end;}                END;			  				              C_CITZAF_Menu:                BEGIN				  {Link to a hier menu}                END;							  C_EyeChi:			{ Use this to call the EyeChi routine }                BEGIN				  Open_Strip_Peak;				  Mouse_Active_Window;                                    END;				              C_EDS_QC:                BEGIN				  {Link to a hier menu}                 END;				              C_Deactivate:			    BEGIN			  		Kill_Quants;	{in Global_Functions}                END;              OTHERWISE                BEGIN                END;              END; {End of item case}          END; {End for this list}        L_Math:          BEGIN            CASE theItem OF {Handle all commands in this menu list}              C_Clear_Work:                BEGIN                  ClearWork;                END;              C_Clear_Results:                BEGIN                  IF AnswerMessage('Are you sure you want to clear the RESULTS spectrum???',                                   'This operation erases the channel contents, but leaves',                                   'the header information intact.', '') THEN                    BEGIN 					  For nn := 1 to Maximum_Channels do Plt_Spec[9]^^.S[nn] := 0.0;                      Plt_Spec[9]^^.SpectrumStuff.Spectrum_Info.Maximum_Counts := zero;                      Plt_Spec[9]^^.SpectrumStuff.Spectrum_Info.Minimum_Counts := zero;                      Refresh_ROIs;                      Update_Full;                    END;                END;              C_Clear_ALL:                BEGIN                  BeepBeep;                  IF AnswerMessage('Are you sure you want to clear ALL spectra???',                                   'This operation erases the channel contents, but leaves',                                   'the header information intact.', '') THEN                    BEGIN                      FOR nn := 1 TO 10 DO                        BEGIN 						  For Index := 1 to Maximum_Channels do Plt_Spec[nn]^^.S[Index] := 0.0;						  For Index := 1 to Maximum_Channels do Plt_Spec[nn]^^.S[Index] := 0.0;                          Plt_Spec[nn]^^.SpectrumStuff.Spectrum_Info.Maximum_Counts := zero;                          Plt_Spec[nn]^^.SpectrumStuff.Spectrum_Info.Minimum_Counts := zero;                        END;                      Refresh_ROIs;                      Update_Full;                      SpecWork_has_been_Changed := True;					  					  For nn := 1 to Maximum_Channels do 					  begin					    Col_1^[nn] := 0.0;                        Col_2^[nn] := 0.0;						Col_3^[nn] := 0.0;						Col_4^[nn] := 0.0;						Col_5^[nn] := 0.0;						Col_6^[nn] := 0.0; 					  end;                     END;                END;              C_Add_Work_To_Results:                BEGIN                  FOR Index := 1 TO Spectrum_Size DO                    Plt_Spec[9]^^.S[Index] := Plt_Spec[9]^^.S[Index] + Plt_Spec[10]^^.S[Index];                  Spectrum_Full[9] := True;                  Spectrum_Full[10] := True;                  CheckItem(FullMenu, A^.C_Full[9], Spectrum_Full[9]);                  CheckItem(FullMenu, A^.C_Full[10], Spectrum_Full[10]);                  Update_max_min(9);                  Update_Full;                END;              C_Add_Poisson_Noise_to_Work:                BEGIN                   { Put a copy of the header stuff in first }				  BlockMove(@Plt_Spec[10]^^,@Plt_Spec[9]^^,SizeOf(Plt_Spec[10]^^));                  Add_Noise;                  Spectrum_Full[9] := True;                  Spectrum_Full[10] := True;                  CheckItem(FullMenu, A^.C_Full[9], Spectrum_Full[9]);                  CheckItem(FullMenu, A^.C_Full[10], Spectrum_Full[10]);                  Update_max_min(9);                  Refresh_ROIs;                  Update_Full;                END;              C_Measure_Beam_Energy:                BEGIN                  IF (Plt_Spec[10]^^.S[50] = 0) AND (Plt_Spec[10]^^.S[100] = 0) AND {``}                     (Plt_Spec[10]^^.S[200] = 0) THEN                    BEGIN                      BeepBeep;                      putmessage('There is no Spectrum in "Work" ', '', '', '');                    END { if (Plt_spec[10]...}                  ELSE                    WITH Plt_Spec[10]^^.Expt_Info DO                      BEGIN                        IF (Number_of_Channels * dE * 0.001 < kV) THEN                          BEGIN                            IF AnswerMessage('Hmmm, this calculation may not be possible because',                                             'the spectrum was saved to less than the beam voltage.',                                             'If you`re sure the spectrum goes to zero rather than truncates',                                             'hit IT`S OK, but if you`re wrong I may crash.') THEN                              Duane_Hunt;                          END { If (number_of_channels ...}                        ELSE Duane_Hunt;                      END; { else with...}                  Mouse_Active_Window;                  {Update_Full;}                END;              C_WDS_to_EDS:                BEGIN                  IF WDS_Active = FALSE THEN                    putmessage('You must have a WDS spectrum ready to convert.', 'If you do, make sure that WDS is on',                               'in the Experiment Header', '')                  ELSE D_WDS; {in Utilities}                  Mouse_Active_Window;                END;              C_Smooth:                BEGIN                  KludgeBoolean := FALSE;                  D_Smooth_Options;                  Mouse_Active_Window;                  IF KludgeBoolean = FALSE THEN                    BEGIN                       { Put a copy of the header stuff in first }					  BlockMove(@Plt_Spec[10]^^,@Plt_Spec[9]^^,SizeOf(Plt_Spec[9]^^));                      Spectrum_Full[9] := True;                      Spectrum_Full[10] := True;                      CheckItem(FullMenu, A^.C_Full[9], Spectrum_Full[9]);                      CheckItem(FullMenu, A^.C_Full[10], Spectrum_Full[10]);                      Smooth;                      Update_Full;                    END;                END;              C_Digital_Filter:                BEGIN                  KludgeBoolean := FALSE;                  D_Digital_Filter_Param;                  Mouse_Active_Window;                  IF KludgeBoolean = FALSE THEN                    BEGIN                      BlockMove(@Plt_Spec[10]^^,@Plt_Spec[9]^^,SizeOf(Plt_Spec[9]^^)); { Put a copy of the header stuff in first } 					  BlockMove(@Plt_Spec[10]^^.S,@Col_1^,SizeOf(Col_1^));                      Digital_Filter; { works in and out of Col_1^ } 					  BlockMove(@Col_1^,@Plt_Spec[9]^^.S,SizeOf(Plt_Spec[9]^^.S));                      Spectrum_Full[9] := True;                      Spectrum_Full[10] := True;                      CheckItem(FullMenu, A^.C_Full[9], Spectrum_Full[9]);                      CheckItem(FullMenu, A^.C_Full[10], Spectrum_Full[10]);                      Update_max_min(9);                      Update_Full;                    END;                END;              C_Remove_Background:                BEGIN                 (* IF (ROI^^.BackGround[1].Exists) AND (ROI^^.BackGround[2].Exists) THEN *) D_BG_Correct                 (* ELSE                    BEGIN                      BeepBeep;                      putmessage('You forgot to choose the minimum of background ROI 1 and 2', '', '', '');                    END;                  Mouse_Active_Window;                  Update_Full;*)                END;              C_Show_Detector_Response:                BEGIN				if NOT (SiLi_Response_Calculated) then				  begin					  Detector_Efficiency(theBGRec,SiLi_Response_Calculated);					  {this calculates a new  Det_Effic_P^, sets					   Gen_ResponseFnc equal to it, and sets SiLi_Response_Calculated					   to true.}				  end;                  FOR nn := 1 TO Maximum_Channels DO                    Plt_Spec[9]^^.S[nn] :=  Det_Effic_P^[nn];                  Spectrum_Full[9] := True;                  CheckItem(FullMenu, A^.C_Full[9], Spectrum_Full[9]);                  Update_max_min(9);                  Update_Full;                END;              C_Replace_Response_by_Wk:                BEGIN                  IF AnswerMessage('Are you sure you want to replace the DTSA instrumental response curve with',                                   'the curve that is in the WORK spectrum? If It`s OK I will do it. If it`s',                                   'NOT OK then I will cancel the operation.',                                   'The response curve affects the SIMPLEX and spectrum generation.') THEN					BEGIN                    FOR nn := 1 TO Maximum_Channels DO                       Det_Effic_P^[nn] := Plt_Spec[10]^^.S[nn];					  {the Gen_ResponseFnc remains the calulated fnc: Det_Effic is					    used in calculations so thats ok}					  SiLi_Response_Calculated := true;					END;                  END;               C_Calculate_Response_NOW:                BEGIN                  IF AnswerMessage('Are you sure you want to calculate a new DTSA instrumental response curve for',                                   'the spectrum that is in WORK? If It`s OK I will do it. If it`s NOT OK ',                                   'I will cancel the operation.',                                   'If the Response is already valid then nothing will happen.') THEN					BEGIN					 (* CompareGen_To_Work; 					  IF (SiLi_Response_Calculated = False) { if a new spectrum in work...}					  THEN 					  BEGIN	*)						GenFromWork(theBGRec);	{gets theGenRec values from Work }						Detector_efficiency(theBGRec,SiLi_Response_Calculated);					 (* END;*)					END;                  END; 			  C_Compare_Wk_to_R:			    BEGIN				  {AutoBG;}				  For nn := 1 to Maximum_Channels do				  begin					tempR := Plt_Spec[9]^^.S[nn];					if (tempR < 1e-31) AND (tempR > -1e-31) then					TempR := 1.0;					Plt_Spec[1]^^.S[nn] := Plt_Spec[10]^^.S[nn]/tempR;					Plt_Spec[2]^^.S[nn] := Plt_Spec[10]^^.S[nn] - Plt_Spec[9]^^.S[nn];				  end;				  Update_max_min(1);				  Update_max_min(2);				  UnCheck_AllSpectra;				  Spectrum_Full[1] := True;				  CheckItem(FullMenu, A^.C_Full[1], Spectrum_Full[1]);				  Spectrum_Full[2] := True;				  CheckItem(FullMenu, A^.C_Full[2], Spectrum_Full[2]);                  Auto_Scale_Display := True;				  Update_Full;			    END;								C_Strip_Escapes:			  Begin			    Escape_Peaks;			  end;			                C_X_Ray_DataBase:                BEGIN				  Xray_Data_Request := True;                  D_Per_Tab_Buttons;				  Xray_Data_Request := False;                END;              OTHERWISE                BEGIN                END;              END; {End of item case}          END; {End for this list}        L_Parameters:          BEGIN            CASE theItem OF {Handle all commands in this menu list}              C_Spectrum_Header:                BEGIN                  KludgeBoolean := True; {temp bool to grey resp-to-rslts if cuming from bg subtr}                  Called_for_Generate := FALSE;                  Called_for_Work_Spec := True;				  if  Plt_spec[10]^^.Expt_Info.RefFile then D_Ref_Hdr				  else Spectrum_Header_Dialog;                  Mouse_Active_Window;                END;              C_Experiment_Header:                BEGIN                  KludgeBoolean := True; {temp bool to grey resp-to-rslts if cuming from bg subtr}                  Called_for_Generate := FALSE;                  Called_for_Work_Spec := True;				  if Plt_spec[10]^^.Expt_Info.RefFile then D_RefExpt_Hdr else D_Expt_Hdr;                  Mouse_Active_Window;                END;			  C_Show_Headers:				  BEGIN					{Link to a hier menu}				  END;	{ C_Show_Headers:}              OTHERWISE                BEGIN                  Mouse_Active_Window;                END;              END; {End of item case}          END; {End for this list}        L_Full:          BEGIN            {Handle all commands in this menu list}            IF theItem = 1 THEN Index := 10            ELSE              IF theItem = 2 THEN Index := 9              ELSE Index := theItem - 2;            IF theItem = A^.C_Full[Index] THEN              BEGIN                IF Spectrum_Full[Index] = FALSE THEN                  BEGIN                    Spectrum_Full[Index] := True;                    CheckItem(FullMenu, theItem, Spectrum_Full[Index]);                    Update_Full;                  END { if Spectrum_Full }                ELSE                  BEGIN                    Spectrum_Full[Index] := FALSE;                    CheckItem(FullMenu, theItem, Spectrum_Full[Index]);                    Update_Full;                  END;              END; { if theItem...}            IF theItem = Clear_Full THEN              BEGIN                roi_showing := FALSE;                FOR Index := 1 TO 10 DO                  BEGIN                    Spectrum_Full[Index] := FALSE;                    CheckItem(FullMenu, A^.C_Full[Index], Spectrum_Full[Index]);                  END;                Update_Full;              END;          END; {End for L_Full}	    {SDD}  	L_SetupAcqPlugins:BEGIN {SDD}		IF (CallAcquirePlugIns(acquireSetup,theItem)) THEN BEGIN;{SDD}			Refresh_ROIs;{SDD}			Update_Full;{SDD}		END;{SDD}   END; {L_SetupAcqPlugins}{SDD}  	L_SelectAcqPlugins:BEGIN {SDD}		CheckItem(GetMenu(129),gDTSACurrentPlugIn,FALSE);{SDD}		gDTSACurrentPlugIn:=theItem;{SDD}		CheckItem(GetMenu(129),gDTSACurrentPlugIn,TRUE);  {SDD}		IF (gAcquirePlugIns[gDTSACurrentPlugIn]^.MenuStart) THEN BEGIN{SDD} 			EnableItem(GetMenu(152),C_Start);{SDD}		END ELSE BEGIN{SDD} 			DisableItem(GetMenu(152),C_Start);{SDD}		END;{SDD}		IF (gAcquirePlugIns[gDTSACurrentPlugIn]^.MenuStop) THEN BEGIN{SDD} 			EnableItem(GetMenu(152),C_Stop);{SDD}		END ELSE BEGIN{SDD} 			DisableItem(GetMenu(152),C_Stop);{SDD}		END;{SDD}		IF (gAcquirePlugIns[gDTSACurrentPlugIn]^.MenuResume) THEN BEGIN{SDD} 			EnableItem(GetMenu(152),C_Resume);{SDD}		END ELSE BEGIN{SDD} 			DisableItem(GetMenu(152),C_Resume);{SDD}		END;{SDD}   END; {L_SelectAcqPlugins}{SDD}		{SDD}  	L_Acquisition:BEGIN {SDD}		CASE theItem OF{SDD3}			C_AssignBuffers:BEGIN{SDD3}				IF (AssignAcqBuffers) THEN BEGIN{SDD3}					bErr:=CallAcquirePlugIns(acquireChange,-1);{SDD3}					Refresh_ROIs;{SDD3}					Update_Full;{SDD3}				END;{SDD}			END;{SDD}			C_Stop:BEGIN{SDD}				IF (CallAcquirePlugIns(acquireStop,gDTSACurrentPlugIn)) THEN BEGIN{SDD}					Refresh_ROIs;{SDD}					Update_Full;{SDD}				END;{SDD}  		  	END;{SDD}			C_Resume:BEGIN{SDD}				IF (CallAcquirePlugIns(acquireResume,gDTSACurrentPlugIn)) THEN BEGIN{SDD} 					EnableItem(GetMenu(152),C_StopAll);{SDD}					Refresh_ROIs;{SDD}					Update_Full;{SDD}				END;{SDD}			END;{SDD}			C_Start:BEGIN{SDD}				IF (CallAcquirePlugIns(acquireStart,gDTSACurrentPlugIn)) THEN BEGIN{SDD} 					EnableItem(GetMenu(152),C_StopAll);{SDD}					Refresh_ROIs;{SDD}					Update_Full;{SDD}				END;{SDD}			END;{SDD}			C_StopAll: BEGIN{SDD}				IF (CallAcquirePlugIns(acquireStop,-1)) THEN BEGIN{SDD} 					DisableItem(GetMenu(152),C_StopAll);{SDD} 					EnableItem(GetMenu(152),C_ResumeAll);{SDD}					Refresh_ROIs;{SDD}					Update_Full;{SDD}				END;{SDD}			END;{SDD}			C_ResumeAll:BEGIN{SDD}				IF (CallAcquirePlugIns(acquireResume,-1)) THEN BEGIN{SDD} 					EnableItem(GetMenu(152),C_StopAll);{SDD} 					EnableItem(GetMenu(152),C_ResumeAll);{SDD}					Refresh_ROIs;{SDD}					Update_Full;{SDD}				END;{SDD}			END;{SDD}			C_StartAll:BEGIN{SDD}				IF (CallAcquirePlugIns(acquireStart,-1)) THEN BEGIN{SDD} 					EnableItem(GetMenu(152),C_StopAll);{SDD} 					DisableItem(GetMenu(152),C_ResumeAll);{SDD}					Refresh_ROIs;{SDD}					Update_Full;{SDD}				END;{SDD}			END;{SDD}			C_Automation:BEGIN{SDD}				{D_Top;}   {SDD}			END;{SDD}		END; {End of item case}{SDD3}		IF (gDTSACurrentPlugIn<>0) THEN BEGIN{SDD3}			IF (gAcquirePlugIns[gDTSACurrentPlugIn]^.MenuStart) THEN BEGIN{SDD3} 				EnableItem(GetMenu(152),C_Start);{SDD3}			END ELSE BEGIN{SDD3} 				DisableItem(GetMenu(152),C_Start);{SDD3}			END;{SDD3}			IF (gAcquirePlugIns[gDTSACurrentPlugIn]^.MenuStop) THEN BEGIN{SDD3} 				EnableItem(GetMenu(152),C_Stop);{SDD3} 				DisableItem(GetMenu(152),C_AssignBuffers);{SDD3}			END ELSE BEGIN{SDD3} 				DisableItem(GetMenu(152),C_Stop);{SDD3} 				EnableItem(GetMenu(152),C_AssignBuffers);{SDD3}			END;{SDD3}			IF (gAcquirePlugIns[gDTSACurrentPlugIn]^.MenuResume) THEN BEGIN{SDD3} 				EnableItem(GetMenu(152),C_Resume);{SDD3}			END ELSE BEGIN{SDD3} 				DisableItem(GetMenu(152),C_Resume);{SDD3}			END;{SDD3}		END;{SDD}	END; {End for L_Acquisition}     (*   L_Show_Header:          BEGIN            FOR Index := 1 TO 10 DO			IF theItem = C_SPick[Index] THEN			BEGIN				IF Header_Info_Window <> NIL THEN				BEGIN					DisposeWindow(Header_Info_Window);					Header_Info_Window := NIL;				END;                IF Index = 1 THEN mm := 10                ELSE IF Index = 2 THEN mm := 9				ELSE mm := Index - 2;				Open_Header_Information(mm);	{see Tools.p}            END;	{ FOR Index := 1 TO 10...}          END;	{ L_Show_Header:}		*)        OTHERWISE          BEGIN          END;        END;      HiliteMenu(0); {Turn menu selection off}           END; {End of procedure Handle_My_Menu}END.