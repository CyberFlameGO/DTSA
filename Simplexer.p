 (*{[j=30/55,:+,u+,r+,o=320,d-,k+,n+,#+,v+,q+,b+]}{[f-]}*){*********************************} UNIT Simplexer ;{*********************************}{**********************************} INTERFACE {**********************************} USES QuickDraw, QuickdrawText, Types, OSUtils, ToolUtils, Timer, Errors, Menus, Files, Lists, Memory, Dialogs, Events,   Packages, Printing, Retrace, SegLoad, StandardFile, fenv, fp {SANE, StrLib}, Controls, Windows, TextUtils,   Spectrum_Structures, Declarations, INITIALIZE, Global_Functions, Utilities,  Xray_Energies, SANDIA, CurveFit, Physics, Physics_Windows, Xray ;     PROCEDURE D_Constraints_Window;	{this is the Simplex Strategy window not constraints;    								 D_Constraints is constraint dialog}    PROCEDURE Sequential_Simplex;	PROCEDURE D_Simplex;	PROCEDURE Simplex_Start;	FUNCTION Sigma_Compute(sigin, dpkein:  real {double_t}):  real {double_t}; 	(*PROCEDURE SGauss (VAR EStart,ChKv:double_t; VAR ESet,ASet,SigSet: PKARY;					   VAR NumGauss,NumChs:integer; VAR GaussOut:WindowArray);  *) 					   	{******************************} IMPLEMENTATION {**********************************}(*{[f+]}*){$S Simplexer}  VAR    Max_Hold                      : Real;    BigExit					      : Boolean;	Window_Counter                : Integer;    Counter                       : Integer;	Total_Number_of_Peaks         : Integer;	Alpha_Peak_in_Window          : Integer;	sign_peak					  : Integer;	Number_of_Independent_Peaks   : Integer;	Constraints_ExitDialog        : Boolean;   (* Hold                          : LinFitExtArray; { 36 terms }	solution                      : LinFitExtArray; { [1..Max_Num_Terms] of double_t}*)    aSimplex                      : Simplex;	{1..51 of 1..52 of double_t} (* PROCEDURE SGauss; {(VAR EStart,ChKv:double_t; VAR ESet,ASet,SigSet: PKARAY ;					   VAR NumGauss,NumChs:integer; VAR GaussOut:WindowArray)}        VAR        Energy, dele, arg: double_t;        kk, jj			 : Integer;      BEGIN                  {PROCEDURE SGauss}           {   calculate the  sum of gaussians at each channel -               array GaussOut[n] will have sum at each ch of all gaussians and incomplete chg               for the window + filter chs at each end }	    {debugstr('begin NGauss');}        FOR jj := 1 TO NumChs DO GaussOut[jj] := 0.0;		{debugstr('zero`ed GaussOut');}         FOR kk := 1 TO NumGauss DO BEGIN          arg := - 0.5 / (sigSet[kk] * sigSet[kk]);          Energy := EStart;  { energy in kev of 1st ch in window inc filter chs }          FOR jj := 1 TO NumChs DO BEGIN            dele := Energy - ESet[kk];            GaussOut[jj] := GaussOut[jj] + ASet[kk] * (EXP(dele * dele * arg));            Energy := Energy + ChKv;          END;               { for jj }        END;                 { for kk }      END;                   {PROCEDURE SGauss}  *)      FUNCTION Sigma_Compute(sigin, dpkein:  real {double_t}):  real {double_t};       { Sigma_Compute -- compute sigma of one peak from sigma of another }       { enter: sigin = sigma of known peak in kev                        }       { dpkein  = energy difference from known peak in ev                }       { returns: sigma of the peak in kev                                }       { aSigConst := 1.0 / (2.354825 * 2.354825)                         }       { theSigConst := 2.5 * aSigConst                                   }       {¥¥¥ eqn for theoretical res is fwhm := sqrt(2.5664*evofPeak) }       { need to work this in as a limit, so pass in the energy to this function }                VAR          sigtrm, deltrm, sum           :  real {double_t};        BEGIN {fnc Sigma_Compute}          IF wds_active THEN            BEGIN              Sigma_Compute := sigin; { what goes in, goes out, until we know more.}            END          ELSE            BEGIN              sigtrm := sigin * sigin; {sigin is in kev}              deltrm := theSigConst * dpkein * 0.001; { convert to keV }              sum := deltrm + sigtrm;              IF sum < 0 THEN sum := 0.0;              Sigma_Compute := SQRT(sum); { to give sigma in kev}            END;        END; { fnc Sigma_Compute }PROCEDURE D_Fit_Params;      CONST        I_ACCEPT            = 1;        I_One_Coeff         = 3;	{hypermet}        I_Two_Coeff         = 2;	{multiplier}		I_Resolution        = 4;		I_Message			= 8;		I_HyperText			= 6;		I_FiltText			= 5;     VAR        ExitDialog:         Boolean;        GetSelection:       DialogPtr;        tempRect			:Rect;        DType:              Integer;        DItem:              Handle;        CItem			:   controlhandle;        sTemp:              Str255;        itemHit:            Integer;  		str	    		: str255;      BEGIN	          GetSelection := GetNewDialog(129, NIL, POINTER( - 1));        ShowWindow(GetSelection);{makes it visible}        SelectWindow(GetSelection);{makes it active window}        SetPort(GetSelection);	{makes it current port}        OutlineButton(GetSelection, 1, 16); { outline the accept button } 		        {¥¥¥¥¥¥¥¥¥¥Setup initial conditions¥¥¥¥¥¥¥¥¥¥¥¥¥}        			 {one_Coeff := Pierson_Num ;}			 GetDialogItem(GetSelection, I_One_Coeff, DType, DItem, tempRect);			 RealToString(one_Coeff, 5, 5, Str);			 SetDialogItemText(DItem, Str);	 			 GetDialogItem(GetSelection, I_Two_Coeff, DType, DItem, tempRect);			 RealToString(two_Coeff, 5, 2, Str);			 SetDialogItemText(DItem, Str);			 		GetDialogItem(GetSelection, I_Resolution, DType, DItem, tempRect);		RealToString(WDS_Fitting_Resolution,5, 2, Str);        SetDialogItemText(DItem, Str);        				ExitDialog := FALSE;        REPEAT          ModalDialog(NIL, itemHit);          GetDialogItem(GetSelection, itemHit, DType, DItem, tempRect);          CItem := controlhandle(DItem);          {Handle it real time}          IF (itemHit = I_ACCEPT) THEN BEGIN            ExitDialog := True;				GetDialogItem(GetSelection, I_Resolution, DType, DItem, tempRect);			GetDialogItemText(DItem, sTemp);			WDS_Fitting_Resolution := MyStr2Num(sTemp);			Analysis_result^^.fit_Params.FWStart := WDS_Fitting_Resolution;			 If  (Analysis_result^^.fit_Params.FWStart > 90.0 ) then begin			 	    if not answermessage('The resolution is >90 eV.',										 'This is rather high for WDS.',					                     'However, If IT`S OK I`ll go on,',									     'otherwise you can change the value.')			 		then ExitDialog := false;			 		end;          END;         IF (itemHit = I_One_Coeff) then		 BEGIN		   GetDialogItem(GetSelection, I_One_Coeff, DType, DItem, tempRect);		   GetDialogItemText(DItem, sTemp);		    		   if (MyStr2Num(sTemp)<0) or (MyStr2Num(sTemp)>1.0) then		      begin			   putmessage('Value must be between 0 and 1. A value of zero means the profile will',			              'be pure Lorentzian, and a value one means a pure Gauss curve.','','');			   one_Coeff := MyStr2Num('0.5');			   RealToString(one_Coeff, 5, 5, Str);			   SetDialogItemText(DItem, Str);			   			   end;         END;		        UNTIL ExitDialog;				   GetDialogItem(GetSelection, I_One_Coeff, DType, DItem, tempRect);		   GetDialogItemText(DItem, sTemp);		   one_Coeff := MyStr2Num(sTemp);		   {Pierson_Num := one_Coeff;}		   		   GetDialogItem(GetSelection, I_Two_Coeff, DType, DItem, tempRect);		   GetDialogItemText(DItem, sTemp);		   Two_Coeff := MyStr2Num(sTemp);        GetDialogItem(GetSelection, I_Resolution, DType, DItem, tempRect);		GetDialogItemText(DItem, sTemp);		WDS_Fitting_Resolution := MyStr2Num(sTemp);		Analysis_result^^.fit_Params.FWStart := WDS_Fitting_Resolution;		         DisposeDialog(GetSelection);        Mouse_Active_Window;		      END; {  }PROCEDURE D_SiliFit_Params;      CONST        I_ACCEPT            = 1;		I_Resolution        = 2;   VAR        ExitDialog:         Boolean;        GetSelection:       DialogPtr;        tempRect			:Rect;        DType:              Integer;        DItem:              Handle;        CItem			:   controlhandle;        sTemp:              Str255;        itemHit:            Integer; 		str   : str255;      BEGIN	          GetSelection := GetNewDialog(130, NIL, POINTER( - 1));        ShowWindow(GetSelection);{makes it visible}        SelectWindow(GetSelection);{makes it active window}        SetPort(GetSelection);	{makes it current port}        OutlineButton(GetSelection, 1, 16); { outline the accept button } 		        {¥¥¥¥¥¥¥¥¥¥Setup initial conditions¥¥¥¥¥¥¥¥¥¥¥¥¥}	 		GetDialogItem(GetSelection, I_Resolution, DType, DItem, tempRect);		RealToString(Analysis_result^^.fit_Params.FWStart,5, 2, Str);        SetDialogItemText(DItem, Str);		ExitDialog := FALSE;        REPEAT          ModalDialog(NIL, itemHit);          GetDialogItem(GetSelection, itemHit, DType, DItem, tempRect);          CItem := controlhandle(DItem);          {Handle it real time}          IF (itemHit = I_ACCEPT) THEN BEGIN            ExitDialog := True;				GetDialogItem(GetSelection, I_Resolution, DType, DItem, tempRect);			GetDialogItemText(DItem, sTemp);			 			analysis_result^^.fit_params.FWStart := MyStr2Num(sTemp); 			 If  (analysis_result^^.fit_params.FWStart < 120.0 ) then begin			 	    if not answermessage('The resolution is <120 eV.',										 'This is rather low for EDS.',					                     'However, If IT`S OK I`ll go on,',									     'otherwise you can change the value.')			 		then ExitDialog := false;			 		end;          END;		        UNTIL ExitDialog;		           GetDialogItem(GetSelection, I_Resolution, DType, DItem, tempRect);		GetDialogItemText(DItem, sTemp);		analysis_result^^.fit_params.FWStart := MyStr2Num(sTemp);		        DisposeDialog(GetSelection);        Mouse_Active_Window;		      END; { D_SiliFit_Params }  {=================================}  PROCEDURE D_Constraints;    CONST      Accept                        = 1;	  C_Use_Constraints			    = 2;      C_Width_Constraint            = 7;      C_Energy_Constraint           = 5;	  C_ROI_Constraints			    = 10;    VAR      GetSelection                  : DialogPtr;             tempRect                      : Rect;                  DType                         : Integer;               DItem                         : Handle;                CItem, CTempItem              : controlhandle;         sTemp                         : Str255;                itemHit                       : Integer;               temp                          : Integer;	      BEGIN        GetSelection := GetNewDialog(128, NIL, Pointer( - 1));        ShowWindow(GetSelection);        SelectWindow(GetSelection);        SetPort(GetSelection);  	  OutlineButton(GetSelection, 1, 16); { outline the accept button }      GetDialogItem(GetSelection, C_Width_Constraint, DType, DItem, tempRect);      RealToString(Analysis_Result^^.Fit_params.DFWHMM, 5,1, sTemp);      SetDialogItemText(DItem, sTemp);      GetDialogItem(GetSelection, C_Energy_Constraint, DType, DItem, tempRect);      RealToString(Analysis_Result^^.Fit_params.DEN, 5,1, sTemp);      SetDialogItemText(DItem, sTemp);	  	   GetDialogItem(GetSelection, C_Use_Constraints, DType, DItem, tempRect);	   CTempItem := controlhandle(DItem);	   SetControlValue(CTempItem, 0);	   	   GetDialogItem(GetSelection, C_ROI_Constraints, DType, DItem, tempRect);	   CItem := controlhandle(DItem);	   SetControlValue(CItem, 0);	   if constraint_switch then SetControlValue(CTempItem, 1)	   else SetControlValue(CItem, 1);       Constraints_ExitDialog := FALSE;        REPEAT          ModalDialog(NIL, itemHit);          GetDialogItem(GetSelection, itemHit, DType, DItem, tempRect);          CItem := controlhandle(DItem);          IF (itemHit = Accept) THEN Constraints_ExitDialog := TRUE;        IF (itemHit = C_Use_Constraints) or (itemHit = C_ROI_Constraints) THEN          BEGIN			GetDialogItem(GetSelection, C_Use_Constraints, DType, DItem, tempRect);			CItem := controlhandle(DItem);            temp := GetControlValue(CItem);            SetControlValue(CItem, (temp + 1) MOD 2);			GetDialogItem(GetSelection, C_ROI_Constraints, DType, DItem, tempRect);			CItem := controlhandle(DItem);            temp := GetControlValue(CItem);            SetControlValue(CItem, (temp + 1) MOD 2);		  END;      UNTIL Constraints_ExitDialog;  	   GetDialogItem(GetSelection, C_Use_Constraints, DType, DItem, tempRect);	   CItem := controlhandle(DItem);       temp := GetControlValue(CItem);	   if (temp = 1) then begin	   	constraint_switch := true;			GetDialogItem(GetSelection, C_Width_Constraint, DType, DItem, tempRect);			GetDialogItemText(DItem, sTemp);			Analysis_Result^^.Fit_params.DFWHMM := MyStr2Num(sTemp);	  			GetDialogItem(GetSelection, C_Energy_Constraint, DType, DItem, tempRect);			GetDialogItemText(DItem, sTemp);			Analysis_Result^^.Fit_params.DEN := MyStr2Num(sTemp);	   end	   else constraint_switch := false; 			 			 temprect := GetSelection^.portRect; 			 DisposeDialog(GetSelection);			 FillWhiteSpace(temprect);    END; {D_Constraints;}	  PROCEDURE D_Simplex;        CONST      Ix_Accept                     = 1;      I_Simp_Strategy		        = 4;	{button to dial}      I_Change_Tolerance            = 3;	{edit text}      I_xCancel                     = 2;      I_Help                        = 5;      I_Use_Constraints             = 6;	{button to dial}      I_Fit_Family_peaks_usin       = 7;      I_Fit_Family_peaks_sepe       = 8;      I_Choose_Elements_To_Fit      = 9;      I_Choose_Output_Options       = 10;	  I_FlowChart                   = 11;	  I_Used_Resolution             = 13;	{dependent static text}	  I_Used_eV                     = 14;	{dependent static text}	  I_Detector_Parameters         = 16;	{button to dial}	  I_DeltaE_Txt                  = 19;	  I_FWHM_Txt                    = 26;	  I_onoff					    = 20;	  I_DEN							= 21;	  I_DFWHM						= 22;	  I_Majors   					= 23;	  I_Minors						= 24;	  I_Satellites					= 25;	  I_Max_Iter					= 29;	{edit text}	{  I_Deselect					= 30;}	      VAR      GetSelection                  : DialogPtr;      tempRect                      : Rect;      DType                         : Integer;      Index,nrd                     : Integer;      DItem                         : Handle;      CItem			                : controlhandle;      sTemp,stoler,siter            : Str255;      itemHit                       : Integer;      temp,nn                       : Integer;      ExitDialog                    : boolean;      str1,str2,str                 : str255;	  ediff,fwhmw				    : real;	  lmax_iter						: longint;	    PROCEDURE Simplex_Help;    VAR      tempRect                     : Rect;                  offset                       : integer;	  Left                         : integer;	  Top                          : integer;      n                            : integer;	  G_Help                       : DialogPtr;      itemHit                      : integer;      DType                         : Integer;      DItem                         : Handle;	  ExitDialog                    : Boolean;	  str                           : Str255;    CONST      G_Accept                      = 1;	  BEGIN                                              G_Help := GetNewDialog(433, NIL, POINTER( - 1));ShowWindow(G_Help);SelectWindow(G_Help);SetPort(G_Help);OutlineButton(G_Help, 1, 16); { outline the OK button }SetFont('Monaco', 9, []);offset := 12;Left := 5;Top := 15;		   n := 0;	  moveto(Left,Top);DrawString('The Simplex is a ¥NON-LINEAR¥ curve fitting procedure; it requires some thought and preparation.');	  n := n+1; moveto(Left,Top + n*offset);str := 'It requires starting estimates. We have taken care of amplitude and energy starting points. The detector';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'resolution you entered in the Experiment Header via the "Detector Parameters" dialog gives the procedure';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'a width estimate. NON-LINEAR procedures need to know when to quit. A fractional change for fitted values';DrawString(str); n := n+1; moveto(Left,Top + n*offset); str := 'is usually used. Define this via the "Tolerence" dialog (<.001). The smaller the number the better the';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'fit but the longer it takes. You may also limit the number of iterations with the "Maximum Iterations"';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'box. It IS possible to be too greedy. Our version of the simplex starts with all peak heights in a given';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'x-ray family locked together. If you pick free fitting, this continues until the fit achieves a certain';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := '"goodness of fit". This switch tolerance is determined by the "Switch Factor" in the "Simplex Details"';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'dialog. The switch tolerance is the exit "tolerence" multiplied by  the "Switch Factor".';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := '    It is possible to limit the space the simplex searches for values by setting "constraints".';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'Do this with the "Set Contraints" checkbox. "Energy" and "Width" can be restricted by entering ';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'appropriate values in the "Simplex Details" dialog. ¥WARNING¥ If your spectrum is not calibrated to';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'better than your energy "constraint" the simplex may never converge. A similar caveat holds  ';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'for the resolution. ¥¥¥Use constraints only if you have entered the correct resolution and your';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'spectrum is in calibration. Dont get greedy. The simplex has to have some "breathing room".¥¥¥ ';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'Even if you don`t enter constraints, the fitting window is used to set energy limits. ';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := '¥The up and down "arrow" keys (ON THE KEYBOARD) will change the vertical display during the ';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'fitting operation. They are slightly sluggish because of all the arithmetic being done.'; DrawString(str); n := n+2; moveto(Left,Top + n*offset);str := '¥¥DISADVANTAGES of SIMPLEX¥¥ Slow and sometimes fails.';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := '¥¥ADVANTAGES of SIMPLEX¥¥ Does not require reference spectra, only thought. Will give answers for';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'peak widths and positions in addition to amplitudes. LLSQ only finds amplitudes. ';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'If a spectrum has been calibrated using the "Calibrate" function and the slope and intercept'; DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'saved in the Experiment Header, the energies reported will ALWAYS be calibrated values.'; DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'NOTE: AutoROI may now be used from the "Select Elements" window to pick the ROIs.'; DrawString(str); n := n+2; moveto(Left,Top + n*offset);REPEAT  ModalDialog(NIL, itemHit);  GetDialogItem(G_Help, itemHit, DType, DItem, tempRect);  IF (itemHit = G_Accept) THEN	BEGIN	  ExitDialog := True;	END;UNTIL ExitDialog;		DisposeDialog(G_Help);			BeginUpdate(BackPlane);			DrawAxesFull;			Update_Full;			EndUpdate(BackPlane);		    UpDate_SiLi_Window(SiLiWindow) ;END;                                              {End of Simplex_Help procedure}PROCEDURE Update;	 	BEGIN	  SetPort(GetSelection);	  if not constraint_switch then { hide the static text about constraints }	  begin		   GetDialogItem(GetSelection, I_DeltaE_Txt, DType, DItem, tempRect);		   SetDialogItemText(DItem, '');		   GetDialogItem(GetSelection, I_FWHM_Txt, DType, DItem, tempRect);		   SetDialogItemText(DItem, ''); 		   GetDialogItem(GetSelection, 21, DType, DItem, tempRect);		   SetDialogItemText(DItem, ''); 		   GetDialogItem(GetSelection, 22, DType, DItem, tempRect);		   SetDialogItemText(DItem, '');  	  end	  else	  begin		   str1 := 'Book Energy (eV) +/-';		   str2 := '    FWHM Mn(ev) +/-';		   GetDialogItem(GetSelection, I_DeltaE_Txt, DType, DItem, tempRect);		   SetDialogItemText(DItem, str1);		   GetDialogItem(GetSelection, I_FWHM_Txt, DType, DItem, tempRect);		   SetDialogItemText(DItem, str2);	  end; 	   GetDialogItem(GetSelection, I_Used_Resolution, DType, DItem, tempRect);	   RealToString(Analysis_result^^.fit_Params.FWStart, 5, 2, sTemp);	   SetDialogItemText(DItem, sTemp);		   GetDialogItem(GetSelection, I_Used_eV, DType, DItem, tempRect);	   RealToString(Plt_spec[10]^^.Expt_Info.dE, 5, 2, sTemp);	   SetDialogItemText(DItem, sTemp);	   GetDialogItem(GetSelection, I_onoff, DType, DItem, tempRect);	   if constraint_switch then sTemp := 'on.'	   else sTemp := 'off.'; 	   SetDialogItemText(DItem, sTemp);	   GetDialogItem(GetSelection, I_DEN, DType, DItem, tempRect);	  if constraint_switch then	   RealToString(Analysis_Result^^.Fit_params.DEN, 5, 1, sTemp)	   else sTemp := '';	   SetDialogItemText(DItem, sTemp);	   GetDialogItem(GetSelection, I_DFWHM, DType, DItem, tempRect);	  if constraint_switch then	   RealToString(Analysis_Result^^.Fit_params.DFWHMM, 5, 1, sTemp)	   else sTemp := '';	   SetDialogItemText(DItem, sTemp);	          RealToString(Analysis_Result^^.Fit_params.Toler, 5, 5, stoler);	   GetDialogItem(GetSelection, I_Change_Tolerance, DType, DItem, tempRect);	   SetDialogItemText(DItem, stoler);	   numtostring(Maximum_Iterations,siter);	   GetDialogItem(GetSelection, I_Max_Iter, DType, DItem, tempRect);	   SetDialogItemText(DItem, siter);	   	   	   OutlineButton(GetSelection, 1, 16); { outline the accept button } 	END; {Update}    BEGIN	{ PROCEDURE D_Simplex; }      GetSelection := GetNewDialog(1941, NIL, Pointer( - 1));      ShowWindow(GetSelection);      SelectWindow(GetSelection);      SetPort(GetSelection);	  OutlineButton(GetSelection, 1, 16); { outline the accept button }	        {¥¥¥¥¥Setup initial conditions¥¥¥¥¥¥}	  constraint_switch := Analysis_Result^^.Fit_params.constrained;	   	  	        GetDialogItem(GetSelection, I_Fit_Family_peaks_usin, DType, DItem, tempRect);      CItem := controlhandle(DItem);      IF wtswitch THEN SetControlValue(CItem, 0) { do free fitting which starts wtd,ie wt switches }      ELSE SetControlValue(CItem, 1);      GetDialogItem(GetSelection, I_Fit_Family_peaks_sepe, DType, DItem, tempRect);      CItem := controlhandle(DItem);      IF wtswitch THEN SetControlValue(CItem, 1)      ELSE SetControlValue(CItem, 0); { do free fitting which starts wtd, ie wt switches }	       if Majors then 	   begin        GetDialogItem(GetSelection, I_Satellites, DType, DItem, tempRect);	    SetControlValue(controlhandle(DItem), 0);		GetDialogItem(GetSelection, I_Minors, DType, DItem, tempRect);		SetControlValue(controlhandle(DItem), 0); 		GetDialogItem(GetSelection, I_Majors, DType, DItem, tempRect);		SetControlValue(controlhandle(DItem), 1); 	   end;      if Minors then 	   begin        GetDialogItem(GetSelection, I_Satellites, DType, DItem, tempRect);	    SetControlValue(controlhandle(DItem), 0);		GetDialogItem(GetSelection, I_Minors, DType, DItem, tempRect);		SetControlValue(controlhandle(DItem), 1); 		GetDialogItem(GetSelection, I_Majors, DType, DItem, tempRect);		SetControlValue(controlhandle(DItem), 0); 	   end;      if Satellites then 	   begin        GetDialogItem(GetSelection, I_Satellites, DType, DItem, tempRect);	    SetControlValue(controlhandle(DItem), 1);		GetDialogItem(GetSelection, I_Minors, DType, DItem, tempRect);		SetControlValue(controlhandle(DItem), 0); 		GetDialogItem(GetSelection, I_Majors, DType, DItem, tempRect);		SetControlValue(controlhandle(DItem), 0); 	   end;	   	  if Plt_Spec[10]^^.Expt_Info.Detector.spec = EDS then      		Analysis_result^^.fit_Params.FWStart :=								Plt_Spec[10]^^.Expt_Info.Si_Resolution;	  if Plt_Spec[10]^^.Expt_Info.Detector.spec = WDS then	  begin        	Plt_Spec[10]^^.Expt_Info.WDS_Resolution := WDS_Fitting_Resolution;        	Analysis_result^^.fit_Params.FWStart :=								Plt_Spec[10]^^.Expt_Info.WDS_Resolution;	  end;      Update;      Quick_Exit := FALSE;      ExitDialog := FALSE;	        REPEAT        ModalDialog(NewModalFilterProc(@DefaultFilter), itemHit);        GetDialogItem(GetSelection, itemHit, DType, DItem, tempRect);        CItem := controlhandle(DItem);        IF (itemHit = Ix_Accept) THEN          BEGIN            ExitDialog := TRUE;          END;        IF (itemHit = I_Detector_Parameters) THEN          BEGIN             if wds_active then D_Fit_Params			 else D_SiliFit_Params;			Update;          END;        IF (itemHit = I_FlowChart) THEN		  Begin			Flow_Chart(434);			Update;		  End;        IF (itemHit = I_Simp_Strategy) THEN          BEGIN		  	D_Constraints_window;	{Believe me, this IS the Nelder-Meade stuff despite the name}			Update;          END;        IF (itemHit = I_xCancel) THEN {...restore original windows and periodic _picks!!}          BEGIN		    Quick_Exit := TRUE;	{...so Simplex_Start is not called in SiLi Window}			 temprect := GetSelection^.portRect; 			 DisposeDialog(GetSelection);			 FillWhiteSpace(temprect);            exit(D_Simplex);			           END;        IF (itemHit = I_Help) THEN 		  BEGIN		   Simplex_Help;               Update; 		  END;         IF (itemHit = I_Choose_Output_Options) THEN          BEGIN		    binary_choice := true;            D_Results_Options; {sandia}			Update;           END;        IF (itemHit = I_Choose_Elements_To_Fit) THEN        BEGIN            IF ROI^^.PEAK[1].Exists = False THEN             BEGIN                BeepBeep;                if (AnswerMessage('There are no PEAK ROIS to indicate peak bundles to be fit!',								 'If IT`S OK I`ll make ROIS; if not, set up ROIS in the ROI window.',						   		 '   {Use QUANT ROI to select your background for ratios of peak areas',								 '     to a chosen background. The default is 1.35 to 1.45 keV.}'))				then begin					Use_Manual_ROIs := false;					AutoROI_Chooser;					Kill_Quants;					Refresh_ROIs;					DrawAxesFull;					update_full;					UpDate_SiLi_Window(SiLiWindow) ;			  									end				else  begin				  tempRect := GetSelection^.portRect;				  DisposeDialog(GetSelection);				  FillWhiteSpace(tempRect);                  exit(D_Simplex);				end;             END	{ IF ROI^^.PEAK[1].Exists = False...}			 ELSE{``````}	 BEGIN		                (*Use_Manual_ROIs := true; 			   ...if Rois made by auto roi and we come back to this window			   and shut an element off, the code doesn't know to clear the ROI, etc so			   set this true only in SiLiWin 9/20/95 CRT*)			  AutoROI_Chooser;			  Kill_Quants;              Refresh_ROIs;		     END; {else}			Update;          END;	{ itemHit = I_Choose_Elements_To_Fit...}        IF (itemHit = I_Use_Constraints) THEN          BEGIN		    D_Constraints;			Update;	      END;        IF (itemHit >= I_Majors) AND (itemHit <= I_Satellites) THEN          BEGIN            FOR Index := I_Majors TO I_Satellites DO              BEGIN                GetDialogItem(GetSelection, Index, DType, DItem, tempRect);                SetControlValue(controlhandle(DItem), 0);              END;            SetControlValue(CItem, 1);            IF itemHit = I_Minors THEN              BEGIN				 Majors       := True;				 Minors       := True;				 Satellites   := False;              END            ELSE IF itemHit = I_Satellites THEN              BEGIN				 Majors       := True;				 Minors       := True;				 Satellites   := True;              END		    ELSE	{ IF itemHit = I_Majors }              BEGIN				 Majors       := True;				 Minors       := False;				 Satellites   := False;              END;          END;        IF (itemHit >= I_Fit_Family_peaks_usin) AND (itemHit <= I_Fit_Family_peaks_sepe) THEN          BEGIN            FOR Index := I_Fit_Family_peaks_usin TO I_Fit_Family_peaks_sepe DO              BEGIN                GetDialogItem(GetSelection, Index, DType, DItem, tempRect);                SetControlValue(controlhandle(DItem), 0);              END;            SetControlValue(CItem, 1);          END;	 	  IF (itemHit = I_Change_Tolerance) then begin		 GetDialogItem(GetSelection, I_Change_Tolerance, DType, DItem, tempRect);		 GetDialogItemText(DItem, stoler);		 stoler := Strip_Trailing_Blanks(stoler);		 Analysis_Result^^.Fit_params.Toler := MyStr2Num(stoler);		 end;		 	  IF (itemHit = I_Max_Iter) then begin		 GetDialogItem(GetSelection, I_Max_Iter, DType, DItem, tempRect);		 GetDialogItemText(DItem, siter);		  siter := Strip_Trailing_Blanks(siter);		  StringToNum(siter, lmax_iter);		  if (lmax_iter > 30000) then begin			  lmax_iter := 30000;			  numtostring(lmax_iter,siter);			  SetDialogItemText(DItem, siter);		  end;		  Maximum_Iterations := lmax_iter;		 end;      UNTIL ExitDialog;	 	 {if we're here we accepted...}	  GetDialogItem(GetSelection, I_Fit_Family_peaks_sepe, DType, DItem, tempRect);      temp := GetControlValue(controlhandle(DItem));	  if temp = 1 then wtswitch := true	{starts out wtd then finishes free, ie wtswitch}	  else wtswitch := false;	  GetDialogItem(GetSelection, I_Change_Tolerance, DType, DItem, tempRect);	  GetDialogItemText(DItem, sTemp);      Analysis_Result^^.Fit_params.Toler := MyStr2Num(sTemp);	  Analysis_result^^.fit_Params.constrained := constraint_switch;       	  GetDialogItem(GetSelection, I_Max_Iter, DType, DItem, tempRect);	  GetDialogItemText(DItem, siter);	  siter := Strip_Trailing_Blanks(siter);	  StringToNum(siter, lmax_iter);	  if (lmax_iter > 30000) then lmax_iter := 30000;	  Maximum_Iterations := lmax_iter;	  	{Test each window size and proximity to ends of spectrum...}	 WITH Plt_spec[10]^^,Expt_Info DO	 FOR nn := 1 TO Number_of_PeakRois - 1 DO	 BEGIN	 	str:='';		str1 := '';		str2:= '';		IF Plt_spec[10]^^.Expt_Info.Detector.spec = WDS THEN fwhmw := two_Coeff * Analysis_result^^.fit_Params.FWStart		else		begin			ediff := ROI^^.PEAK[nn].Hi * dE - 5895.0;			fwhmw := SQRT(ediff * 2.5 + Si_Resolution * Si_Resolution);		end;		nrd := 2 * rinttol(fwhmw / (Plt_spec[10]^^.Expt_Info.dE * 2));		numtostring(nn,str1);	  		IF (nrd + ROI^^.PEAK[nn].Hi > Number_of_Channels) then		begin		   str2 := concat('ROI #',str1,' is too close to the spectrum end.');		   ROI^^.PEAK[nn].Hi := Number_of_Channels - nrd;		end		ELSE IF (ROI^^.PEAK[nn].Lo - nrd  < 1) then 		begin		   str2 := concat('ROI #',str1,' is too close to the spectrum beginning.');		   ROI^^.PEAK[nn].Lo := nrd + 1;		end;		if str2 <> '' then putmessage(str,str2,'I`ll adjust it for you, but','please check it before doing the fit.');			  END;	  temprect := GetSelection^.portRect;       DisposeDialog(GetSelection);	  FillWhiteSpace(temprect);      Refresh_ROIs;      Update_Full;	      END; { PROCEDURE D_Simplex }  PROCEDURE D_Constraints_Window;    CONST      Accept                        = 1;	  Cancel						= 2;      C_Alpha                       = 3;      C_Gamma                       = 11;      C_Beta                        = 12;      C_Width                       = 20;      C_Energy                      = 17;      C_Height                      = 21;      C_Switch                      = 23;    VAR      GetSelection                  : DialogPtr;             tempRect                      : Rect;                  DType                         : Integer;               DItem                         : Handle;                CItem              			: controlhandle;         sTemp                         : Str255;                itemHit                       : Integer;             BEGIN        GetSelection := GetNewDialog(452, NIL, Pointer( - 1));        ShowWindow(GetSelection);        SelectWindow(GetSelection);        SetPort(GetSelection);        GetDialogItem(GetSelection, C_Alpha, DType, DItem, tempRect);      RealToString(NM_Alpha, 5, 5, sTemp);      SetDialogItemText(DItem, sTemp);      GetDialogItem(GetSelection, C_Beta, DType, DItem, tempRect);      RealToString(NM_Beta, 5, 5, sTemp);      SetDialogItemText(DItem, sTemp);      GetDialogItem(GetSelection, C_Gamma, DType, DItem, tempRect);      RealToString(NM_Gamma, 5, 5, sTemp);      SetDialogItemText(DItem, sTemp);      GetDialogItem(GetSelection, C_Width, DType, DItem, tempRect);      RealToString(Width_Perturb, 5, 5, sTemp);      SetDialogItemText(DItem, sTemp);      GetDialogItem(GetSelection, C_Energy, DType, DItem, tempRect);      RealToString(Energy_Perturb, 5, 5, sTemp);      SetDialogItemText(DItem, sTemp);      GetDialogItem(GetSelection, C_Height, DType, DItem, tempRect);      RealToString(Amp_Perturb, 5, 5, sTemp);      SetDialogItemText(DItem, sTemp);      GetDialogItem(GetSelection, C_Switch, DType, DItem, tempRect);      RealToString(Analysis_Result^^.Fit_params.switch, 5, 5, sTemp);      SetDialogItemText(DItem, sTemp);	  OutlineButton(GetSelection, 1, 16); { outline the accept button }	        Constraints_ExitDialog := FALSE;        REPEAT          ModalDialog(NewModalFilterProc(@DefaultFilter), itemHit);          GetDialogItem(GetSelection, itemHit, DType, DItem, tempRect);          CItem := controlhandle(DItem);          IF (itemHit = Accept) THEN Constraints_ExitDialog := TRUE;        IF (itemHit = Cancel) THEN           BEGIN			 temprect := GetSelection^.portRect; 			 DisposeDialog(GetSelection);			 FillWhiteSpace(temprect);             exit(D_Constraints_Window);			           END;      UNTIL Constraints_ExitDialog;        GetDialogItem(GetSelection, C_Alpha, DType, DItem, tempRect);      GetDialogItemText(DItem, sTemp);      NM_Alpha := MyStr2Num(sTemp);      GetDialogItem(GetSelection, C_Beta, DType, DItem, tempRect);      GetDialogItemText(DItem, sTemp);      NM_Beta := MyStr2Num(sTemp);      GetDialogItem(GetSelection, C_Gamma, DType, DItem, tempRect);      GetDialogItemText(DItem, sTemp);      NM_Gamma := MyStr2Num(sTemp);      GetDialogItem(GetSelection, C_Width, DType, DItem, tempRect);      GetDialogItemText(DItem, sTemp);      Width_Perturb := MyStr2Num(sTemp);      GetDialogItem(GetSelection, C_Energy, DType, DItem, tempRect);      GetDialogItemText(DItem, sTemp);      Energy_Perturb := MyStr2Num(sTemp);      GetDialogItem(GetSelection, C_Height, DType, DItem, tempRect);      GetDialogItemText(DItem, sTemp);      Amp_Perturb := MyStr2Num(sTemp);      GetDialogItem(GetSelection, C_Switch, DType, DItem, tempRect);      GetDialogItemText(DItem, sTemp);      Analysis_Result^^.Fit_params.switch := MyStr2Num(sTemp);			 temprect := GetSelection^.portRect; 			 DisposeDialog(GetSelection);			 FillWhiteSpace(temprect);    END; {End of procedure}  {=================================}   PROCEDURE Simplex_Event_Loop;    VAR      gotEvent                      : boolean;	  KeyCh                         : char;    BEGIN	  gotEvent := false;	  CommaDown := false;      IF hasWNE { multifinder in control }         THEN        BEGIN          gotEvent := WaitNextEvent(EveryEvent, myEvent {keyDownEvent} , 60, NIL);        END      ELSE { no multifinder }        BEGIN          SystemTask;          gotEvent := GetNextEvent(EveryEvent, myEvent);        END;        IF (myEvent.modifiers <> 0) AND (cmdKey <> 0) THEN { Pass only command-chars }          BEGIN          KeyCh := CHR(BITAND(myEvent.message, charCodeMask));          IF KeyCh = ',' THEN CommaDown := True; {Return True when cmd-',' found}        END;  		      IF gotEvent THEN        BEGIN            CASE myEvent.what OF            Keydown, AutoKey:              BEGIN                WITH myEvent DO                  BEGIN                    Chcode := Bitand(message, Charcodemask); {Get character}                    ch := Chr(Chcode); {Change to ASCII}                    IF (Ord(Chcode) = 30) THEN Max_Hold := Max_Hold / 1.2;                    IF (Ord(Chcode) = 31) THEN Max_Hold := Max_Hold * 1.2;					                   END;              END;            END; { CASE }          IF myEvent.what = mouseDown THEN Do_Text_Window(myEvent);        END;    END; { Procedure Simplex_Event_Loop }  PROCEDURE PLOT_Simplex(DataMax : Real; ChannelMin, ChannelMax, Window_Counter : Integer);    VAR      channel                       : Integer;      Pix_X_Min                     : Integer;      Pix_X_Max                     : Integer;      Pix_Y_Min                     : Integer;      Pix_Y_Max                     : Integer;      slopeY                        : real;	  InterceptY                    : real;      slopeX                        : real;	  InterceptX                    : real;      temp, M, Left_Val, Right_Val  : real;       strLeft, strRight             : Str255;     BEGIN       Simplex_Event_Loop;  { Look for up or down arrows }      SetPort(grafPtr(colorPPtr)); { Set up to write into off screen buffer }      EraseRect(qd.thePort^.portRect);      RGBBackColor(BackGround_Color);      Pix_X_Min := Full_Left_Screen;      Pix_X_Max := Full_Right_Screen;      Pix_Y_Min := Full_Bottom_Screen;      Pix_Y_Max := Full_Top_Screen;      slopeY := - (Pix_Y_Max - (Pix_Y_Max - Pix_Y_Min) / 2) / DataMax;      InterceptY := - (Pix_Y_Max - Pix_Y_Min) / 2;      slopeX := (Pix_X_Max - Pix_X_Min) / (ChannelMax - ChannelMin);      InterceptX := Pix_X_Min - slopeX * ChannelMin;      MoveTo(rinttol(slopeX * ChannelMin + InterceptX), rinttol(slopeY * (Win[2]^^[ChannelMin]) +                                                            InterceptY));      colorPPtr^.pnSize.h := 1;      colorPPtr^.pnSize.v := 1;      aRGB := SpectrumColor[10];      RGBForeColor(aRGB);      {¥¥¥¥ Main Plotting loop¥¥¥¥}      FOR channel := ChannelMin TO ChannelMax DO        BEGIN          Y_Pixel := rinttol(slopeY * (Win[2]^^[channel]) + InterceptY);          IF (Y_Pixel < Pix_Y_Max) THEN Y_Pixel := Pix_Y_Max;          IF (Y_Pixel > Pix_Y_Min) THEN Y_Pixel := Pix_Y_Min; { Pix_Y_Max here means the bottom of                                                                the screen as per Quickdraw                                                                convention }          X_Pixel := rinttol(slopeX * channel + InterceptX);          colorPPtr^.pnSize.h := 1;          colorPPtr^.pnSize.v := 1;          LINETO(X_Pixel, Y_Pixel);        END; { for channel...}      MoveTo(rinttol(slopeX * ChannelMin + InterceptX), rinttol(InterceptY));      LINETO(rinttol(slopeX * ChannelMax + InterceptX), rinttol(InterceptY)); { Draw the zero line }      MoveTo(rinttol(slopeX * ChannelMin + InterceptX), rinttol(slopeY * (Win[3]^^[ChannelMin]) +                                                            InterceptY));      aRGB := SpectrumColor[9];      RGBForeColor(aRGB);      FOR channel := ChannelMin TO ChannelMax DO        BEGIN          Y_Pixel := rinttol(slopeY * (Win[3]^^[channel]) + InterceptY);          IF (Y_Pixel < Pix_Y_Max) THEN Y_Pixel := Pix_Y_Max;          IF (Y_Pixel > Pix_Y_Min) THEN Y_Pixel := Pix_Y_Min; { Pix_Y_Max here means the bottom of                                                                the screen as per Quickdraw                                                                convention }          X_Pixel := rinttol(slopeX * channel + InterceptX);          colorPPtr^.pnSize.h := 1;          colorPPtr^.pnSize.v := 1;          LINETO(X_Pixel, Y_Pixel);        END; { for channel...}      SetPort(grafPtr(BackPlane));      OffScreen_2_OnScreen; 		{ roi energies are now in eV and true values...}				{Why is dE divided by 10? }			  WITH Analysis_result^^,fit_Params,ExptStuff do BEGIN       Left_Val :=  (Fitting_ROI_Lo[Window_Counter] * energy_slope + energy_intercept) *	   				Plt_spec[10]^^.Expt_Info.dE/10 ;       RealToString(Left_Val, 5, 2, strLeft);      strLeft := Strip_Trailing_Blanks(strLeft);      M := (8000 - (Fitting_ROI_Lo[Window_Counter] * energy_slope + energy_intercept)) /	  	   (8192 - (Fitting_ROI_Lo[Window_Counter] * energy_slope + energy_intercept));      temp := (Fitting_ROI_Hi[Window_Counter] * energy_slope + energy_intercept) * M + 	  		  (8000 - M * 8192); {Calculate the value at the 10th tic mark}       Right_Val := temp * Plt_spec[10]^^.Expt_Info.dE/10 ;      RealToString(Right_Val, 5, 2, strRight);      strRight := Strip_Trailing_Blanks(strRight);      END;	{WITH...}          SetPort(GrafPtr(LeftHLCGPtr));          RGBBackColor(BackGround_Color);		  RGBForeColor(Axes_Color);          SetFont('Monaco', 9, []);  		  EraseRect(LeftHLCGPtr^.portPixMap^^.Bounds);		  		  MoveTo(LeftHLCGPtr^.portPixMap^^.Bounds.Left + 1, LeftHLCGPtr^.portPixMap^^.Bounds.Bottom - 1);          DrawString(strLeft);		  MoveTo(LeftHLCGPtr^.portPixMap^^.Bounds.Right - 50, LeftHLCGPtr^.portPixMap^^.Bounds.Bottom - 1);		  DrawString(strRight);          Numtostring(Window_Counter,strRight);		  strRight := CONCAT('Window in Progress is: ',strRight);		  MoveTo(LeftHLCGPtr^.portPixMap^^.Bounds.Left + 250, LeftHLCGPtr^.portPixMap^^.Bounds.Bottom - 1);		  DrawString(strRight); 			          SetPort(GrafPtr(BackPlane));          RGBBackColor(White_Color);          RGBForeColor(Black_Color); { These are critical for the success of copybits }          CopyBits(BitMapHandle(LeftHLCGPtr^.portPixMap)^^, BitMapHandle(CGrafPort(BackPlane^).portPixMap)^^,                   LeftHLCGPtr^.portPixMap^^.Bounds, LeftHLCGPtr^.portPixMap^^.Bounds, SrcCopy, NIL);          RGBBackColor(BackGround_Color);     END; { procedure PLOT_Simplex }{$S Simplex78}Procedure Load_Data(indx, iindex : integer);	BEGIN     IF (eV_Line[indx] >= ROI^^.PEAK[Window_Counter].Lo * Plt_Spec[10]^^.Expt_Info.dE) AND 	( eV_Line[indx] <= ROI^^.PEAK[Window_Counter].Hi * Plt_Spec[10]^^.Expt_Info.dE) THEN      BEGIN        Counter := Counter + 1;        Analysis_Result^^.Fit_params.Siegbahn[Counter] := Nm_Line[indx];        Analysis_Result^^.Fit_params.Atomic_Number[Counter] := periodic_picks[iindex];        If sign_peak = 0 then sign_peak := counter;		PkAmpInfo[Counter].sign := sign_peak;        IF (Alpha_Peak_in_Window = 0) THEN          BEGIN            Number_of_Independent_Peaks := Number_of_Independent_Peaks + 1;            PkAmpInfo[Counter].wt := one;            PkAmpInfo[Counter].master := Counter;          END        ELSE          BEGIN            PkAmpInfo[Counter].wt := Wt_Line[indx];            PkAmpInfo[Counter].master := Alpha_Peak_in_Window;          END;        Peak_Energy[Counter] := eV_Line[indx] * 0.001;      END;	END;	{Procedure Load_Data}PROCEDURE Load_K_Satelites( Index : integer);	VAR		i		: integer;BEGIN			FOR i := 77 to 96 do begin				Load_Data(i, index);			end;			FOR i := 98 to 100 do begin				Load_Data(i, index);			end;			  END;  { Load_K_Satelites }PROCEDURE Load_L_Satelites_1( Index : integer);	VAR		i		: integer;  BEGIN      	FOR i := 101 to 135 do begin			Load_Data(i, index);		end;       END; { Load_L_Satelites_1( Index : integer); }				 {$S Simplex77}PROCEDURE  Load_M_Satelites( Index : integer);	VAR		i		: integer;    BEGIN		FOR i := 136 to 143 do begin			Load_Data(i, index);		end; END; { Load_M_Satelites }  PROCEDURE L_START_1(Index : Integer);   	VAR   		i		: integer;  BEGIN        Alpha_Peak_in_Window := 0;		sign_peak := 0;		     IF (eV_Line[42] >= ROI^^.PEAK[Window_Counter].Lo * Plt_Spec[10]^^.Expt_Info.dE) AND 		( eV_Line[42] <= ROI^^.PEAK[Window_Counter].Hi * Plt_Spec[10]^^.Expt_Info.dE) THEN	      BEGIN	        Counter := Counter + 1;	        Number_of_Independent_Peaks := Number_of_Independent_Peaks + 1;	        Analysis_Result^^.Fit_params.Siegbahn[Counter] := Nm_Line[42];	        Analysis_Result^^.Fit_params.Atomic_Number[Counter] := periodic_picks[index];	        Alpha_Peak_in_Window := Counter;	        sign_peak := Counter;	        PkAmpInfo[Counter].wt := Wt_Line[42];	        PkAmpInfo[Counter].master := Alpha_Peak_in_Window;	        Peak_Energy[Counter] := eV_Line[42] * 0.001;	      END;			i := 43;		Load_Data(i, index);	FOR i := 14 to 15 do begin		Load_Data(i, index);	end;	i := 18;	Load_Data(i, index);	i := 29;	Load_Data(i, index);	i := 31;	Load_Data(i, index);	i := 35;	Load_Data(i, index);	i := 45;	Load_Data(i, index);	i := 49;	Load_Data(i, index);                	if Minors then begin		FOR i := 8 to 13 do begin			Load_Data(i, index);		end;		FOR i := 16 to 17 do begin			Load_Data(i, index);		end;		FOR i := 19 to 28 do begin			Load_Data(i, index);		end;		i := 30;		Load_Data(i, index);		FOR i := 32 to 34 do begin			Load_Data(i, index);		end;		FOR i := 36 to 41 do begin			Load_Data(i, index);		end;		i := 44;		Load_Data(i, index);		FOR i := 46 to 48 do begin			Load_Data(i, index);		end;		FOR i := 50 to 52 do begin			Load_Data(i, index);		end;		i := 144;	{¥¥5/16/99 LG2¥¥}		Load_Data(i, index);	end;	{if Minors}END; { PROCEDURE L_START_1(Index : Integer) }			   	PROCEDURE Load_M_Minors(Index : Integer);	VAR		i		: integer;		BEGIN		FOR i := 53 to 55 do begin			Load_Data(i, index);		end;		FOR i := 58 to 60 do begin			Load_Data(i, index);		end;		FOR i := 62 to 65 do begin			Load_Data(i, index);		end;		FOR i := 67 to 68 do begin			Load_Data(i, index);		end;		FOR i := 70 to 71 do begin			Load_Data(i, index);		end;	END;	{PROCEDURE Load_M_Minors}  {$S Simplex1}  PROCEDURE Simplex_Start;    var 	  calibrate_is_on	: boolean;    PROCEDURE Start; { this is done only once }      VAR                Index,nn,NumZ,nz,nfam,numfams,num_in_Fam   : Integer;        str1,str2				    	: str255;		LowEv, HiEv : real;		do_K,do_L,do_M					: boolean;        i								: integer;			keV_per_Channel					:  real {double_t};      BEGIN {procedure start }        {  Number_of_PeakRois; global; given value in MCA }		{¥¥¥ We weight only if the alpha line is in the window.¥¥¥}		{¥¥¥ We check the sign of all amplitudes against the first line that occurs.¥¥¥}		{The user draws a ROI around a peak bundle he sees in the spectrum. If the spectrum		 is shifted etc, peaks he sees in his window may not be 'found' below. If he has		 calibrated his spectrum, we may do either of two things to find all the peaks:		 1) compare book energies to window energies in book space, or		 2) compare line energies converted to data space to apparent window energies.		 We have to do one or the other whether Calibrate_Energy_Scale is true or false.		 2) requires fewer code changes.		 Calibrate_Energy_Scale => true and back to correct value in PROCEDURE Simplex_Start		 xray_data_request = false causes Get_Energies to convert x-ray energies to		 data space values so that the correct lines are found for the Rois.		 Roi energies ARE in data space values in this procedure. The Roi energies are		 converted to true values at the end so that spectra with any calibration		 can be fit for the SAME LINES.}        		Cal_vals.Energy_Slope := Plt_Spec[10]^^.Expt_Info.Energy_Slope;		Cal_vals.Energy_Intercept := Plt_Spec[10]^^.Expt_Info.Energy_Intercept;		keV_per_Channel := Plt_Spec[10]^^.Expt_Info.dE * 0.001; { ch calibration in kev/ch}        Total_Number_of_Peaks := 0; { number of peaks so far }        Counter := 0; {# pks found}        Analysis_Result^^.Fit_params.Number_of_Windows := Number_of_PeakRois - 1;		numfams := 0;				if Skip_some then numfams := getHandleSize(Handle(SkipFam)) div sizeof(aFamily);		FOR nn := 1 TO Analysis_Result^^.Fit_params.Number_of_Windows DO          BEGIN		    Window_Counter := nn;            Number_of_Independent_Peaks := 0; {# independent peaks in each window}            Analysis_Result^^.Fit_params.First_in_Roi[Window_Counter] := Counter + 1;						FOR Index := 1 TO Number_of_Elements_Simplexed DO			BEGIN				do_K := true;				do_L := true;				do_M := true;	          if Skip_some then			  begin		        nfam := 1;				Repeat						if ((SkipFam^^[nfam].Z = periodic_picks[Index]) and						((SkipFam^^[nfam].Roi  = Window_Counter) or (SkipFam^^[nfam].Roi = 1000))) then					begin	{there should be only ONE false in any window because there should be					         only lines from one family for the Z in a window...However fit with							 auto_rois usually gives more than one false and for all rois}				      if (SkipFam^^[nfam].skip_fam=1) then do_K := false else					  if (SkipFam^^[nfam].skip_fam=2) then do_L := false else					  if (SkipFam^^[nfam].skip_fam=3) then do_M := false;				    end;		        	nfam := nfam + 1;				Until (nfam > numfams);	{must go thru all SkipFam...} 			  end;	{if Skip_some then...}			  			  numZ := counter;	{total number of lines so far...zero the 1st time thru}			  num_in_Fam := counter; {at the end of each family, counter - num_in_Fam is			                          number of lines found in the roi for the family}			  Get_Energies(periodic_picks[Index]);{...gives energies converted to data space}			  Alpha_Peak_in_Window := 0; { This is set to 0 for each line family;increments to 1										  to indicate existence of alpha in window}			  sign_peak := 0;										  { periodic_picks[index] is defined in Get_Simplex_Energies in Utilities.p }	     IF (eV_Line[1] >= ROI^^.PEAK[Window_Counter].Lo * Plt_Spec[10]^^.Expt_Info.dE) AND 		( eV_Line[1] <= ROI^^.PEAK[Window_Counter].Hi * Plt_Spec[10]^^.Expt_Info.dE) THEN	      BEGIN	        Counter := Counter + 1;	        Number_of_Independent_Peaks := Number_of_Independent_Peaks + 1;	        Analysis_Result^^.Fit_params.Siegbahn[Counter] := Nm_Line[1];	        Analysis_Result^^.Fit_params.Atomic_Number[Counter] := periodic_picks[index];	        Alpha_Peak_in_Window := Counter;	        sign_peak := Counter;	        PkAmpInfo[Counter].wt := Wt_Line[1];	        PkAmpInfo[Counter].master := Alpha_Peak_in_Window;	        Peak_Energy[Counter] := eV_Line[1] * 0.001;	      END;						FOR i := 2 to 3 do begin				Load_Data(i, index);			end;                 	 	        if Minors then begin	        FOR i := 4 to 7 do BEGIN				Load_Data(i, index);			END;			i := 97;{¥¥¥¥This satelite needs to always be fit }			Load_Data(i, index);			end;	{if Minors}       if Satellites then Load_K_Satelites (index);    	If counter > num_in_Fam then	{found some lines for this fam in this roi}	begin  	  If (do_K) then for nz := num_in_Fam + 1 to counter do								   Analysis_Result^^.Fit_params.ref_index[nz] := 0	  else for nz := num_in_Fam + 1 to counter do	   begin				Analysis_Result^^.Fit_params.ref_index[nz] := -1;	   end;     num_in_Fam := counter;   end;	{If counter > num_in_Fam...}	 L_START_1(index); {Break up the procedures so the stupid compiler can accept them }     if Satellites then 	    BEGIN		  Load_L_Satelites_1 (index); {Break up the procedures so the stupid compiler can accept them }		END;      	If counter > num_in_Fam then	begin	  If (do_L) then for nz := num_in_Fam + 1 to counter do							   Analysis_Result^^.Fit_params.ref_index[nz] := 0 	  else for nz := num_in_Fam + 1 to counter do	  begin	  		Analysis_Result^^.Fit_params.ref_index[nz] := -1;	  end;      num_in_Fam := counter;	end;			        Alpha_Peak_in_Window := 0;		sign_peak := 0;;	     IF (eV_Line[72] >= ROI^^.PEAK[Window_Counter].Lo * Plt_Spec[10]^^.Expt_Info.dE) AND 		( eV_Line[72] <= ROI^^.PEAK[Window_Counter].Hi * Plt_Spec[10]^^.Expt_Info.dE) THEN	      BEGIN	        Counter := Counter + 1;	        Number_of_Independent_Peaks := Number_of_Independent_Peaks + 1;	        Analysis_Result^^.Fit_params.Siegbahn[Counter] := Nm_Line[72];	        Analysis_Result^^.Fit_params.Atomic_Number[Counter] := periodic_picks[index];	        Alpha_Peak_in_Window := Counter;	        sign_peak := Counter;	        PkAmpInfo[Counter].wt := Wt_Line[72];	        PkAmpInfo[Counter].master := Alpha_Peak_in_Window;	        Peak_Energy[Counter] := eV_Line[72] * 0.001;	      END;								FOR i := 73 to 74 do begin			Load_Data(i, index);		end;		FOR i := 56 to 57 do begin			Load_Data(i, index);		end;		i := 61;		Load_Data(i, index);		i := 66;		Load_Data(i, index);		i := 69;		Load_Data(i, index); 	                	if Minors then Load_M_Minors(Index);     if Satellites then Load_M_Satelites (index);    	If counter > num_in_Fam then	begin	  If (do_M) then for nz := num_in_Fam + 1 to counter do							   Analysis_Result^^.Fit_params.ref_index[nz] := 0 	  else for nz := num_in_Fam + 1 to counter do	  begin	  		Analysis_Result^^.Fit_params.ref_index[nz] := -1;	  end;    end; 			 {Have found all the lines for element #index in window Window_Counter}			 			  If counter > numz then {numz set = to counter at start of the loop for this Roi} 			  {there are some lines for element index in window Window_Counter;			   if ref_index for the line is -1 then it is to be skipped in the fitting			   but do everything for now...}			  Begin				  nz := numz + 1;				  {convert the Peak_Energy[nz] in keV back to book values...}				  Peak_Energy[nz] := (Peak_Energy[nz] -									  Analysis_Result^^.ExptStuff.energy_intercept/1000)/								     (Analysis_Result^^.ExptStuff.energy_slope);				  HiEv := Peak_Energy[nz];				  LowEv := Peak_Energy[nz];				  				  for nz := numz + 2 to counter do				  begin					 Peak_Energy[nz] := (Peak_Energy[nz] -									   Analysis_Result^^.ExptStuff.energy_intercept/1000)/									  (Analysis_Result^^.ExptStuff.energy_slope);					 if Peak_Energy[nz] >= HiEv then  HiEv := Peak_Energy[nz]					 else if Peak_Energy[nz] < LowEv then LowEv := Peak_Energy[nz];					 {...for elements below Fl alpha energies are =, so the low E line will					  be the alpha1 and the hi E line will be alpha2}				  end;	{ for nz := numz + 2...}				  				  With Analysis_Result^^,Fit_params DO				  Begin				   LowEv := LowEv * 1000;				   HiEv := HiEv * 1000;				   for nz := numz + 1 to counter do				   begin {with each line for Z in the window save the same data}					  ev_LoLine[nz] := LowEv;	{book energies in ev}					  ev_HiLine[nz] := HiEv;				   end;				  End;	{With Analysis_Result^^...}			 			  End;	{ If counter > numz...}			              END; { FOR INDEX 1 to # elements }            IF (Counter - Total_Number_of_Peaks = 0) THEN              BEGIN                numtostring(Window_Counter, str1);                Str2 := concat('None of the elements checked, if any, have lines in window ', str1);                putmessage(Str2, 'Please correct the elements selected, or', 'clear the Peak Roi.', '');			    simplex_active:=false;                BigExit := TRUE;                exit(Start);              END;            Total_Number_of_Peaks := Counter;            IF Total_Number_of_Peaks > MaxNumPks THEN              BEGIN                putmessage('There are more peaks in the total number of windows than the',                           'present dimension statements allow: sorry, but you must start over.',                           '', '');                exit(Start);              END;			  Analysis_Result^^.ExptStuff := Plt_Spec[10]^^.Expt_Info;		  {Save true window energies so that setup may be used with any spectrum calibration;		   Analysis_Result.ExptStuff is always from the spectrum being fit. 		   NOTE eV,  NOT keV.} 		 Analysis_Result^^.Fit_params.Fitting_ROI_Lo[Window_Counter] := 		  (ROI^^.PEAK[Window_Counter].Lo * Analysis_Result^^.ExptStuff.dE -		   Analysis_Result^^.ExptStuff.energy_intercept)/Analysis_Result^^.ExptStuff.energy_slope;		 Analysis_Result^^.Fit_params.Fitting_ROI_Hi[Window_Counter] := 		  (ROI^^.PEAK[Window_Counter].Hi * Analysis_Result^^.ExptStuff.dE -		   Analysis_Result^^.ExptStuff.energy_intercept)/Analysis_Result^^.ExptStuff.energy_slope;	    		END; { For Window_Counter...}        Analysis_Result^^.Fit_params.Number_of_Peaks := Total_Number_of_Peaks;        IF (Total_Number_of_Peaks = 0) THEN exit(Start);					Analysis_Result^^.Fit_params.Fit_Procedure := 'Sm';		Simplex_active := True;		LLSQ_active := False;		Hall_Active := False;      END; { procedure start }  BEGIN	{ PROCEDURE Simplex_Start; }       IF Elements_Chosen = FALSE THEN      BEGIN          BeepBeep;          putmessage('You have not chosen any elements to Simplex.', 'Do that now.', '', '');      	  	 IF ROI^^.PEAK[1].Exists = FALSE THEN         BEGIN          BeepBeep;		  if (AnswerMessage('There are no PEAK ROIS to indicate peak bundles to be fit!',						   'If IT`S OK I`ll go to AUTO ROI; if not, set up ROIS in the ROI window.',						   '   {Use QUANT ROI to select your background for ratios of peak areas',						   '     to a chosen background. The default is 1.35 to 1.45 keV.}'))		  then begin				   Use_Manual_ROIs := false;				   AutoROI_Chooser;		       end          else exit(Simplex_Start);         END	{...PEAK[1].Exists = FALSE...}		 ELSE BEGIN		 (* Use_Manual_ROIs := true;...set this true only in SiliWin CRT 9/20/95 *) 		  AutoROI_Chooser;         END;	{...PEAK[1].Exists = TRUE...}	  END;	{IF Elements_Chosen = FALSE...}				       GetDateTime(Start_Time);      The_Time := Start_Time;	  calibrate_is_on := xray_data_request;	  xray_data_request := false;      Start;	{gets the energies in data space}	  xray_data_request := calibrate_is_on;        WITH Analysis_result^^.fit_Params DO      WITH Plt_spec[10]^^.Expt_Info DO        BEGIN			  {if ROI^^.Quant.Exists save the calibrated			   true energies of the end points so other spectra with different calibrations			   can be integrated between the same energies; otherwise use 1450 ev and 1540 ev}                IF (ROI^^.Quant.Exists) THEN                BEGIN				{if the spectrum is calibrated do ch -> energy in calibrated space...}		         Chosen_ROI_Lo := {0.001 * }(ROI^^.Quant.Lo * dE - energy_intercept)/energy_slope; { energy of 1st filter ch }		         Chosen_ROI_Hi := {0.001 * }(ROI^^.Quant.Hi * dE - energy_intercept)/energy_slope; { energy of 1st filter ch }                END				ELSE BEGIN                  Chosen_ROI_Lo := 1450.0;                  Chosen_ROI_Hi := 1540.0;				END;        END; { WITH Analysis_Result^^... }   END;	{PROCEDURE Simplex_Start;}       PROCEDURE Sequential_Simplex;    CONST      Hi_Peak_Meas                  = 3;      Lo_Peak_Meas                  = 9;    VAR            lista                         : LinFitIntArray;      covar                         : LinFitCovArray;      tempRect                      : Rect;	  TextRect                      : Rect;      DItem                         : Handle;      PkInfo                        : ARRAY [1..MaxNumPks] OF WtngInfo; { integers and reals } 	  eprime                        : PKARRAY_ptr;  {points to double_t }	  amp                           : PKARRAY_ptr;  {points to double_t }	  sig                           : PKARRAY_ptr;  {points to double_t }	        Number_of_IndPeaks_in_Window  : Integer;      Total_Number_of_Peaks         : Integer;      Number_of_Peaks_in_Window     : Integer;	  Number_Fit_in_Window          : Integer;      NumChs_in_Window              : Integer;      Number_of_Axes                : Integer;        { number of axes = npeak+2 <= MaxNumCords,}	                                                  {( energies+ampl and sigma of largest) }      Number_of_Vertices            : Integer;        { number of vertices (= npeak+3: input set of energy }      Filter_Plus_Window            : Integer;        { # of data channels in the nwth window + filter; calc'd in simcont }      iter8                         : Integer;        { iteration counter (per window)}      Window_Counter                : Integer; 	  Index                         : Integer;	  DType                         : Integer;	  	  OldTime                       : Longint;	        sigmax                        :  real {double_t};      sigmin                        :  real {double_t};      Energy_Limit_keV              :  real {double_t};       { limit for pk energy in kev }      arg                           :  real {double_t};       { Variable used locally in FIT and REPORT }      filtkev                       :  real {double_t};      keV_to_Channel                :  real {double_t};      keV_per_Channel               :  real {double_t};           { energy per channelin kev }       Peak_Amplitude                : PKARY;        { Peak_Amplitude(i) is estimated amplitude of ith peak, simcont }      Energy_Difference             : PKARY;        { Energy_Difference(i) is Peak_Energy(i) - Peak_Energy(Biggest_Peak_Index),                                                       simcont }      Peak_Sigma                    : PKARY;        { Peak_Sigma(i) is estimated sigma (kev) of ith peak }      BkgSubt                       : Boolean;      str				            : Str255;     PROCEDURE simcont; { for each window this calls all the routines that process peak bundle and report results }      VAR        EDiffev                       :  real {double_t};        FWHMBigPk                     :  real {double_t};        emax                          :  real {double_t};        emin                          :  real {double_t};        amax                          :  real {double_t};		amin                          :  real {double_t};        Pert_factor                   :  real {double_t};        endev                         :  real {double_t};        ediff                         :  real {double_t};        fwhmw                         :  real {double_t};        bigpk                         :  real {double_t};		bigpkE                        :  real {double_t};        Vertex_Response               : ARRAY [1..MaxNumVertices] OF  real {double_t};	{51 vertices}        nfw                           : Integer;        nrd                           : Integer;        i                             : Integer;        ii                            : Integer;        n1                            : Integer;        firstpk                       : Integer;        Biggest                       : Integer;        First_Filter_Channel          : Integer;        np                            : Integer;        Last_Filter_Channel           : Integer;        Lowest_Response               : Integer;        Highest_Response              : Integer;        npkch                         : Integer;         	  PROCEDURE GetOut;	  VAR i : integer;		  BEGIN			BigAutoFitExit := True;			FOR i := 1 TO 3 DO			  H_UnLock_Dispose(Handle(Win[i]), 'Win[i] in Aborting SIMPLEX');			Spectrum_Size := 1024;			ChannelMin := 1;			ChannelMax := 1024;			Old_ChannelMin := 1;			Old_ChannelMax := 1024;			New_Range := 1024;			Range_Keeper := 7; { 7 is 1024 }			Spectrum_Full[1] := FALSE;			CheckItem(FullMenu, A^.C_Full[9], Spectrum_Full[1]);			Spectrum_Full[9] := FALSE;			CheckItem(FullMenu, A^.C_Full[9], Spectrum_Full[9]);			Open_Sili_Window; { Return to the SiLi window }			Mouse_Active_Window;			Update_Full;			exit(Sequential_Simplex);		  END;      PROCEDURE Set_Limits;	          BEGIN { procedure Set_Limits }		 { SIGMA HAS TO HAVE A DYNAMIC TEST...THE BACK CALCULATED SIGMA AT THE ENERGY		   VERTEX MUST BE WITHIN THE LIMITS; THIS CALC IS DONE IN FUNCTION LIMIT;		   THE SIGMAX AND SIGMIN ARE CALCULATED IN THE MAIN PROC;		   ROI enrgies are spectrum space values in eV}		  WITH Analysis_result^^,fit_Params,ExptStuff DO BEGIN          IF constraint_switch THEN            BEGIN	{Fitting_ROI_Hi and Fitting_ROI_Lo are true window energies so convert to			         spectrum energies}              { set maximum and minimum energy of biggest peak in keV...it must be in the ROI }              emax := Peak_Energy[Biggest] * energy_slope + energy_intercept/1000 + Energy_Limit_keV;              IF emax >( Fitting_ROI_Hi[Window_Counter] * energy_slope + energy_intercept)/1000 THEN                emax := (Fitting_ROI_Hi[Window_Counter] * energy_slope + energy_intercept)/1000;              emin := Peak_Energy[Biggest] * energy_slope + energy_intercept/1000 - Energy_Limit_keV;              IF emin < (Fitting_ROI_Lo[Window_Counter] * energy_slope + energy_intercept)/1000 THEN                emin := (Fitting_ROI_Lo[Window_Counter] * energy_slope + energy_intercept)/1000;            END          ELSE            BEGIN              emax := (Fitting_ROI_Hi[Window_Counter] * energy_slope + energy_intercept)/1000;              emin := (Fitting_ROI_Lo[Window_Counter] * energy_slope + energy_intercept)/1000;            END;		  END;	{WITH...}		 if (bigpk >= Peak_Amplitude[Biggest]) then         	amax := bigpk + 0.2*(bigpk) { bigpk = highest ch cnt in the window }         else         	amax := Peak_Amplitude[Biggest] + 0.2*(Peak_Amplitude[Biggest]);        (*  amin := - 3.2 * SQRT(bigpk);	10/4/95  *)		  amin := - amax;        END; { procedure Set_Limits }      PROCEDURE perturb;       (* To start pert_factor = 1 so that the perturbations are .001*fwhm,          .01*energy, .2*amp. This allows tight constraint on fwhm; assumes          that any non-linearity in energy calibration is increasing with energy.           aSimplex[j,i] : j => the vertex, i=> parameter.            For the fitting to switch to all peaks free, all values between the          worst vertices in two Simplexs have a relative difference less than the          input tolerance * switch_factor. When the switch to free fitting occurs,          the current best vertex is used for the new starting values. We don't           want to perturb these values too much so the pert_factor becomes          input tolerance * switch_factor.            *)        VAR          j, i                          : Integer;        BEGIN { procedure perturb }          { set sigma of biggest peak estimate }          aSimplex[1, 1] := Peak_Sigma[Biggest]; { sigma of biggest pk in kev for EDS and WDS }		  { set energy in data space of biggest peak estimate }          aSimplex[1, 2] := Peak_Energy[Biggest] * analysis_result^^.ExptStuff.energy_slope		  					+ analysis_result^^.ExptStuff.energy_intercept/1000;          { set peak amplitude estimates }          j := 0;          FOR i := (1 + Total_Number_of_Peaks) TO		           (Total_Number_of_Peaks + Number_of_Peaks_in_Window) DO		 {ref_index is set in start: 0 = do the pk, -1 = skip the peak}		  IF (Analysis_Result^^.Fit_params.ref_index[i] <> -1) then		  IF (PkInfo[i].master = i) THEN { this is an independent peak, use for vertex; after		   wtswitch, this is true for all peaks except KA2s}		  BEGIN			j := j + 1;			{ total_Number_of_Peaks here is the num of peaks, fit or not, from prev windows }			aSimplex[1, j + 2] := Peak_Amplitude[i];		  END;	{FOR i := (1 + Total_Number_of_Peaks)...}          		  { copy first vertex to all others }          FOR i := 2 TO Number_of_Vertices DO            FOR j := 1 TO Number_of_Axes DO              aSimplex[i, j] := aSimplex[1, j];          { Perturb one parameter estimate of all but first vertex to form initial simplex.}          {...perturb a sigma of biggest peak}          aSimplex[2, 1] := aSimplex[2, 1] * (1.0 - Width_Perturb * Pert_factor);          {...perturb an energy of biggest peak }          aSimplex[3, 2] := aSimplex[3, 2] * (1.0 - Energy_Perturb * Pert_factor);          {...perturb peak amplitudes }          FOR j := 1 TO (Number_of_Axes - 2) DO {...to #ind peaks which increases at switch}            BEGIN              aSimplex[j + 3, j + 2] := aSimplex[j + 3, j + 2] * (1.0 - Amp_Perturb * Pert_factor);            END;        END; { end procedure perturb }       PROCEDURE fit;       { fit -- perform simplex fit ;  calls Convergence_Test, Replace, Response }        VAR                                           {for fit}          just_did                      : Str255;          alpha                         :  real {double_t};          beta                          :  real {double_t};          gamma                         :  real {double_t};          abar, astar, astar2           : COORDinate; { 52 double_t }          oldv                          : subspace;	{array of 1..3 of COORDinate}          rstar2, rstar                 :  real {double_t};          j, i                          : Integer;    { index of highest Response vertex, }          { Lowest_Response is defined in simcont }        FUNCTION Convergence_Test({iter8: Integer;} VAR vertex: COORDinate): Boolean;        { Convergence_Test -- test for convergence. 		  Enter: vertex = vertex with highest, ie worst, Response;          returns true if termination satisfied, false if termination criteria not satisfied }          VAR                                         {for Convergence_Test}            dv                            :  real {double_t};            oldarg                        :  real {double_t};            i, j	                      : Integer;            test                          : Boolean;            FWHMMn_temp                   :  real {double_t};          BEGIN {funct Convergence_Test }		    just_did := '';            test := True;            IF (iter8 = 1) THEN oldarg := 0.0;            IF (iter8 <= Maximum_Iterations) THEN {if iter8 >= Maximum_Iterations Convergence_Test is true}              BEGIN { if iter8 }                i := 1 + iter8 MOD 3; {1 mod 3=1, 2 mod 3=2, 5 mod 3=2}                IF (iter8 <= 3) { must do min of three to initialize oldv[1..3,Number_of_Axes]}                THEN test := FALSE				ELSE IF (Vertex_Response[Lowest_Response] >= 1.0E29)				THEN test := FALSE                ELSE                BEGIN { test for convergence }				  FOR j := 1 TO Number_of_Axes DO { over sigma, energy and the n amps }				  BEGIN					IF test THEN					BEGIN					   dv := oldv[i, j];					   IF oldv[i, j] = 0.0 THEN					   BEGIN					   		{beepbeep;}					   		dv := Analysis_result^^.fit_Params.Toler;					   END;					   arg := (vertex[j] - oldv[i, j]) / dv;					   {if oldv = 0, vertex <= toler**2 for TEST to stay true!}					   IF (abs(arg)) > (Analysis_result^^.fit_Params.Toler) THEN					   BEGIN							   test := FALSE;							   oldarg := arg;					   END; {IF (abs(arg)) >...}					END; {if test }                  END; {FOR j}                END; { else }                FOR j := 1 TO Number_of_Axes DO                  oldv[i, j] := vertex[j]; { save current vertex }              END; { if iter8 <= Maximum_Iterations...}            IF Plt_spec[10]^^.Expt_Info.Detector.spec = WDS THEN              FWHMMn_temp {in ev} := - 1 { to indicate that this is meaningless }            ELSE FWHMMn_temp {in ev} := 2354.825 * Sigma_Compute(vertex[1], 5.895 - vertex[2]);          GetDateTime(The_Time);		  		 	(*	 IF Fit_Invisibly then IF (OldTime <> The_Time) then begin				PLOT_Simplex(Max_Hold, 1, Filter_Plus_Window - nfw, Window_Counter );				Simplex_Event_Loop;                OldTime := The_Time;		 end else...the next bit should work too		*)		 IF NOT Calibrate_Window_Active THEN         IF (OldTime <> The_Time) THEN		 IF Vertex_Response[Lowest_Response] < 1.0E29 THEN         BEGIN				IF NOT Fit_Invisibly THEN begin				  				  SetPort(TextWindow);				  EraseRect(TextRect);				  Setrect(TextRect, 175, 0, 585, 116); { Leave enough room on the right for the "bye" button. }  				  SetFont('Geneva', 12, []);                  				  str := '';				  moveto(176, 50);				  numtostring(The_Time - Start_Time, str);				  DrawString(str);  				  moveto(176, 68);				  RealToString((arg), 9, 8, str); { -2 for scientific notation }				  DrawString(str); {this outputs the spread of the last amp of the worst vertex }  				  moveto(176, 32);				  RealToString((Vertex_Response[Lowest_Response]), 6, 5, str);				  DrawString(str);  				  moveto(176, 14);				  RealToString((aSimplex[1, 1]) * 2355.0, 5, 2, str);				  DrawString(str);				 				  str := '';				  moveto(176, 86);				  IF (arg = - oldarg) THEN str := just_did				  ELSE numtostring(iter8, str);				  DrawString(str);  				  moveto(176, 103);				  RealToString((FWHMMn_temp), 5, 2, str);				  DrawString(str);				END;	{IF NOT Fit_Invisibly}				PLOT_Simplex(Max_Hold, 1, Filter_Plus_Window - nfw, Window_Counter );												{Simplex_Event_Loop;} {If not plotting, put this back.}				                OldTime := The_Time;              END;	{ not Calibrate_Window_Active...(OldTime <> The_Time)...}            IF Calibrate_Window_Active THEN			 IF (OldTime <> The_Time) THEN              BEGIN                SelectWindow(Calibrate_GetSelection);                SetPort(Calibrate_GetSelection);                BackColor(WhiteColor);                ForeColor(BlackColor);                IF Window_Counter = 1 THEN                  BEGIN                    Low_Peak_Meas := aSimplex[Lowest_Response, 2] * 1000;                    GetDialogItem(Calibrate_GetSelection, Lo_Peak_Meas, DType, DItem, tempRect);                    RealToString(Low_Peak_Meas, 5, 3, str);                    SetDialogItemText(DItem, str);                  END;                IF Window_Counter = 2 THEN                  BEGIN                    High_Peak_Meas := aSimplex[Lowest_Response, 2] * 1000;                    GetDialogItem(Calibrate_GetSelection, Hi_Peak_Meas, DType, DItem, tempRect);                    RealToString(High_Peak_Meas, 5, 3, str);                    SetDialogItemText(DItem, str);                  END;				  OldTime := The_Time;               END;            			if CommaDown then { Force a convergence, useful in a batch run to continue on if the			                 Simplex hangs in its little back and forth problem }                  BEGIN				    beepbeep;                     Convergence_Test := True;                    exit(Convergence_Test);                  END;			            spincursor;            IF (stopButton) OR (Interrupted) THEN                 IF ((NOT Fit_Invisibly) or Calibrate_Window_Active) THEN                  BEGIN                    Convergence_Test := True;                    exit(Convergence_Test);                  END                  ELSE GetOut;	{Fit_Invisibly = T for Calibrate}  			            Convergence_Test := test;                      END; {function Convergence_Test }       		FUNCTION Response(VAR vertex: COORDinate):  real {double_t};         { Response -- compute Response of specified vertex }          VAR                                         { for Response }            kk, np, j, jj,sp                 : Integer;            absfil, temp             :  real {double_t};      		theResp				  :  real {double_t};          FUNCTION limit(VAR vertex: COORDinate): Boolean;             { limit -- test vertex against limits; enter: vertex = vertex to be checked;              returns true if the vertex exceeds a limit, false if the vertex is within limits }            VAR              i                             : Integer;              test                          : Boolean;              sig_Mn                        :  real {double_t};            BEGIN { fnc limit }              test := FALSE;              IF ((vertex[2] > emax) OR (vertex[2] < emin)) THEN			  begin			  	test := True;				{putmessage('energy limit violation','','','');}			  end              ELSE BEGIN                  IF wds_active THEN				  BEGIN					IF (vertex[1] > sigmax) OR (vertex[1] < sigmin) THEN test := True				  END                  ELSE BEGIN				      i := 1;				      {calculate sig at Mn from vertex sig}                      sig_Mn := Sigma_Compute(vertex[1], (5.895 - vertex[2]));                      If (sig_Mn > sigmax) OR (sig_Mn < sigmin) THEN test := True                      Else Repeat						  if abs(vertex[i + 2]) > amax THEN test := True						  else i := i + 1;					  Until (i >= (Number_of_Axes - 2)) or (test = True);                   END;              END; { ELSE BEGIN }              limit := test;            END; { fnc limit... called by function Response}          BEGIN { function Response }		  {Unfortunately, even tho' the energy values are in data space, PROFILE generates pure		   Gaussians unaffected by the slope so the fit to real improperly calibrated spectra		   can never be very good.}            IF limit(vertex) THEN begin			  { if limit is true, a value exceeds its limit and the response of the vertex			    is set so that it becomes the worst vertex.}              theResp := 1.0E29;			END            ELSE BEGIN			  theResp := 0.0;			  kk := 0;			  j := 0;			  jj := Total_Number_of_Peaks;	{Total_Number_of_Peaks			  								 counts all pks inc those not fit}			  sp := 1;			  REPEAT				jj := jj + 1;					IF (Analysis_Result^^.Fit_params.ref_index[jj] <> -1) then				Begin	{it is being fit}				  kk := kk + 1;	{count a pk to fit in the window}				  eprime^[kk] :=  (Energy_Difference[kk] + vertex[2]);				  {maybe the energy difference shuold be dynamic...}				  sig^[kk] :=  (Sigma_Compute(vertex[1], Energy_Difference[kk]));				   IF (jj = PkInfo[jj].master) THEN				   BEGIN {weighting and jj IS master peak, or finished weighting }{can only wt if alpha1 pk in the window; then it is the master, otherwise each pk is its own master pk...the most major line in the family in the window is always the sign peak}					 np := kk;		{...hold for amp calculation for wtd pks}					 j := j + 1; {count an independent pk}					 if jj = PkInfo[jj].sign then sp := j;{true only for sign pk}					 {...amp determined without weighting but					 it must have the same sign as the sign pk...}	 (*       		 IF (vertex[j + 2]/vertex[sp + 2] < 0.0) THEN	   {10Nov95}    		theResp := 1.0E29	   			     ELSE amp^[kk] :=  (vertex[j + 2]);				*)	        		 IF (vertex[j + 2]/vertex[sp + 2] < 0.0) THEN					 Begin{later10Nov95}    		vertex[j + 2] := - vertex[j + 2];						amp^[kk] :=  vertex[j + 2];					 END	   			     ELSE amp^[kk] :=  (vertex[j + 2]);				   END	{IF (jj = ...}				   ELSE BEGIN	{if each pk is NOT its own Master Pk they have the same sign by definition}					{ amp in generated space * Wtng for amp from wtng for area * Eff}					 amp^[kk] :=  ((vertex[j + 2] / Det_Effic_P^[rinttol(eprime^[np] * 1000.0 / Plt_spec[10]^^.Expt_Info.dE)]) *					               (PkInfo[jj].wt * sig^[np] / sig^[kk]) *								   Det_Effic_P^[rinttol(eprime^[kk] * 1000.0 / Plt_spec[10]^^. Expt_Info.dE)]);			       END;	{IF (jj = PkInfo[jj].master)...ELSE BEGIN...}					End;{IF (ref_index[i] <> -1)...}			  UNTIL ((theResp > 0.0) or (kk = Number_Fit_in_Window));			  			  IF (not (theResp > 0.0)) THEN	{calculate the response...}			  BEGIN			 {   calculate the  sum of gaussians at each channel -				 array Win[1]^^ will have sum at each ch of all gaussians and incomplete chg				 for the window + filter chs at each end }				  FOR j := 1 TO Max_Fitting_Chans DO					BEGIN					   Win[1]^^[j] := 0.0; 					   Win[3]^^[j] := 0.0;					END;								   profile(filtkev, keV_per_Channel, eprime^, amp^ , sig^, Number_Fit_in_Window, Filter_Plus_Window, Win[1]^^);				 { generates gaussians for fit pks into first (Filter_Plus_Window) chs of Win[1]^^ }  			   atophat(Win[1]^^, Win[3]^^, Filter_Plus_Window, nfw);				 { filtered gaussians into first (Filter_Plus_Window-nfw) chs of Win[3]^^ }  				  Simplex_Event_Loop;   				  temp := 0.0;		(*    with Analysis_result^^,fit_Params,ExptStuff do				  kk := rinttol((Fitting_ROI_Lo[Window_Counter] * energy_slope + energy_intercept)/							  dE);						       FOR j := 1 TO (Filter_Plus_Window - nfw) DO			   BEGIN				  absfil := abs((Col_1^[kk + j - 1]));				   { original data }						   IF absfil = 0.0 THEN absfil := 1.0;  				   temp := temp + (Win[2]^^[j] - Win[3]^^[j]) * (Win[2]^^[j] - Win[3]^^[j]) / absfil;			 {...this is norm. by original data...should be normalized by variance in filtered data:			     that is the ·Col_1^ over the filter chs for each ch.}			   END; { j loop }	    *)  {7/25/95}    with Analysis_result^^,fit_Params,ExptStuff do				{ np := rinttol((Fitting_ROI_Lo[Window_Counter] * energy_slope + energy_intercept)/							  dE) - 1;}	{...first ch in Fitting_ROI in original data less 1}				  kk := First_Filter_Channel - 1;	{First_Filter_Channel is nrd lower than ist roi ch}				  FOR j := 1 TO (Filter_Plus_Window - nfw) DO				  BEGIN	{loop thru num of chs in fitting roi for (Ydata-Yfit)**2 in filtered space...}					  kk := kk + 1;					 { np := np + 1;}					  absfil := 0.0;					  for jj := kk to (kk + nfw) do absfil := absfil + abs(Col_1^[jj]); {(kk + nfw) IS correct}					  {...·sigma for filtered data from propagation of errors, ie					      ·data cnts over filter chs at each ch...could this be 0.0???						  No!! values include the continuum  counts at each ch.}				  (*  absfil := absfil - Col_1^[np];	{WHY should we subtract this out?}	*)					  temp := temp + (Win[2]^^[j] - Win[3]^^[j]) * (Win[2]^^[j] - Win[3]^^[j])/absfil;			      END; { j loop }				  theResp := temp / (Filter_Plus_Window - nfw - Number_of_Axes); { Normalized Chi-Square }                END;	{IF (not Response > 0.0)...}			END; { ELSE BEGIN }			Response := theResp;	{this should now be the same as LLSQ}          END; { function Response...returns double_t result }        PROCEDURE Replace(VAR vert: COORDinate; VAR rsp:  real {double_t});		 { COORDinate is double_t }         {  Replace -- replace aSimplex(Highest_Response,) by specified vertex:}         {  vert = vertex to replace aSimplex(Highest_Response)}         {  Resp = Response to replace Vertex_Response[Highest_Response] }          VAR            j                             : Integer;          BEGIN { procedure Replace }            FOR j := 1 TO Number_of_Axes DO              aSimplex[Highest_Response, j] := vert[j];                          Vertex_Response[Highest_Response] := rsp;            { rsp is Response(aSimplex(Highest_Response))...the worst normalized Xi Sq }          END; { procedure Replace }        BEGIN { procedure fit }          alpha := NM_Alpha;          beta := NM_Beta;          gamma := NM_Gamma;          Lowest_Response := 1;          Highest_Response := 1;           FOR i := 1 TO Number_of_Vertices DO { initialization: compute responses for all vertices }            BEGIN              Vertex_Response[i] := Response(aSimplex[i]);            END; 		  Simplex_Event_Loop; { results of call needed in Convergence_Test }					WHILE NOT Convergence_Test({iter8,} aSimplex[Highest_Response]) DO        BEGIN { next iteration}              iter8 := iter8 + 1;              FOR i := 1 TO Number_of_Vertices DO			  BEGIN {find highest and lowest responses }				IF Vertex_Response[i] > Vertex_Response[Highest_Response] THEN Highest_Response := i;				IF Vertex_Response[i] < Vertex_Response[Lowest_Response] THEN				Lowest_Response := i;			  END; { for i }				          { compute centroid abar of all vertices except aSimplex(Highest_Response)}             FOR j := 1 TO Number_of_Axes DO abar[j] := 0.0;             			 FOR i := 1 TO Number_of_Vertices DO             IF i <> Highest_Response THEN             FOR j := 1 TO Number_of_Axes DO abar[j] := abar[j] + aSimplex[i, j];              			 FOR j := 1 TO Number_of_Axes DO abar[j] := abar[j] / (Number_of_Vertices - 1); 		  		  {11/8 the highest resp could be the set max for unequal signs or exceeding a limit...		   the resps could therefore all be equal!!!}          { compute reflection (astar) of aSimplex[Highest_Response] across centroid, abar... }              FOR j := 1 TO Number_of_Axes DO                  astar[j] := (1.0 + alpha) * abar[j] - alpha * aSimplex[Highest_Response, j]; 			  rstar := Response(astar); { the Response of the reflected worst vertex }             IF rstar < Vertex_Response[Lowest_Response]{...original code}            (*IF rstar <= Vertex_Response[Lowest_Response] *)				 {if reflected worst better than or = to the BEST...this is true for about 1/3			  the iterations!!!}			 THEN BEGIN { compute expansion (astar2) of reflected worst...}                 FOR j := 1 TO Number_of_Axes DO                    astar2[j] := gamma * astar[j] + (1.0 - gamma) * abar[j];				 rstar2 := Response(astar2);                  			   {original code in flow chart:if expanded reflected worst is better than best,			    replace worst vertex with it... rstar2 <Vertex_Response[Lowest_Response] }                IF rstar2 < rstar THEN	{crs}                BEGIN {NOW if expanded reflected better than reflected then                       replace worst with it}                      Replace(astar2, rstar2);                END                ELSE                BEGIN { if expanded reflected not better than reflected,					    replace worst with reflected only; back to Convergence_Test }                      Replace(astar, rstar);                END;             END {if rstar <= Vertex_Response[Lowest_Response]...THEN begin }        (*    ELSE IF rstar > Vertex_Response[Highest_Response] THEN	...original code		      The change to >= was made because we set the response to a fixed value when			  any parameter limit is exceeded. This means that this value will be the worst			  response. If the reflection also exceeds a limit, the reflc resp will EQUAL			  the worst response...and it will not be better than some other resp...		*)			 ELSE IF rstar >= Vertex_Response[Highest_Response] THEN			 BEGIN { if reflection of worst is worse than or = worst, try contracting worst}				 FOR j := 1 TO Number_of_Axes DO				   astar2[j] := beta * aSimplex[Highest_Response, j] + (1.0 - beta) * abar[j];				 rstar2 := Response(astar2);	{resp of the contraction of worst}				 				 {if contraction worse than or = worst, shift the whole Simplex and				  recalculate all responses...changed to >= 10/5/95; before				  if the contracton = worst we were stuck}				 IF rstar2 >= Vertex_Response[Highest_Response] THEN				 BEGIN					FOR i := 1 TO Number_of_Vertices DO					BEGIN					  FOR j := 1 TO Number_of_Axes DO						aSimplex[i, j] := (aSimplex[i, j] + aSimplex[Lowest_Response, j]) / 2.0;					  Vertex_Response[i] := Response(aSimplex[i]);					END; { for j }				 END { begin for i }				 ELSE	{if contraction better than worst, replace worst with it...}				 BEGIN					 Replace(astar2, rstar2);                (* beepbeep;*)				 END;             END { ELSE IF rstar >= Vertex_Response[Highest_Response] ...BEGIN }             ELSE             BEGIN { reflection is not better than or = best nor worse than or = the worst}                    i := 1;                    j := 0;                    REPEAT {is reflection better than some vertex other than the best?}                      IF (i <> Highest_Response) AND (rstar < Vertex_Response[i]) THEN                        BEGIN	{reflection better than some vertex other than the best}                          j := i;                          Replace(astar, rstar); {replace the worst with its reflection}                        END                      ELSE i := i + 1;                    UNTIL (i > Number_of_Vertices) OR (j = i);                    IF (i > Number_of_Vertices) THEN                    BEGIN {...reflection better than worst but is still the worst}                        FOR j := 1 TO Number_of_Axes DO { contraction of reflection }                          astar2[j] := beta * astar[j] + (1.0 - beta) * abar[j];                        						rstar2 := Response(astar2);                        IF rstar2 >= Vertex_Response[Highest_Response] THEN                        { contraction of reflection worse than or = to worst }                        BEGIN { Shift the whole thing }                            FOR i := 1 TO Number_of_Vertices DO                            BEGIN                                FOR j := 1 TO Number_of_Axes DO                                  aSimplex[i, j] := (aSimplex[i, j] + aSimplex[Lowest_Response, j]) / 2.0;                                Vertex_Response[i] := Response(aSimplex[i]);                            END; { for i }                        END { IF rstar2 > }                        ELSE{ contraction of reflection better than worst }                        BEGIN                          Replace(astar2, rstar2);{replace worst with contraction of reflection}                        END;                      END; { IF...BEGIN }                  END; { ELSE BEGIN... }            END; { while not converge... }        END; { procedure fit }      PROCEDURE report(VAR vertex: COORDinate; BestResp:  real {double_t});       { vertex = vertex with lowest Response,  aSimplex[Lowest_Response]) }       { BestResp = Response of specified vertex, Vertex_Response[Lowest_Response] }        VAR          Energy                        :  real {double_t};          see		                    :  real {double_t};		  aconst                        :  real {double_t};          kk, jj, j, k, nf                  : Integer;        PROCEDURE wtfit(VAR see:  real {double_t});         { subroutine fits a polynomial of up to 4 terms (order) to residuals, simplex fit }         { residuals, and returns the best fit values in FitS^^.FittedBkg and the std dev in see. }          VAR            {ncvm                          : Integer;} 			Num_Terms                     : Integer; 			Index                         : Integer;			index1                        : Integer;            std, R_indx	                  :  real {double_t};			Temp	                      :  real {double_t};            Hold                          : LinFitExtArray; { 36 terms }			solution                      : LinFitExtArray; { [1..Max_Num_Terms] of double_t}			Chans_to_do, order            : longint;           BEGIN { wtfit }              FOR Index := 1 TO 4 DO              BEGIN                Test_a_Handle(Handle(Xdata[Index]), 'Xdata[Index], wtfit in Simplex');                Xdata[Index] := WindowArrayHdl(NewHandle(sizeof(WindowArray))); { double_t }                moveHHi(Handle(Xdata[Index]));                HLock(Handle(Xdata[Index]));              END;            Test_a_Handle(Handle(Ydata), 'Ydata in wtfit');            Ydata := WindowArrayHdl(NewHandle(sizeof(WindowArray))); { double_t }            moveHHi(Handle(Ydata));            HLock(Handle(Ydata));            Test_a_Handle(Handle(Weight), 'Weight in wtfit');            Weight := WindowArrayHdl(NewHandle(sizeof(WindowArray))); { double_t }            moveHHi(Handle(Weight));            HLock(Handle(Weight));            FOR Index := 1 TO Max_Num_Terms DO solution[Index] := 0.0;              FOR Index := 1 TO Max_Fitting_Chans DO			  begin			    Weight^^[index] :=  100000.0;				Ydata^^[index] := 0.0; { double_t }			    FOR index1 := 1 TO 4 DO Xdata[index1]^^[index] := 0.0; { double_t } 			  end;			            index1 := 0;            Energy := filtkev;            FOR Index := First_Filter_Channel TO Last_Filter_Channel DO              BEGIN {for index}                index1 := index1 + 1;				                Ydata^^[index1] := (FitS^^.Residuals[index1]); {data to fit, FitS is real, Ydata is double_t}                Xdata[1]^^[index1] := 1.0; { double_t }                FOR order := 2 TO 4 DO                  Xdata[order]^^[index1] := Xdata[order - 1]^^[index1] * Energy; { Xdata, Energy are double_t }				  	            IF Col_1^[Index] < 1 THEN Weight^^[index1] := 1e12 { has to be big for big spectra }                ELSE Weight^^[index1] := SQRT(abs((Col_1^[Index])));				                Energy := Energy + keV_per_Channel;              END; {for index}            see := 1e12; { double_t, has to be big for big spectra }            std := 0.0; { double_t }            FOR order := 2 TO 4 DO              BEGIN                  FOR Index := 1 TO order DO lista[Index] := Index;                Chans_to_do := Filter_Plus_Window;                Lfit(Ydata, Weight, Xdata, Chans_to_do, order, {lista,} covar, solution, std);                  IF (std >= 0.0) and (std < see) THEN                  BEGIN                    see := std; { std deviation }                    Num_Terms := order;                    FOR Index := 1 TO order DO Hold[Index] := solution[Index];                  END; { if std }              END; { for order...solution has fitting constants }			              Energy := filtkev;            FOR Index := 1 TO Filter_Plus_Window DO              BEGIN {for index}                FitS^^.FittedBkg[Index] := {num2real}(Hold[1]);                FOR index1 := 2 TO Num_Terms DO				 BEGIN				  (* IF ClassExtended(XpwrI( Energy, ( index1 - 1 ) )) <> NormalNum then 				     BEGIN					   temp := 1; 					 END  					   ELSE *)				   R_indx := index1 - 1;				   temp := pow( Energy,R_indx);				   temp :=   Hold[index1] * temp ;                  FitS^^.FittedBkg[Index] := FitS^^.FittedBkg[Index] + {num2real}(temp); 				 END;							                 Energy := Energy + keV_per_Channel;              END; {for index}			  			              FOR Index := 1 TO 4 DO H_UnLock_Dispose( Handle(Xdata[Index]),'Xdata[Index] in simplx' );            H_UnLock_Dispose(Handle(Ydata), 'Ydata in simplx');            H_UnLock_Dispose(Handle(Weight), 'Weight in simplx');           END; { procedure wtfit }        BEGIN { procedure REPORT }          j := 0;		  nf := 0;	{counts the number fit in the window}          FOR kk := 1 TO Number_of_Peaks_in_Window DO		  BEGIN			jj := kk + Total_Number_of_Peaks; { Total_Number_of_Peaks equals # in previous windows }			IF (Analysis_Result^^.Fit_params.ref_index[jj] <> -1) then			BEGIN			    nf :=  nf + 1;				eprime^[nf] :=  Energy_Difference[nf] + vertex[2] ;				sig^[nf] :=  (Sigma_Compute(vertex[1], Energy_Difference[nf]));				IF (jj = PkInfo[jj].master) THEN				BEGIN					j := j + 1; {count an independent pk}					amp^[nf] :=  (vertex[j + 2]); { amp is simply the fitted value }					k := nf;				END				ELSE				BEGIN					(*k := PkInfo[jj].master - Total_Number_of_Peaks;*)					amp^[nf] :=  ((vertex[j + 2] / Det_Effic_P^[rinttol(eprime^[k] * 1000 / Plt_spec[10]^^.Expt_Info.dE)]) * (PkInfo[jj].							   wt * sig^[k] / sig^[nf]) * Det_Effic_P^[rinttol(eprime^[nf] * 1000 / Plt_spec[10]^^.Expt_Info.dE)]);				END;				Analysis_result^^.Fit_result.Err_or_Energy[jj] := eprime^[nf];  			  {ALWAYS report the calibrated energy...}				  Analysis_result^^.Fit_result.Err_or_Energy[jj] :=						  (Analysis_result^^.Fit_result.Err_or_Energy[jj] - 						   Plt_spec[10]^^.Expt_Info.Energy_Intercept / 1000) /						   Plt_spec[10]^^.Expt_Info.Energy_Slope;		   END	{IF (ref_index[jj] <> -1)...}		   ELSE BEGIN				Analysis_result^^.Fit_result.Err_or_Energy[jj] := 0.0;		   END;	     END; {of kk loop}          FOR kk := 1 TO Max_Fitting_Chans DO            BEGIN              FitS^^.Gaussians[kk] := zero;              Win[1]^^[kk] := 0.0;              END;			      profile(filtkev, keV_per_Channel, eprime^, amp^ , sig^, Number_Fit_in_Window, Filter_Plus_Window, Win[1]^^);          kk := First_Filter_Channel;          FOR j := 1 TO Filter_Plus_Window DO            BEGIN              FitS^^.Gaussians[j] := (Win[1]^^[j]);              FitS^^.Residuals[j] := Col_1^[kk] - FitS^^.Gaussians[j];              kk := kk + 1;            END; { for j }          IF (NOT BkgSubt) THEN wtfit(see); {for order up to 4, find best polynomial fit to FitS^^.Residuals; fitted background is                                              returned in FitS^^.FittedBkg and "See" is the Chi-Square of the polynomial fit: }           aconst := SQRT(2.0 * pi) / keV_per_Channel;          WITH Analysis_result^^, Fit_result, fit_Params, ExptStuff DO          BEGIN		      nf := 0;	{indexes over pks that are fit}              FOR kk := 1 TO Number_of_Peaks_in_Window DO			  BEGIN                jj := kk + Total_Number_of_Peaks;				IF (ref_index[jj] <> -1) then				BEGIN				  nf := nf + 1;                  { ch # of peak kk at  fitted energy }                  { ch # of peak jj at  book energy, not fitted energy, in the spectrum: }                  j := rinttol((Peak_Energy[jj] * energy_slope + energy_intercept/1000) * keV_to_Channel) -				  			  First_Filter_Channel + 1;                  Area[jj] := (aconst * sig^[nf] * amp^[nf]); {peak(s) area }                  IF FitS^^.FittedBkg[j] <> 0.0 THEN                  BEGIN                      IF (NOT BkgSubt) THEN Peak_to_Local_Bkg[jj] := Area[jj] / FitS^^.FittedBkg[j]                      ELSE Peak_to_Local_Bkg[jj] := 0;                  END                  ELSE Peak_to_Local_Bkg[jj] := 0;                  Peak_to_Chosen_Bkg[jj] := Area[jj] / Chosen_Norm_Bkg;                  conc[jj] := zero;                  WITH Plt_spec[10]^^, SpectrumStuff, Spectrum_Info DO                  BEGIN        (*  8/28/96   IF (This_is_a_Standard) THEN                      BEGIN                      *)                          k := 0;                          REPEAT                            k := k + 1;                          UNTIL (element_info[k].Atomic_Number = Atomic_Number[jj]) OR						        (k >= Number_of_Elements); {...if Number_of_Elements = 0}                          IF (element_info[k].Atomic_Number = Atomic_Number[jj]) THEN						       conc[jj] := element_info[k].weight_fraction                          ELSE conc[jj] := 0.0;         (*           END; *)                  END; {With Plt_spec[10]^^,...}				END	{IF (ref_index[i] <> -1) then... }				ELSE BEGIN				   Area[jj] := zero;				   conc[jj] := zero;				   Peak_to_Chosen_Bkg[jj] := zero;				   Peak_to_Local_Bkg[jj] := zero;				END;              END; { for kk... }			  { get the FWHM_Mn in calibrated space...}			  vertex[2] := (vertex[2] - Plt_spec[10]^^.Expt_Info.Energy_Intercept / 1000)/			  			    Plt_spec[10]^^.Expt_Info.Energy_Slope;              IF Plt_spec[10]^^.Expt_Info.Detector.spec = WDS THEN                FWHM_Mn[Window_Counter] := 2354.825 * Sigma_Compute(vertex[1], vertex[2])              ELSE FWHM_Mn[Window_Counter] := 2354.825 * Sigma_Compute(vertex[1], (5.895 - vertex[2]));              Response[Window_Counter] := BestResp;              Iterations[Window_Counter] := iter8;          END; { WITH Analysis_Result^^,Fit_Result... }        END; { procedure REPORT }    BEGIN { procedure SIMCONT called for each window; calls Sigma_Compute,Set_Limits, tophat, perturb, fit, report }        { enter: Col_1^  = data spectrum, global }        { Filter_Plus_Window  = equals NumChs_in_Window  + # filter chs: global }        { bkev = energy of first channel in nth window inc filter: global to SIMCONT }        { keV_per_Channel = energy per channel in kev: global }        { Number_of_Peaks_in_Window,Plt_Spec[10]^^.Expt_Info.Si_Resolution,Peak_Amplitude,Peak_Energy }        FOR i := 1 TO 3 DO		BEGIN		  Test_a_Handle(Handle(Win[i]), 'Win[i] in simplx');		  Win[i] := WindowArrayHdl(NewHandle(sizeof(WindowArray)));		  moveHHi(Handle(Win[i]));		  HLock(Handle(Win[i]));		END;        FOR i := 1 TO Max_Fitting_Chans DO		BEGIN		  Win[1]^^[i] := 0.0; { double_t }		  Win[2]^^[i] := 0.0;		  Win[3]^^[i] := 0.0;		  FitS^^.Residuals[i] := zero; { realWindowArray }		  FitS^^.FittedBkg[i] := zero; { realWindowArray }		  FitS^^.Gaussians[i] := zero; { realWindowArray }		END;  { Switch can be input via the constraints dialog; it used to be 1000. The toler    input via the dialog is the final exit tolerance for the fit. The toler below    is that for using weights for the first part of a free fit. }         { weighted fitting is on to start, then off ie wt switches...}        IF (wtswitch) THEN	{ this is the switch point tolerance... }          Analysis_result^^.fit_Params.Toler := Analysis_result^^.fit_Params.switch * Analysis_result^^.fit_Params.Toler;        										 		{Number_of_IndPeaks_in_Window does NOT include the ones to skip...}         Number_of_Axes := Number_of_IndPeaks_in_Window + 2;	{we're in SimCont}         Number_of_Vertices := Number_of_Axes + 1;						 {... a vertex consists of an energy, sigma and amp for the						   biggest peak and amps for the other peaks. There is						   a starting vertex, a vertex with energy perturbed,						   a vertex with sigma perturbed, and npeaks vertices						   with one amp each perturbed; see insimp }        { ¥¥¥¥¥¥ calculate filter parameters for end energy of window ¥¥¥¥¥¥ }		{ Fitting_ROI_Hi and _Lo are in eV must be converted from calibrated values to		  spectrum space values. }          endev := Analysis_result^^.fit_Params.Fitting_ROI_Hi[Window_Counter] *				 Plt_spec[10]^^.Expt_Info.energy_slope + Plt_spec[10]^^.Expt_Info.energy_intercept;		{ energy diff from Mn to END of window in data space...for FW at hi end of window}        ediff := Plt_spec[10]^^.Expt_Info.energy_slope * (Analysis_result^^.fit_Params.Fitting_ROI_Hi[Window_Counter] - 5895.0);        IF Plt_spec[10]^^.Expt_Info.Detector.spec = WDS THEN fwhmw := two_Coeff * Analysis_result^^.fit_Params.FWStart        ELSE fwhmw := SQRT(ABS(ediff * 2.5 + Analysis_result^^.fit_Params.FWStart * Analysis_result^^.fit_Params.FWStart)); 		{  get even # chs in cntr lobe for window... }        nrd := 2 * rinttol(fwhmw / (Plt_spec[10]^^.Expt_Info.dE * 2));        		With Plt_spec[10]^^.Expt_Info do		begin		  First_Filter_Channel:=		   rinttol((Analysis_result^^.fit_Params.Fitting_ROI_Lo[Window_Counter] * energy_slope +				  energy_intercept)/ dE) - nrd;		  if First_Filter_Channel < 1 then 		  begin			  First_Filter_Channel := 1;			  Analysis_result^^.fit_Params.Fitting_ROI_Lo[Window_Counter] :=				  ((1 + nrd) * dE - energy_intercept)/ energy_slope;		  end;		  Last_Filter_Channel:=		   rinttol((Analysis_result^^.fit_Params.Fitting_ROI_Hi[Window_Counter] * energy_slope +				  energy_intercept)/ dE) + nrd;		  if Last_Filter_Channel > Number_of_Channels then 		  begin	{umm, maybe I shouldn't change the anal_res value...???} 			  Last_Filter_Channel := Number_of_Channels;			(*Analysis_result^^.fit_Params.Fitting_ROI_Hi[Window_Counter] :=				  ((Number_of_Channels - nrd) * dE - energy_intercept)/ energy_slope;*)		  end;		End; 	{With...}		        nfw := 2 * nrd; { # chs in filter for the window }{Moved here from Main Simplex 9/8/95...we need to know if the extra filter chs take us outside the spectrum and correct the hi and lo E ROI values if so. Some variables are local to Simcont.}		          WITH Analysis_result^^,fit_Params,ExptStuff DO		  BEGIN			NumChs_in_Window := rinttol((Fitting_ROI_Hi[Window_Counter] * energy_slope + energy_intercept)/dE) -								rinttol((Fitting_ROI_Lo[Window_Counter] * energy_slope + energy_intercept)/dE) + 1;		  END; { With...}        Filter_Plus_Window := NumChs_in_Window + nfw; { total # chs needed to do filter; }        Last_Filter_Channel := First_Filter_Channel + Filter_Plus_Window - 1;         filtkev := First_Filter_Channel * keV_per_Channel; { data space energy of 1st filter ch }        i := 0;        bigpk := 1;        FOR ii := First_Filter_Channel TO Last_Filter_Channel DO          BEGIN            i := i + 1;            Win[1]^^[i] := (Col_1^[ii]) ;			{ find the biggest channel count in window...}            IF  Win[1]^^[i] > bigpk THEN bigpk := Win[1]^^[i] ; { find the biggest channel count in window }          END; { for ii }         atophat(Win[1]^^, Win[2]^^, Filter_Plus_Window, nfw); { on return first NumChs_in_Window chs in Win[2]^^ have filtered data }		{FOR i := 1 TO NumChs_in_Window DO			Plt_spec[7]^^.S[i] := Win[2]^^[i];}        i := 0;	{	Max_Hold := 1.0;} { for plotting the digitally filtered stuff }		Max_Hold := one;  { for plotting the digitally filtered stuff }        FOR i := 1 TO NumChs_in_Window DO           IF  Win[2]^^[i] > Max_Hold THEN Max_Hold := ( Win[2]^^[i]) ;    		  Max_Hold := 1.2 * Max_Hold;        		firstpk := Analysis_result^^.fit_Params.First_in_Roi[Window_Counter];		ii := firstpk + Number_of_Peaks_in_Window - 1;		Biggest := 0;		i := firstpk;		{ the peaks are numbered continuously through all the windows,		  element by element in each window  }	    REPEAT	{find the first pk in the window that is not skipped...it may be the first pk}		  if (Analysis_Result^^.Fit_params.ref_index[i] <> -1) then Biggest := i;		  i := i + 1;	    UNTIL (i > ii) or (Biggest = i-1);				{The energies and energy diffs used are true x-ray line values...from Start		 ...converted to		 spectrum space so there is some acommodation to spectra with slope and		 intercept not equal to 1 and zero.		 Unfortunately Procedure Profile needs to be rewritten to be able to generate		 correct Gaussians and then shift and stretch them to compare to the data. This		 we will not do because the analyst should work with correctly calibrated spectra		 and not expect the math to fix his sloppy data.}		          FOR i := firstpk TO (firstpk + Number_of_Peaks_in_Window - 1) DO		 BEGIN		  IF (Analysis_Result^^.Fit_params.ref_index[i] <> -1) then		  BEGIN { IF (Analysis_Result... }			  IF (i = PkInfo[i].master) THEN	{ if this is a pk to wt against }			  BEGIN { IF (firstpk... }				  npkch := 1 + rinttol((Peak_Energy[i] * 1000 * 									Plt_spec[10]^^.Expt_Info.energy_slope + 									Plt_spec[10]^^.Expt_Info.energy_intercept)/									Analysis_result^^.ExptStuff.dE) -						 rinttol((Analysis_result^^.fit_Params.Fitting_ROI_Lo[Window_Counter] *								 Plt_spec[10]^^.Expt_Info.energy_slope +								 Plt_spec[10]^^.Expt_Info.energy_intercept)/								 Analysis_result^^.ExptStuff.dE);			   (*  IF (Analysis_result^^.fit_Params.Siegbahn[i] = 'KA1  ') THEN				 			Peak_Amplitude[i] := (abs( Win[2]^^[npkch]))				  ELSE Peak_Amplitude[i] := (abs( Win[2]^^[npkch] * 2.0)); 			   changed 11/8/95	*)			    If abs(Win[2]^^[npkch]) > 0.0 then 				Peak_Amplitude[i] := ( Win[2]^^[npkch] * 2.0) else				Peak_Amplitude[i] := ( Win[2]^^[npkch + 1] * 2.0);				 { find biggest pk among the independent ones }				 IF (Peak_Amplitude[i] > Peak_Amplitude[Biggest]) THEN Biggest := i;			  END { IF (i=PkInfo... }			  ELSE { this is a dependent peak, amplitude by weighting including KA2s }			   IF PkInfo[i].master > 0 then			   Peak_Amplitude[i] := Peak_Amplitude[PkInfo[i].master] * PkInfo[i].wt			   ELSE Peak_Amplitude[i] := 0.0;		  END { IF (Analysis_Result...starting amplitude estimates for pks to be fit...there 				are 0 values for pks that are to be skipped!}		  ELSE Peak_Amplitude[i] := 0.0; 		 END;	{FOR i := firstpk...}         IF Plt_spec[10]^^.Expt_Info.Detector.spec = WDS THEN { WDS detector }          BEGIN            FWHMBigPk {ev} := Analysis_result^^.fit_Params.FWStart;          END        ELSE BEGIN            EDiffev {ev,data space} := 2500 * (Peak_Energy[Biggest] - 5.895) *						            Plt_spec[10]^^.Expt_Info.energy_slope;            FWHMBigPk {ev} := SQRT(Analysis_result^^.fit_Params.FWStart * Analysis_result^^.fit_Params.FWStart + EDiffev);          END;        Peak_Sigma[Biggest] {kev} := FWHMBigPk / 2354.825;        		ii := 0;		FOR i := firstpk TO (firstpk + Number_of_Peaks_in_Window - 1) DO		IF (Analysis_Result^^.Fit_params.ref_index[i] <> -1) then 		begin		  ii := ii + 1;          Energy_Difference[ii] := (Peak_Energy[i] - Peak_Energy[Biggest]) *						           Plt_spec[10]^^.Expt_Info.energy_slope;	    end;		{now have Energy_Difference only for pks to fit including KA2s}        IF Plt_spec[10]^^.Expt_Info.Detector.spec = WDS THEN fwhmw := two_Coeff * Analysis_result^^.fit_Params.FWStart        ELSE fwhmw := SQRT(ABS(ediff * 2.5 + Analysis_result^^.fit_Params.FWStart * Analysis_result^^.fit_Params.FWStart));		                  Set_Limits; { data space limits will be used even in 'no constraints' selected }        Pert_factor := 1.0; { real }                 perturb; { takes book values and defines the vertices of the simplex		           in data space }        iter8 := 0;                 fit; { do the simplex logic }        { If the Fit has been achieved with Peak weighting and final fit is sought with }        { all peaks free then restart the process with the current best values as starting }        { parameters }        { restart using best values so far fitting with all peaks (except Ka2) free: }        IF (wtswitch) THEN          BEGIN { switch the w'ting from on to off...now free fit the amps }            Pert_factor := 1.0 * Analysis_result^^.fit_Params.Toler; {hopefully, < 1}            IF (Pert_factor > 1) THEN Pert_factor := 1.0;     { Now DIVIDE out of toler the value of switch by which it was multiplied to get       back the final exit toler that was put in via the dialog box.}            Analysis_result^^.fit_Params.Toler := (Analysis_result^^.fit_Params.Toler / Analysis_result^^.fit_Params.switch);            Number_of_Axes := Number_Fit_in_Window + 2;         {...redefined because now all peaks except Ka2's are fit; these are subtracted below }                        i := 0;		   ii := 0;		   FOR  n1 := firstpk TO (firstpk + Number_of_Peaks_in_Window - 1) DO		   BEGIN			 IF (Analysis_Result^^.Fit_params.ref_index[n1] <> -1) then             BEGIN			   ii := ii + 1;	{count a fit pk}			  {these eprimes are in data space..}			  eprime^[ii] :=  (Energy_Difference[ii] + aSimplex[Lowest_Response, 2]);			  sig^[ii] :=  (Sigma_Compute(aSimplex[Lowest_Response, 1], Energy_Difference[ii]));			  IF (n1 = PkInfo[n1].master) THEN			  BEGIN				i := i + 1; {count an independent pk}				Peak_Amplitude[n1] := aSimplex[Lowest_Response, i + 2];{...amp in detected space }				np := ii;			  END			  ELSE BEGIN	{so, we get a pk amp by weighting... for KA2 also}				Peak_Amplitude[n1] := (aSimplex[Lowest_Response, i + 2] / Det_Effic_P^[rinttol(eprime^[np] * 1000.0 / Plt_spec[10]^^.Expt_Info.dE)]) *									  (PkInfo[n1].wt * sig^[np] / sig^[ii]) * Det_Effic_P^[rinttol(eprime^[ii] * 1000.0 / Plt_spec[10]^^. Expt_Info.dE)];				{ amp in generated space * Wtng for amp from wtng for area * Eff}			  END;			  			  IF (Analysis_result^^.fit_Params.Siegbahn[n1] = 'KA2  ') THEN			  BEGIN	{we have starting amps for all the pks including KA2s...we continue to wt Ka2}				  Number_of_Axes := Number_of_Axes - 1;				  {and master number remains the number for the KA1}			  END			  ELSE			  BEGIN				  PkInfo[n1].master := n1; {reset the master number to the pk number!!!except KA2}				  PkInfo[n1].wt := one; { real }			  END; {ELSE...begin }			 END;	{IF (Analysis_Result^^....otherwise Peak_Amplitude = 0.0}           END; { FOR  n1...}            Number_of_Vertices := Number_of_Axes + 1;            bigpkE := Peak_Energy[Biggest]; { save the book energy of the biggest peak }            Peak_Sigma[Biggest] := aSimplex[Lowest_Response, 1];			{aSimplex[Lowest_Response, 2] is fitted data space value: convert to book energy			 because perturb converts to data space...}            Peak_Energy[Biggest] := (aSimplex[Lowest_Response, 2] -									 Analysis_result^^.ExptStuff.energy_intercept/1000)/									 Analysis_result^^.ExptStuff.energy_slope;            			perturb; { re-define vertices of simplex from Peak_Sigma[Biggest],Peak_Energy[Biggest] }            Peak_Energy[Biggest] := bigpkE; { reset to book energy }                         fit; { do the simplex logic again}          END; { IF( WtSwitch...}        report(aSimplex[Lowest_Response], Vertex_Response[Lowest_Response]); { output results of }        { final fit for window Window_Counter }        FOR i := First_Filter_Channel TO Last_Filter_Channel DO { display resids,etc}          BEGIN            if OptionKeyDown then Plt_spec[2]^^.s[i] := FitS^^.Gaussians[i - First_Filter_Channel + 1];            Plt_spec[9]^^.s[i] := FitS^^.Residuals[i - First_Filter_Channel + 1];            Plt_spec[1]^^.s[i] := FitS^^.FittedBkg[i - First_Filter_Channel + 1];          END;		  UpDate_Max_Min(10);		  Plt_Spec[9]^^.SpectrumStuff.Spectrum_Info.Maximum_Counts := Plt_Spec[10]^^.SpectrumStuff.Spectrum_Info.Maximum_Counts;		  Plt_Spec[9]^^.SpectrumStuff.Spectrum_Info.Minimum_Counts := Plt_Spec[10]^^.SpectrumStuff.Spectrum_Info.Minimum_Counts;		  Plt_Spec[1]^^.SpectrumStuff.Spectrum_Info.Maximum_Counts := Plt_Spec[10]^^.SpectrumStuff.Spectrum_Info.Maximum_Counts;		  Plt_Spec[1]^^.SpectrumStuff.Spectrum_Info.Minimum_Counts := Plt_Spec[10]^^.SpectrumStuff.Spectrum_Info.Minimum_Counts;		  if OptionKeyDown then		  begin		   Plt_Spec[2]^^.SpectrumStuff.Spectrum_Info.Maximum_Counts := Plt_Spec[10]^^.SpectrumStuff.Spectrum_Info.Maximum_Counts;		   Plt_Spec[2]^^.SpectrumStuff.Spectrum_Info.Minimum_Counts := Plt_Spec[10]^^.SpectrumStuff.Spectrum_Info.Minimum_Counts;		    	        Spectrum_Full[2] := True;	        CheckItem(FullMenu, theItem, Spectrum_Full[2]);	        Update_Full;		  end;        FOR i := 1 TO 3 DO          H_UnLock_Dispose(Handle(Win[i]), 'Win[i] in simcont');      END; {simcont}    {¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥}    BEGIN { begin the main routine of the simplex program: Sequential_simplex }	{The set of peak energies are book values. These must be converted using	 energy_slope and enrgy_intercept.} 	   amp := PKARRAY_ptr(NewPtr(SizeOf(PKARY)));				   if amp = NIL then				     begin					   SysBeep(1);				       putmessage('Not enough memory available for this operation',					   'Quit the program, then  do a "get info" and assign more memory to DTSA.','',''); 					   exit(Sequential_simplex);					 end; 	   eprime := PKARRAY_ptr(NewPtr(SizeOf(PKARY)));				   if eprime = NIL then				     begin					   SysBeep(1);				       putmessage('Not enough memory available for this operation',					   'Quit the program, then  do a "get info" and assign more memory to DTSA.','',''); 					   exit(Sequential_simplex);					 end; 	   sig := PKARRAY_ptr(NewPtr(SizeOf(PKARY)));				   if sig = NIL then				     begin					   SysBeep(1);				       putmessage('Not enough memory available for this operation',					   'Quit the program, then  do a "get info" and assign more memory to DTSA.','',''); 					   exit(Sequential_simplex);					 end;      IF (wds_active) AND (Plt_spec[10]^^.Expt_Info.Detector.spec = EDS) THEN        BEGIN          putmessage('The program is configured for WDS but the spectrum is EDS. Please', 'check out the conflict and start over.',                     'Be sure the eV/Channel and the detector resolution are sensible for your spectrum.', '');          exit(Sequential_Simplex);        END;      IF (NOT wds_active) AND (Plt_spec[10]^^.Expt_Info.Detector.spec = WDS) THEN        BEGIN          putmessage('The program is configured for EDS but the spectrum is WDS. Please', 'check out the conflict and start over.',                     'Be sure the eV/Channel and the detector resolution are sensible for your spectrum.', '');          exit(Sequential_Simplex);        END;      	  GetDateTime(Start_Time);		{¥¥¥¥4/11/94¥¥¥¥}      OldTime := Start_Time;      {don't put slope and intercept here!!!}      keV_per_Channel  := (Plt_spec[10]^^.Expt_Info.dE * 0.001); { ch calibration in kev/ch}      keV_to_Channel   := ((1000.0 / Plt_spec[10]^^.Expt_Info.dE));             Energy_Limit_keV := (Analysis_result^^.fit_Params.DEN * 0.001);      stopButton := FALSE; { used in simplex event loop to button out }      BigExit := FALSE;      BigAutoFitExit := FALSE;      Blink_Timer := 0;      BlockMove(@Plt_spec[10]^^, @Plt_spec[9]^^, sizeof(Plt_spec[10]^^));	{before escapes removed}      FOR Index := 1 TO Maximum_Channels DO        Plt_spec[1]^^.s[Index] := zero; { Initialize and/or assign any  required fields }      Analysis_result^^.ExptStuff := Plt_spec[10]^^.Expt_Info;      Analysis_result^^.SpectrumStuff := Plt_spec[10]^^.SpectrumStuff;	  if Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.BkgSubtracted then		  blockmove(@Plt_spec[10]^^.S,@col_1^,sizeof(Plt_spec[10]^^.s))	  Else READ_SPECTRUM; { Counts to col_1^. Subt escapes from col_1^. · cnts in spectrum..not used.}		  blockmove(@col_1^,@Plt_spec[7]^^.S,sizeof(Plt_spec[7]^^.s));	  WITH Analysis_result^^ DO { Initialize and/or assign any other required fields }      BEGIN          WITH fit_Params, Fit_result, ExptStuff DO          BEGIN              Fit_Procedure := 'Sm';              ROI^^.Quant.Value := 0.0;  			  {if ROI^^.Quant.Exists then there were chs selected and we saved the			   calibrated true energies in Chosen_ROI_Lo and _Hi of the end points so even spectra			   with different calibrations could be integrated between the same energies}				ROI^^.Quant.Lo := rinttol((Chosen_ROI_Lo * energy_slope + energy_intercept) / dE);				ROI^^.Quant.Hi := rinttol((Chosen_ROI_Hi * energy_slope + energy_intercept) / dE);			  FOR Index := ROI^^.Quant.Lo TO ROI^^.Quant.Hi DO					  ROI^^.Quant.Value := ROI^^.Quant.Value + Col_1^[Index];			  Chosen_Norm_Bkg := ROI^^.Quant.Value / (ROI^^.Quant.Hi - ROI^^.Quant.Lo + 1)	      END; { WITH Fit_Params, Fit_result }      END; { WITH Analysis_Result^^ }      IF BigExit THEN exit(Sequential_Simplex);      tocnts := 0.0; { real }      BkgSubt := FALSE;      IF (Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.BkgSubtracted) THEN BkgSubt := True;      { perform simplex fit on Number_of_PeakRois window spectra }      	 	  IF NOT Calibrate_Window_Active THEN BEGIN		  IF Fit_Invisibly THEN Simplex_Output_Handler(0)		  ELSE Simplex_Output_Handler(1);	  END;      { the PkInfo gets reset at the switch point so keeping PkAmpInfo }      FOR Index := 1 TO Analysis_result^^.fit_Params.Number_of_Peaks DO       				 PkInfo[Index] := PkAmpInfo[Index];      { now calculate the sigma limits at Mn }      IF constraint_switch THEN	  BEGIN		sigmax := ((Analysis_result^^.fit_Params.FWStart + Analysis_result^^.fit_Params.DFWHMM) / 2354.825);		sigmin := ((Analysis_result^^.fit_Params.FWStart - Analysis_result^^.fit_Params.DFWHMM) / 2354.825);	  END      ELSE BEGIN	{if the ROI is tight, the E's can't vary much so sigma will unless      				 constrained by some reasonable value}          IF wds_active THEN		  BEGIN			sigmax :=  0.10 ; {these must be in keV}			sigmin :=  0.0010 ;		  END          ELSE		  BEGIN	{FWStart is width at Mn}			sigmax := ((Analysis_result^^.fit_Params.FWStart + 0.10 * Analysis_result^^.fit_Params.FWStart) / 2354.825); {KEV}			sigmax := sigmax; {KEV}			sigmin := 0.0010 {123.0 / 2354.825}; {KEV}		  END;      END;        Total_Number_of_Peaks := 0;		FOR Window_Counter := 1 TO Analysis_result^^.fit_Params.Number_of_Windows DO        BEGIN	{Fitting_ROI_Hi and Fitting_ROI_Lo are true energies...}          WITH Analysis_result^^,fit_Params,ExptStuff DO		  BEGIN			IF (Window_Counter = Number_of_Windows) THEN			  Number_of_Peaks_in_Window := Number_of_Peaks - First_in_Roi[Window_Counter] + 1			ELSE Number_of_Peaks_in_Window := First_in_Roi[Window_Counter + 1] - First_in_Roi[Window_Counter];						Number_of_IndPeaks_in_Window := 0;			Number_Fit_in_Window := 0;			FOR Index := First_in_Roi[Window_Counter] TO First_in_Roi[Window_Counter] + Number_of_Peaks_in_Window - 1 DO			IF (ref_index[index] <> -1) then			begin			  IF (PkAmpInfo[Index].master = Index) THEN			  			Number_of_IndPeaks_in_Window := Number_of_IndPeaks_in_Window + 1;			  Number_Fit_in_Window := Number_Fit_in_Window + 1;			end;		  END; { With...}          simcont; { calls Set_Limits, perturb, fit, report }          Total_Number_of_Peaks := Analysis_result^^.fit_Params.First_in_Roi[Window_Counter] + Number_of_Peaks_in_Window - 1;        END; {for Window_Counter}      	  IF NOT Calibrate_Window_Active 	  THEN begin		 IF Fit_Invisibly		  THEN Simplex_Output_Handler(0)		  ELSE Simplex_Output_Handler(2);	  END;				  {...Write out the "click on a region..." message; see Curvefit }      ChangeCursor(ArrowC);   	DisposePtr(Ptr(eprime )); 	  eprime := NIL;  	DisposePtr(Ptr(amp));  	  amp := NIL; 	DisposePtr(Ptr(sig));  	  sig := NIL;    END; { End the main routine of the simplex program }END. { of UNIT Simplex }