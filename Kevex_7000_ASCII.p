UNIT KEVEX_7000_Plug;INTERFACEUSES	Types, QuickDraw, Memory, fp, StandardFile, GestaltEqu, Errors, Files,	TextUtils, {PascalA4,} FilePlugIns;const		__procinfo : longint = $3F80;{$Main}PROCEDURE	ENTRYPOINT(message:Integer; VAR InPtr:IOPlugPtr; VAR theResult:OSerr);IMPLEMENTATION{$IFC NOT POWERPC}uses PascalA4;{$ENDC}PROCEDURE KEVEX_7000(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);FORWARD;PROCEDURE DoAbout(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);FORWARD;PROCEDURE DoOpen(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);FORWARD;PROCEDURE DoWrite(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);FORWARD;FUNCTION	Str2Num(s: Str255): Real;FORWARD;PROCEDURE 	ENTRYPOINT{(message:Integer; VAR InPtr:IOPlugPtr; VAR theResult:OSErr)};		{ Main dispatching routine.  Initializes and sets up the global variables,	}		{		and performs the operation specified by the message. 				}VAR	firstTime	: BOOLEAN;	OldA4		: Longint;BEGIN{$IFC NOT POWERPC}	oldA4 := SetCurrentA4();	RememberA4();{$ENDC}	theResult:=noErr;	firstTime:=(InPtr=NIL);					{ See if this is the first time called }	IF firstTime THEN BEGIN						{ If so, allocate and initialize a data area }		InPtr:= IOPlugPtr(NewPtrClear(sizeof(IOPlug)));		IF (InPtr=NIL) THEN BEGIN			debugstr('memFullErr');			theResult:=memFullErr;{$IFC NOT POWERPC}	oldA4 := SetA4(oldA4);{$ENDC}			EXIT(ENTRYPOINT);		END;				END;		CASE message OF					{ Perform the requested operation }		fileAbout		:DoAbout(InPtr, theResult);		ImpFile			:KEVEX_7000(InPtr, theResult);		ExpFile			:DoWrite(InPtr, theResult);		OpenInPlug		:DoOpen(InPtr, theResult);		OpenExPlug		:DoOpen(InPtr, theResult);		END; {CASE message}		{$IFC NOT POWERPC}	oldA4 := SetA4(oldA4);{$ENDC}END;PROCEDURE DoAbout(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);	Begin	End;	PROCEDURE DoOpen(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);	Begin		InPtr^.PlugInName:='KEVEX 7000';		{Debugstr('Inside of KEVEX_7000 - Do Open');}		theResult := noErr;	End;	PROCEDURE DoWrite(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);	Begin	End;PROCEDURE KEVEX_7000(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);      TYPE	TByte                         = PACKED ARRAY [1..1] OF byte;    tBuffer                 = PACKED ARRAY [1..10000] OF signedbyte;    tBufPtr                 = ^tBuffer;    VAR      xx                            : real;      End_of_File, nn               : longint;      Current_File_Position         : longint;	  FileSize               		: longint;      bytecount                     : longint;	  indexL                        : longint;      n, counter, jj            	: integer;      err                           : integer;      refnum                        : integer;      Value                         : Extended;      theType                       : OSType;      Prompt , mssg                 : str255;      errCode                       : OSErr;      reply                         : SFReply;      FStr, str	                    : str255;	  strLength                     : TByte;	  tipBufPtr                     : tBufPtr;      LABEL        103, 400;    BEGIN		refnum := InPtr^.Rd_Refnum;		{Debugstr('Inside of Column_Plug - ReadFromASCII');}		InPtr^.Specimen_Comment_Field := '';			nn := 0;		err := GetEOF(refnum, FileSize);		tipBufPtr := tBufPtr(NewPtr(sizeof(tBuffer)));		err := FSRead(refnum, FileSize, Pointer(tipBufPtr));		indexL := 0;		        InPtr^.Number_of_Channels := 1024; { I think all 7000's are 1024 only }        strLength[1] := 5;        BlockMove(@strLength, @str[0], 1);{write 1 char stored at @strLength to @str[0]}        	        indexL := 0;		repeat            indexL := indexL + 1;            BlockMove(@tipBufPtr^[indexL], @str[1], strLength[1]);	    until ((str = 'KEVEX') or (indexL = FileSize - 4));	    		IF (indexL >= (FileSize-4)) then begin			theResult := badFileFormat;			exit(KEVEX_7000);		end;		          {ее We have to include LFs for the Kevex case since the analyzer itself sends them out}          {ее We also have to include the possibility that some Mac terminal program has removed them }          REPEAT            indexL := indexL + 1;          UNTIL tipBufPtr^[indexL] = 13;	{CR}          indexL := indexL + 1;          IF (tipBufPtr^[indexL] = 10) THEN indexL := indexL + 1; {skip a LF}          jj := 0;          REPEAT            jj := jj + 1;          UNTIL tipBufPtr^[indexL + jj] = 13; {measure the length of the line }          strLength[1] := jj - 1;          BlockMove(@strLength, @str[0], 1);          BlockMove(@tipBufPtr^[indexL + 1], @str[1], strLength[1]);          InPtr^.Specimen_Comment_Field := str;          REPEAT            indexL := indexL + 1;          UNTIL tipBufPtr^[indexL] = 13; { index to beginning of next line and then pick up the times}          indexL := indexL + 1;          IF (tipBufPtr^[indexL] = 10) THEN indexL := indexL + 1; {skip a LF}          strLength[1] := 5;          BlockMove(@strLength, @str[0], 1);          BlockMove(@tipBufPtr^[indexL + 2], @str[1], strLength[1]);          InPtr^.Live_Time := str2num(str);          BlockMove(@tipBufPtr^[indexL + 18], @str[1], strLength[1]);          InPtr^.Real_Time := str2num(str);          REPEAT            indexL := indexL + 1;          UNTIL tipBufPtr^[indexL] = 13;          indexL := indexL + 1;          IF (tipBufPtr^[indexL] = 10) THEN indexL := indexL + 1; {skip a LF}          jj := 0;          REPEAT            jj := jj + 1;          UNTIL tipBufPtr^[indexL + jj] = 13; {measure the length of the line}          strLength[1] := jj - 3;          BlockMove(@strLength, @str[0], 1);          BlockMove(@tipBufPtr^[indexL + 1], @str[1], strLength[1]);          InPtr^.Specimen_Comment_Field := CONCAT(InPtr^.Specimen_Comment_Field, ' ', str);          REPEAT            indexL := indexL + 1;          UNTIL tipBufPtr^[indexL] = 13;          indexL := indexL + 1;          IF (tipBufPtr^[indexL] = 10) THEN indexL := indexL + 1; {skip a LF}          REPEAT            indexL := indexL + 1;          UNTIL (tipBufPtr^[indexL] = $4B) AND (tipBufPtr^[indexL + 1] = $45) AND (tipBufPtr^[indexL + 2] = $56); { move on into the            buffer until the second "KEV" found }          { Here, "indexL" is pointing at the K in KEV }          REPEAT            indexL := indexL + 1;          UNTIL tipBufPtr^[indexL] = 13;          indexL := indexL + 1;          IF (tipBufPtr^[indexL] = 10) THEN indexL := indexL + 1; {skip a LF}          jj := 1; { jj will be the channel number }          REPEAT {еееее This part reads in the spectrum еееее}          103:            str := '';            IF (tipBufPtr^[indexL] = $0D {CR} ) THEN indexL := indexL + 1;            WHILE tipBufPtr^[indexL] = $0A DO              indexL := indexL + 1; { jump over a run of LF's }            IF (tipBufPtr^[indexL] = $07) OR (tipBufPtr^[indexL] = $1A) THEN GOTO 400; { Bell or SUB }            WHILE tipBufPtr^[indexL] = $20 DO              indexL := indexL + 1; { jump over a run of spaces }            WHILE (tipBufPtr^[indexL] <> $20) AND (tipBufPtr^[indexL] <> $0D) DO              BEGIN                IF (tipBufPtr^[indexL] = $07) OR (tipBufPtr^[indexL] = $1A) THEN GOTO 400; { BEL or SUB }                str := CONCAT(str, chr(tipBufPtr^[indexL]));                indexL := indexL + 1;                IF tipBufPtr^[indexL - 1] = $56 {V}                   THEN                  GOTO 103;              END; { While }            IF LENGTH(str) > 0 THEN              BEGIN                InPtr^.Spec_cts[jj] := str2num(str);                jj := jj + 1;              END;            indexL := indexL + 1;          UNTIL jj >= InPtr^.Number_of_Channels; {еееее This part read in the spectrum еееее}		 400: 		InPtr^.LastChannel := InPtr^.Number_of_Channels;		theResult := noErr;        DisposePtr(Ptr(tipBufPtr));      END; { IF Which_Format = 14 THEN...... KEVEX 7000 ASCII }{*****************************************************************************}FUNCTION Str2Num(s: Str255): Real;   { Pascal implementation of Str2Num (fp.p: Str2Dec, Dec2Str) }VAR	aDecimal		: Decimal;	aCStr			: ConstCStringPtr;	anIndex			: Integer;	aValidPrefix	: Integer; { ignore }BEGIN	aCStr := P2CStr(@s);	anIndex := 0;	str2dec( aCStr, anIndex, aDecimal, aValidPrefix );	Str2Num := dec2num( aDecimal );END;END.