 {[j=30/55,:+,u+,r+,o=120,k+,n+,#+,v+,q+,b+]}{[f-]} {*********************************} UNIT BG_Correct;{*********************************}{**********************************} INTERFACE {**********************************} USES  QuickDraw, QuickdrawText, Types, OSUtils, ToolUtils, Timer, Errors, Menus, Files, Lists, Memory, Retrace, SegLoad,   Dialogs, Packages, Printing, StandardFile, Resources, fenv, fp, PasLibIntf, Windows, TextUtils, Controls, Spectrum_Structures, Declarations, INITIALIZE, Global_Functions, Physics,  Xray_Energies, Physics_Windows, Utilities, xray, MathWin ; PROCEDURE D_BG_Correct;PROCEDURE D_H_Limit;PROCEDURE Duane_Hunt;Procedure AutoBG;{******************************} IMPLEMENTATION {**********************************}{$S BG_Correct}var 		ExitDialog   : boolean;		Exit_the_Lot : boolean;        ax,b,abdev   : real;        aa,abdevt    : real;        nxdata       : longint;        Procedure Error_Report;begin  BeepBeep;  Putmessage('There was a math failure in Background Fit. Check to make sure the',             'kV is appropriate and the composition is meaningful in the "Background Subtract" dialog.',			 'Also, check to be certain there is a valid Detector Resonse curve calculated. See features under',			 'the "Math" menu bar item.');  Exit_the_Lot := TRUE;end;	procedure Duane_Hunt;			const		I_Accept = 1;		I_Cancel = 2;		I_x8 = 6;		I_Picture1 = 7;			var			GetSelection : DialogPtr;			tempRect : Rect;			DType : Integer;			DItem : Handle;			sTemp : Str255;			itemHit : Integer;			Doit         : Boolean;	        str	    : str255;	procedure Refresh_Dialog; 		var 			rTempRect:Rect; 	 		begin 			SetPort(GetSelection);			rTempRect := tempRect;			GetDialogItem(GetSelection,I_Accept,DType,DItem,tempRect);			PenSize(3, 3);			InsetRect(tempRect, -4, -4);			FrameRoundRect(tempRect, 16, 16); 			PenSize(1, 1); 			 			PenSize(4,4);			MoveTo(303,248);			LineTo(303,288);			PenSize(1,1);						tempRect := rTempRect;	  end; 	 	 	begin			GetSelection := GetNewDialog(1939, nil,  Pointer(-1) );			ShowWindow(GetSelection);			SelectWindow(GetSelection);			SetPort(GetSelection);			 			 			GetDialogItem(GetSelection,I_x8,DType,DItem,tempRect);			RealToString(Energy_Estimate,5,2,str);			SetDialogItemText(DItem,str);						Refresh_Dialog; 			 			ExitDialog := FALSE;			Doit       := FALSE;			repeat				ModalDialog(NewModalFilterProc(@DefaultFilter), itemHit);				GetDialogItem(GetSelection, itemHit, DType, DItem, tempRect);				 				 				if (ItemHit =I_Accept) then				begin				    Doit       := True;										ExitDialog:=TRUE;					Refresh_Dialog;				end;								if (ItemHit =I_Cancel) then				begin					 					ExitDialog:=TRUE;					Refresh_Dialog;				end;								if (ItemHit =I_Picture1) then				begin				BeepBeep;				end;								 			until ExitDialog; 			GetDialogItem(GetSelection,I_x8,DType,DItem,tempRect);			GetDialogItemText(DItem, sTemp);						Energy_Estimate := MyStr2Num( sTemp );			temprect := GetSelection^.portRect; 			DisposeDialog(GetSelection);			FillWhiteSpace(temprect);			Update_Full;			if Doit then D_H_Limit;					end;   PROCEDURE BG_Subtract_Help;    VAR      tempRect                     : Rect;                  offset                       : integer;	  Left                         : integer;	  Top                          : integer;      n                            : integer;	  G_Help                       : DialogPtr;      itemHit                      : integer;      DType                         : Integer;      DItem                         : Handle;	  str : str255;    CONST      G_Accept                      = 1;	  BEGIN                                             {[f-]}G_Help := GetNewDialog(433, NIL, POINTER( - 1));ShowWindow(G_Help);SelectWindow(G_Help);SetPort(G_Help);OutlineButton(G_Help, 1, 16); { outline the OK button }SetFont('Monaco', 9, []);offset := 12;Left := 5;Top := 15;		   n := 0;	  moveto(Left,Top);DrawString('This Dialog permits the subtraction of the continuum component from a spectrum. The');	  n := n+1; moveto(Left,Top + n*offset);str := 'primary uses of this feature are in the generation of "references" for the linear least';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'squares procedure and the determination of detector window thicknesses, such as the ';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'silicon dead layer and ice build up. When removing the background from a thin specimen';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'it is not necessary to know the specimen composition accurately. Indeed, using a guess ';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'of the average atomic number will be sufficient. For bulk specimens, however, the exact ';DrawString(str); n := n+1; moveto(Left,Top + n*offset); str := 'composition must be entered since they are used to calculate the height of absorption ';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'edges.  ';DrawString(str); n := n+2; moveto(Left,Top + n*offset); str := 'You may input oxides by entering the formula (AL2O3, etc.). This will also automatically';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'supply the valences necessary for stoichiometric oxide calculations. A database of compositions';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'may be defined. Enter a composition, name it in the name box and insert it in your database file.';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'To retrieve a composition: open the file, double click the name and the composition will appear.';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'When removing the background while making  LLSQ references the background ROI`s should be';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'setup near the peak bundle of interest. It is not important if the fit is then bad  ';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'elsewhere in the spectrum. The low energy ROI should be a little further from a peak';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'than the high energy ROI due to incomplete charge distortion.  ';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := '';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'When using this option to make LLSQ references it is probably a good idea to use the';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := '"free quadratic" model found by in the "Options" submenu. However, when determining window';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'thicknesses, or determining if there are scattered electrons in your machine it is probably';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'better to use the MBH choice for "thin" specimens, and either the "Small" or the "Rao-Sahib ';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'Wittry" choices for "bulk" specimens.';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := ' ';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := '¥¥ NOTE¥¥ The detector components are the ones associated with the SPECTRUM GENERATE dialog ';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := 'and are NOT the ones associated with the spectrum header. ';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := ' ';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := ' ';DrawString(str); n := n+1; moveto(Left,Top + n*offset);str := ' ';DrawString(str); n := n+1; moveto(Left,Top + n*offset);{[f+]}REPEAT  ModalDialog(NIL, itemHit);  GetDialogItem(G_Help, itemHit, DType, DItem, tempRect);  IF (itemHit = G_Accept) THEN	BEGIN	  ExitDialog := True;	END;UNTIL ExitDialog;		DisposeDialog(G_Help);      beginupdate(BackPlane);      DrawAxesFull;      Update_Full;      EndUpdate(BackPlane);END;                                              {End of G_Help procedure}(*  FUNCTION GFilter(theDialog: DialogPtr; VAR theEvent: EventRecord; VAR itemHit: Integer): boolean;	Function is in Physics_Windows.*)		Procedure AutoBG;		VAR		index, E_strt, indx			: integer;		count, nn, E_stop			: integer;		deviat						: real;		spacing						: integer;		BEGIN        FOR nn := 1 TO Max_ROIs DO          BEGIN            ROI^^.BackGround[nn].Lo := 0;            ROI^^.BackGround[nn].Hi := 0;            ROI^^.BackGround[nn].ROI := nn;           {Sets up a unique number for each ROI 						                                separate from the index}            ROI^^.BackGround[nn].value := zero;            ROI^^.BackGround[nn].Exists := FALSE;          END;	 BlockMove(@Col_1^, @Col_4^, Sizeof(Col_4^));	{ original sans escapes }	 Digital_Filter;		{ tophat filter of Col_1 into Col_1 }	 E_strt := rinttol(2000/Plt_Spec[10]^^.Expt_Info.dE);		{ channel # nearest 2 kV }	 E_stop := rinttol((Plt_Spec[10]^^.Expt_Info.kV - 2.0) * 1000/Plt_Spec[10]^^.Expt_Info.dE);  { stop 2kV before beam voltage }	 indx := 0;	 count := 0;	 index := E_strt;	 spacing := 30;	 if Plt_Spec[10]^^.Expt_Info.number_of_channels > 4096 then spacing := spacing * 2;	 REPEAT	 	 spinCursor;	 	 deviat := 2.5 * SQRT(Col_4^[index]);	     if ((Col_4^[index] - (Col_1^[index])) < (Col_4^[index] + deviat)) AND		    ((Col_4^[index] - (Col_1^[index])) > (Col_4^[index] - deviat)) then		   begin		     count := count + 1;			 if (count = 30) then			   begin			     indx := indx + 1;			     ROI^^.BackGround[indx].Lo := index - count +1;				 ROI^^.BackGround[indx].Hi := index;				 ROI^^.BackGround[indx].Exists := true;				 count := 0;				 index := index + spacing;			   end			 else			   index := index + 1;		   end		 else		   begin		     if (count > 15) then			   begin				 indx := indx + 1;			     ROI^^.BackGround[indx].Lo := index - count +1;				 ROI^^.BackGround[indx].Hi := index -1;				 ROI^^.BackGround[indx].Exists := true;				 count := 0;				 index := index + spacing;			   end			 else				   count := 0;			   index := index + 10;		   end;	UNTIL (index >= Plt_Spec[10]^^.Expt_Info.number_of_channels) OR			(index >= E_stop) OR			(indx >= Max_ROIs);	 Number_of_BackGrounds := indx;	 BlockMove(@Col_4^, @Col_1^, Sizeof(Col_1^));{put data sans escapes back...}	 Refresh_ROIs;	 	END;	{ Procedure AutoBG }		procedure D_BG_Options;	const		I_Accept = 1;		I_Cancel = 2;		I_Small = 3;		I_Kramers = 4;		I_Lifshin_s_quadratic = 5;		I_FRAME_C = 6;		I_Rao_Sahib_Wittry = 7;		I_Spare8 = 8;		I_Green_Dyson = 9;		I_Spare11 = 10;		I_Spare15 = 13;		I_Modified_Bethe_Heitler= 14;		I_Kirkpatrick_WiedmannR = 15;		I_Kirkpatrick_WiedmannMP = 16;		I_Marshall_Hall = 17;		I_FreeQuadratic = 18;		var 			ExitDialog			: boolean; 			BG_OptionsPtr		: DialogPtr;			tempRect			: Rect;			DType				: Integer;			Index				: Integer;			DItem				: Handle;			CItem 				: controlhandle;			itemHit				: Integer;			temp				: Integer;            	procedure Refresh_Dialog; 		var 			rTempRect:Rect; 	 		begin 			SetPort(BG_OptionsPtr);			rTempRect := tempRect;			GetDialogItem(BG_OptionsPtr,I_Accept,DType,DItem,tempRect);			PenSize(3, 3);			InsetRect(tempRect, -4, -4);			FrameRoundRect(tempRect, 16, 16); 			PenSize(1, 1); 						{Draw a line, Drawn line1 }			PenSize(4,4);			MoveTo(20,80);			LineTo(539,80);			PenSize(1,1);						{Draw a line, Drawn line1-2 }			PenSize(4,4);			MoveTo(20,300);			LineTo(539,300);			PenSize(1,1);						{Draw a line, Drawn line3 }			PenSize(3,3);			MoveTo(20,120);			LineTo(120,120);			PenSize(1,1);						{Draw a line, Drawn line3-4 }			PenSize(3,3);			MoveTo(340,120);			LineTo(440,120);			PenSize(1,1);						tempRect := rTempRect;	end; 	 	 	begin  			BG_OptionsPtr := GetNewDialog(3301, nil,  Pointer(-1) );			ShowWindow(BG_OptionsPtr);			SelectWindow(BG_OptionsPtr);			SetPort(BG_OptionsPtr);			 						{ ¥¥ÊSetup initial conditions ¥¥ }						if Thin_CONT_Xsect_BG <> 17 then			Thin_CONT_Xsect_BG := Thin_CONT_Xsect ; { if its not the free quadratic then make it			                                          what was picked in the "generate thin" dialog }			GetDialogItem(BG_OptionsPtr,I_Modified_Bethe_Heitler,DType,DItem,tempRect);			if Thin_CONT_Xsect_BG= 7 then SetControlValue(controlhandle(DItem), 1) else SetControlValue(controlhandle(DItem), 0);						GetDialogItem(BG_OptionsPtr,I_FreeQuadratic,DType,DItem,tempRect);			if Thin_CONT_Xsect_BG= 17 then SetControlValue(controlhandle(DItem), 1) else SetControlValue(controlhandle(DItem), 0);						GetDialogItem(BG_OptionsPtr,I_Kirkpatrick_WiedmannMP,DType,DItem,tempRect);			if Thin_CONT_Xsect_BG= 5 then SetControlValue(controlhandle(DItem), 1) else SetControlValue(controlhandle(DItem), 0);			            {¥¥¥¥¥¥¥¥¥¥¥¥ grey out the unused items ¥¥¥¥¥¥¥¥¥¥¥¥¥}			GetDialogItem(BG_OptionsPtr,I_Kirkpatrick_WiedmannR,DType,DItem,tempRect);			HiliteControl(controlhandle(DItem), 255);						GetDialogItem(BG_OptionsPtr,I_Marshall_Hall,DType,DItem,tempRect);			HiliteControl(controlhandle(DItem), 255);			if Bulk_CONT_Xsect_BG <> 16 then			Bulk_CONT_Xsect_BG := Bulk_CONT_Xsect ; { if its not the free quadratic then make it			                                          what was picked in the "generate bulk" dialog }			GetDialogItem(BG_OptionsPtr,I_Small,DType,DItem,tempRect);			if Bulk_CONT_Xsect_BG= 4 then SetControlValue(controlhandle(DItem), 1) else SetControlValue(controlhandle(DItem), 0);						GetDialogItem(BG_OptionsPtr,I_Kramers,DType,DItem,tempRect);			if Bulk_CONT_Xsect_BG= 5 then SetControlValue(controlhandle(DItem), 1) else SetControlValue(controlhandle(DItem), 0);								GetDialogItem(BG_OptionsPtr,I_Lifshin_s_quadratic,DType,DItem,tempRect);			if Bulk_CONT_Xsect_BG= 6 then SetControlValue(controlhandle(DItem), 1) else SetControlValue(controlhandle(DItem), 0);						GetDialogItem(BG_OptionsPtr,I_FRAME_C,DType,DItem,tempRect);			if Bulk_CONT_Xsect_BG= 16 then SetControlValue(controlhandle(DItem), 1) else SetControlValue(controlhandle(DItem), 0);									GetDialogItem(BG_OptionsPtr,I_Rao_Sahib_Wittry,DType,DItem,tempRect);			if Bulk_CONT_Xsect_BG = 8 then SetControlValue(controlhandle(DItem), 1) else SetControlValue(controlhandle(DItem), 0);													GetDialogItem(BG_OptionsPtr,I_Spare8,DType,DItem,tempRect);			HiliteControl(controlhandle(DItem), 255);						GetDialogItem(BG_OptionsPtr,I_Green_Dyson,DType,DItem,tempRect);			HiliteControl(controlhandle(DItem), 255);						GetDialogItem(BG_OptionsPtr,I_Spare11,DType,DItem,tempRect);			HiliteControl(controlhandle(DItem), 255);			 			GetDialogItem(BG_OptionsPtr,I_Spare15,DType,DItem,tempRect);			if Mu_Choice = 3 then SetControlValue(controlhandle(DItem), 1) else SetControlValue(controlhandle(DItem), 0);											GetDialogItem(BG_OptionsPtr,I_Spare15,DType,DItem,tempRect);			HiliteControl(controlhandle(DItem), 255);								 			Refresh_Dialog; 			 			ExitDialog:=FALSE;			 			repeat				ModalDialog(NewModalFilterProc(@DefaultFilter), itemHit);				GetDialogItem(BG_OptionsPtr, itemHit, DType, DItem, tempRect);				CItem := controlhandle(DItem);				 				if (ItemHit =I_Accept) then				begin					ExitDialog:=TRUE;					Refresh_Dialog;				end;								if (ItemHit =I_Cancel) then				begin					ExitDialog:=TRUE;					Refresh_Dialog;				end;			 				if (ItemHit >=I_Small) and (ItemHit <=I_Spare11) then				begin					for Index:=I_Small  to I_Spare11 do					begin						GetDialogItem(BG_OptionsPtr, Index, DType, DItem, tempRect);						SetControlValue(controlhandle(DItem), 0);					end;					SetControlValue(CItem, 1);				end;				 								if (ItemHit >=I_Modified_Bethe_Heitler) and (ItemHit <=I_FreeQuadratic) then				begin					for Index:=I_Modified_Bethe_Heitler  to I_FreeQuadratic do					begin						GetDialogItem(BG_OptionsPtr, Index, DType, DItem, tempRect);						SetControlValue(controlhandle(DItem), 0);					end;					SetControlValue(CItem, 1);				end;								 			until ExitDialog;		 			Index:=I_Small;			repeat				GetDialogItem(BG_OptionsPtr, Index, DType, DItem, tempRect);				temp := GetControlValue(controlhandle(DItem));				Index := Index + 1;			until (temp<>0) or (Index >I_Spare11);			temp:= Index -I_Small +1;			{ In the main 'generate bulk' dialog the buttons top to bottom go 4,5,6,7,8,9,3,2 }			 Bulk_CONT_Xsect_BG := 16; { FRAME, unless otherwise }			if temp = 2 then Bulk_CONT_Xsect_BG := 4;			if temp = 3 then Bulk_CONT_Xsect_BG := 5;			if temp = 4 then Bulk_CONT_Xsect_BG := 6;			if temp = 5 then Bulk_CONT_Xsect_BG := 16;			if temp = 6 then Bulk_CONT_Xsect_BG := 8;			if temp = 6 then beepbeep;					 		  			Index:=I_Modified_Bethe_Heitler;	{14}			repeat				GetDialogItem(BG_OptionsPtr, Index, DType, DItem, tempRect);				temp := GetControlValue(controlhandle(DItem));				Index := Index + 1;			until (temp<>0) or (Index >I_FreeQuadratic);			temp:= Index -I_Modified_Bethe_Heitler +1;			{ In the main 'generate thin' dialog the buttons top to bottom go 7 to 2 }			if temp = 2 then Thin_CONT_Xsect_BG := 7	{MBH}		    else if temp = 3 then Thin_CONT_Xsect_BG := 6 {KW} 			else if temp = 4 then Thin_CONT_Xsect_BG := 5	{KW/MP}			else if temp = 5 then Thin_CONT_Xsect_BG := 4	{MH}			else if temp = 6 then Thin_CONT_Xsect_BG := 17			else Thin_CONT_Xsect_BG := 17; { Free Quadratic, unless otherwise }			if Thin_CONT_Xsect_BG <> 17 then			Thin_CONT_Xsect := Thin_CONT_Xsect_BG ; { if its not the free quadratic then assign it			                                          to the "generate thin" dialog }			if Bulk_CONT_Xsect_BG <> 16 then			Bulk_CONT_Xsect := Bulk_CONT_Xsect_BG ; { if its not the free quadratic then assign it			                                          to the "generate Bulk" dialog }											DisposeDialog(BG_OptionsPtr);			Mouse_Active_Window;	       { Update_Full;}		end;{$S BG_Correct1}  PROCEDURE D_BG_Correct;{TYPE	Comp_Rec				=	RECORD								C_Name		:	string[32];								C_Number	:	integer;								C_Density	:	real;								C_Atno		:	Array [1..15] of integer;								C_WtFr		:	Array [1..15] of real;								C_Valence	:	Array [1..15] of integer;								C_Code		:	longint;								C_SpareL	:	longint;								C_spareI	:	integer;	END;		Comp_RecPtr			=	^Comp_Rec;	Comp_RecHdl			=	^Comp_RecPtr;  }    CONST      BG_Accept                     = 1;	  BG_Cancel                     = 2;	  G_zero	                    = 3;	  Load_Work_Params              = 4;      Send_Work_Params              = 5;	  	  BG_Detector_Params            = 6;      G_KV                          = 8;	  R_Man_ROI						= 9;	  R_Auto_ROI					= 10;	  Name_New_Database				= 11;      I_Z1                          = 13;      I_Value                       = 14;	  I_Help                        = 58;	  I_Quantity                    = 60;      BG_ThinRadio                  = 64;	  BG_BulkRadio                  = 65;      BG_Options                    = 66;	  R_Wt_Fr                       = 67;      R_Atm_Fr                      = 68;      R_Num_Atms                    = 69;      R_mMol_Dry_Wt                 = 70;      R_Ox_Fr                       = 71;      R_Valence                     = 72;	  Insert_in_Database            = 74;	{Insert item}	  Remove_Item                   = 75;	{Remove item}	  Edit_Text_Item                = 76;	{the edit box for std name}	  Retreive_Item                 = 77;	{Load a Database}      T_Sum                         = 81;      T_Diff_From_1                 = 82;      T_Average_Z                   = 83;    VAR      ExitDialog                    : boolean;      tempLong                      : Longint;      tempRect                      : Rect;      DType                         : Integer;      Index, nn,Num_SubLayers   	: Integer;	  Rho_T							: real;      DItem                         : Handle;      CItem 			            : controlhandle;      XDItem                        : Handle;      XDType                        : Integer;      sTemp                         : Str255;      itemHit                       : Integer;      temp                          : Integer;      tempReal                      : real {double_t};      Chem_Scale                    : Integer;      Sum                           : real {double_t};      Smallest_Wt_by_A              : real {double_t};      Wt_by_A                       : ARRAY [1..15] OF real {double_t};	  Sum_Wt_By_A                   : real {double_t};      Formula_Wt                    : real {double_t};      Num_Elements,Num_ROIWinBkgs   : Integer;      Average_Z                     : real {double_t};     { myform                        : decform;}      thestr                        : Str255;      theOxWeightF		            : ARRAY [1..15] OF real {double_t};      theValence                    : ARRAY [1..15] OF longint;	  theOxStr						: ARRAY [1..15] OF Str_5;	  G_Input                       : DialogPtr;      G_Concentration               : Array[1..15] of real {double_t};	  G_At_Num                      : Array[1..15] of integer;      cSize                         : Point;          {Pointer to a cell in a list}      dataBounds                    : Rect;	  Thin_Radio                   : ControlHandle;	  Bulk_Radio                   : ControlHandle;	  ManROI_Radio                 : ControlHandle;	  AutoROI_Radio                : ControlHandle;	  scaler                       : real {double_t}; {running sum of of divisions}	  value                        : real {double_t};	  keV_per_Channel    { energy per channelin kev }: real;	  	  Number_of_Elements           : Integer;	  cscTheta                     : real;	  s5Temp					   : Str_5;      str,str7, strt_str		   : str255;	  sinPhi					   : Real;	  BG_ROI_Val				   : ARRAY [1..Max_ROIs] of real;		str1,str2,str3		: str255;	 errCode				: Integer;     bytecount               : Longint;	 Auto_BG_ROI, Man_BG_ROI	: boolean;     TempROI                        : ROIHndl;    PROCEDURE Refresh_Dialog;            VAR        rTempRect                     : Rect;      BEGIN      ShowWindow(G_Input);      SelectWindow(G_Input);      SetPort(G_Input);		        GetDialogItem(G_Input, BG_Accept, DType, DItem, rTempRect);        PenSize(3, 3);        InsetRect(rTempRect, - 4, - 4);        FrameRoundRect(rTempRect, 16, 16);        PenSize(1, 1);         LUpdate(G_Input^.visRgn, cList);        rTempRect := Rect_I_List1;        InsetRect(rTempRect, - 1, - 1);        FrameRect(rTempRect);      END;Function Cont_FChi( chan_number : integer ): real ;var 	  term          : real;      Mu_over_Rho   : real;      term1         : real;	  fchi          : real;	  E             : real;	  kk            : integer;	  Begin            term1 := exp(1.65 * ln(Bulk_KV));            E := chan_number * keV_per_Channel;            Mu_over_Rho := zero;            spinCursor; 			            FOR kk := 1 TO Number_of_Elements DO              BEGIN                Get_Energies(A^.Bulk_At_Num[kk]);        { get edge energies etc. }                Mu_over_Rho := MassAbsCoeff(E * 1000.0, 				                A^.Bulk_At_Num[kk]) * A^.Bulk_Concentration[kk] + Mu_over_Rho;              END;            { Begin fChi expression for the continuum }            term := 1.2E-6 * (term1 - exp(1.65 * ln(E)));            fchi := 1 + term * Mu_over_Rho * cscTheta * sinPhi;			if fchi <= 1e-7 then fchi := 1e-7;            Cont_FChi := 1/(fchi*fchi);end;PROCEDURE Thin_Free_Quadratic;VAR	term_1             : real {double_t};	term               : integer;	diff               : real {double_t};	ave_bg_energy      : real {double_t};	Sum_X              : double_t;	Sum_Y              : double_t;	Sum_XX             : double_t;	Sum_XY             : double_t;	Denominator        : real {double_t};	Coef_1             : real {double_t};	Coef_2             : real {double_t};	counts_per_ch      : real {double_t};	index              : integer;	E_low              : real {double_t};	E_high             : real {double_t};	NB                 : integer;	Used_chans		   : integer;	BEGIN	{ Do a least squares fit through the selected ROIs to determine the           two coefficients for the continuum fit. }	Sum_X   := 0.0;	Sum_Y   := 0.0;	Sum_XX  := 0.0;	Sum_XY  := 0.0;	 keV_per_Channel := Plt_spec[10]^^.Expt_Info.dE * 0.001;        { ch calibration in kev/ch}	NB := Number_of_Backgrounds-1;	For index := 1 to NB do		Begin		  spinCursor;		  counts_per_ch  := ROI^^.background[index].Value /				 (ROI^^.BackGround[index].Hi - ROI^^.BackGround[index].Lo + 1);          E_low :=  ROI^^.background[index].Lo * keV_per_Channel ;		  E_high :=  ROI^^.background[index].Hi * keV_per_Channel ;		  ave_bg_energy := (E_high + E_low)/2.0;		  diff :=  Thin_KV - ave_bg_energy;		{ Eo-E }			  term := rinttol(ave_bg_energy * 1000.0 / Plt_spec[10]^^.Expt_Info.dE);	{ Channel No. }		  term_1 := Det_Effic_P^[term]* diff/ave_bg_energy ;		    			if term_1 <= 0 then 				 begin 				  (* Realtostring(E_low,10,5,str);				   Realtostring(E_high,10,5,str1);				   Realtostring(ave_bg_energy,10,5,str2);				   Realtostring(diff,10,5,str3);				   Realtostring(term_1,10,5,str4);				   str := CONCAT('Elo, Ehi= ',str,'  ',str1,' Av BG eng= ', str2,' diff and term_1= ',str3,'  ',str4);				   Numtostring(NB,str1);				   Realtostring(term,10,5,str2);				   str1 := Concat('NB and term= ',str1,'   ',str2);				   putmessage('There was an arithmetic error in BG Subtract, I can`t go on',str1,str,'');*)				   Exit_the_Lot := FALSE;				   exit(Thin_Free_Quadratic);				 end; 		  Sum_X := Sum_X + diff;		  Sum_Y := Sum_Y + counts_per_ch/term_1;		  Sum_XX := Sum_XX + diff*diff;		  Sum_XY := Sum_XY + diff*counts_per_ch/term_1;		   		  		End;	Denominator := NB * Sum_XX - Sum_X * Sum_X; 	if Denominator = 0 then 				 begin				   Exit_the_Lot := FALSE;				   Error_Report;				   exit(Thin_Free_Quadratic);				 end;	Coef_2 := (Sum_XX * Sum_Y - Sum_X * Sum_XY)/Denominator;		{ Linear term }	Coef_1 := (NB * Sum_XY - Sum_X * Sum_Y)/Denominator;	{ Slope }      { Start a loop to compute the continuum at each channel of the spectrum. }	  Used_chans := theBGRec^^.Number_of_channels;	  if (rinttol((Plt_Spec[10]^^.Expt_Info.kV) * 1000/Plt_Spec[10]^^.Expt_Info.dE) < Used_chans) then 	  		Used_chans := rinttol((Plt_Spec[10]^^.Expt_Info.kV) * 1000/Plt_Spec[10]^^.Expt_Info.dE);	  	  For index := 1 to Maximum_Channels do Col_1^[index] := 0.0; { in case there is left over crap in the high channels }	For index := 1 to Used_chans do		Begin		  spinCursor;		  ave_bg_energy :=  keV_per_Channel * index;       { Get average BG energy for each channel }		  if (ave_bg_energy < Thin_KV) then		    begin		     diff :=  Thin_KV - ave_bg_energy;		{ Eo-E }		     term_1 := Det_Effic_P^[index] * diff/ave_bg_energy;		     Col_1^[Index] := term_1 * (Coef_1*diff + Coef_2);	{ counts_per_ch }		    end		  else			 Col_1^[Index] := zero;		End;		 		Convolve_Col1;END;      PROCEDURE frame_background; { Bulk Free Quadratic }{ This procedure computes the continuum background with the FRAMEC algorithm. }{ It requires the following values:	Number of background regions selected - NB 				Area of each region - BG_area				Begin and end energy of each region - E_low and E_high				The detector efficiency function - Det				f(chi) function - fchi				Beam energy - E0				keV per channel - dE				Number_of_channels }VAR	term_1             : real {double_t};	term               : integer;	diff               : real {double_t};	ave_bg_energy      : real {double_t};	Sum_X              : double_t;	Sum_Y              : double_t;	Sum_XX             : double_t;	Sum_XY             : double_t;	Denominator        : real {double_t};	Coef_1             : real {double_t};	Coef_2             : real {double_t};	counts_per_ch      : real {double_t};	index              : integer;	E_low              : real;	E_high             : real;	NB                 : integer;	Used_chans		   : integer;    	BEGIN	{ Do a least squares fit through the selected ROIs to determine           the two coefficients for the continuum fit. }	Sum_X   := 0.0;	Sum_Y   := 0.0;	Sum_XX  := 0.0;	Sum_XY  := 0.0;	keV_per_Channel := Plt_spec[10]^^.Expt_Info.dE * 0.001;          { ch calibration in kev/ch}		NB := Number_of_Backgrounds-1;	For index := 1 to NB do		Begin		  spinCursor;		  counts_per_ch  := ROI^^.background[index].Value /				 (ROI^^.BackGround[index].Hi - ROI^^.BackGround[index].Lo + 1);          E_low := ROI^^.background[index].Lo * keV_per_Channel;		  E_high := ROI^^.background[index].Hi * keV_per_Channel;		  ave_bg_energy := (E_high + E_low) *0.5;		  diff :=  Bulk_KV - ave_bg_energy;		{ Eo-E }		  term := rinttol(ave_bg_energy * 1000.0 / Plt_spec[10]^^.Expt_Info.dE);	{ Channel No. }		  term_1 := Det_Effic_P^[term]* Cont_FChi(term)* diff/ave_bg_energy;		  if Exit_the_Lot then exit(frame_background); 			if term_1 <= 0 then 			begin			  Exit_the_Lot := FALSE;			  Error_Report;			  exit(frame_background);			end;  		  Sum_X := Sum_X + diff;		  Sum_Y := Sum_Y + counts_per_ch/term_1;		  Sum_XX := Sum_XX + diff*diff;		  Sum_XY := Sum_XY + diff*counts_per_ch/term_1;		End;	Denominator := NB * Sum_XX - Sum_X * Sum_X;		if Denominator <= 0 then 	   begin	     Exit_the_Lot := FALSE;		 Error_Report;		 exit(frame_background);	   end;   	Coef_2 := (Sum_XX * Sum_Y - Sum_X * Sum_XY)/Denominator;		{ Linear term }	Coef_1 := (NB * Sum_XY - Sum_X * Sum_Y)/Denominator;	{ Slope }      { Start a loop to compute the continuum at each channel of the spectrum. }	  Used_chans := theBGRec^^.Number_of_channels;	  if (rinttol((Plt_Spec[10]^^.Expt_Info.kV) * 1000/Plt_Spec[10]^^.Expt_Info.dE) < Used_chans) then 	  		Used_chans := rinttol((Plt_Spec[10]^^.Expt_Info.kV) * 1000/Plt_Spec[10]^^.Expt_Info.dE);	  For index := 1 to Maximum_Channels do Col_1^[index] := 0.0; { in case there is left over crap in the high channels }	For index := 1 to Used_chans do		Begin		  ave_bg_energy :=  keV_per_Channel * index;       { Get average BG energy for each channel }		  if (ave_bg_energy < Bulk_KV) then		    begin			 spinCursor;		     diff := Bulk_KV - ave_bg_energy;		     term_1 := Det_Effic_P^[index] * Cont_FChi(index) * diff/ave_bg_energy;		     Col_1^[Index] := term_1 * (Coef_1*diff + Coef_2);	{ counts_per_ch }		    end		  else			 Col_1^[Index] := zero;		End;	if WDS_Active = False then	  Convolve_Col1;	  END;{frame_background}    PROCEDURE Add_LStr(theString: Str255; theList: ListHandle);            VAR        theRow                        : Integer;      BEGIN        IF (theList <> NIL) THEN          BEGIN            cSize.h := 0;            theRow := LAddRow(1, 200, theList);            cSize.v := theRow;            sTemp := theString;            LSetCell(POINTER(ord(@sTemp) + 1), length(sTemp), cSize, theList);            LDraw(cSize, theList);          END;      END;		PROCEDURE SetGValues; { G_Concentration is always wtF...convert to desired units}      VAR        nn                           : Integer;   			  BEGIN {PROCEDURE SetGValues; num_elements is known}        FOR nn := num_elements to 14 DO          BEGIN            GetDialogItem(G_Input, I_Z1 + 2 * nn, DType, DItem, tempRect);            SetDialogItemText(DItem, '0');            GetDialogItem(G_Input, I_Value + 2 * nn, DType, DItem, tempRect);            SetDialogItemText(DItem, '0');	     END;        		{myform.style := fixedDecimal;		myform.digits := 6;}		IF Chem_Scale = 2  THEN	{Num_Elements is #of elements}		BEGIN		  if (Num_Elements <= 0) then exit(SetGValues);		  if num_elements > 15 then num_elements := 15;		   { Call Procedure WeightF_to_Ox to convert G_Concentration[1..n] to		      theOxWeightF[1..m]:m = n - 1, and to make theOxStr[1..m]. } 			FOR nn := 1 TO Num_Elements-1 DO			  BEGIN			    WtFrac_to_Oxide(theValence[nn], nn, G_At_Num[nn], s5Temp, 								G_Concentration[nn], tempReal);				theOxStr[nn] := s5Temp;				theOxWeightF[nn] := tempReal;			  END;			  theOxWeightF[Num_Elements] := 0.0;						FOR nn := 0 TO Num_Elements-2 DO			  BEGIN				GetDialogItem(G_Input, I_Z1 + 2 * nn, DType, DItem, tempRect);				SetDialogItemText(DItem, theOxStr[nn+1]);				tempReal := theOxWeightF[nn+1];				{Mynum2str} RealToString(tempReal, 5, 4, thestr); {tempReal is double_t,thestr is a decstr}								GetDialogItem(G_Input, I_Value + 2 * nn, DType, DItem, tempRect);				SetDialogItemText(DItem, thestr);			  END; {FOR nn := 0...}			  if num_elements > 15 then num_elements := 15;			  if num_elements < 1 then num_elements := 1;			nn := Num_Elements - 1;			sTemp := '0';			GetDialogItem(G_Input, I_Z1 + 2 * nn, DType, DItem, tempRect);			SetDialogItemText(DItem, sTemp);			GetDialogItem(G_Input, I_Value + 2 * nn, DType, DItem, tempRect);			SetDialogItemText(DItem, sTemp);		END	{ IF Chem_Scale = 2...}		ELSE BEGIN			FOR nn := 0 TO Num_Elements-1 DO			  BEGIN				GetDialogItem(G_Input, I_Z1 + 2 * nn, DType, DItem, tempRect);				if G_At_Num[nn+1] = 8 then sTemp := '8' 				else sTemp := A^.sym[G_At_Num[nn+1]]; 				SetDialogItemText(DItem, sTemp);			  END; {FOR nn := 0...}				IF (Chem_Scale = 3) THEN	{# of atoms }			BEGIN { Pre calculate the needed quantities }			   Wt_By_A[1] := G_Concentration[1] / At_Wt^^.Value[G_At_Num[1]] ;			   Smallest_Wt_By_A := Wt_By_A[1];			   FOR nn := 2 TO Num_Elements DO				  BEGIN	{find nn of smallest # of atoms}					Wt_By_A[nn] := G_Concentration[nn] / At_Wt^^.Value[G_At_Num[nn]] ;					IF Wt_By_A[nn] < Smallest_Wt_By_A						  THEN Smallest_Wt_By_A := Wt_By_A[nn];				  END;			END {IF Chem_Scale = 3...}				ELSE IF Chem_Scale = 5 THEN	{ atomic fract }			BEGIN { Pre calculate the needed quantities }				Sum_Wt_By_A := 0.0;				FOR nn := 1 TO Num_Elements DO				BEGIN					Wt_By_A[nn] := G_Concentration[nn] / At_Wt^^.Value[G_At_Num[nn]] ;					Sum_Wt_By_A := Sum_Wt_By_A + Wt_By_A[nn];				END;			END; {IF (Chem_Scale = 5)...}				FOR nn := 0 TO Num_Elements - 1 DO			BEGIN				GetDialogItem(G_Input, I_Z1 + 2 * nn, DType, DItem, tempRect);				 temp := G_At_Num[nn+1];				 tempReal := 0.0; { double_t variable }				 IF temp = 8 THEN SetDialogItemText(DItem, '8')				 ELSE SetDialogItemText(DItem, A^.sym[temp]);								IF Chem_Scale = 6 THEN BEGIN					numtostring(theValence[nn + 1],sTemp);					GetDialogItem(G_Input, I_Value + 2 * nn, DType, DItem, tempRect);					SetDialogItemText(DItem, sTemp);				END				ELSE BEGIN { IF Chem_Scale <> 6...}				   IF Chem_Scale = 1 THEN tempReal := G_Concentration[nn+1]				   				   ELSE IF Chem_Scale = 3 THEN					   tempReal := (Wt_By_A[nn + 1] / Smallest_Wt_By_A)				  				   ELSE IF Chem_Scale = 4 THEN					 BEGIN					   temp := G_At_Num[nn+1];					   tempReal := (G_Concentration[nn+1] * 1E6 )/ At_Wt^^.Value[temp];					 END {else IF Chem_Scale = 4 ...}				   				   ELSE IF Chem_Scale = 5 THEN				   		tempReal := Wt_By_A[nn + 1] / Sum_Wt_By_A; {atom fract}			   				   { see SANE p25}				   {Mynum2str} RealToString(tempReal, 5, 4, thestr); {tempReal is double_t,thestr is a decstr}				   GetDialogItem(G_Input, I_Value + 2 * nn, DType, DItem, tempRect);				   SetDialogItemText(DItem, thestr);				END; { IF Chem_Scale <> 6...}			  END; { for nn := 0 to 0 TO Num_Elements - 1 do... }		 END; {IF Chem_Scale <> 2...}      END;	{SetValues;   ...Generate}      PROCEDURE GetGValues; {G_Concentration should always hold wtfraction}      VAR        nn,ZValue                 : Integer;		WValue					  : real {double_t};		str	:str255;      BEGIN		  Formula_Wt := 0.0;		  IF (Chem_Scale <> 6) THEN Num_Elements := 0;		  		  IF (Chem_Scale = 2) THEN		  BEGIN			 FOR nn := 0 TO 14 DO			 BEGIN			   GetDialogItem(G_Input, I_Value + 2*nn, DType, DItem, tempRect);			   GetDialogItemText(DItem, sTemp);			   WValue := MyStr2Num(sTemp); {convert the string to a real value}			   			   GetDialogItem(G_Input, I_Z1 + 2 * nn, DType, DItem, tempRect);			   GetDialogItemText(DItem, str); {to start, str is '0' ie zero }			   str := Strip_Trailing_Blanks(str); { trim the space after a single char replace }			   If (ord(str[1]) <> 48) and (WValue > 0) then			   begin				 Num_Elements := Num_Elements + 1;				 if num_elements > 15 then num_elements := 15;				 theOxStr[Num_Elements] := str;				 theOxWeightF[Num_Elements] := WValue;			   end			   else begin				 theOxWeightF[nn+1] := 0.0;				 theOxStr[nn+1] := str;			   end;			   thevalence[nn+1]:= 0;	{give this values in Oxide_to_Z routine}			 END;	{ FOR nn := 0 TO 14...}			 Num_Elements := Num_Elements + 1; {include oxygen}			 if num_elements > 15 then num_elements := 15;			 {Call the routine Oxide_to_Z to get the z,wtfs and valences}			 G_Concentration[Num_Elements] := 0.0;			 FOR nn := 1 TO Num_Elements - 1 DO			  begin			   s5Temp := theOxStr[nn];			   Oxide_to_WtFrac(s5Temp, nn, G_At_Num[nn], thevalence[nn], G_Concentration[nn],			   					WValue, theOxWeightF[nn]);			   G_Concentration[Num_Elements] := G_Concentration[Num_Elements] + WValue;			  end;			  G_At_Num[Num_Elements] := 8;			  thevalence[Num_Elements] := 2;		  END	{ IF (Chem_Scale = 2)...}		  ELSE IF (Chem_Scale = 6) THEN	{we already know the Z's}		  FOR nn := 0 TO Num_Elements - 1 DO		  BEGIN			 GetDialogItem(G_Input, I_Value + 2 * nn, DType, DItem, tempRect);			 GetDialogItemText(DItem, sTemp);			 StringtoNum(sTemp,theValence[nn + 1]);		  END	{ IF (Chem_Scale = 6)...}		  ELSE BEGIN		  FOR nn := 0 TO 14 DO		  BEGIN            GetDialogItem(G_Input, I_Z1 + 2 * nn, DType, DItem, tempRect);            GetDialogItemText(DItem, sTemp);			sTemp := Strip_Trailing_Blanks(sTemp); { trim the space after a single char replace }            if sTemp = '8' then ZValue := 8			else ZValue := AtSymbol_To_Znum(sTemp);						GetDialogItem(G_Input, I_Value + 2 * nn, DType, DItem, tempRect);			GetDialogItemText(DItem, sTemp);			WValue := MyStr2Num(sTemp); {convert the string to a real value}						If (ZValue >= 0) and (WValue > 0) then			begin			  Num_Elements := Num_Elements + 1;			  if num_elements > 15 then num_elements := 15;			  G_At_Num[Num_Elements] := ZValue;			  G_Concentration[Num_Elements] := WValue;			end			else begin			  G_Concentration[nn+1] := 0.0;			  G_At_Num[nn+1] := 0;			end;       	  END;	{ FOR nn := 0 TO 14...}		  IF (Chem_Scale = 3) THEN 	{ # of atoms }		  BEGIN			 FOR nn := 0 TO Num_Elements - 1 DO			 BEGIN			   temp := G_At_Num[nn + 1];			   G_Concentration[nn+1] := G_Concentration[nn+1] * (At_Wt^^.Value[temp] );			   Formula_Wt := Formula_Wt + G_Concentration[nn+1];			 END;	{FOR nn := 0...}			 FOR nn := 0 TO Num_Elements - 1 DO G_Concentration[nn+1] :=												G_Concentration[nn+1] / Formula_Wt;		  END	{ IF (Chem_Scale = 3) }   		  ELSE IF (Chem_Scale = 4) THEN {mMole/kgdrywt}		  FOR nn := 0 TO Num_Elements - 1 DO		  BEGIN				temp := G_At_Num[nn+1];				G_Concentration[nn+1] :=  G_Concentration[nn+1] * At_Wt^^.Value[temp]  * 1E-6;		  END	{IF (Chem_Scale = 4) ... FOR nn := 0 ...}   		  ELSE IF (Chem_Scale = 5) THEN { atomic fract }		  BEGIN 			   Sum_Wt_By_A := 0.0;			   FOR nn := 0 TO Num_Elements-1 DO			   BEGIN				  temp := G_At_Num[nn+1];				   Wt_By_A[nn + 1] := G_Concentration[nn+1] * At_Wt^^.Value[temp] ;				   Sum_Wt_By_A := Sum_Wt_By_A + Wt_By_A[nn + 1];			   END;			   FOR nn := 0 TO Num_Elements - 1 do			   BEGIN				 G_Concentration[nn+1] := Wt_By_A[nn + 1] / Sum_Wt_By_A;			   END;		   END;	{IF (Chem_Scale = 5)...}		 END; {if chem_scale<>6}      END; { sub Procedure GetValues }   	PROCEDURE Do_GSums;      VAR        nn                            : Integer;      	  BEGIN        Sum := zero;        Average_Z := zero;		{We always know what G_Concentration,etc and, IF (Chem_Scale = 2),		 we know OxWeightF, OxStr etc }        FOR nn := 0 TO Num_Elements - 1 DO          BEGIN {if we read strings then no math needed}			IF (Chem_Scale = 2) then Sum := Sum + theOxWeightF[nn+1]			ELSE IF (Chem_Scale = 5) then			begin			  GetDialogItem(G_Input, I_Value + 2 * nn, DType, DItem, tempRect);			  GetDialogItemText(DItem, sTemp);			  Sum := Sum + MyStr2Num(sTemp);			end			Else  Sum := sum + G_Concentration[nn+1];		    Average_Z := Average_Z + G_Concentration[nn+1] * G_At_Num[nn+1];          END;            GetDialogItem(G_Input, T_Sum, XDType, XDItem, tempRect);            RealToString(Sum, 5, 5, Str);            SetDialogItemText(XDItem, Str);            GetDialogItem(G_Input, T_Diff_From_1, XDType, XDItem, tempRect);            RealToString(1 - Sum, 5, 5, Str);            SetDialogItemText(XDItem, Str);            GetDialogItem(G_Input, T_Average_Z, XDType, XDItem, tempRect);            RealToString(Average_Z, 5, 5, Str);            SetDialogItemText(XDItem, Str);       END;	{ PROCEDURE Do_GSums }	PROCEDURE Zero_the_Comps;	  VAR	    nn	: integer;	  BEGIN            BeepBeep;            FOR nn := 0 TO 14 DO {strings and values to 0}              BEGIN                GetDialogItem(G_Input, I_Z1 + 2 * nn, DType, DItem, tempRect);                SetDialogItemText(DItem, '0');                GetDialogItem(G_Input, I_Value + 2 * nn, DType, DItem, tempRect);                SetDialogItemText(DItem, '0');                G_At_Num[nn + 1] := 0;                G_Concentration[nn + 1] := 0.0;                theOxWeightF[nn + 1] := 0.0;                theOxStr[nn + 1] := '';                theValence[nn + 1] := 0;              END;            str := '0';            GetDialogItem(G_Input, T_Sum, XDType, XDItem, tempRect);            SetDialogItemText(XDItem, str);            GetDialogItem(G_Input, T_Diff_From_1, XDType, XDItem, tempRect);            SetDialogItemText(XDItem, str);            GetDialogItem(G_Input, T_Average_Z, XDType, XDItem, tempRect);            SetDialogItemText(XDItem, str);            Num_Elements := 0;	  END;	  	   PROCEDURE Do_normal_BG;  VAR  	index, nn			: integer;  Label   69;	 	BEGIN      G_Input := GetNewDialog(3300, NIL, POINTER( - 1));      Exit_the_Lot := FALSE;      ShowWindow(G_Input);      SelectWindow(G_Input);      SetPort(G_Input);  	  GetDialogItem(G_Input, BG_ThinRadio, DType, DItem, tempRect);	  Thin_Radio := controlhandle(DItem);	  GetDialogItem(G_Input, BG_BulkRadio, DType, DItem, tempRect);	  Bulk_Radio := controlhandle(DItem);	  GetDialogItem(G_Input, R_Man_ROI, DType, DItem, tempRect);	  ManROI_Radio := controlhandle(DItem);	  GetDialogItem(G_Input, R_Auto_ROI, DType, DItem, tempRect);	  AutoROI_Radio := controlhandle(DItem);      OutlineButton(G_Input, 1, 16);	  GetDialogItem(G_Input, Insert_in_Database, DType, DItem, tempRect);	  HiliteControl(controlhandle(DItem), 255);	  GetDialogItem(G_Input, Remove_Item, DType, DItem, tempRect);	  HiliteControl(controlhandle(DItem), 255);       SetRect(Rect_I_List1, 194, 189, 615, 332); { l,t,r,b }      tempRect := Rect_I_List1;      tempRect.Right := tempRect.Right - 15;      IF (tempRect.Right <= (tempRect.Left + 15)) THEN tempRect.Right := tempRect.Left + 15;      InsetRect(tempRect, - 1, - 1);      FrameRect(tempRect);      InsetRect(tempRect, 1, 1);      SetRect(dataBounds, 0, 0, 1, 0);      cSize.h := tempRect.Right - tempRect.Left;      cSize.v := 0;      cList := LNew(tempRect, dataBounds, cSize, 0, G_Input, True, FALSE, FALSE, True);      cList^^.selFlags := lOnlyOne + lNoNilHilite;      LSetDrawingMode(False, cList);      strt_str := 'Enter Here name of new item in database (<32 chars)';      GetDialogItem(G_Input, Edit_Text_Item, DType, DItem, tempRect);      SetDialogItemText(DItem, strt_str);     { Add_LStr('1    Kakanui Hornblende', cList);      Add_LStr('2    Kakanui Augite', cList);      Add_LStr('3    Quartz', cList);}	  	        cSize.v := 0;      LSetSelect(True, cSize, cList);       Refresh_Dialog;	    Number_of_Entries := 0;		OpenNew_Database := false;		  IF (DataBase_Open = true) THEN		   begin			LSetDrawingMode(true, cList);			Open_Database;			  GetDialogItem(G_Input,Insert_in_Database,DType,DItem,tempRect);			  HiliteControl(controlhandle(DItem), 0); 			  GetDialogItem(G_Input,Remove_Item,DType,DItem,tempRect);			  HiliteControl(controlhandle(DItem), 0); 								  LdelRow(0, 1, cList);			  LSetDrawingMode(FALSE, cList);			  if Comp_handles then				begin				  FOR Index := 1 TO Number_of_Entries DO					BEGIN					  IF NOT (Comp_Data[Index]^^.C_Name = '') THEN						BEGIN						  numtostring(Index, str1);						  str2 := Strip_Trailing_Blanks(str1);						  str1 := Strip_Trailing_Blanks(Comp_Data[Index]^^.C_Name);						  str := CONCAT(str2, '  ', str1);						  Add_LStr(str, cList);						END;					END;				end;			  LSetDrawingMode(true, cList);			  cSize.v := 0;			  LSetSelect(true, cSize, cList); { this selects the first entry }					Refresh_Dialog;		   end;	{Here's the logic: We have two handles to the same kind of structure, theBGRec and	 theGenRec. We use and change the theBGRec values in this proc.	 We can only get concentrations from work if the spectrum is generated	 or a standard; we should NEVER change these values based on this proc.}	   	   IF ((Active_Chemical_Scale < 1) OR (Active_Chemical_Scale > 5)) THEN        Active_Chemical_Scale := 1;      Chem_Scale := Active_Chemical_Scale;      GetDialogItem(G_Input, I_Quantity, XDType, XDItem, tempRect);      SetDialogItemText(XDItem, 'Weight Fraction');      GetDialogItem(G_Input, R_Wt_Fr, DType, DItem, tempRect);      SetControlValue(controlhandle(DItem), 1);	  	  Called_for_Generate := False; 	  Called_for_Work_Spec := False;				  	  	  Zero_the_Comps;	  	  	        {the Plt_spec[10] values will not change unless accept}      	  WITH Plt_Spec[10]^^.SpectrumStuff.Spectrum_Info DO	  FOR nn := 1 TO 15 DO        BEGIN { stuff in what's in the record }          G_At_Num[nn] := Element_Info[nn].Atomic_Number;          IF G_At_Num[nn] <= 0 THEN G_At_Num[nn] := 0		  else Num_Elements := Num_Elements + 1;		  if num_elements > 15 then num_elements := 15;			if ((Element_Info[nn].Valence < 0.0) OR (Element_Info[nn].Valence > 7.0)) then Element_Info[nn].Valence := 0.0;		  		  thevalence[nn] := rinttol(Element_Info[nn].Valence);          G_Concentration[nn] := Element_Info[nn].Weight_Fraction;							         END;			  	   SetControlValue(ManROI_Radio, 0);		   SetControlValue(AutoROI_Radio, 1);		   Man_BG_ROI := false;		   Auto_BG_ROI := true;		   		IF Plt_Spec[10]^^.Expt_Info.kV > 100.00 then begin			Running_Thin_Mode := true;			Running_Bulk_Mode := false;		end;        IF Running_Thin_Mode THEN		BEGIN	  	   SetControlValue(Bulk_Radio, 0);		   SetControlValue(Thin_Radio, 1); 		  { RealToString(Thin_KV, 5, 3, Str);}		END        ELSE IF Running_Bulk_Mode THEN 		BEGIN	  	   SetControlValue(Bulk_Radio, 1);		   SetControlValue(Thin_Radio, 0);   		  { RealToString(Bulk_KV, 5, 3, Str);}		END;				RealToString(Plt_Spec[10]^^.Expt_Info.kV, 5, 3, Str);        GetDialogItem(G_Input, G_KV, DType, DItem, tempRect);        SetDialogItemText(DItem, Str);	  if num_elements > 0 then	  begin	  if num_elements > 15 then num_elements := 15;		SetGValues;		Do_GSums;	  end;        ExitDialog := FALSE;         Quick_Exit := False;        REPEAT        ModalDialog(NewModalFilterProc(@GFilter), itemHit);        GetDialogItem(G_Input, itemHit, DType, DItem, tempRect);        CItem := controlhandle(DItem);         IF (itemHit > 100) AND (itemHit < 999) then		BEGIN		    temp := itemHit-100;		    GetDialogItem(G_Input, Edit_Text_Item, DType, DItem, tempRect);			if (Comp_handles) then			  begin				str7 := Strip_Trailing_Blanks(Comp_Data[temp]^^.C_Name);				SetDialogItemText(DItem, str7);				num_elements := Comp_Data[temp]^^.C_Number;				if num_elements > 15 then num_elements := 15;				if num_elements < 1 then num_elements := 1;				{Thin_density := Comp_Data[temp]^^.C_Density;}				for index := 1 to num_elements do				  begin					G_At_Num[index] := Comp_Data[temp]^^.C_Atno[index];					G_Concentration[index] := Comp_Data[temp]^^.C_WtFr[index];					thevalence[index] := Comp_Data[temp]^^.C_Valence[index];				  end;			  end;  		{	GetDialogItem(G_Input, G_Density, DType, DItem, tempRect);			RealToString(Thin_density, 5, 3, Str);			IF Running_Thin_Mode THEN SetDialogItemText(DItem, Str) ELSE SetDialogItemText(DItem, 'N/A');}						GetDialogItem(G_Input, I_Quantity, XDType, XDItem, tempRect);						GetDialogItem(G_Input, R_Wt_Fr, DType, DItem, tempRect);			SetDialogItemText(XDItem, 'Weight Fraction');			CItem := controlhandle(DItem);			Chem_Scale := 1;			SetGValues;			Do_GSums;			FOR Index := R_Wt_Fr TO R_Valence DO              BEGIN                GetDialogItem(G_Input, Index, DType, DItem, tempRect);                SetControlValue(controlhandle(DItem), 0);  {turn off all radios}              END;            SetControlValue(CItem, 1);	{turn on the selected radio}					    Refresh_Dialog;        END;         IF (itemHit >= R_Wt_Fr) AND (itemHit <= R_Valence) THEN { RADIO Buttons }        BEGIN		  IF itemHit = R_Ox_Fr THEN		  BEGIN				nn:=1;				Repeat				  If theValence[nn] > 0 then nn := nn + 1; 				Until (theValence[nn] <= 0) or (nn = Num_Elements);				{remember the valence[Num_Elements] is the valence[Oxygen] which				 doesn't count.}				 if num_elements < 1 then num_elements := 1;				IF (theValence[nn] <= 0) AND (G_Concentration[1] > 0.0)  then						Putmessage('I cannot give you the Oxide fractions without the valences.',								   'Another way to enter the data is to `zero all` then click the oxide',								   'button and enter formulas such as Al2O3. The valences will then be',								   'calculated from the stoichiometry relation.')				ELSE IF ((G_At_Num[Num_Elements] <> 8) AND (G_Concentration[1] > 0.0)) then					  Putmessage('The last element must be oxygen for this conversion.',								  '','','')				ELSE BEGIN					 GetDialogItem(G_Input, I_Quantity, XDType, XDItem, tempRect);					 SetDialogItemText(XDItem, 'Oxide Weight Fraction');					 Chem_Scale := 2;					 FOR Index := R_Wt_Fr TO R_Valence DO					   BEGIN						 GetDialogItem(G_Input, Index, DType, DItem, tempRect);						 SetControlValue(controlhandle(DItem), 0);  {turn off all radios}					   END;					 SetControlValue(CItem, 1);	{turn on the selected radio}				END;		   END	{ IF itemHit = R_Ox_Fr THEN...}		   ELSE BEGIN	{ IF itemHit <> R_Ox_Fr THEN...}            GetDialogItem(G_Input, I_Quantity, XDType, XDItem, tempRect);            FOR Index := R_Wt_Fr TO R_Valence DO              BEGIN                GetDialogItem(G_Input, Index, DType, DItem, tempRect);                SetControlValue(controlhandle(DItem), 0);              END;            SetControlValue(CItem, 1);            IF itemHit = R_Wt_Fr THEN              BEGIN                SetDialogItemText(XDItem, 'Weight Fraction');                Chem_Scale := 1;              END            ELSE IF itemHit = R_Num_Atms THEN              BEGIN                SetDialogItemText(XDItem, '#Atoms in a Compound');                Chem_Scale := 3;              END            ELSE IF itemHit = R_mMol_Dry_Wt THEN              BEGIN                SetDialogItemText(XDItem, 'mMol/kg dry Weight');                Chem_Scale := 4;              END            ELSE IF itemHit = R_Atm_Fr THEN              BEGIN                SetDialogItemText(XDItem, 'Atomic Fraction');                Chem_Scale := 5;              END            ELSE IF itemHit = R_Valence THEN              BEGIN                SetDialogItemText(XDItem, 'Valence');                Chem_Scale := 6;              END;		    END;	{ IF itemHit <> R_Ox_Fr THEN...}			IF num_elements > 0 then begin			if num_elements > 15 then num_elements := 15;			if num_elements < 1 then num_elements := 1;			  SetGValues; {we always have theWeightFs and theZs}			  Do_GSums;			  End;		  END; { IF (itemHit >= R_Wt_Fr) AND (itemHit <= R_Valence) THEN...}   					IF itemHit = R_Man_ROI then				begin                 IF (ROI^^.BackGround[1].Exists) AND (ROI^^.BackGround[2].Exists) THEN				 begin				 Man_BG_ROI := true;				 Auto_BG_ROI := false;				   SetControlValue(ManROI_Radio, 1);				   SetControlValue(AutoROI_Radio, 0);				 end                 ELSE                    BEGIN                      BeepBeep;                      putmessage('You forgot to choose the minimum of background ROI 1 and 2', '', '', '');					  Man_BG_ROI := false;				 	  Auto_BG_ROI := true;					   SetControlValue(ManROI_Radio, 0);					   SetControlValue(AutoROI_Radio, 1);                    END;				end;			IF itemHit = R_Auto_ROI then				begin				   Man_BG_ROI := false;				   Auto_BG_ROI := true;				   SetControlValue(ManROI_Radio, 0);				   SetControlValue(AutoROI_Radio, 1);				 end;	         IF (itemHit = I_Help) THEN            BEGIN            BG_Subtract_Help ;            Refresh_Dialog;          END;        IF (itemHit = BG_Cancel) THEN            BEGIN		   {What if it were BkgSubtracted from a previous pass... 		    Plt_spec[9]^^.SpectrumStuff.Spectrum_Info.BkgSubtracted := False;}            DisposeDialog(G_Input);			if (Comp_handles = true) then			for index := 1 to Number_of_Entries do			H_UnLock_Dispose( Handle(Comp_Data[index]) , 'Comp_Data handle' );			Comp_handles := false;			{putmessage('About to dispose of the cList','','','');			LDispose(cList);}			BeginUpdate(BackPlane);			DrawAxesFull;			Update_Full;			EndUpdate(BackPlane);		    UpDate_SiLi_Window(SiLiWindow) ;            Mouse_Active_Window;			Quick_Exit := TRUE; {this is a global to thwart bad things that go bump in the night }			BG_Active := false;            exit(D_BG_Correct);          END;		          IF (itemHit = G_zero) THEN  Zero_the_Comps;        IF (itemHit = BG_Accept) THEN          BEGIN            GetGValues;			IF (Running_Thin_Mode) then			begin			  Specimen_Thickness := Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.Specimen_Thickness;			  Thin_density := Plt_spec[10]^^.SpectrumStuff.Spectrum_Info.Specimen_Density;			end;			IF G_At_Num[ 1 ] = 0 THEN 			  putmessage('There is nothing for me to work with, please enter one or more',						 'elements and their concentrations','or use the CANCEL button.','')						 			ELSE IF ((Running_Thin_Mode = False) AND (Running_Bulk_Mode = False)) THEN			   putmessage('Neither a Thick nor Thin Specimen is selected, Please select the',						 'appropriate specimen type or CANCEL.','','')            ELSE  IF ((Running_Thin_Mode) and			          (Specimen_Thickness = 0)) THEN			BEGIN			   if answermessage('The specimen thickness is 0.',			   				 'If IT`S OK I`ll use 100 nm for the missing value.',							 'If IT`S NOT OK, go to the spectrum header and supply',							 'the correct value.') then				Begin					specimen_thickness := 0.00001;{cm}			        ExitDialog := True;				End;			END	{ IF ((Running_Thin_Mode) and...}            ELSE  IF ((Running_Thin_Mode) and			          (Thin_density = 0)) THEN			BEGIN			   if answermessage('The density is 0.',			   				 'If IT`S OK I`ll use 1 for the missing value.',							 'If IT`S NOT OK, go to the spectrum header and supply',							 'the correct value.') then				Begin					Thin_density := 1;			        ExitDialog := True;				End;			END	{ IF ((Running_Thin_Mode) and...}			ELSE BEGIN			  Active_Chemical_Scale := Chem_Scale;			  ExitDialog := True;			  if (Comp_handles = true) then			  for index := 1 to Number_of_Entries do				H_UnLock_Dispose( Handle(Comp_Data[index]) , 'Comp_Data handle' );			  Comp_handles := false;			END;          END;         IF (itemHit = BG_Options) THEN          BEGIN            D_BG_Options; ;            Refresh_Dialog;          END;        IF (itemHit = Insert_in_Database) THEN          BEGIN		  IF (DataBase_Open = TRUE) THEN			BEGIN		    if Number_of_Entries >= 50 then			  begin			    putmessage('You have reached the maximum number',							' of compositions allowed for this file.',							' Please start a new data file for additional',							' compositions.');			  end			else			  begin			GetDialogItem(G_Input, Edit_Text_Item, DType, DItem, tempRect);      		GetDialogItemText(DItem, sTemp);			str7 := Strip_Trailing_Blanks(sTemp);			if NOT (strt_str = str7) then			begin			Number_of_Entries := Number_of_Entries + 1;			 Test_a_Handle(Handle(Comp_Data[Number_of_Entries]),'Comp_Data[Number_of_Entries]');			 Comp_Data[Number_of_Entries] := Comp_RecHdl(NewHandle(SizeOf(Comp_Rec))); 			 if MemError = memFullErr then Out_of_Memory_Warning;			 MoveHHi(Handle(Comp_Data[Number_of_Entries]));   			 HLock(Handle(Comp_Data[Number_of_Entries]));			 Comp_handles := true;			  nn := Length(str7);			  if nn > 32 then				str7[0] := chr(32);			Comp_Data[Number_of_Entries]^^.C_Name := str7;			if num_elements > 15 then num_elements := 15;			if num_elements < 1 then num_elements := 1;			Comp_Data[Number_of_Entries]^^.C_Number := num_elements;			{Comp_Data[Number_of_Entries]^^.C_Density := Thin_density;}			for index := 1 to num_elements do			  begin			    Comp_Data[Number_of_Entries]^^.C_Atno[index] := G_At_Num[index];				Comp_Data[Number_of_Entries]^^.C_WtFr[index] := G_Concentration[index];				if ((theValence[Index] < 1) OR (theValence[Index] > 7)) then					theValence[Index] := 0;				Comp_Data[Number_of_Entries]^^.C_Valence[index] := thevalence[index];			  end;						Add_to_Database;			numtostring(Number_of_Entries,str1);			str1 := Strip_Trailing_Blanks(str1);			str := concat(str1,'  ',str7);			LSetDrawingMode(True, cList);			Add_LStr(str, cList);			Refresh_Dialog;			end;			end;		   END;		{ IF (DataBase_Open = TRUE) }		  END;		  IF (itemHit = Remove_Item) THEN			BEGIN			  StringToNum(str_info, tempLong);			  if (tempLong > 0) then				begin			  Remove_from_Database(tempLong);			  if Comp_handles then			  begin				  H_UnLock_Dispose(Handle(Comp_Data[Number_of_Entries]), 'Comp_Data handle');				  cSize.v := 0;				  LSetSelect(true, cSize, cList); { this selects the first entry }				  LSetDrawingMode(true, cList);				  LdelRow(0, 1, cList);				  Number_of_Entries := Number_of_Entries - 1;				  LSetDrawingMode(false, cList);				  for index := 1 to Number_of_Entries do					begin					  IF NOT (Comp_Data[Index]^^.C_Name = '') THEN						BEGIN						  str7 := Comp_Data[index]^^.C_Name;						  numtostring(index, str1);						  str1 := Strip_Trailing_Blanks(str1);						  str := CONCAT(str1, '  ', str7);						  Add_LStr(str, cList);						END;				end;			  LSetDrawingMode(true, cList);			  end;			  Refresh_Dialog;			  cSize.v := 0;			  LSetSelect(true, cSize, cList); { this selects the first entry }			  end;	{ if (tempLong > 0) }			END;        IF (itemHit = Name_New_Database) THEN          BEGIN			DataBase_Open := False;			LdelRow(0,1,cList);          	Create_Database;			  GetDialogItem(G_Input,Insert_in_Database,DType,DItem,tempRect);			  HiliteControl(controlhandle(DItem), 0); 			  GetDialogItem(G_Input,Remove_Item,DType,DItem,tempRect);			  HiliteControl(controlhandle(DItem), 0); 			Refresh_Dialog;		  END;        IF (itemHit = Retreive_Item) THEN          BEGIN		    OpenNew_Database := true;			LSetDrawingMode(true, cList);          	Open_Database;			  GetDialogItem(G_Input,Insert_in_Database,DType,DItem,tempRect);			  HiliteControl(controlhandle(DItem), 0); 			  GetDialogItem(G_Input,Remove_Item,DType,DItem,tempRect);			  HiliteControl(controlhandle(DItem), 0); 			   cSize.v := 0;			   LSetSelect(True, cSize, cList);   { this selects the first entry }			   LdelRow(0,1,cList);			   LSetDrawingMode(false, cList);			For index := 1 to Number_of_Entries DO			 BEGIN			 if not (Comp_Data[index]^^.C_Name = '') AND (Comp_handles) then			   begin				 NumtoString(index,str1);				 str2 := Strip_Trailing_Blanks(str1);				 str1 := Strip_Trailing_Blanks(Comp_Data[index]^^.C_Name);				 str := concat(str2,'  ',str1);				 Add_LStr(str, cList);			    end;			END;			LSetDrawingMode(True, cList);			Refresh_Dialog;			cSize.v := 0;			LSetSelect(True, cSize, cList);   { this selects the first entry }			OpenNew_Database := false;					  END; { ¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥ } 		           IF (itemHit = Send_Work_Params) THEN BEGIN	{this is active only from BK Subt}		  If Plt_Spec[10]^^.SpectrumStuff.Spectrum_Info.Theoretically_Generated or		     Plt_Spec[10]^^.SpectrumStuff.Spectrum_Info.This_is_a_Standard then			 str := 'The concentrations will not be changed.'		  else str := '';		  IF AnswerMessage('These values and those in the detector dialog will replace ',				   		   'the ones in the Experiment and Spectrum Headers of WORK??',						   str,'If you`re sure IT`S OK, I`ll do it now.') THEN		  Begin  {IF AnswerMessage...}			  beepbeep; 			    			   WITH theBGRec^^ do 			   begin					 Plt_Spec[10]^^.Expt_Info.BN_Thickness  := BN_Thickness;					 Plt_Spec[10]^^.Expt_Info.SiN_Thickness  := SiN_Thickness;					 Plt_Spec[10]^^.Expt_Info.Mylar  := Mylar;					 Plt_Spec[10]^^.Expt_Info.Moxtek  := Moxtek;					 Plt_Spec[10]^^.Expt_Info.Paralene  := Paralene;					 Plt_Spec[10]^^.Expt_Info.Diamond  := Diamond;					 Plt_Spec[10]^^.Expt_Info.Quantum  := Quantum;					 Plt_Spec[10]^^.Expt_Info.Detector_Area  := Detector_Area;					 Plt_Spec[10]^^.Expt_Info.Si_Resolution  := Si_Resolution;					 Plt_Spec[10]^^.Expt_Info.WDS_Resolution  := WDS_Resolution;					 Plt_Spec[10]^^.Expt_Info.Detector_Thickness  := Detector_Thickness;					 Plt_Spec[10]^^.Expt_Info.Si_Thickness  := Si_Thickness;					 Plt_Spec[10]^^.Expt_Info.Au_Thickness  := Au_Thickness;					 Plt_Spec[10]^^.Expt_Info.Be_Thickness  := Be_Thickness;					 Plt_Spec[10]^^.Expt_Info.Ice_Thickness  := Ice_Thickness;					 Plt_Spec[10]^^.Expt_Info.C_Thickness  := C_Thickness;					 Plt_Spec[10]^^.Expt_Info.Al_Thickness  := Al_Thickness;					 Plt_Spec[10]^^.Expt_Info.Azimuth  := Azimuth;					 Plt_Spec[10]^^.Expt_Info.Elevation  := Elevation;					 Plt_Spec[10]^^.Expt_Info.Detector_tilt  := Detector_tilt;					 Plt_Spec[10]^^.SpectrumStuff.Spectrum_Info.Spec_Detector_Distance  := Spec_detector_Distance;					 Plt_Spec[10]^^.SpectrumStuff.Spectrum_Info.Take_Off_Angle  := Take_Off_Angle;					 Plt_Spec[10]^^.SpectrumStuff.Spectrum_Info.Y_Tilt  := Y_Tilt;					 Plt_Spec[10]^^.SpectrumStuff.Spectrum_Info.X_Tilt  := X_Tilt;					IF Running_Bulk_Mode THEN Plt_Spec[10]^^.Expt_Info.kV := Bulk_kV;					IF Running_Thin_Mode THEN Plt_Spec[10]^^.Expt_Info.kV := Thin_kV; 				end;	{ WITH theBGRec }							IF MCA_Spectrum_Active then if AnswerMessage('A DTSA File of Spectra is open!!!',                                             'If "Its OK"  I will replace the values ',											 'in the Experiment and Spectrum Header in the file.','') then	            WITH Plt_spec[10]^^,Expt_Info,SpectrumStuff				DO begin					 errCode := FSpOpenDF(Read_DTSA_Spec, fsRdWrPerm, Hold_RefNum);					 RdBinaryName := Read_DTSA_Spec.name;					IF errCode <> NoErr THEN BeepBeep  					ELSE BEGIN						 errCode := SetFPos_Err(Hold_RefNum, fsFromStart, 0,'');						 bytecount := sizeof(expt_infoRec);						 errCode := FSWrite_Err(Hold_RefNum, bytecount, @Plt_spec[10]^^.Expt_Info,'');						 bytecount := (sizeof(expt_infoRec) + 										sizeof(Plot_infoRec) + (longint(Spectrum_Counter)-1) * 									   (sizeof(Spectrum_Structure) +										longInt(Plt_spec[10]^^.Expt_Info.Number_of_Channels) * 4));						errCode := SetFPos_err(Hold_RefNum, fsFromStart, bytecount,'');										bytecount := sizeof(Spectrum_Structure) ;						errCode := FSWrite_err(Hold_RefNum, bytecount, @Plt_spec[10]^^.SpectrumStuff,'');											   END;	{ ELSE BEGIN...}					errCode := FSClose(Hold_RefNum);					errCode := FlushVol(NIL, Read_DTSA_Spec.vRefNum);	           END;	{ WITH...} 			END;  {IF AnswerMessage...}          END; { IF (itemHit = Send_Work_Params) THEN BEGIN... }         IF (itemHit = Load_Work_Params) THEN		 IF (AnswerMessage('Are you sure IT`S OK to move all the "Work Spectrum" parameters',				            'into the fields of this dialog and the detector dialog??', '', ''))          THEN BEGIN		    		     WITH theBGRec^^ DO			 BEGIN			{Will we need a new sili response?? TEST BEFORE WE CHANGE theBGRec...}			 IF (Plt_spec[10]^^.Expt_Info.BN_Thickness <> BN_Thickness) OR (Plt_spec[10]^^.Expt_Info.SiN_Thickness <>				SiN_Thickness) OR (Plt_spec[10]^^.Expt_Info.Mylar <> Mylar) OR (Plt_spec[10]^^.Expt_Info.Diamond <>				Diamond) OR (Plt_spec[10]^^.Expt_Info.Moxtek <> Moxtek) OR (Plt_spec[10]^^.Expt_Info.Paralene <> Paralene)				OR (Plt_spec[10]^^.Expt_Info.Quantum <> Quantum) OR (Plt_spec[10]^^.Expt_Info.Detector_Thickness				<> Detector_Thickness) OR (Plt_spec[10]^^.Expt_Info.Si_Thickness <> Si_Thickness) OR (Plt_spec[10]^^.				Expt_Info.Au_Thickness <> Au_Thickness) OR (Plt_spec[10]^^.Expt_Info.Be_Thickness <> Be_Thickness) OR (				Plt_spec[10]^^.Expt_Info.Ice_Thickness <> Ice_Thickness) OR (Plt_spec[10]^^.Expt_Info.C_Thickness <>				C_Thickness) OR (Plt_spec[10]^^.Expt_Info.Al_Thickness <> Al_Thickness) OR (Plt_spec[10]^^.Expt_Info.				Detector_tilt <> Detector_tilt) OR (Plt_spec[10]^^.Expt_Info.dE <> dE) OR (Plt_spec[10]^^.Expt_Info.				Number_of_Channels > Number_of_Channels) 			  THEN SiLi_Buffer_Calculated := false;		  	  index := rinttol(1740.0/Plt_spec[10]^^.Expt_Info.dE);		  	  if Det_Effic_P^[index] <= 0.0 then SiLi_Buffer_Calculated := false;		  	  		  {...NOW put work into theBgRec}				   BN_Thickness := Plt_Spec[10]^^.Expt_Info.BN_Thickness ;			   SiN_Thickness := Plt_Spec[10]^^.Expt_Info.SiN_Thickness ;			   Mylar := Plt_Spec[10]^^.Expt_Info.Mylar ;			   Moxtek := Plt_Spec[10]^^.Expt_Info.Moxtek ;			   Paralene := Plt_Spec[10]^^.Expt_Info.Paralene ;			   Diamond := Plt_Spec[10]^^.Expt_Info.Diamond ;			   Quantum := Plt_Spec[10]^^.Expt_Info.Quantum ;			   Detector_Area := Plt_Spec[10]^^.Expt_Info.Detector_Area ;			   Si_Resolution := Plt_Spec[10]^^.Expt_Info.Si_Resolution ;			   Detector_Thickness := Plt_Spec[10]^^.Expt_Info.Detector_Thickness ;			   Si_Thickness := Plt_Spec[10]^^.Expt_Info.Si_Thickness ;			   Au_Thickness := Plt_Spec[10]^^.Expt_Info.Au_Thickness ;			   Be_Thickness := Plt_Spec[10]^^.Expt_Info.Be_Thickness ;			   Ice_Thickness := Plt_Spec[10]^^.Expt_Info.Ice_Thickness ;			   C_Thickness := Plt_Spec[10]^^.Expt_Info.C_Thickness ;			   Al_Thickness := Plt_Spec[10]^^.Expt_Info.Al_Thickness ;			   Azimuth := Plt_Spec[10]^^.Expt_Info.Azimuth ;			   Elevation := Plt_Spec[10]^^.Expt_Info.Elevation ;			   Detector_tilt := Plt_Spec[10]^^.Expt_Info.Detector_tilt ;			   Spec_detector_Distance := Plt_Spec[10]^^.SpectrumStuff.Spectrum_Info.Spec_Detector_Distance ;			   Take_Off_Angle := Plt_Spec[10]^^.SpectrumStuff.Spectrum_Info.Take_Off_Angle ;			   Y_Tilt := Plt_Spec[10]^^.SpectrumStuff.Spectrum_Info.Y_Tilt ;			   X_Tilt := Plt_Spec[10]^^.SpectrumStuff.Spectrum_Info.X_Tilt ;			 			 IF Running_Bulk_Mode THEN Bulk_kV := Plt_Spec[10]^^.Expt_Info.kV			 ELSE IF Running_Thin_Mode THEN Thin_kV := Plt_Spec[10]^^.Expt_Info.kV			 ELSE BEGIN			 	Bulk_kV := Plt_Spec[10]^^.Expt_Info.kV;				Running_Bulk_Mode := true;				putmessage('Nothing was chosen so I have set',' the background routine to "Bulk".','','');			 END; 			 dE := Plt_Spec[10]^^.Expt_Info.dE;			 number_of_channels := Plt_Spec[10]^^.Expt_Info.number_of_channels;			 Detector.Spec := Plt_Spec[10]^^.Expt_Info.Detector.Spec ;			 if ( Plt_Spec[10]^^.Expt_Info.Detector.ID <>1) and			    ( Plt_Spec[10]^^.Expt_Info.Detector.ID <> 2) then 				Plt_Spec[10]^^.Expt_Info.Detector.ID := 1;			 Detector.ID := Plt_Spec[10]^^.Expt_Info.Detector.ID; 			 		   IF Plt_Spec[10]^^.SpectrumStuff.Spectrum_Info.Theoretically_Generated or			  Plt_Spec[10]^^.SpectrumStuff.Spectrum_Info.This_is_a_Standard		   THEN 		   BEGIN			  			  Zero_the_Comps;	  			   			   FOR nn := 1 TO 15 DO	{G_XXX are local variables}			   BEGIN			   		IF ((Plt_Spec[10]^^.SpectrumStuff.Spectrum_Info.Element_Info[nn].Valence >=0.0) AND 			   		(Plt_Spec[10]^^.SpectrumStuff.Spectrum_Info.Element_Info[nn].Valence < 7)) then					thevalence[nn] := 					   rinttol(Plt_Spec[10]^^.SpectrumStuff.Spectrum_Info.Element_Info[nn].								  Valence)					ELSE						thevalence[nn] := 0;					G_At_Num[nn] := 					   Plt_Spec[10]^^.SpectrumStuff.Spectrum_Info.Element_Info[nn].Atomic_Number;					G_Concentration[nn] := 					   Plt_Spec[10]^^.SpectrumStuff.Spectrum_Info.Element_Info[nn].Weight_Fraction;					if (G_At_Num[nn]>0) and (G_Concentration[nn]>0) then					   num_elements := num_elements + 1;					   if num_elements > 15 then num_elements := 15;					   if num_elements < 1 then num_elements := 1;			   END;	{FOR nn := 1 TO 15...}			END; { If Plt_Spec[10]^^....}   			 if num_elements > 0 then			 begin			   SetGValues;			   Do_GSums;			 end;		  END;	{ WITH theBGRec^^...}        END;	{ IF (itemHit = Load_Work_Params)...}		  { ¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥ }           IF (itemHit = BG_Detector_Params) THEN          BEGIN            Called_for_Generate := FALSE;            Called_for_Work_Spec := FALSE;			KludgeBoolean := False;            Detector_Parameters; {since we change theBgRec in Detector_Parameters,			                      we also test if a new response fnc is required;								  SiLi_Buffer_Calculated is set to proper value}            Mouse_Active_Window;            Refresh_Dialog;          END;        IF (itemHit = BG_ThinRadio )          THEN                                                    BEGIN			   SetControlValue(Bulk_Radio, 0);			   SetControlValue(Thin_Radio, 1);			   Running_Thin_Mode := True;			   Running_Bulk_Mode := False;			END;			          IF (itemHit = BG_BulkRadio)          THEN                                                    BEGIN			   SetControlValue(Bulk_Radio, 1);			   SetControlValue(Thin_Radio, 0);			   Running_Thin_Mode := False;			   Running_Bulk_Mode := True;		    END;		IF (itemHit >= I_Z1) and (itemHit <= I_Value + 28) THEN		  BEGIN { we don't want to read values just because we changed units		          but we do if we changed z or quantity}			GetGValues;{gives theWeightFs and theZs}			Do_GSums;		  END;{¥¥¥¥}  UNTIL ExitDialog;		If (Plt_Spec[10]^^.Expt_Info.Detector.ID <>1) and	   (Plt_Spec[10]^^.Expt_Info.Detector.ID <>2) then	   Plt_Spec[10]^^.Expt_Info.Detector.ID := 1;   {The following values MUST be the same as Plt_Spec[10] or we can't subtract...}    WITH theBGRec^^ do     BEGIN 	      IF (dE <> Plt_Spec[10]^^.Expt_Info.dE) OR	      (theBGRec^^.number_of_channels < Plt_Spec[10]^^.Expt_Info.number_of_channels) OR	      (Detector.Spec <> Plt_Spec[10]^^.Expt_Info.Detector.Spec) OR	      (Detector.ID <> Plt_Spec[10]^^.Expt_Info.Detector.ID) 		  THEN  BEGIN			   dE := Plt_Spec[10]^^.Expt_Info.dE;			   number_of_channels := Plt_Spec[10]^^.Expt_Info.number_of_channels;			   Detector.Spec := Plt_Spec[10]^^.Expt_Info.Detector.Spec ;			   Detector.ID := Plt_Spec[10]^^.Expt_Info.Detector.ID; 			   SiLi_Buffer_Calculated := false;		    END;		 if (Detector.Spec = WDS) then if (Si_Resolution > 90.0) then begin		 							   Si_Resolution := Plt_Spec[10]^^.Expt_Info.Si_Resolution;		  							   SiLi_Buffer_Calculated := false;									   end		 Else if (Detector.Spec = EDS) then if (Si_Resolution < 90.0) then begin		  							 SiLi_Buffer_Calculated := false;			 						 Si_Resolution := Plt_Spec[10]^^.Expt_Info.Si_Resolution;									 end;	 END; 	{ WITH...}				GetDialogItem(G_Input, G_KV, DType, DItem, tempRect);		GetDialogItemText(DItem, sTemp);		IF Running_Bulk_Mode THEN 		BEGIN		  Bulk_KV := MyStr2Num(sTemp);		  FOR nn := 1 TO 15 DO		  BEGIN			A^.Bulk_At_Num[nn] := G_At_Num[nn] ;			A^.Bulk_Concentration[nn] := G_Concentration[nn] ;          END;        END        ELSE IF Running_Thin_Mode THEN 			BEGIN		  Thin_KV := MyStr2Num(sTemp);		  FOR nn := 1 TO 15 DO		  BEGIN			  A^.Thin_At_Num[nn] := G_At_Num[nn] ;			  A^.Thin_Concentration[nn] := G_Concentration[nn] ;		  END;        END;       { for the continuum fChi calculation, above: }       cscTheta := 1 / SIN(theBGRec^^.Take_Off_Angle / 57.295779);        	(*	CompareGen_To_Work; {Find out if the stored, active, response is valid for spectrum in WORK}		IF (SiLi_Response_Calculated = False) { if a new spectrum in work...} THEN  BEGIN		  GenFromWork;	{get theGenRec values from Work }		  Detector_efficiency(theGenRec,SiLi_Response_Calculated); { and calculate a new one }		END;	*)			sinPhi := Sin(Geom.Beam_Entry_Angle / 57.295779);		if num_elements > 15 then num_elements := 15;		if num_elements < 1 then num_elements := 1;  	  Number_of_Elements := num_elements;	{Do ROIs...get ·counts in each ROI}  	  if Man_BG_ROI then	    begin	{the ROIs don't include any escape peaks 'cus they are removed}	  	 	 Refresh_ROIs; { Update the ROI's for the new spectrum in "work" }	 	{ ...used Escape above so work on Col_1} {for me only} BlockMove(@Col_1^, @Plt_Spec[6]^^.S, Sizeof(Plt_Spec[6]^^.S));		end	  else if Auto_BG_ROI then	    begin			ReserveMem(SizeOf(ROIs)); { Reserve memory near the beginning of heap }			if MemError = memFullErr then 			  begin			    Out_of_Memory_Warning;				exit(D_BG_Correct);			  end;				TempROI := ROIHndl(NewHandle(SizeOf(ROIs)));			HLock(Handle(TempROI));			TempROI^^ := ROI^^;			Num_ROIWinBkgs := Number_of_Backgrounds;{save it in case manual rois are set}			AutoBG;	{sets ROIs,returns data sans escapes to col_1; it's also in col_2 }		end;				for nn := 1 TO Number_of_Backgrounds - 1 do		begin		  BG_ROI_Val[ nn ] := zero;		  For index := ROI^^.Background[nn].Lo to ROI^^.Background[nn].Hi do			BG_ROI_Val[ nn ] := BG_ROI_Val[ nn ] + Col_1^[Index] ;		end;	     	{continuum procs modify col_1 so above moved data sans escapes into col_2...}		{Do continuum...}	IF not SiLi_Buffer_Calculated then		Detector_efficiency(theBGRec,SiLi_Buffer_Calculated); { and calculate a new one }		IF (Running_Thin_Mode) then	BEGIN	  if (Thin_CONT_Xsect_BG = 17)  then  	  begin		  Exit_the_Lot := FALSE;		  Thin_Free_Quadratic;  {writes generated contin to col_1}		  if Exit_the_Lot then GoTo 69; 	  end  	  else begin	  	Q_Continuum_Thin(0);    { comes back as (Qz*dE/Atomic_Weight), per unit Steradian into the                                     take-off angle specified, weighted for all the elements in the                                     thin specimen, in the array ¥¥ Bkg_P^[k] ¥¥ . The 0 in                                     the argument is to signal that the procedure should use the                                     concentrations etc from the thin input window}  {Don't need to scale by thin physics constant cause we scale to data...}	   Num_SubLayers := 50;	   Rho_T := Thin_Density * Specimen_Thickness;	   FOR Index := 1 TO theBGRec^^.Number_of_channels DO	   BEGIN		Col_6^[Index] := Bkg_P^[Index] *  Det_Effic_P^[Index] / Num_SubLayers;	{(generated BG * det eff)/num_SubLayers} ;		SpinCursor;		mu_rho_P^[Index] := 0.0; { At each channel get the mass absorption coefficient }		FOR nn := 1 TO Number_of_Elements DO		BEGIN		 Get_Energies(A^.Thin_At_Num[nn]); { get edge energies etc. }		 mu_rho_P^[Index] := MassAbsCoeff(Index * theBGRec^^.dE, A^.Thin_At_Num[nn]) * A^.Thin_Concentration[nn] +							 mu_rho_P^[Index];		END;		Col_1^[Index] := 0.0;		FOR nn := 0 TO Num_SubLayers - 1 DO { Divide film into Num_SubLayers and do Beers Law}		Col_1^[Index] :=  Col_1^[Index] + Col_6^[Index] *		 exp( - mu_rho_P^[Index] * (Rho_T - nn * Rho_T / Num_SubLayers) / Num_SubLayers * cscTheta);	   END; { FOR Index := 1 TO theBGRec^^.Number_of_channels ... }	  END;	{ELSE BEGIN...}	  Convolve_Col1;	{has contin with mass abs after the electronics}	END	{ IF (Running_Thin_Mode)...col_1 has bkg}	ELSE IF (Running_Bulk_Mode) then	BEGIN	  if (Bulk_CONT_Xsect_BG = 16)  then  	    begin		  {BeepBeep;BeepBeep;BeepBeep;}		  Exit_the_Lot := FALSE;		  frame_background; {write into col[1] and convolves...but col_2 has spec sans escapes}		  if Exit_the_Lot then GoTo 69;		end  	  else 	  begin		Bulk; { Col[4]^^.S gets the received-in-detector continuum with mass abs				from Bulk and all other cols including col_2 now holding data sans				escapes get something}	 	BlockMove(@Col_4^, @Col_1^, Sizeof(Col_1^));        {From Bulk in Physics.p we pick up col4 which has the generated continuum. In		 Bulk the generated continuum goes to col1, is convolved, then the broadened pks are added,		 then the escape peaks are added. Here we broaden but no peaks are added		 because we subtract escapes from the spectrum data.}		Convolve_Col1;	{col_1 = generated continuum * si_effic * convolver}	  end;	END;	    BlockMove(@Col_1^, @Col_3^, Sizeof(Col_1^));{this is the continuum we need}		BlockMove(@Plt_Spec[10]^^.S, @Col_1^, Sizeof(Col_1^)); 		Escape;	                 { again remove escape pks from data in col[1] }	    BlockMove(@Col_1^, @Col_2^, Sizeof(Col_1^));	    BlockMove(@Col_3^, @Col_1^, Sizeof(Col_1^));		 	    scaler := 0.0 ;		for nn := 1 TO Number_of_Backgrounds - 1 do		begin		   Value := 0.0;		   For index := ROI^^.Background[nn].Lo to ROI^^.Background[nn].Hi do			 Value := Value + Col_1^[Index] ;{col_1: convolved continuum, NO escapes}			  if Value <= 0 then 			   begin				 BlockMove(@Bkg_P^, @Plt_spec[7]^^.S, sizeof(Plt_spec[7]^^.S));				 BlockMove(@Det_Effic_P^, @Plt_spec[6]^^.S, sizeof(Plt_spec[6]^^.S));				 BlockMove(@Col_1^, @Plt_spec[8]^^.S, sizeof(Plt_spec[8]^^.S));				 Realtostring(scaler,5, 5,str);				 numtostring(Number_of_Backgrounds,str1);				 numtostring(index,str2);				 Realtostring(Value,5, 5,str3);				 str := CONCAT('scaler, Number_of_Backgrounds= ',str,'  ',str1,' index= ', str2,' Value = ',str3);				 putmessage('There was an arithmetic error in BG Subtract, I can`t go on',str,'',				 'Spectrm 8 has the contents of the Col_1^ vector,7 is Bkg_P and 6 is Det_Effic_P');				 GoTo 69;			   end;  		   scaler :=  scaler + BG_ROI_Val[ nn ] / Value ;	{BG_ROI_Val is from spectrum		   													 with escapes}		end;	{for nn := 1...}	 	   scaler := scaler/( Number_of_Backgrounds - 1  ) ;	   {scale generated bkg to data...}	   	   FOR Index := 1 TO theBGRec^^.Number_of_channels DO	   					 Col_1^[Index] := scaler * Col_1^[Index] ;{scaled continuum}	 {move header stuff to 9...} 	 BlockMove(@Plt_Spec[10]^^, @Plt_spec[9]^^, Sizeof(Work_Spectrum)); 	 {subtract the scaled generated continuum from data sans escapes}  		(* BlockMove(@Col_2^, @Plt_spec[2]^^, Sizeof(Col_2^)); 		 BlockMove(@Col_1^, @Plt_spec[1]^^, Sizeof(Col_1^));*) 	  FOR Index := 1 TO theBGRec^^.Number_of_channels DO Plt_spec[9]^^.s[Index] := 							   Col_2^[Index] - Col_1^[Index] ;	  Plt_spec[9]^^.SpectrumStuff.Spectrum_Info.BkgSubtracted := True;69:	  	  if Auto_BG_ROI then	    begin		  ROI^^ := TempROI^^;	{reset ROI info}		  Number_of_Backgrounds := Num_ROIWinBkgs;		  H_UnLock_Dispose( Handle(TempROI) , 'TempROI handle' );		  Refresh_ROIs;		end;			  Spectrum_Full[9] := True;	  CheckItem(FullMenu, A^.C_Full[9], Spectrum_Full[9]);	  Spectrum_Full[10] := True;	  CheckItem(FullMenu, A^.C_Full[10], Spectrum_Full[10]);	  UpDate_Max_Min(9);	  (*CheckItem(FullMenu, A^.C_Full[1], Spectrum_Full[1]);	  CheckItem(FullMenu, A^.C_Full[2], Spectrum_Full[2]);*)	  if (Comp_handles = true) then		for index := 1 to Number_of_Entries do		H_UnLock_Dispose( Handle(Comp_Data[index]) , 'Comp_Data handle' );	  Comp_handles := false; 	  BG_Active  := false; 	  BlockMove(@Gen_ResponseFnc^, @Det_Effic_P^, Sizeof(Det_Effic_P^));       DisposeDialog(G_Input);      Mouse_Active_Window;	  Update_Full;		END;	{PROCEDURE Do_normal_BG}	(*PROCEDURE Do_Qual_BG;		BEGIN		END;	{PROCEDURE Do_Qual_BG}*)    BEGIN	{PROCEDURE D_BG_Correct;}	  BG_Active := true; 	  BlockMove(@Bkg_ResponseFnc^, @Det_Effic_P^, Sizeof(Det_Effic_P^)); 	   	 BlockMove(@Plt_Spec[10]^^.S, @Col_1^, Sizeof(Col_1^)); 	 Escape;	                 { removes escape pks from col[1] }	 BlockMove(@Col_1^, @Col_2^, Sizeof(Col_1^));	 {...unfortunately we call Bulk below and it writes into ALL Col_n. HaHa!} if NOT Do_it_in_the_Dark then		{ Skip background window when doing quals. }	    begin	  		Do_normal_BG; END    {if not Do_It_In_the_Dark } ELSE BEGIN  { ¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥ Auto Peak Label Part ¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥ }   {The escapes were removed and data sans escapes put into col_1 and col_2.   The following values must be the same as Plt_Spec[10] or we can't subtract...}    WITH theBGRec^^ do     BEGIN 	      IF (dE <> Plt_Spec[10]^^.Expt_Info.dE) OR	      (theBGRec^^.number_of_channels < Plt_Spec[10]^^.Expt_Info.number_of_channels) OR	      (Detector.Spec <> Plt_Spec[10]^^.Expt_Info.Detector.Spec) OR	      (Detector.ID <> Plt_Spec[10]^^.Expt_Info.Detector.ID) 		  THEN  BEGIN			   dE := Plt_Spec[10]^^.Expt_Info.dE;			   number_of_channels := Plt_Spec[10]^^.Expt_Info.number_of_channels;			   Detector.Spec := Plt_Spec[10]^^.Expt_Info.Detector.Spec ;			   Detector.ID := Plt_Spec[10]^^.Expt_Info.Detector.ID; 			   SiLi_Buffer_Calculated := false;		    END;		 if (Detector.Spec = WDS) then if (Si_Resolution > 90.0) then begin		 							   Si_Resolution := Plt_Spec[10]^^.Expt_Info.Si_Resolution;		  							   SiLi_Buffer_Calculated := false;									   end		 Else if (Detector.Spec = EDS) then if (Si_Resolution < 90.0) then begin		  							 SiLi_Buffer_Calculated := false;			 						 Si_Resolution := Plt_Spec[10]^^.Expt_Info.Si_Resolution;									 end;	 END; 	{ WITH...}	  WITH Plt_Spec[10]^^.SpectrumStuff.Spectrum_Info DO	  FOR nn := 1 TO 15 DO        BEGIN { stuff in what's in the record }		  num_elements := 0;          IF Element_Info[nn].Atomic_Number > 0 THEN		  begin		  	G_At_Num[nn] := Element_Info[nn].Atomic_Number;		  	IF ((Element_Info[nn].Valence >=0.0) AND 			   		(Element_Info[nn].Valence < 7)) then				thevalence[nn] := rinttol(Element_Info[nn].Valence)			ELSE				thevalence[nn] := 0;		    {thevalence[nn] := rinttol(Element_Info[nn].Valence);}		    G_Concentration[nn] := Element_Info[nn].Weight_Fraction;			num_elements := num_elements + 1;		  end;		END;	{ WITH } 				IF (G_At_Num[1] = 0) then		 begin			G_At_Num[1] := 26;			G_Concentration[1] := 1.0;			num_elements := 1;		 end;			 IF Running_Bulk_Mode THEN BEGIN				 Bulk_kV := Plt_Spec[10]^^.Expt_Info.kV;				 Bulk_CONT_Xsect_BG := 16;				  FOR nn := 1 TO 15 DO				  BEGIN					A^.Bulk_At_Num[nn] := G_At_Num[nn] ;					A^.Bulk_Concentration[nn] := G_Concentration[nn] ;				  END;			 END			 ELSE IF Running_Thin_Mode THEN BEGIN				 Thin_kV := Plt_Spec[10]^^.Expt_Info.kV;				 Thin_CONT_Xsect_BG := 17;				  FOR nn := 1 TO 15 DO				  BEGIN					  A^.Thin_At_Num[nn] := G_At_Num[nn] ;					  A^.Thin_Concentration[nn] := G_Concentration[nn] ;				  END;			 END			 ELSE BEGIN				 Bulk_kV := Plt_Spec[10]^^.Expt_Info.kV;				 Bulk_CONT_Xsect_BG := 16;			 				  FOR nn := 1 TO 15 DO				  BEGIN					A^.Bulk_At_Num[nn] := G_At_Num[nn] ;					A^.Bulk_Concentration[nn] := G_Concentration[nn] ;				  END;			 END;       { for the continuum fChi calculation, above: }       cscTheta := 1 / SIN(theBGRec^^.Take_Off_Angle / 57.295779);        		CompareGen_To_Work(theBGRec); {Find out if the stored, active, response is valid for spectrum in WORK}		IF (SiLi_Response_Calculated = False) { if a new spectrum in work...} THEN  BEGIN		  GenFromWork(theBGRec);	{get theGenRec values from Work }		  Detector_efficiency(theBGRec,SiLi_Response_Calculated); { and calculate a new one }		END; 				sinPhi := Sin(Geom.Beam_Entry_Angle / 57.295779);		if num_elements > 15 then num_elements := 15;		if num_elements < 1 then num_elements := 1;  	    Number_of_Elements := num_elements;			 		ReserveMem(SizeOf(ROIs)); { Reserve memory near the beginning of heap }			if MemError = memFullErr then 			  begin			    Out_of_Memory_Warning;				exit(D_BG_Correct);			  end;			TempROI := ROIHndl(NewHandle(SizeOf(ROIs)));		HLock(Handle(TempROI));		TempROI^^ := ROI^^;		Num_ROIWinBkgs := Number_of_Backgrounds;{save it in case manual rois are set}		AutoBG;	{data sans escapes still in col_1...}		BlockMove(@Col_1^, @Col_2^, Sizeof(Col_1^));		for nn := 1 TO Number_of_Backgrounds - 1 do		   begin			 BG_ROI_Val[ nn ] := zero;			 for index := ROI^^.Background[nn].Lo to ROI^^.Background[nn].Hi do			   begin			       BG_ROI_Val[ nn ] := BG_ROI_Val[ nn ] + Col_1^[Index] ;			   end;			 		   end;		   	IF (Running_Thin_Mode) then	BEGIN									 if (Thin_CONT_Xsect_BG = 17)  then  Thin_Free_Quadratic		 else 		 BEGIN			Q_Continuum_Thin(0);    { comes back as (Qz*dE/Atomic_Weight), per unit Steradian into the										take-off angle specified, weighted for all the elements in the										thin specimen, in the array ¥¥ Bkg_P^[k] ¥¥ . The 0 in										the argument is to signal that the procedure should use the										concentrations etc from the thin input window}		    FOR Index := 1 TO theBGRec^^.Number_of_channels DO 							   Col_1^[Index] := Bkg_P^[Index] *  Det_Effic_P^[Index] ;	     END;	     Convolve_Col1;	END	ELSE IF (Running_Bulk_Mode) then	BEGIN	  if (Bulk_CONT_Xsect_BG = 16)  then  frame_background {write into col[1] and convolves}	  else begin		Bulk; { Col[4]^^.S has the received-in-detector continuum from "bulk" }		For Index := 1 to Maximum_Channels do Col_1^[Index] := 0.0; { in case there is left over crap in the high channels }	    FOR Index := 1 TO theBGRec^^.Number_of_channels DO Col_1^[Index] := Col_4^[Index] ;        Convolve_Col1;	  end;	END;	    scaler := zero ;		for nn := 1 TO Number_of_Backgrounds - 1 do		   begin			 Value := zero;			 for index := ROI^^.Background[nn].Lo to ROI^^.Background[nn].Hi do			   begin			       Value := Value + Col_1^[Index] ;			   end;			 			 scaler :=  scaler + BG_ROI_Val[ nn ] / Value ;			   end;	 	   scaler := scaler/( Number_of_Backgrounds - 1  ) ;	   	   	   FOR Index := 1 TO theBGRec^^.Number_of_channels DO Col_1^[Index] := scaler * Col_1^[Index] ;	  WITH Plt_Spec[10]^^.SpectrumStuff.Spectrum_Info DO	  FOR nn := 1 TO 15 DO        BEGIN { stuff in what's in the record }          IF G_At_Num[nn] > 0 THEN		  begin		  	Element_Info[nn].Atomic_Number := G_At_Num[nn];		    Element_Info[nn].Valence := thevalence[nn];		    Element_Info[nn].Weight_Fraction := G_Concentration[nn];		  end;        END;	  	 BlockMove(@Plt_Spec[10]^^, @Plt_spec[9]^^, Sizeof(Plt_spec[9]^^)); 	 FOR Index := 1 TO theBGRec^^.Number_of_channels DO Plt_spec[9]^^.s[Index] := 							   Col_2^[index] - Col_1^[Index] ;	  Plt_spec[9]^^.SpectrumStuff.Spectrum_Info.BkgSubtracted := True;	  (*	  	  Spectrum_Full[9] := True;	  CheckItem(FullMenu, A^.C_Full[9], Spectrum_Full[9]); 	  *)	 	  	  Spectrum_Full[10] := True;	  CheckItem(FullMenu, A^.C_Full[10], Spectrum_Full[10]);	  UpDate_Max_Min(9); 	  BG_Active  := false; 	  BlockMove(@Gen_ResponseFnc^, @Det_Effic_P^, Sizeof(Det_Effic_P^));       Mouse_Active_Window;      	  ROI^^ := TempROI^^;	  Number_of_Backgrounds := Num_ROIWinBkgs;	  H_UnLock_Dispose( Handle(TempROI) , 'TempROI handle' );	  Refresh_ROIs;		      END; {if Do_it_in_the_Dark ...Auto Peak Label Part}  END; {End of procedure D_BG_Correct}  {=================================}{$S BG_Correct2}PROCEDURE sort({n: longint;} VAR ra: glsarray);LABEL 99;VAR   l,j,ir,i,n	: integer;   rra			: real;BEGIN	n := nxdata;   l := (n DIV 2)+1;   ir := n;   WHILE true DO BEGIN      IF (l > 1) THEN BEGIN         l := l-1;         rra := ra[l]      END ELSE BEGIN         rra := ra[ir];         ra[ir] := ra[1];         ir := ir-1;         IF (ir = 1) THEN BEGIN            ra[1] := rra;            GOTO 99         END      END;      i := l;      j := l+l;      WHILE (j <= ir) DO BEGIN         IF (j < ir) THEN            IF (ra[j] < ra[j+1]) THEN j := j+1;         IF (rra < ra[j]) THEN BEGIN            ra[i] := ra[j];            i := j;            j := j+j         END ELSE            j := ir+1      END;      ra[i] := rra   END;99:   END;FUNCTION rofunc(b: real): real;VAR   d,sum: real;   j,n1,nmh,nml: integer;BEGIN   n1 := nxdata+1;   nml := n1 DIV 2;   nmh := n1-nml;   FOR j := 1 to nxdata DO arr^[j] := yyy^[j]-b*xxx^[j];   sort({nxdata,}arr^);   aa := 0.5*(arr^[nml]+arr^[nmh]);   sum := 0.0;   abdevt := 0.0;   FOR j := 1 to nxdata DO BEGIN      d := yyy^[j]-(b*xxx^[j]+aa);      abdevt := abdevt+abs(d);      IF (d > 0.0) THEN sum := sum+xxx^[j] ELSE sum := sum-xxx^[j]   END;   rofunc := sumEND;PROCEDURE medfit(xxxx,yyyy: glsarray; VAR ax,b,abdev: real {; nxdata: integer});LABEL 3;VAR   j: integer;   sy,sxy,sxx,sx,sigb,f2,f1,f: real;   del,chisq,bb,b2,b1: real;BEGIN   sx := 0.0;   sy := 0.0;   sxy := 0.0;   sxx := 0.0;   FOR j := 1 to nxdata DO BEGIN      sx := sx+xxxx[j];      sy := sy+yyyy[j];      sxy := sxy+xxxx[j]*yyyy[j];      sxx := sxx+sqr(xxxx[j])   END;   del := nxdata*sxx-sx*sx;   aa := (sxx*sy-sx*sxy)/del;   bb := (nxdata*sxy-sx*sy)/del;   chisq := 0.0;   FOR j := 1 to nxdata DO BEGIN      chisq := chisq+sqr(yyyy[j]-(aa+bb*xxxx[j]))   END;   sigb := sqrt(chisq/del);   b1 := bb;   f1 := rofunc(b1);   IF (f1 > 0.0) THEN BEGIN      b2 := bb+abs(3.0*sigb)   END ELSE BEGIN      b2 := bb-abs(3.0*sigb)   END;   f2 := rofunc(b2);   WHILE ((f1*f2) > 0.0) DO BEGIN      bb := 2.0*b2-b1;      b1 := b2;      f1 := f2;      b2 := bb;      f2 := rofunc(b2)   END;   sigb := 0.01*sigb;   WHILE (abs(b2-b1) > sigb) DO BEGIN      bb := 0.5*(b1+b2);      IF ((bb = b1) OR (bb = b2)) THEN GOTO 3;      f := rofunc(bb);      IF ((f*f1) >= 0.0) THEN BEGIN         f1 := f;         b1 := bb      END ELSE BEGIN         b2 := bb      END   END;3:   ax := aa;   b := bb;   abdev := abdevt/nxdataEND; PROCEDURE D_H_Limit; LABEL 10; VAR     Enew                         : real;	 Eold                         : real;     deltE                        : real;	 ilow                         : Integer;	 ihi                          : Integer;	 temp                         : Integer;	 maxloop                      : Integer;	 incre                        : Integer;     DH_Xdata                     : WindowArrayHdl;	 DH_Ydata                     : WindowArrayHdl;	 DH_Weight                    : WindowArrayHdl;	 solution                     : ARRAY [1..Max_Num_Terms] OF real;{LinFitExtArray;}   { [1..Max_Num_Terms] of double_t}	 	 conv_lim                     : Integer;	 str,str1,str2,str4,str5	  : str255;	     PROCEDURE DH_Accept (s1,s2,s3,s4:str255)  ;      VAR        mylog                        : DialogPtr;        item                         : integer;              PROCEDURE OutlineButton(theDialog: DialogPtr; itemNo, CornerRad: integer);{ Draws a border around a button. 16 is the normal cornerRad for small buttons }        VAR          itemType                     : integer;          itemBox                      : Rect;          itemHdl                      : Handle;          tempPort                     : grafPtr;        BEGIN          GetPort(tempPort);          SetPort(theDialog);          GetDialogItem(theDialog, itemNo, itemType, itemHdl, itemBox);          PenSize(3, 3);          InsetRect(itemBox, - 4, - 4);          FrameRoundRect(itemBox, CornerRad, CornerRad);          PenSize(1, 1);          SetPort(tempPort);        END;      BEGIN        UseResFile(MCA_Home_Res_RefNum);        mylog := GetNewDialog(8979, NIL, POINTER( - 1));        ShowWindow(mylog);                            {Open a dialog box}        SelectWindow(mylog);                          {Lets see it}        SetPort(mylog);                               {Prepare to add conditional text}        OutlineButton(mylog, 2, 16);        REPEAT          MoveTo(25, 15);                              { Leave these inside the repeat loop, }          DrawString(S1);                             { to avoid buffer problem }          MoveTo(25, 30);          DrawString(S2);          MoveTo(25, 45);          DrawString(S3);          MoveTo(25, 60);		  DrawString(S4);          ModalDialog(NewModalFilterProc(@DefaultFilter), item);        UNTIL (item = 1) or (item = 2);		if item = 2 then Plt_spec[10]^^.Expt_Info.kV := Enew/1000;        DisposeDialog(mylog);      END;          PROCEDURE DHfit; { fits a polynomial of 2nd order to data. Data is weighted in a very		                     untypical way in vicinity of short wave cutoff limit. }                       VAR			  order                        : integer;     			  {Num_Terms                    : integer;}     			  index                        : integer;    			  index1                       : integer;                          			  Energy, R_indx               : real;            BEGIN                                     { wtfit }              FOR index := 1 TO Max_Num_Terms DO solution[index] := 0.0; {Max_Num_Terms=20}              index1 := 0;                            FOR index := 1 TO Max_Fitting_Chans DO                BEGIN                                 {for index}                  DH_Ydata^^[index] := 0;                   DH_Weight^^[index] := 0;                  DH_Xdata^^[index] := 0;                END;                                  {for index}            {IF QC_running := false then}    			              For index := 1 to Maximum_Channels do Plt_Spec[9]^^.S[index] := 0.0;            			  {¥¥¥if ilow or ihi becomes negative, we must start over with a different start voltage¥¥¥}			                FOR index := ilow TO ihi DO                BEGIN                                 {for index}				 SpinCursor;                  index1 := index1 + 1;				  DH_Xdata^^[index1] := temp*Plt_spec[10]^^.Expt_Info.dE;                  DH_Ydata^^[index1] := Plt_Spec[10]^^.S[index];				  xxx^[index1] := DH_Xdata^^[index1];				  yyy^[index1] := DH_Ydata^^[index1]*DH_Xdata^^[index1];                                     temp := temp +1;                 END;                                  {for index}             order :=  2; { order is 1+degree of polynomial } 					  { Num_Terms := order;}					   					        medfit(xxx^,yyy^,ax,b,abdev {, nxdata});              solution[1] := ax;			  solution[2] := b;			  solution[3] := 0;     Enew := -ax/b;     deltE := ABS(abdev/b/10.0);				              Energy := ilow*Plt_spec[10]^^.Expt_Info.dE;			                FOR index := 1 TO nxdata DO                BEGIN                                 {for index}				 SpinCursor;                  FitS^^.FittedBkg[index] := solution[1];                  FOR index1 := 2 TO order {Num_Terms} DO				  	R_indx := index1 - 1;                    FitS^^.FittedBkg[index] := FitS^^.FittedBkg[index] +					solution[index1] * {fast_power}pow(Energy,R_indx);					Plt_Spec[9]^^.S[ilow+index] := FitS^^.FittedBkg[index]/Energy + b;						   				  if Plt_Spec[9]^^.S[ilow+index] > 0.0 then                  Energy := Energy + Plt_spec[10]^^.Expt_Info.dE				  else				   begin				   Enew := Energy;				   exit(DHfit);				   end;				                   END;                                  {for index}            END;                                      { procedure DHfit }BEGIN { Procedure }                                   { Assign the storage space }  DH_Xdata := WindowArrayHdl(NewHandle(sizeof(WindowArray)));  if MemError = memFullErr then Out_of_Memory_Warning;  DH_Ydata := WindowArrayHdl(NewHandle(sizeof(WindowArray)));  if MemError = memFullErr then Out_of_Memory_Warning;  DH_Weight := WindowArrayHdl(NewHandle(sizeof(WindowArray)));  if MemError = memFullErr then Out_of_Memory_Warning;  Spectrum_Full[10] := True;  CheckItem(FullMenu, A^.C_Full[10], Spectrum_Full[10]);  if (Plt_spec[10]^^.S[50] = 0) AND     (Plt_spec[10]^^.S[100] = 0) AND	 (Plt_spec[10]^^.S[200] = 0) then   begin	 BeepBeep;	 putmessage('There is no Spectrum in "Work" ','','','');	 exit(D_H_Limit);    end;  {IF QC_running := false then begin}	  Spectrum_Full[9] := True;	  CheckItem(FullMenu, A^.C_Full[9], Spectrum_Full[9]);  {end;}    Enew := Energy_Estimate;                            { from the D-H dialog }   Eold := Enew*1000;                                  { Change to eV and store value }  Enew := Eold;                                       { Make Enew eV also } (* if (Enew/Plt_spec[10]^^.Expt_Info.dE > Plt_spec[10]^^.Expt_Info.number_of_channels) then    begin	  BeepBeep;	  PutMessage(' You must assign more channels to the display.',	  'There are not enough channels to the right of the Beam Voltage for the math to be happy.','','');	end; *) (*!!!!!! spectrum_size is a display variable which has nothing to do with the math. It should be set  in this code so the fitting can be displayed. !!!!!*)  ilow := rinttol(Enew/Plt_spec[10]^^.Expt_Info.dE-{number``} 300 ); { Lower limit channel number }  ihi := rinttol(Enew/Plt_spec[10]^^.Expt_Info.dE + 150 );     { Upper limit channel number }    if (ihi > spectrum_size) then    ihi := spectrum_size;  temp := ilow;                                       { Assign lower limit to variable temp }  maxloop := 0;                                       { Initialize counters }  conv_lim := 1;10:   	                                   { Iteration loop start }  maxloop := maxloop + 1;                             { Increment loop counter }        case maxloop of		1:  incre := 50;		2:  incre := 10;		3:  incre := 7;		4:  incre := 5;		5:  incre := 3;		otherwise		    incre := 1	    end;   { end case }		if (maxloop > 10) then		conv_lim := 5;		if (maxloop > 20) then		conv_lim := 10;		if 		((maxloop > 50) or			 (ihi <= 0) OR 			 (ilow < 0) or			 (ilow >= ihi) or			 (ilow >= spectrum_size)) then                           { If loop reaches 10, increment incre }      begin		PutMessage(' Procedure failed to converge.','','','');		exit(D_H_Limit);    end;  { end if }     nxdata := iHi-iLow+1;                            { Number of data points in fit }     DHfit;                                           { Do the least squares fitting }     IF QC_running = false then     Update_Full;              ihi := rinttol(Enew/Plt_spec[10]^^.Expt_Info.dE+incre);    { Set new upper limit }	   if (ihi > spectrum_size) then         ihi := spectrum_size;		 	{if Energy_Estimate >= 10.0 then number := 300;	if (Energy_Estimate < 10.0) then number := 100;	if (Energy_Estimate <= 5.0) then number := 20;}       temp := rinttol(Enew/Plt_spec[10]^^.Expt_Info.dE- 300{`` number});     { Set new lower limit }	   ilow := temp;	 if ( maxloop < 8 ) then	  begin       Eold := Enew;                                  { Store current value of Enew }       goto 10;                                       { Repeat the loop }      end;     if ((Enew > (Eold+conv_lim)) or (Enew < (Eold-conv_lim))) then { Test for convergance }     begin       Eold := Enew;                                  { Store current value of Enew }       goto 10;                                       { Repeat the loop }     end;ChangeCursor(ArrowC);IF QC_running = false then begin 	realtostring(deltE,5,2,str5);                             { Write the results }	realtostring(Enew,5,1,str);	str := Concat('The energy of the beam is: ',str,' eV  ±  ',str5,' eV');	realtostring(solution[1],5,2,str1);	realtostring(solution[2],5,2,str2);	{realtostring(solution[3],6,-2,str3);}	{Str4 := Concat(' The equation is : Counts = ',str3,'*E**2 + ',str2,'*E + ',str1);} 	Str4 := Concat(' The equation is : Counts = ',str2,'*E + ',str1); 	DH_Accept(str,'',str4,'');endelsePlt_spec[10]^^.Expt_Info.kV := Enew/1000;H_UnLock_Dispose(Handle(DH_Xdata),'DH_Xdata in D_H_Limit in BG_Correct');              { Delete the storage space used }H_UnLock_Dispose(Handle(DH_Ydata),'DH_Ydata in D_H_Limit in BG_Correct');H_UnLock_Dispose(Handle(DH_Weight),'DH_Weight in D_H_Limit in BG_Correct');  END;	{ Procedure }End.