UNIT AcquirePlugIns;INTERFACEUSES	Memory,Types,QuickDraw,OSUtils,ToolUtils,StandardFile,Lists,Retrace,Printing,Packages,fenv,fp {SANE},		Files, Controls, Windows, Dialogs,Timer,SegLoad,Resources,Menus,Spectrum_Structures,Declarations;(**************************************************************************)CONST	{ Operation messages }	acquireAbout		= 0;		{Plugin should display about dialog								}	acquireOpen			= 1;		{DTSA's first call to the plugin								}	acquireChange		= 2;		{DTSA parameter's to the plugin have changed					}	acquireClose		= 3;		{DTSA's last call to the plugin									}	acquireSetup		= 4;		{Plugin should display setup dialog								}	acquireStart		= 5;		{Plugin should start acquisition								}	acquireStop 		= 6;		{Plugin should stop acquisition									}	acquireResume 		= 7;		{Plugin should resume/continue acquisition						}	acquireUpdate		= 8;		{Plugin should pass update requests (update/fit/save) to DTSA	}	acquireBadParameters=-1;	SpecIsEDX			= 1;	SpecIsEDS			= 1;	SpecIsWDS			= 2;	SpecIsEELS			= 3;		MaxPlugins			= 10;	AcquirePlugFileType	= 'DTam';	DTSAFileCreator		= 'DTSA';	PlugRezType			= 'DTpl';	PeakROI				= 1;	BackROI				= 2;	ScaleROI			= 3;	QuantROI			= 4;TYPE	RealArrayPtr		= ^RealArray;	RealArray			= ARRAY [1..1] of real;    iROI				= RECORD		ROIElem			: Integer;			{Element associtated with the ROI						}		ROIType			: Integer;			{The type of ROI (peak,background,scale,quant)			}        SChan			: Integer;			{Starting channel for the ROI							}        EChan			: Integer;			{Ending channel for the ROI								}        value			: Real;				{Integral value of the ROI								}	END;	ROIListPtr			=^ROIList;			{Defines an array of ROIs								}	ROIList				= RECORD		theROI			: ARRAY [1..1] of iROI;	END;	TimeMeterPtr		= ^TimeMeterRec;	TimeMeterRec		= RECORD		RTime			: Real;		LTime			: Real;		PDead			: Real;		ActiveAcqStr	: Str255;		TMGrafPtr		: GrafPtr; {offscreen bitmap pointer}	END;											{ ¥ This is used by AcquirePlugins for Plugin resource information}	AcquirePlugRezHdl		= ^AcquirePlugRezPtr;	{ Plugin resource information, compatablity check during load	}	AcquirePlugRezPtr		= ^AcquirePlugRez;	AcquirePlugRez			= PACKED RECORD		version			: Integer;			{ The version number of the interface supported.		}		subVersion		: Integer;			{ The sub-version number.						  		}		priority		: Integer;			{ The plug-in's priority.                       		}		Spare1			: Integer;		SpecificHost	: OSType;			{ PlugIn functions only with Host of OSType Type		}		CanAcqSpectra	: Boolean;			{ Can Acquire X-ray Spectra								}		CanAcqXRImage	: Boolean;			{ Can Acquire X-ray images								}		CanAcqImage		: Boolean;			{ Can Acquire SEM/STEM images							}		SpareBoolean	: Boolean;		reserved		: LongInt;	END;															{ ¥ This is used by all DTSA plugins to pass information}	AcqPlugHdl		= ^AcqPlugPtr;	AcqPlugPtr		= ^AcqPlug;	AcqPlug		= RECORD		serialNumber	: LongInt;			{ Host serial number (future copy protection for plugin	}		hostVersion		: Integer;			{ Host version number									}		hostsubVersion	: Integer;			{ Host subversion number								}		hostModes		: LongInt;			{ Host modes that are supported (spectra,images, etc.).	}		hostMaxChan		: LongInt;			{ Maximum of channels that can be passed back to host 	}		PlugInName		: Str255;			{ Menu Name for PlugIn, Fill in for 'open' or leave ''	}				AcqStatus		: Boolean;		NeedAStop		: Boolean;		NeedAUpdate		: Boolean;			{ Update the returned spectra							}		NeedAFit		: Boolean;			{ Fit the returned spectra								}		NeedASave		: Boolean;			{ Save the returned spectra								}		SpectType		: Integer;			{ Type (EDS, WDS, EELS)	of returned spectra				}		FirstChan		: Integer;		LastChan		: Integer;		Min_Cnts		: Real;		Max_Cnts		: Real;		SpectData		: RealArrayPtr;		{ Pointer to Spectral real Data array					}		eV_Intercept	: Real;				{ Calibrated y intercept in eV	(zero for uncalibrated)	}		eV_Slope		: Real;				{ Calibrated y slope in eV		(one for uncalibrated )	}		eV_Channel		: Real;				{ Number of eV per channel in spectra					}				ActRealTime		: Real;				{ The acquisition time (clock on the wall) in seconds	}		ReqLiveTime     : Real;				{ The requested acquisition livetime in seconds			}		ActLiveTime     : Real;	 			{ The actual acquisition livetime in seconds			}		PerDeadTime		: Real;		Begin_Time		: Longint;			{ Acquisition start time in Tickcount format			}		End_Time		: Longint;			{ Acquisition end time in Tickcount format				}				Slow_Counts		: Longint;  		{ Total counts acquired into spectra					}		Med_Counts     	: Longint;  		{ If UTW. Approx. input counts below 1 keV 				} 		Fast_Counts     : Longint;  		{ Total counts as seen by the detector					} 		Probed_Area		: Real;				{ cm. sq. to calculate current density 					}		X_Position		: Real;				{ dimensionless 										}		Y_Position		: Real;				{ dimensionless 										}		Begin_Faraday	: Real;				{ nA 													}		End_Faraday		: Real;				{ nA 													}		FirstValue		: Real;    			{ eg if WDS spectrum the begin lamda					}		EndValue		: Real;		ROIsActive		: Boolean;			{ True is ROI list is active and good					}		ROIcnt			: Integer;			{ Number of ROIs in ROI list							}		ROIs			: ROIListPtr;		{ Ptr to ROI array of size ROIcnt						}		tempPtr1		: Ptr;		tempPtr2		: Ptr;				reserved		: PACKED ARRAY [0..255] OF CHAR;		{ Set to zero for future expansion	}	END;											{ ¥ This is used by AcquirePlugins to remember each plugin	}	AcquirePlugHdl			= ^AcquirePlugPtr;	AcquirePlugPtr			= ^AcquirePlug;	AcquirePlug			= RECORD		fRefNum			: Integer;			{ fRefnum of plugin file								}		vRefNum			: Integer;			{ vRefnum of plugin file								}		DirID			: LongInt;			{ directory ID of plugin file							}		PlugID			: Integer;					PlugName		: Str255;			{ Name of the DTSA plugin name							}		ReqDestBuff		: Integer;		MenuStart		: Boolean;		MenuStop		: Boolean;		MenuResume		: Boolean;		FixupMenus		: Boolean;		theProc			: ProcPtr;			{ Plugin code location (filled when plugin is loaded)	}		AcqPtr			: AcqPlugPtr;		{ Ptr to acquire plugin's record 						}		PrivData		: Ptr;				{ Used for plug-in private data (global), NIL 1st time	}	END;	FUNCTION	AssignAcqBuffers:Boolean;	PROCEDURE	OpenAcquirePlugIns;	FUNCTION	CallAcquirePlugIns(message:Integer;whichPlug:Integer):Boolean;VAR		gAcquirePlugIns			: ARRAY [1..MaxPlugins] of AcquirePlugPtr;	gDTSACurrentPlugIn		: Integer;IMPLEMENTATION{$ifc GENERATINGPOWERPC}PROCEDURE	CallAcquirePlug(message:Integer; theAcqPtr:AcqPlugPtr;VAR thePrivData:Ptr;VAR theResult:OSerr; UniversalProcPtr:Ptr);EXTERNAL;			{Otherwise use C glue routine ("DTSAGlue.c") that calls CallUniversalProc. We can't			 call it directly because CallUniversalProc uses a variable number of arguments.}{$elsec}PROCEDURE	CallAcquirePlug(message:Integer; theAcqPtr:AcqPlugPtr;VAR thePrivData:Ptr;VAR theResult:OSerr; UniversalProcPtr:Ptr);	INLINE	$205F,		{MOVE.L	(A7)+,A0	;pop ptr off stack					}			$4E90;		{JSR	(A0)		;call proc leaving params on stack	}{$endc}FUNCTION	GetPopUpMenuHandle(thisControl:ControlHandle):MenuHandle;VAR	theMenuData		: PopupPrivateDataHandle;BEGIN	theMenuData := PopupPrivateDataHandle(thisControl^^.contrlData);	GetPopUpMenuHandle:=theMenuData^^.mHandle;END;(**************************************************************************)FUNCTION	AssignAcqBuffers:Boolean;CONST	AssignID 		=   502; 		{DLOG}	BUT1_OK			=	1;	BUT2_Cancel		=	2;	mySTXT			=	3;	myPopUp			=	4;	Buf1			=	5;	Buf2			=	6;	Buf3			=	7;	Buf4			=	8;	Buf5			=	9;	Buf6			=	10;	Buf7			=	11;	Buf8			=	12;	BufWork			=	13;	BufResult		=	14;	VAR	Done				: Boolean;	iType				: INTEGER;	iHit				: INTEGER;	iHandle				: Handle;	iBox				: Rect;	theDialog			: DialogPtr;	tMenu				: MenuHandle;	CurPlug				: Integer;	Idx					: Integer;	ReturnVal			: Boolean;	thePlug				: AcquirePlugPtr;	NewValues			: ARRAY [1..MaxPlugins] of Integer;BEGIN	Done:=false;	ReturnVal:=false;	theDialog := GetNewDialog(AssignID, NIL, WindowPtr( -1));	SetPort(WindowPtr(theDialog));	GetDialogItem(theDialog,BUT1_OK,iType,iHandle,iBox);	PenSize(3,3);InSetRect(iBox,-4,-4);FrameRoundRect(iBox,16,16);	CurPlug:=gDTSACurrentPlugIn;	GetDialogItem(theDialog,myPopUp,iType,iHandle,iBox);	tMenu := GetPopUpMenuHandle(ControlHandle(iHandle));	FOR Idx:=1 TO MaxPlugins DO BEGIN		thePlug := gAcquirePlugIns[Idx];		IF (thePlug<>NIL) THEN BEGIN			NewValues[Idx] := thePlug^.ReqDestBuff;			AppendMenu(tMenu,thePlug^.PlugName);			CalcMenuSize(tMenu);			SetControlMaximum(ControlHandle(iHandle),CountMItems(tMenu));		END;	END;	FOR Idx:=1 TO 10 DO BEGIN		GetDialogItem(theDialog,4+Idx,iType,iHandle,iBox);		SetControlValue(ControlHandle(iHandle),0);	END;	GetDialogItem(theDialog,myPopUp,iType,iHandle,iBox);	SetControlValue(ControlHandle(iHandle),CurPlug);	IF ((CurPlug>=1) AND (CurPlug<=10))THEN BEGIN		GetDialogItem(theDialog,4+NewValues[CurPlug],iType,iHandle,iBox);		SetControlValue(ControlHandle(iHandle),1);	END;	ShowWindow(WindowPtr(theDialog));	SelectWindow(WindowPtr(theDialog));	REPEAT		ModalDialog(NIL,iHit);		GetDialogItem(theDialog,iHit,iType,iHandle,iBox);		Case iHit of			BUT1_OK:	BEGIN					FOR Idx:=1 TO MaxPlugins DO BEGIN						thePlug:=gAcquirePlugIns[Idx];						IF (thePlug<>NIL) THEN BEGIN							ReturnVal:=TRUE;							thePlug^.ReqDestBuff:=NewValues[Idx];						END;					END;					Done:=true;				END;			BUT2_Cancel:	BEGIN					Done:=true;				END;			myPopUp:		BEGIN					GetDialogItem(theDialog,4+NewValues[CurPlug],iType,iHandle,iBox);					SetControlValue(ControlHandle(iHandle),0);					GetDialogItem(theDialog,myPopUp,iType,iHandle,iBox);					tMenu := GetPopUpMenuHandle(ControlHandle(iHandle));					CurPlug := GetControlValue(ControlHandle(iHandle));					IF ((CurPlug>=1) AND (CurPlug<=10))THEN BEGIN						GetDialogItem(theDialog,4+NewValues[CurPlug],iType,iHandle,iBox);						SetControlValue(ControlHandle(iHandle),1);					END ELSE BEGIN						sysbeep(10);						CurPlug:=1					END;				END;			OTHERWISE				BEGIN					GetDialogItem(theDialog,4+NewValues[CurPlug],iType,iHandle,iBox);					SetControlValue(ControlHandle(iHandle),0);					NewValues[CurPlug] := iHit-4;					GetDialogItem(theDialog,4+NewValues[CurPlug],iType,iHandle,iBox);					SetControlValue(ControlHandle(iHandle),1);				END;		END;		UNTIL (Done = true);	DisposeDialog(theDialog);	AssignAcqBuffers:=ReturnVal;END;(**************************************************************************)FUNCTION	MyHGetVol(volName: StringPtr; VAR vRefNum: INTEGER; VAR dirID: LONGINT): OSErr;	{BUG NOTE: The high level call, HGetVol, should do this dirty work for us.			}	{Unfortunately it is returning the ioVRefNum which Inside Mac warns may be			}	{a working directory.  The field ioWDVRefNum will always be the real vRefNum.		}(*CONST	kFSAsynch 			= TRUE;	*)						{asynchronous File Manager call}VAR	myWDBRec			: WDPBRec;BEGIN	myWDBRec.ioCompletion:= NIL;	myWDBRec.ioNamePtr:= NIL;	MyHGetVol:= PBHGetVolAsync(@myWDBRec);	vRefNum:= myWDBRec.ioWDVRefNum;						{the real vRefNum}	dirID:= myWDBRec.ioWDDirID;END;(**************************************************************************)PROCEDURE	OpenAcquirePlugIns;	{Find and load external Plugs, to do this you need to find		}	{ the Plugs directory in the directory of the application,		}	{ then search the Plugs directory for Plug type files, then		}	{ search each plug for the correct Plug info resources.			}	{ If good, then load each all Plug resources for each Plug-in	}(*CONST	kFSAsynch 			= TRUE;*)						{asynchronous File Manager call}TYPE	ProcHandle			=^ProcPtr;VAR	err					: OSErr;	tfolderName			: Str255;	tfileName			: Str31;	tID					: INTEGER;	tType				: ResType;	tName				: Str255;	PlugIndx			: Integer;						{ Index into array of DTSA compatable plug-ins				}	RezIndx				: Integer;	BadPlugNoFind		: Boolean;	tCInfo				: CInfoPBRec;	tDirID				: LongInt;	tPlug				: AcquirePlugPtr;	tPlugRez			: AcquirePlugRezHdl;	tProcHandle			: ProcHandle;		PlugRezFile			: Integer;	AppRezFile			: Integer;	AppVRefNum			: Integer;	AppDirID			: LongInt;BEGIN	FOR PlugIndx:=1 TO MaxPlugins DO gAcquirePlugIns[PlugIndx]:=NIL;	PlugIndx:=1;													{Start filling from the start of the Plug array	}	AppRezFile:=CurResFile;											{Remember the applications resource file number	}	err:= MyHGetVol(NIL, AppVRefNum, AppDirID);					{¥1¥ Get the volume and directory of the application}	tDirID:=0;														{ and walk the directory down to the plugins	}					WITH tCInfo DO BEGIN											{Setup the catalog info record					}			ioCompletion:= NIL;											{no completion}			ioNamePtr:= NIL;											{no name}					ioFDirIndex:= -1;											{-1 means use ioDrDirID}		ioVRefNum:= AppVRefNum; 									{use this volume}		ioDrDirID:= AppDirID;										{in the application directory}		err:= PBGetCatInfoSync(@tCInfo);				{¥2¥ Get the number of files in this directory}		IF err=NoErr THEN BEGIN									ioFDirIndex:=ioDRNmFls;									{This is number of files in application dir		}			REPEAT													{Now find the Plugin folder						}				tfolderName:= '';									{initialize string}				ioCompletion:= NIL;									{no completion}				ioNamePtr:= @tfolderName;							{Ptr to string}				ioVRefNum:= AppVRefNum; 							{this is the volume}				ioDrDirID:= AppDirID;								{this is the directory}				err:= PBGetCatInfoSync(@tCInfo);			{Checking through all files}				ioFDirIndex:=ioFDirIndex-1;							{until we find the 'Plug-ins' directory (folder)}			UNTIL ( (ioFDirIndex<=0) or ( (BitTst(@ioFLAttrib,3)) and (ioNamePtr^='Plug-ins') ) );			IF ioFDirIndex>0 THEN tDirID:=tCInfo.ioDirID;			{If ioFDirIndex>0, we got a name/folder match	}		END;		IF tDirID<>0 THEN BEGIN									{¥3¥ IF we got a good Plugs folder, get num of plugins}					ioCompletion:= NIL;										{no completion}					ioNamePtr:= NIL;										{no name}				ioFDirIndex:= -1;										{-1 means use ioDrDirID}			ioVRefNum:= AppVRefNum; 								{this is the volume}			ioDrDirID:= tDirID;										{this is the directory}			err:= PBGetCatInfoSync(@tCInfo);				{Get the number of plugins in this directory	}			IF err=NoErr THEN BEGIN												ioFDirIndex:=ioDRNmFls;								{This is the number of files in this dir		}							REPEAT					tfileName:= '';									{initialize string}					ioCompletion:=NIL;								{no completion}						ioNamePtr:=@tfileName;							{Ptr to string}						ioVRefNum:=AppVRefNum; 							{this is the volume}					ioDrDirID:=tDirID;								{this is the directory}					err:= PBGetCatInfoSync(@tCInfo);		{Search the Plugs directory}					ioFDirIndex:=ioFDirIndex-1;						{until we find a file with correct type/creator	}					IF ( (ioFlFndrInfo.fdType=AcquirePlugFileType) and (ioFlFndrInfo.fdCreator=DTSAFileCreator) ) THEN BEGIN						PlugRezFile:=HOpenResFile(AppVRefNum,tDirID,tfileName,fsCurPerm);																{¥4¥ Setup for multiple plug resources in plugin	}						IF (PlugRezFile<>-1) THEN BEGIN							RezIndx:=1;							tPlugRez:=NIL;							REPEAT									{If good open,Index through all plug resources	}								BadPlugNoFind:=false;				{Setup for getting a good plug resources		}								tPlug:=AcquirePlugPtr(NewPtrClear(Sizeof(AcquirePlug)));								tPlug^.vRefNum	:=AppVRefNum;		{Fill in Plug file data record					}								tPlug^.fRefNum	:=PlugRezFile;								tPlug^.DirID	:=tDirID;								tPlug^.PlugID	:=0;				{fill in later}								tPlug^.PlugName	:=tfileName;								tPlug^.MenuStart:=TRUE;								tPlug^.MenuStop	:=FALSE;								tPlug^.MenuResume:=FALSE;								tPlug^.FixupMenus:=FALSE;								tPlug^.ReqDestBuff:=10;				{ Point to the "Work" buffer	}								tPlug^.theProc	:=NIL;				{fill in later}								tPlug^.AcqPtr	:=NIL;				{fill in later}								tPlug^.PrivData	:=NIL;																{¥5¥ Get plugin's resource info record				}								UseResFile(tPlug^.fRefNum);			{Point to the Plug's res file					}								tPlugRez:=AcquirePlugRezHdl(Get1IndResource(PlugRezType,RezIndx));								RezIndx:=RezIndx+1;								IF (tPlugRez<>NIL) THEN BEGIN									IF (tPlugRez^^.version<>2) THEN BadPlugNoFind:=TRUE;									IF (not tPlugRez^^.CanAcqSpectra) THEN BadPlugNoFind:=TRUE;									IF (tPlugRez^^.SpecificHost<>DTSAFileCreator) THEN BadPlugNoFind:=TRUE;																								{¥6¥ If still good, fill in some more plug record}									IF (not BadPlugNoFind) THEN BEGIN										GetResInfo(Handle(tPlugRez),tID,tType,tName);										tPlug^.PlugID:=tID;										{tPlug^.PlugName:=tName;}									END;									ReleaseResource(Handle(tPlugRez));	{ Done with plug resource so release it		}									tPlugRez:=NIL;								END ELSE BEGIN									BadPlugNoFind:=TRUE;								END;																{¥7¥ Now load, detach and lock the code	segment		}																{ and filling last of plug record and the acq record}								IF (not BadPlugNoFind) THEN BEGIN										tProcHandle:=ProcHandle(GetResource('proc',tPlug^.PlugID));									IF (tProcHandle<>NIL) THEN BEGIN										DetachResource(Handle(tProcHandle));										MoveHHI(Handle(tProcHandle));										HLock(Handle(tProcHandle));										tPlug^.theProc:=tProcHandle^;										tPlug^.AcqPtr:=AcqPlugPtr(NewPtrClear(Sizeof(AcqPlug)));										WITH AcqPlugPtr(tPlug^.AcqPtr)^ DO BEGIN											serialNumber:=4*314159;		{ let's see in anyone notices				}											hostVersion	:=2;			{ Version 2.0 of DTSA						}											hostsubVersion:=0;			{ Who knows what subversion					}											hostModes	:=1;			{ Only Spectra mode for now					}											hostMaxChan	:=8192;											tempPtr1	:= Ptr(ROI^);											tempPtr2	:= Ptr(Lab^);																		{acquireOpen takes care of rest of record	}										END;										gAcquirePlugIns[PlugIndx]:=tPlug;	{Must do this BEFORE CallAcquirePlugIns		}																{¥8¥ The final check, call the plugin code to open	}										IF (CallAcquirePlugIns(acquireOpen,PlugIndx)) THEN BEGIN																		{Add plugin to the Acquire plugins menu		}											UseResFile(AppRezFile);	 	{Point back to the AppRezFile for fail		}											IF (tPlug^.AcqPtr^.PlugInName<>'') THEN BEGIN	{Plug might want name change}												tPlug^.PlugName:=tPlug^.AcqPtr^.PlugInName;											END;											AppendMenu(GetMenu(128),tPlug^.PlugName);	{One for the acquire setup menu	}											AppendMenu(GetMenu(129),tPlug^.PlugName);	{One for the acquire select menu}											PlugIndx:=PlugIndx+1;	{Plugin had good open, go to next array index	}										END ELSE BEGIN				{Open failed, scratch this one					}											UseResFile(AppRezFile);	 	{Point back to the AppRezFile for fail		}											gAcquirePlugIns[PlugIndx]:=NIL;											DisposePtr(Ptr(tPlug^.AcqPtr));											DisposePtr(Ptr(tPlug));										END;									END ELSE BEGIN										UseResFile(AppRezFile);	 		{Point back to the AppRezFile for fail		}										DisposePtr(Ptr(tPlug));									END;								END ELSE BEGIN																						UseResFile(AppRezFile);	 			{Point back to the AppRezFile for fail		}									DisposePtr(Ptr(tPlug));								END;								IF (PlugIndx>MaxPlugins) THEN leave;	{if we run out of slots, don't process anymore	}							UNTIL (BadPlugNoFind);						END;					END;					IF (PlugIndx>MaxPlugins) THEN leave;			{if we run out of slots, don't process anymore	}				UNTIL (ioFDirIndex<=0);							{¥9¥ Done											}			END;		END;	END;	IF (gAcquirePlugIns[1]<>NIL) THEN BEGIN		gDTSACurrentPlugIn:=1;		CheckItem(GetMenu(129),gDTSACurrentPlugIn,TRUE);		  	 	DisableItem(GetMenu(152),5);						{ Stop Acquisition						}		  	 	DisableItem(GetMenu(152),6);						{ Resume Acquisition					}		  	 	DisableItem(GetMenu(152),9);						{ Stop All Acquisition Hardware			}		  	 	DisableItem(GetMenu(152),10);						{ Resume All Acquisition Hardware		}		  	END ELSE BEGIN		gDTSACurrentPlugIn:=0;		DisableItem(GetMenu(152),0);	END;END;PROCEDURE	UpdateDTSABuffers(message:Integer;DTSABuff:WorkPtr;Acq:AcqPlugPtr);BEGIN	WITH DTSABuff^,Acq^ DO BEGIN		SpectData	:=@S;		ROIsActive	:=FALSE;		ROIcnt		:=0;		ROIs		:=NIL;		CASE message OF			acquireSetup:BEGIN				(*FirstChan									:=1;				SpectrumStuff.Acq_Info.FirstChannel			:=FirstChan;				SpectrumStuff.Acq_Info.LastChannel			:=LastChan;				Expt_Info.Number_of_Channels				:=(LastChan-FirstChan)+1;*)				Expt_Info.dE								:=eV_Channel;				SpectrumStuff.Acq_Info.RequestedLiveTime	:=rinttol{Num2LongInt}(ReqLiveTime);			END;			acquireOpen,acquireChange:BEGIN				SpectType									:=SpecIsEDX;	{ Default to EDS/EDX			}				(*FirstChan									:=1;				LastChan									:=(FirstChan+Expt_Info.Number_of_Channels)-1;*)				Min_Cnts									:=SpectrumStuff.Spectrum_Info.Maximum_Counts;				Max_Cnts									:=SpectrumStuff.Spectrum_Info.Minimum_Counts;				eV_Intercept								:=Expt_Info.Energy_Intercept;				eV_Slope									:=Expt_Info.Energy_Slope;				eV_Channel									:=Expt_Info.dE;				IF (message=acquireOpen) THEN BEGIN					SpectrumStuff.Acq_Info.Acquiring:=FALSE;					Slow_Counts:=0;					Med_Counts:=0;					Fast_Counts:=0;					ActRealTime:=0;					ActLiveTime:=0;				END;			END;			acquireClose,acquireStart,acquireStop,acquireResume,acquireUpdate:BEGIN				IF (SpectrumStuff.Acq_Info.Acquiring) THEN BEGIN					SpectrumStuff.Spectrum_Info.Maximum_Counts	:=Max_Cnts;					SpectrumStuff.Spectrum_Info.Minimum_Counts	:=Min_Cnts;					SpectrumStuff.Acq_Info.Probed_Area			:=Probed_Area;					SpectrumStuff.Acq_Info.X_Position			:=X_Position;					SpectrumStuff.Acq_Info.Y_Position			:=Y_Position;					(*SpectrumStuff.Acq_Info.Begin_Faraday		:=Begin_Faraday;					SpectrumStuff.Acq_Info.End_Faraday			:=End_Faraday;*)					SpectrumStuff.Acq_Info.Begin_Time			:=Begin_Time;					SpectrumStuff.Acq_Info.FirstValue			:=FirstValue;					SpectrumStuff.Acq_Info.EndValue				:=EndValue;					SpectrumStuff.Acq_Info.Real_Time			:=ActRealTime;					SpectrumStuff.Acq_Info.Live_Time			:=ActLiveTime;					SpectrumStuff.Acq_Info.Slow_Channel_Counts	:=Slow_Counts;					SpectrumStuff.Acq_Info.Medium_Channel_Counts:=Med_Counts;					SpectrumStuff.Acq_Info.Fast_Channel_Counts	:=Fast_Counts;					SpectrumStuff.Acq_Info.RequestedLiveTime	:=rinttol{Num2LongInt}(ReqLiveTime);					SpectrumStuff.Acq_Info.ActualLiveTime		:=rinttol{Num2LongInt}(ActLiveTime);				END;				IF ((message=acquireStop) OR (message=acquireClose)) THEN BEGIN					SpectrumStuff.Acq_Info.Acquiring:=FALSE;				END ELSE IF ((message=acquireStart) OR (message=acquireResume)) THEN BEGIN					SpectrumStuff.Acq_Info.Acquiring:=TRUE;					SpectrumStuff.Spectrum_Info.Theoretically_generated:=False;				END;			END;		END;	END;END;(**************************************************************************)FUNCTION	CallAcquirePlugIns(message:Integer;whichPlug:Integer):Boolean;VAR	thePlug				: AcquirePlugPtr;	theResult			: OSErr;	theCurResFile		: Integer;	Idx					: Integer;	SIdx				: Integer;	EIdx				: Integer;	theReturnValue		: Boolean;	TimeMeter			: TimeMeterPtr;	BEGIN	theCurResFile:=CurResFile;									{Save the current resource file			}	theReturnValue:=FALSE;	theResult:=NoErr;	IF (whichplug=0) THEN EXIT(CallAcquirePlugIns);	IF (whichplug=-1) THEN BEGIN		SIdx:=1;		EIdx:=10;	END ELSE BEGIN		SIdx:=whichplug;		EIdx:=whichplug;	END;	CASE message OF	acquireAbout:	 BEGIN		thePlug:=gAcquirePlugIns[whichplug];		IF (thePlug<>NIL) THEN BEGIN			WITH thePlug^ DO BEGIN				UseResFile(fRefNum);							{Change to the Plugs's resource file }				CallAcquirePlug(message,AcqPtr, PrivData, theResult, theProc);				UseResFile(theCurResFile);						{Restore the current resource file		}				theReturnValue:=(theResult=NoErr);			END;		END;	 END;	acquireSetup:	 BEGIN		thePlug:=gAcquirePlugIns[whichplug];		IF (thePlug<>NIL) THEN BEGIN			WITH thePlug^ DO BEGIN				AcqPtr^.NeedAUpdate	:=FALSE;				AcqPtr^.NeedAFit	:=FALSE;				AcqPtr^.NeedASave	:=FALSE;				UseResFile(fRefNum);							{Change to the Plugs's resource file }				CallAcquirePlug(message,AcqPtr,PrivData,theResult,theProc);				UseResFile(theCurResFile);						{Restore the current resource file		}				IF (theResult=NoErr) THEN BEGIN					UpdateDTSABuffers(message,Plt_Spec[ReqDestBuff]^,AcqPtr);					theReturnValue:=TRUE;				END;			END;		END;	 END;	acquireOpen:	 BEGIN		thePlug:=gAcquirePlugIns[whichplug];		IF (thePlug<>NIL) THEN BEGIN			WITH thePlug^ DO BEGIN				Spectrum_Full[ReqDestBuff]:=TRUE;					{Make the buffer visable				}				CheckItem(FullMenu, A^.C_Full[ReqDestBuff], Spectrum_Full[ReqDestBuff]); 				UpdateDTSABuffers(message,Plt_Spec[ReqDestBuff]^,AcqPtr);				AcqPtr^.AcqStatus	:=FALSE;				AcqPtr^.NeedAStop	:=FALSE;				AcqPtr^.NeedAUpdate	:=TRUE;				AcqPtr^.NeedAFit	:=FALSE;				AcqPtr^.NeedASave	:=FALSE;				UseResFile(fRefNum);							{Change to the Plugs's resource file }				CallAcquirePlug(message,AcqPtr,PrivData,theResult,theProc);				UseResFile(theCurResFile);						{Restore the current resource file		}				theReturnValue:=(theResult=NoErr);			END;		END;	 END;	acquireChange:	 BEGIN		FOR Idx:=SIdx TO EIdx DO BEGIN								{Check all valid plugins			}			thePlug:=gAcquirePlugIns[Idx];			IF (thePlug<>NIL) THEN BEGIN				WITH thePlug^ DO BEGIN					Spectrum_Full[ReqDestBuff]:=TRUE;					{Make the buffer visable				}					CheckItem(FullMenu, A^.C_Full[ReqDestBuff], Spectrum_Full[ReqDestBuff]);					UpdateDTSABuffers(message,Plt_Spec[ReqDestBuff]^,AcqPtr);					AcqPtr^.NeedAUpdate	:=FALSE;					AcqPtr^.NeedAFit	:=FALSE;					AcqPtr^.NeedASave	:=FALSE;					UseResFile(fRefNum);							{Change to the Plugs's resource file }					CallAcquirePlug(message,AcqPtr,PrivData,theResult,theProc);					UseResFile(theCurResFile);						{Restore the current resource file		}					theReturnValue:=(theResult=NoErr);				END;			END;		END;	 END;	acquireClose,acquireStart,acquireStop,acquireResume,acquireUpdate:	 BEGIN		FOR Idx:=SIdx TO EIdx DO BEGIN								{Check all valid plugins			}			thePlug:=gAcquirePlugIns[Idx];			IF (thePlug<>NIL) THEN BEGIN				WITH thePlug^ DO BEGIN					AcqPtr^.NeedAUpdate	:=FALSE;					AcqPtr^.NeedAFit	:=FALSE;					AcqPtr^.NeedASave	:=FALSE;					UseResFile(fRefNum);							{Change to the Plugs's resource file	}					CallAcquirePlug(message,AcqPtr,PrivData,theResult,theProc);					UseResFile(theCurResFile);						{Restore the current resource file		}					IF (AcqPtr^.NeedAUpDate) THEN BEGIN						IF (ReqDestBuff=10) THEN BEGIN				{Special Flags associated with 			}							SpecWork_has_been_Changed:=True;		{ buffer 10 'Work'						}							ItsBeenAcquired:=True;						END;						UpdateDTSABuffers(message,Plt_Spec[ReqDestBuff]^,AcqPtr);						theReturnValue:=TRUE;					END;					IF (gDTSACurrentPlugIn=Idx) THEN BEGIN			{Update Counters and Meters				}						TimeMeter:=TimeMeterPtr(SiLi_AcqCntlHdl^^.contrlData);						IF (TimeMeter^.RTime<>AcqPtr^.ActRealTime) THEN BEGIN							With TimeMeter^ DO BEGIN								RTime:=AcqPtr^.ActRealTime;								LTime:=AcqPtr^.ActLiveTime;								PDead:=AcqPtr^.PerDeadTime;								ActiveAcqStr:=PlugName;							END;							SetControlValue(SiLi_AcqCntlHdl,-1);						END;						IF (GetControlReference(SiLi_InCntHdl)<>AcqPtr^.Fast_Counts) THEN BEGIN							SetControlReference(SiLi_InCntHdl,AcqPtr^.Fast_Counts);							SetControlValue(SiLi_InCntHdl,-1);						END;						IF (GetControlReference(SiLi_OutCntHdl)<>AcqPtr^.SLow_Counts) THEN BEGIN							SetControlReference(SiLi_OutCntHdl,AcqPtr^.SLow_Counts);							SetControlValue(SiLi_OutCntHdl,-1);						END;						IF (AcqPtr^.NeedAStop) THEN BEGIN							With TimeMeter^ DO BEGIN								RTime:=AcqPtr^.ActRealTime;								LTime:=AcqPtr^.ActLiveTime;								PDead:=AcqPtr^.PerDeadTime;								ActiveAcqStr:=PlugName;							END;							SetControlValue(SiLi_AcqCntlHdl,-1);																	{When the current meter device	}							FixupMenus	:=TRUE;						{ acquires to set time then		}							AcqPtr^.NeedAStop:=FALSE;				{ need to fixup the acquire menu}						END;										{ to reflext the current state	}						IF (message=acquireStart) THEN BEGIN							MenuStart	:=TRUE;							MenuStop	:=TRUE;							MenuResume	:=FALSE;						END ELSE IF (message=acquireStop) THEN BEGIN							MenuStart	:=TRUE;							MenuStop	:=FALSE;							MenuResume	:=TRUE;						END ELSE IF (message=acquireResume) THEN BEGIN							MenuStart	:=TRUE;							MenuStop	:=TRUE;							MenuResume	:=FALSE;						END;					END;				END;			END;		END;	 END;	OTHERWISE	 BEGIN	 	Debugstr('should never get here');	 END;	END;	CallAcquirePlugIns:=theReturnValue;END;END.