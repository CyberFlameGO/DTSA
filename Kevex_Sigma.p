UNIT Kevex_Sigma_Plug;INTERFACEUSES	Types, QuickDraw, Memory, fp, StandardFile, GestaltEqu, Errors, Files,	TextUtils, PascalA4, FilePlugIns;const		__procinfo : longint = $3F80;{$Main}PROCEDURE	ENTRYPOINT(message:Integer; VAR InPtr:IOPlugPtr; VAR theResult:OSerr);IMPLEMENTATION{$IFC NOT POWERPC}uses PascalA4;{$ENDC}PROCEDURE Kevex_Sigma(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);FORWARD;PROCEDURE DoAbout(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);FORWARD;PROCEDURE DoOpen(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);FORWARD;PROCEDURE DoWrite(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);FORWARD;FUNCTION	Str2Num(s: Str255): Real;FORWARD;PROCEDURE 	ENTRYPOINT{(message:Integer; VAR InPtr:IOPlugPtr; VAR theResult:OSErr)};		{ Main dispatching routine.  Initializes and sets up the global variables,	}		{		and performs the operation specified by the message. 				}VAR	firstTime	: BOOLEAN;	OldA4		: Longint;BEGIN{$IFC NOT POWERPC}	oldA4 := SetCurrentA4();	RememberA4();{$ENDC}	theResult:=noErr;	firstTime:=(InPtr=NIL);					{ See if this is the first time called }	IF firstTime THEN BEGIN						{ If so, allocate and initialize a data area }		InPtr:= IOPlugPtr(NewPtrClear(sizeof(IOPlug)));		IF (InPtr=NIL) THEN BEGIN			debugstr('memFullErr');			theResult:=memFullErr;{$IFC NOT POWERPC}	oldA4 := SetA4(oldA4);{$ENDC}			EXIT(ENTRYPOINT);		END;				END;		CASE message OF					{ Perform the requested operation }		fileAbout		:DoAbout(InPtr, theResult);		ImpFile			:Kevex_Sigma(InPtr, theResult);		ExpFile			:DoWrite(InPtr, theResult);		OpenInPlug		:DoOpen(InPtr, theResult);		OpenExPlug		:DoOpen(InPtr, theResult);		END; {CASE message}{$IFC NOT POWERPC}	oldA4 := SetA4(oldA4);{$ENDC}END;PROCEDURE DoAbout(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);	Begin	End;	PROCEDURE DoOpen(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);	Begin		InPtr^.PlugInName:='Kevex Sigma ASCII';		{Debugstr('Inside of Kevex_Sigma - Do Open');}		theResult := noErr;	End;	PROCEDURE DoWrite(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);	Begin	End;  PROCEDURE Kevex_Sigma(VAR InPtr : IOPlugPtr; VAR theResult:OSerr);        CONST      tSerial_BufferSize            = 80000; {Never more than a single spectrum, 2048 chans}    TYPE      tPAC256Buffer                 = PACKED ARRAY [1..tSerial_BufferSize] OF signedbyte;      tPAC256BufPtr                 = ^tPAC256Buffer;	  TByte                         = PACKED ARRAY [1..1] OF byte;    VAR      index, nn, jj, kk             : integer;      FileSize                      : longint;      theRefnum                     : integer;      tipBufPtr                     : tPAC256BufPtr;      indexL, pos                   : longint;      strLength, lenth              : TByte;      bytecount                     : longint;      str, str1, str2               : str255;      Car_Ret                       : Boolean;      START_EV                      : Real;	  END_EV                        : Real;	  num_channels					: integer;	  errCode                       : OSErr;	  Function search_str(len : TByte; VAR strx : str255):longint;	VAR		strr	: str255;	BEGIN        strLength[1] := len[1];        BlockMove(@strLength, @strr[0], 1);        REPEAT          BlockMove(@tipBufPtr^[indexL], @strr[1], strLength[1]);          indexL := indexL + 1;        UNTIL ((strr = strx) OR (indexL >= FileSize));		if (indexL >= FileSize) then begin			search_str := indexL;			exit(search_str);		end;        indexL := indexL + strLength[1];		search_str := indexL;		if (strx = 'Channel') then exit(search_str);        WHILE ((tipBufPtr^[indexL] = $20) OR (tipBufPtr^[indexL] = $09) OR (tipBufPtr^[indexL] = $0A)) DO          indexL := indexL + 1; { jump over a run of spaces and LFs}        strr := '';        WHILE NOT (tipBufPtr^[indexL] = $0D) DO          BEGIN            strr := CONCAT(strr, chr(tipBufPtr^[indexL]));            indexL := indexL + 1;          END; { While }		  strx := strr;		  search_str := indexL;	END;    BEGIN		theRefnum := InPtr^.Rd_Refnum;		{Debugstr('Inside of Kevex_Sigma');}		FOR nn := 1 TO 8192 DO		  InPtr^.Spec_cts[nn] := 0.0;			InPtr^.Specimen_Comment_Field := '';			InPtr^.dE := 10.0;			InPtr^.kV := 0.0;			InPtr^.Begin_Faraday := 1.0;			InPtr^.End_Faraday := 1.0;			InPtr^.FirstValue := 0.0;			InPtr^.EndValue := 0.0;			InPtr^.Real_Time := 0.0;			InPtr^.Live_Time := 0.0;			InPtr^.FirstChannel := 1;			InPtr^.Energy_Slope := 1.0;			InPtr^.Energy_Intercept := 0.0;			InPtr^.NDoffset := 0;			InPtr^.Spectrum_Type := 'EDS ';				  errCode := GetEOF(theRefnum, FileSize);      tipBufPtr := tPAC256BufPtr(NewPtr(sizeof(tPAC256Buffer)));      IF tipBufPtr = NIL THEN        BEGIN          exit(Kevex_Sigma);        END;      IF FSRead(theRefnum, FileSize, Pointer(tipBufPtr)) <> NoErr THEN        BEGIN		  theResult := badFileFormat;		  DisposePtr(Ptr(tipBufPtr));          exit(Kevex_Sigma);        END;      Car_Ret := false;        indexL := 0;		lenth[1] := 17;		str := 'File revision:  1';		pos := search_str(lenth, str);		if (indexL >= FileSize) then begin			theResult := badFileFormat;			exit(Kevex_Sigma);		end;				lenth[1] := 18;		str := 'File format:  Text';		pos := search_str(lenth, str);		if (indexL >= FileSize) then begin			theResult := badFileFormat;			exit(Kevex_Sigma);		end;		lenth[1] := 14;		str := 'Spectrum file:';		pos := search_str(lenth, str);		if (indexL >= FileSize) then begin			theResult := badFileFormat;			exit(Kevex_Sigma);		end;		{IF (LENGTH(str) > 0) THEN InPtr^.Specimen_Comment_Field := str;}		lenth[1] := 9;		str := 'Comments:';		pos := search_str(lenth, str);		if (indexL >= FileSize) then begin			theResult := badFileFormat;			exit(Kevex_Sigma);		end;		IF (LENGTH(str) > 0) THEN InPtr^.Specimen_Comment_Field :=  str;		lenth[1] := 5;		str := 'Date:';		pos := search_str(lenth, str);		if (indexL >= FileSize) then begin			theResult := badFileFormat;			exit(Kevex_Sigma);		end;		{IF (LENGTH(str) > 0) THEN ;}	{this is the date}		lenth[1] := 4;		str := 'keV:';		pos := search_str(lenth, str);		if (indexL >= FileSize) then begin			theResult := badFileFormat;			exit(Kevex_Sigma);		end;		IF (LENGTH(str) > 0) THEN InPtr^.kV := str2num(str);		lenth[1] := 11;		str := 'Tilt angle:';		pos := search_str(lenth, str);		if (indexL >= FileSize) then begin			theResult := badFileFormat;			exit(Kevex_Sigma);		end;		{IF (LENGTH(str) > 0) THEN ;}	{This is the tilt}		lenth[1] := 16;		str := 'Emergence angle:';		pos := search_str(lenth, str);		if (indexL >= FileSize) then begin			theResult := badFileFormat;			exit(Kevex_Sigma);		end;		{IF (LENGTH(str) > 0) THEN ;}	{This is the TOA}		lenth[1] := 11;		str := 'eV/Channel:';		pos := search_str(lenth, str);		if (indexL >= FileSize) then begin			theResult := badFileFormat;			exit(Kevex_Sigma);		end;		IF (LENGTH(str) > 0) THEN InPtr^.dE := str2num(str);		lenth[1] := 12;		str := 'Memory size:';		pos := search_str(lenth, str);		if (indexL >= FileSize) then begin			theResult := badFileFormat;			exit(Kevex_Sigma);		end;		IF (LENGTH(str) > 0) THEN begin			if str[1] = '1' then num_channels := 1024			else if str[1] = '2' then num_channels := 2048			else if str[1] = '4' then num_channels := 4096			else if str[1] = '8' then num_channels := 8192			else begin				theResult := badFileFormat;				exit(Kevex_Sigma);			end;			InPtr^.Number_of_Channels := num_channels;			InPtr^.LastChannel := InPtr^.Number_of_Channels;		end;		lenth[1] := 15;		str := 'Beam reference:';		pos := search_str(lenth, str);		if (indexL >= FileSize) then begin			theResult := badFileFormat;			exit(Kevex_Sigma);		end;				IF (LENGTH(str) > 0) THEN begin			str1 := '';			for jj := 1 to LENGTH(str) do begin				if (((str[jj] >= '0') AND (str[jj] <= '9')) OR (str[jj] = '.')) then 					str1 := concat(str1, str[jj]);			end;			InPtr^.Begin_Faraday := str2num(str1);			InPtr^.End_Faraday := str2num(str1);		end;		lenth[1] := 13;		str := 'Acquire time:';		pos := search_str(lenth, str);		if (indexL >= FileSize) then begin			theResult := badFileFormat;			exit(Kevex_Sigma);		end;		IF (LENGTH(str) > 0) THEN InPtr^.Live_Time := str2num(str);		lenth[1] := 8;		str := 'Spectrum';		pos := search_str(lenth, str);		if (indexL >= FileSize) then begin			theResult := badFileFormat;			exit(Kevex_Sigma);		end;		lenth[1] := 6;		str := 'Escape';		pos := search_str(lenth, str);		if (indexL >= FileSize) then begin			theResult := badFileFormat;			exit(Kevex_Sigma);		end;		lenth[1] := 10;		str := 'Background';		pos := search_str(lenth, str);		if (indexL >= FileSize) then begin			theResult := badFileFormat;			exit(Kevex_Sigma);		end;		lenth[1] := 8;		str := 'Gaussian';		pos := search_str(lenth, str);		if (indexL >= FileSize) then begin			theResult := badFileFormat;			exit(Kevex_Sigma);		end;		lenth[1] := 9;		str := 'Elements:';		pos := search_str(lenth, str);		if (indexL >= FileSize) then begin			theResult := badFileFormat;			exit(Kevex_Sigma);		end;		WHILE NOT (tipBufPtr^[indexL] = $0D) DO			indexL := indexL + 1;		lenth[1] := 7;		str := 'Channel';		pos := search_str(lenth, str);		if (indexL >= FileSize) then begin			theResult := badFileFormat;			exit(Kevex_Sigma);		end;		WHILE NOT (tipBufPtr^[indexL] = $0D) DO	{skip to CR}			indexL := indexL + 1;		jj := 0;		kk := 0;		REPEAT			str := '';							WHILE  ((tipBufPtr^[indexL] = $20 {sp} ) OR					(tipBufPtr^[indexL] = $09 {tab}) OR					(tipBufPtr^[indexL] = $0A {lf} )) DO						indexL := indexL + 1; { jump over a run of spaces/tabs/lfs }			WHILE  ((tipBufPtr^[indexL] <> $20) AND 					(tipBufPtr^[indexL] <> $09) AND					(tipBufPtr^[indexL] <> $0D) AND					(tipBufPtr^[indexL] <> $0A)) DO 				  begin					str := CONCAT(str, chr(tipBufPtr^[indexL]));					indexL := indexL + 1;				  end;				  				IF (LENGTH(str) > 0) THEN begin					if kk = 1 then begin						jj := jj + 1;						InPtr^.Spec_cts[jj] := str2num(str);						kk := 0;				  	  end					else						kk := 1;				END;			indexL := indexL + 1;			UNTIL (indexL >= FileSize);       	DisposePtr(Ptr(tipBufPtr));		theResult := noErr;    END; { Procedure Kevex_Sigma }{*****************************************************************************}FUNCTION Str2Num(s: Str255): Real;   { Pascal implementation of Str2Num (fp.p: Str2Dec, Dec2Str) }VAR	aDecimal		: Decimal;	aCStr			: ConstCStringPtr;	anIndex			: Integer;	aValidPrefix	: Integer; { ignore }BEGIN	aCStr := P2CStr(@s);	anIndex := 0;	str2dec( aCStr, anIndex, aDecimal, aValidPrefix );	Str2Num := dec2num( aDecimal );END;END. 