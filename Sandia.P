{[j=30/55,:+,u+,r+,d-,o=300,k+,n+,#+,v+,q+,b+]}{[f-]}{*********************************} UNIT SANDIA ;{*********************************}{**********************************} INTERFACE {**********************************} USES   QuickDraw, QuickdrawText, Types, OSUtils, ToolUtils, Controls, Timer, Errors, Events, Menus, Files, Lists, Memory, Retrace, SegLoad, Windows,   Packages, Printing, TextEdit, StandardFile, Resources, Devices, Fonts, fenv, fp, MixedMode, TextUtils, Finder, Spectrum_Structures,  Declarations, INITIALIZE, Xray_Energies, Global_Functions, Utilities, Physics, xray, Physics_Windows ;      PROCEDURE Initialize_MAIN;    PROCEDURE HandleMAINEvent(theEvent: EventRecord; VAR ActivetextHndl: TEHandle);    PROCEDURE ReviewFitResults(Filename:fnamestr; VolNum:integer);    PROCEDURE WriteFitResults;    PROCEDURE WriteOneFit;    FUNCTION ItsNaN(theString: str255): boolean;  	 {******************************} IMPLEMENTATION {**********************************}{[f+]}{$S SANDIA1}  CONST    PAGEHEIGHT                    = 710;              {pixels per 25cm, used in destrect for text}    PAGEWIDTH                     = 620               {506} ; {pixels per 18cm, used in destrect for text}    VISIBLE                       = true;    INVISIBLE                     = false;    GOAWAY                        = true;  VAR    theEvent                      : EventRecord;      {event passed from operating system}    thumbvalue                    : integer;    ActivePeek                    : WindowPeek;       {pointer to ActiveRec}    {ActivetextHndl                : TEHandle;}         {handle to text in Active window, either main or help}   {ActiveVscrollhndl             : ControlHandle;}    {Handle of active vertical scroll bar}    linesonscreen                 : integer;          {for font of current TE port}    linesperpage                  : integer;          {ditto}    numpages                      : integer;          {ditto}    charsonscreen                 : integer;          {ditto}    charperline                   : integer;          {ditto}    avgcharwidth                  : integer;          {ditto}    theMouseLocation              : Point;    ActiveWindow                  : WindowPtr;        {pointer to the front (active) window}     { Screen stuff}    DragArea                      : Rect;             { defines region within which window can be dragged }    GrowArea                      : Rect;             { defines region within which window can change }    delayend                      : Longint;          {needed for delay procedure}    delayticks                    : integer;    counter                       : integer;    { Main Window stuff }    MAINRec                       : WindowRecord;     { holds data for main window }    MAINPeek                      : WindowPeek;       { pointer to MainRec }    MAINwindowrect                : Rect;             { current size of main window }    MAINtextHndl                  : TEHandle;         { handle to text in main window }    MAINdestrect                  : Rect;             { destination rect for main window text}    MAINviewrect                  : Rect;             { view rect for main window text}    MAINVscrollrect               : Rect;             { size rect for Vertical scroll bar}    MAINVscrollhndl               : ControlHandle;    { Handle of vertical scroll bar}    MvValue, MvMin, MvMax         : integer;    MhValue, MhMin, MhMax         : integer;	  BottomRect					: rect;	(*¥* add these three UPPs *¥*)	gVscrollUPP			: UniversalProcPtr;	{gHscrollUPP			: UniversalProcPtr;}	gClikLoopUPP		: UniversalProcPtr;  FUNCTION ItsNaN(theString: str255): boolean;    BEGIN      ItsNaN := false;      (*IF (ord(ClassExtended(Str2Num(theString)))) < 3 THEN ItsNaN := true;*)    END;  PROCEDURE OpenMainWindow; {called only at startup}    BEGIN      WITH MaxWindowRect DO        SetRect(MAINwindowrect, 16, 38, Right - 4, Bottom - 4);      { set main windowsize, relative to max possible }      MAINPtr := NewWindow(@MAINRec, {create the main window, make it visible}                           MAINwindowrect, 'Output', INVISIBLE, DocumentProc, Pointer( - 1), GOAWAY, 1001); { 1001 window refcon        used in MainEventLoop }      MAINPeek := WindowPeek(MAINPtr); { get pointer to window record }      MAINPeek^.windowKind := UserKind; { set window type = user kind (ID=8)}      SetPort(MAINPtr); { set window to current graf port }      SetRect(MAINdestrect, 4, 0, PAGEWIDTH + 4, PAGEHEIGHT); { set initial destination rectangle }      SetRect(MAINviewrect, 0, 0, MAINwindowrect.Right - 16, MAINwindowrect.Bottom - 16);      { set view rectangle }      MAINtextHndl := TENew(MAINdestrect, MAINviewrect); {create the edit record for the main window & store its Hndl}            ReserveMem(sizeof(TERec));      HLock(Handle(MAINtextHndl));            TEActivate(MAINtextHndl); {Activate the text edit record, even though it's invisible}       {Courier 10pt and Monaco 9 pt give the best tabular output.        Courier is a laser font, and monaco is a required system font,        so output will always be predictable}      IF RealFont(courier, 10) = true {if my favorite font is availableÉ }         THEN        WITH MAINtextHndl^^ DO          BEGIN            txFont := courier; {then use it,}            txSize := 10;          END      ELSE        WITH MAINtextHndl^^ DO          BEGIN            txFont := monaco; { Éotherwise, use this reserved system font & size}            txSize := 9; { which gives 80 characters across the full screen}          END;      MAINtextHndl^^.txFace := []; { plain text } (* lineHeight is wrong, using system values*)      MAINtextHndl^^.crOnly := 1; {turn word wrap on, for good luck}      WITH MAINPeek^.port.portRect DO {get ready for vert scroll bar}        BEGIN          MAINVscrollrect.Top := Top - 1; { size rect for Vertical scroll bar}          MAINVscrollrect.Bottom := Bottom - 14;          MAINVscrollrect.Right := Right + 1;          MAINVscrollrect.Left := Right - 15;        END;					(*¥* replace default clikLoop with own *¥*)					(*¥* & change from proc pointer to UPP *¥*)					MAINtextHndl^^.clickLoop := gClikLoopUPP;       {for the courier 10 font}      MvMin := 1;      MvMax := 70; {a full page will hold about 88 single spaced lines, but the max is less by the 18 lines displayed on the screen}                    {this is just for starters, Handleclick in main prgm                     does it better}      MvValue := 1;      MhMin := 1;      MhMax := 5; {a full line is about ~84 characters, but the max is less by the ~79 characters displayed on the screen}      MhValue := 1;      {create Vertical scroll bar }      MAINVscrollhndl := NewControl(MAINPtr, MAINVscrollrect, '', VISIBLE, MvValue, MvMin, MvMax, scrollbarProc, 0);            ReserveMem(sizeof(ControlRecord));      HLock(Handle(MAINVscrollhndl));                  ShowControl(MAINVscrollhndl);    END; {of procedure OpenMainWindow}  PROCEDURE SetWindowLimits(VAR ScreenArea: Rect; VAR MaxWindowRect: Rect; VAR DragArea: Rect; VAR GrowArea: Rect);        {        purpose:    sets four needed limits for window work:                    ScreenArea,MaxWindowRect,DragArea,GrowArea.        }    BEGIN      WITH ScreenArea DO        BEGIN          SetRect(MaxWindowRect, 0, 38, Right, Bottom); { set max size available for application windows (global)}          SetRect(DragArea, 4, 25, Right - 4, Bottom - 4); { set drag region (global) leaves 4 pixel margin inside max screen                                                            dimensions}          SetRect(GrowArea, 300, 100, Right, Bottom) { set grow region (global). Window cannot get too narrow to read the title, nor                                                      too short to not use the bar}        END;    END; {of procedure SetWindowLimits}     PROCEDURE SetScrollbarLimits(wPtr: WindowPtr; texthndl: TEHandle);{  purpose : refresh certain values applying to the active scroll bars.              accesses & changes many appl global variables }    BEGIN      WITH texthndl^^ DO {adjust the scroll controls}        BEGIN          avgcharwidth := StringWidth('ABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890abcdefghijklmnopqrstuvwxyz') DIV 62;          linesonscreen := (viewrect.Bottom - viewrect.Top) DIV lineHeight;          linesperpage := 710 DIV lineHeight;          numpages := nLines DIV linesperpage + 1;          destrect.Bottom := numpages * 710;          charsonscreen := (viewrect.Right - viewrect.Left) DIV avgcharwidth;          charperline := (destrect.Right - destrect.Left) DIV avgcharwidth;          IF charperline - charsonscreen + 1 >= 1 {needed if windowed widened over pre-set width}             THEN            SetControlMaximum(MAINVscrollhndl, linesperpage * numpages - linesonscreen + 1);          thumbvalue := (viewrect.Top - destrect.Top) DIV lineHeight + 1;          SetControlValue(MAINVscrollhndl, thumbvalue); {vertical scroll bar}        END;    END; {of Procedure SetScrollLimits}  FUNCTION ToUpperCase(chr: char): char; {operates on a single character}       {       Purpose:    if chr is a lower case letter, returns the corresponding                   upper case letter, otherwise, chr is unchanged.                   Local function.       }    BEGIN      IF (ord(chr) > 96) AND (ord(chr) < 123) THEN ToUpperCase := char(ord(chr) - 32)      ELSE ToUpperCase := chr    END; {of ToUpperCase}{$S SANDIA2}	  PROCEDURE LABELS_1(nfit:integer);	  VAR	  str, str1, str2, str8	: str255;	  n,nn       : integer;				BEGIN	    WITH Analysis_result^^, SpectrumStuff, Acq_Info, Spectrum_Info, Fit_params, Fit_result, ExptStuff DO          BEGIN            IF (debugeron AND (Hall_active AND NOT binary_choice)) THEN putmessage('output from old Hall file', '', '', '');            IF (Plain_Boolean) THEN              BEGIN              (* IF (Do_HallOutput AND NOT binary_choice) THEN writeln(Plain, '           ', Hall_Name)                ELSE writeln(Plain, '   Results from ', MCA_ResultsName);                writeln(Plain, DateAndTimeStr);			  *)                writeln(Plain, '');                writeln(Plain, 'Analyst: ', Analyst);                writeln(Plain, 'Specimen_ID: ', Specimen_ID);                writeln(Plain, 'Experiment Comments: ', Specimen_Comment_Field);                writeln(Plain, ' Fit to the the file: ', MCA_Filename);                writeln(Plain, ' Beam keV =  ', KV: 6: 3);                writeln(Plain, ' Take Off Angle =  ', Take_Off_Angle: 6: 3);				if Plt_Spec[10]^^.Expt_Info.Detector.spec = EDS then                writeln(Plain, ' Detector resolution at Mn(eV) =  ', Si_Resolution: 6: 3);				if Plt_Spec[10]^^.Expt_Info.Detector.spec = WDS then                writeln(Plain, ' WDS resolution =  ', WDS_Resolution: 6: 3);				              END;            IF (Normal_Output) AND (Plain_Boolean) THEN              BEGIN                writeln(Plain, ' Si(Li) Dead Zone (um) = ', Si_Thickness: 6: 3);                writeln(Plain, ' Detector Thickness (mm) =  ', Detector_Thickness: 6: 3);                writeln(Plain, ' Detector Area (sq. mm) =  ', Detector_Area: 6: 3);                writeln(Plain, ' Detector-Specimen distance (mm) =  ', Spec_Detector_Distance: 6: 3);                IF C_Thickness > 0.0 THEN writeln(Plain, ' Carbon Window Component =  ', C_Thickness: 6: 3);                IF Ice_Thickness > 0.0 THEN writeln(Plain, ' Ice (as Oxygen) =  ', Ice_Thickness: 6: 3);                IF Be_Thickness > 0.0 THEN writeln(Plain, ' Be Thickness =  ', Be_Thickness: 6: 3);                IF Au_Thickness > 0.0 THEN writeln(Plain, ' Au Thickness =  ', Au_Thickness: 6: 3);                IF Mylar > 0.0 THEN writeln(Plain, ' Mylar Thickness =  ', Mylar: 6: 3);                IF Moxtek > 0.0 THEN writeln(Plain, ' Moxtek Thickness =  ', Moxtek: 6: 3);                IF Paralene > 0.0 THEN writeln(Plain, ' Paralene Thickness =  ', Paralene: 6: 3);                IF BN_Thickness > 0.0 THEN writeln(Plain, ' BN Thickness =  ', BN_Thickness: 6: 3);                IF SiN_Thickness > 0.0 THEN writeln(Plain, ' Si3N4 Thickness =  ', SiN_Thickness: 6: 3);                writeln(Plain, ' Elevation Angle =  ', elevation: 6: 3);                writeln(Plain, ' Azimuth Angle =  ', azimuth: 6: 3);                writeln(Plain);                IF (Do_hallOutput AND NOT binary_choice) THEN                  WITH Hall_Setup^^ DO                    BEGIN                      str := ' ';                      IF (Filmcorr = 0.0) THEN str := '  No Film correction. '                      ELSE                        BEGIN                          realtostring(Filmcorr, 5, 2, str);                          str := CONCAT('Normalized correction from film = ', str, ' from file ', filmfile);                        END;                      writeln(Plain, str);                      str := ' ';                      IF (do_bulk) THEN                        BEGIN                          realtostring(bulk_factor, 5, 2, str);                          str := CONCAT('  Bulk correction factor for ', A^.Sym[Bulk_Z], Bulk_Line, ' = ', str, ' from file ',                                        bulkfile);                        END                      ELSE str := '  No Bulk correction. ';                      writeln(Plain, str);                      str := ' ';                      realtostring(Average_Z, 4, 2, str);                      str := CONCAT('  Input average atomic number for the matrix was ', str);                      writeln(Plain, str);                      str := ' ';                      n := 1;                      REPEAT                        str := CONCAT('  From file ', Standard_files[n], ' K factors are:  ');                        FOR nn := 1 TO number_of_peaks DO                          BEGIN                            IF (Std_File_Code[nn] = n) THEN                              BEGIN                                str2 := CONCAT(' for ', A^.Sym[Atomic_number[nn]], Siegbahn[nn], '  ');                                    { All internal calcs done in wtfract so convert for biologists; use 1.0e6 }                                    { because At_Wt^^.Value is now 1 * At_Wt:}                                realtostring(K_Factor[nn] * 1.0E6 / At_Wt^^.Value[Atomic_number[nn]], 5, 2, str1);                                str := CONCAT(str, str1, str2);                              END; { if (Std_File_Code...}                          END; {for nn...}                        writeln(Plain, str);                        n := n + 1;                        str := ' ';                      UNTIL ((Standard_files[n] = ' ') OR (n = 6));                      writeln(Plain);                    END; { IF (Hall_active and...WITH Hall_SetUp^^...}             			  IF Do_CLOutput then 			  begin				 WITH CL_Output^^,Baseinfo do begin				   if Kfitproc = 'ML' then					 str := 'C-L quant of ML fit results '				   else str := 'C-L quant of Simplex fit results ';				   str := concat(str,' ',CL_OutPut^^.ResultsName);				   writeln(Plain, Str);				   realtostring(base_loev,5,3,str1);				   realtostring(base_hiev,5,3,str2);				   str := concat('K factors are relative to ',a^.sym[Base_Z],Base_Line,' lines from ',str1,' ev to ',str2,' ev.');				   writeln(Plain, Str);						 				   n := 1;				  Repeat				   str8:=' ';				   str:= concat('From file ',CL_OutPut^^.BaseInfo.K_files[n],', K factors are');				   for nn := 1 to CL_OutPut^^.BaseInfo.number_of_peaks do begin					if (CL_OutPut^^.LineInfo[nn].fileIndex = n) then begin					   str2:='';					   str1:='';					   str2:= concat(a^.sym[CL_OutPut^^.lineInfo[nn].Z_number],CL_OutPut^^.lineInfo[nn].line);					   realtostring(CL_OutPut^^.LineInfo[nn].KFactor,5,2,str1);					   str:= concat(str,str8, str1,' for ',str2);					   str8:=', ';		 (*putmessage(str,'','','');*)					 end;	{ if (Std_File_Code...}				   end;	{for nn...}				   writeln(Plain, Str);				   n := n+1;				   str:=' ';				 Until ((CL_OutPut^^.BaseInfo.K_files[n] = ' ') or (n = 10));			  END;	{ WITH CL_OutPut^^,BaseInfo...}			  			  End;	{if Do_CLOutput...}			  IF Skip_Some then			  BEGIN			  	{Put the info at the end of each fitting window result}			  END;	{IF Skip_Some...}			  			  END; { if Plain_boolean...}            IF (spread_Boolean and (nfit = 1)) THEN              write(spread, 'Spectrum #', chr(9),'Comments', chr(9),'Class', chr(9), 'Live Time', chr(9), 'Current', chr(9),'Norm Chsn Bkg');		  END; {Big With.............}		 END; {PROCEDURE LABELS_1 }  PROCEDURE WriteFitResults;    VAR      errCode, refnum, temp, J         	: integer;      fndrInfo                     		: FInfo;      err                          		: OSErr;      bytecount                    	 	: Longint;      str, str1, str2, str3, str4, str5, str6, str7, str8: str255;      Conc_SUM : real;		myblock							: HParamBlockRec;		thename 						:str255;	    theVName 			: str31;		saveplain,savespread			: boolean;        DateAndTimeStr                	: str255;      PROCEDURE FormatOutput{(nresult)};     {  pretty up and format the Curve Fit output and write the chosen ASCII and spreadsheet files.}      VAR        K, Index, rn, np, wc			: integer;        index1, index2, Z, ZZ, FirstK	: integer;        Sum, sumPbyB				  : real;        effic                         : real;        Alfa_effic, QKF, the_kV       : real;        PArea, PLB, PCB, err_or_ener  : real;        test_str                      : STRING[4];      BEGIN        { In WriteFitResults we have opened the DTSA results file and read only the		  is_batch byte and first analysis_result }        		        WITH Analysis_result^^, SpectrumStuff, Acq_Info, Spectrum_Info, Fit_params, Fit_result, ExptStuff DO        BEGIN                SpinCursor;                Number_of_PeakRois := Number_of_Windows + 1;                IF (J = 1) and ( spread_Boolean) THEN				BEGIN				{finish col text labels for spread; no derivative info goes to spread sheet;				 J set in calling routine}				    str:='';                    FOR Index := 1 TO Number_of_PeakRois - 1 DO                    BEGIN                        index1 := First_in_Roi[Index]; { number of 1st pk in window }                        IF (Index = Number_of_PeakRois - 1) { in the last ROI }                           THEN                          index2 := number_of_peaks                        ELSE { before the last ROI }                          index2 := First_in_Roi[Index + 1] - 1;                        Z := 0;                        FOR K := index1 TO index2 DO 						IF (((Fit_procedure = 'Sm') and (Ref_Index[k] <> -1)) or 						    ((Fit_procedure = 'ML') and (Ref_Index[k] > 0 ))) THEN                        BEGIN						    IF Z <> Atomic_number[K] THEN							BEGIN								Z := Atomic_number[K];								str2 := CONCAT(A^.Sym[Atomic_number[K]], Siegbahn[K],': Energy  ');							END;						    IF (Siegbahn[K] <> 'KA2  ') AND (Siegbahn[K][4] <> 'D') THEN                            BEGIN							   if (Siegbahn[K] = 'KA1  ') and (Siegbahn[K+1] = 'KA2  ') then								 str:=CONCAT(A^.Sym[Atomic_number[K]], 'KA12')							   else str := CONCAT(A^.Sym[Atomic_number[K]], Siegbahn[K]);							   str1 := CONCAT(str, ': Area');							   IF (Fit_Procedure = 'ML') THEN str2 := CONCAT(str, ': one sigma');							   IF ((Fit_Procedure = 'Sm') and (NOT Do_hallOutput)) THEN str2 := CONCAT(str, ': Energy');							   {...if Do_hallOutput then str2 is Z[firstK],sieg[firstK]: Energy}							   str3 := CONCAT(str, ': P/Lcl bg');							   str4 := CONCAT(str, ': P/chsn bg');							   IF (Do_hallOutput) THEN str5 := CONCAT(A^.Sym[Atomic_number[K]], Siegbahn[K][1], ': Conc(mmole/kg)')							   ELSE str5 := CONCAT(str, ': Conc(WtFract)');							   IF Thin_Physics_Boolean THEN							   BEGIN								 str6 := CONCAT(str, ': Det. Eff.');								 str7 := CONCAT(str, ': Eff*Q¥F¥Omega/A');							   END;							   IF ((Fit_Procedure = 'Sm') AND 	{line K is the last line in the family in this ROI...}								  ((K = index2) OR (Z <> Atomic_number[K + 1]))) 								   THEN BEGIN  {last line area,energy,p/blcl,p/bchsn,conc,·quantareas,·quantareas/Bchsn}							   	IF (NOT Do_hallOutput) THEN write(spread, chr(9),str1,chr(9),str2,chr(9),str3,chr(9),str4,chr(9),																 str5,chr(9),'·',A^.Sym[Atomic_number[K]],Siegbahn[K][1],chr(9),'·',A^.Sym[Atomic_number[K]],Siegbahn[K][1],'/chsn bg')										  {first line energy,conc,·quantareas,·quantareas/Bchsn}								ELSE write(spread,chr(9),str2,chr(9),str5,chr(9),'·area ',A^.Sym[Atomic_number[K]],Siegbahn[K][1],chr(9),'·',A^.Sym[Atomic_number[K]],Siegbahn[K][1],'/chsn bg');							   END							   			{line n:area,E or sigma,P/Blcl,P/Bchsn,conc...}							   ELSE IF ((Fit_Procedure = 'ML') or (NOT Do_hallOutput)) 							   		THEN write(spread,chr(9),str1,chr(9),str2,chr(9),str3,chr(9),str4,chr(9),str5);							   							   IF Thin_Physics_Boolean THEN write(spread, chr(9), str6, chr(9), str7);                                                           END; {IF (Siegbahn[K] <> 'KA2  ') AND...}                        END;	{FOR K := index1 TO index2 DO...IF...}	{ rest of column labels}                    END; { FOR Index := 1 TO Number_of_PeakRois - 1}                                       	    write(spread, chr(13));	{col lables are done}                END; { IF (J = 1) and (spread_Boolean) THEN...}	{finish col text labels for plain and spread}   				{¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥¥}                IF Plain_Boolean THEN                BEGIN                    IF (J = 1) OR (NOT Is_Batch) THEN                    BEGIN                        IF Fit_Procedure = 'Sm' THEN                        BEGIN                            writeln(Plain, ' Tolerence =', Toler: 13: 9);                            IF constrained THEN                            BEGIN                                writeln(Plain, 'Starting estimate for Resolution(eV) was ', FWStart: 5: 2,                                        '; Resolution Constraint(eV) was ', DFWHMM: 6: 3);                                writeln(Plain, '                                                Energy Constraint (eV) was ', DEN:                                        6: 3);                            END                            ELSE writeln(Plain, 'Starting estimate for resolution(eV) was ', FWStart: 5: 2, '; No constraints.');                        END { IF Fit_Procedure = 'Sm'...}                        ELSE                        IF Fit_Procedure = 'ML' THEN                        BEGIN                              rn := 1;                              WHILE (Ref_FileName[rn] <> '') DO                              BEGIN                                  str1 := CONCAT(' From Reference file ', Ref_FileName[rn], ': ');                                  wc := 0;                                  FOR np := 1 TO Analysis_result^^.Fit_params.number_of_peaks DO								{if we didn't have a ref for a line that sorting found, Ref_Index = 0;								 if we chose to skip a line Ref_Index = -1;								 the derivative booleans were set false.}								{  If (Ref_Index[np] <> -1) then	10/6/95}								  If (Ref_Index[np] > 0) then                                  BEGIN                                      IF (Siegbahn[np][4] <> 'D') THEN                                      BEGIN                                          wc := wc + 1; { ref_index is not valued for derivatives }                                          IF (ref_index[wc] = rn) THEN                                            str1 := CONCAT(str1, A^.Sym[Atomic_number[np]], Siegbahn[np]);                                      END;                                  END; {FOR np :=...}                                  writeln(Plain, str1);                                  rn := rn + 1;                               END; {WHILE...}                        END; {IF Fit_Procedure = 'ML' THEN...}                        writeln(Plain);                     END; {If (J = 1) or (not Is_Batch) then...}                END; { IF Plain_Boolean...}                IF (spread_Boolean) THEN	{start writing the values under the col titles}                  BEGIN                    write(spread, Spectrum_Number);					str := '';		            IF Spectrum_Comment_Field = '' THEN str := 'No Comments'                    ELSE if Length(Spectrum_Comment_Field) > 25 then str := copy(Spectrum_Comment_Field,1,25)					ELSE str := Spectrum_Comment_Field;                    write(spread, chr(9), str);			        write(spread, chr(9), Spectrum_Class);                    write(spread, chr(9), Live_Time);                    write(spread, chr(9), Begin_Faraday);			(*		write(spread, chr(9), X_Position);                    write(spread, chr(9), Y_Position);			   *)				    write(spread, chr(9), Chosen_Norm_Bkg);                  END;                IF Plain_Boolean THEN                  BEGIN                    numToString(Spectrum_Number, str1);                    IF Spectrum_Comment_Field = '' THEN str := CONCAT(str1, ':   No Comments')                    ELSE str := CONCAT(str1, ':   ', Spectrum_Comment_Field);                    IF Spectrum_Class = '' THEN str1 := 'Spectrum class: Unknown.'                    ELSE str1 := CONCAT('Spectrum class: ', Spectrum_Class);                    IF (Theoretically_Generated) THEN str1 := CONCAT(' Spectrum was generated; ', str1);                    IF (This_is_a_Standard) THEN str1 := CONCAT(' Spectrum is a standard; ', str1);                    writeln(Plain, str);                    writeln(Plain, str1);                    writeln(Plain, ' Live and Real Time: ', Live_Time: 6, '   ', Real_Time: 6);                    writeln(Plain, ' Begin and End Faraday Current =  ', Begin_Faraday: 6: 3, '   ', End_Faraday: 6: 3);                    writeln(Plain, ' Quant Background Region: ', Chosen_ROI_Lo: 6: 3, 'keV to ', Chosen_ROI_Hi: 6: 3,                            'keV   Normalized Counts: ', Chosen_Norm_Bkg);                    IF (Do_hallOutput AND NOT binary_choice) THEN                      BEGIN                        test_str := CONCAT(Spectrum_Class[1], Spectrum_Class[2], Spectrum_Class[3], Spectrum_Class[4]);                        { there is no entry in the Hall file for Film and Bulk spectr}                        IF (test_str <> 'film') AND (test_str <> 'bulk') THEN                          WITH Hall_Output^^ DO                            BEGIN                              bytecount := Sizeof(Hall_outstuff);                              errCode := FSRead(FileRefNum, bytecount, @Hall_Output^^);                              bytecount := Sizeof(Simplex_Fit); { reset for fit file read }                              IF (Hall_Output^^.do_ML) THEN                                BEGIN                                  IF local THEN                                    str := CONCAT(' Peak to local background ratios from ML fit ', Hall_Output^^.ResultsName)                                  ELSE str := CONCAT(' Peak to chosen background ratios from ML fit ', Hall_Output^^.ResultsName);                                END { if (Hall_Output^^.do_ML...}                              ELSE                                BEGIN                                  IF (local) THEN                                    str := CONCAT('  Peak to local background ratios from Simplex fit ', Hall_Output^^.ResultsName)                                  ELSE                                    str := CONCAT('  Peak to chosen background ratios from Simplex fit ', Hall_Output^^.                                                  ResultsName);                                END; { else begin...}                              writeln(Plain);                              writeln(Plain, str);                              numToString(spectnum, str);                              writeln(Plain, '  DTSA file ', DTSAname, ' spectrum ', str, ': ', class);                              str := ' ';                              realtostring(Z_corr, 5, 4, str1);                              realtostring(BulkBk, 5, 4, str2);                              realtostring(totbk, 5, 4, str3);                              str := CONCAT('  Concentration Z correction factor: ', str1);                              writeln(Plain, str);                              str := CONCAT('  Bulk background contribution: ', str2, '; corrected normalized background: ', str3);                              writeln(Plain, str);                              str := ' ';                            END; { if (test_str <>...WITH...}                      END; { (If (Hall_active and not Binary_choice)...}                END; { IF Plain_Boolean...}				                  Conc_SUM := 0.0;                FOR Index := 1 TO Number_of_PeakRois - 1 DO                BEGIN                    index1 := First_in_Roi[Index]; { number of 1st pk in window }                    IF (Index = Number_of_PeakRois - 1) { in the last ROI }                       THEN index2 := number_of_peaks                    ELSE { before the last ROI }                      index2 := First_in_Roi[Index + 1] - 1;                    IF Plain_Boolean THEN                      BEGIN                        writeln(Plain, '          Fitting Region = ', Fitting_ROI_Lo[Index]: 6: 3, ' : ', Fitting_ROI_Hi[Index]: 6:                                3);                        writeln(Plain, '         Chi Square= ', Response[Index]: 6: 5, '    Calculated FWHM Mn = ', FWHM_Mn[Index]:                                4: 1, '    Iterations=', Iterations[Index]: 4);						str2 := '       CONC';                        IF Fit_Procedure = 'ML' THEN                          str1 := 'SYM  LINE         AREA          FITSigma             P/B(10eV)      P/Chsn      '                        ELSE                          IF Fit_Procedure = 'Sm' THEN                            str1 := 'SYM  LINE         AREA             ENERGY            P/B(10eV)      P/Chsn      ';                        IF Do_hallOutput THEN str1 := CONCAT(str1, '  CONC(mmole/kg)')                        ELSE str1 := CONCAT(str1, '       CONC');                        writeln(Plain, str1);                        str8 := '              --         ';                        Z := 0;	{...for each ROI}                        FOR K := index1 TO index2 DO                        BEGIN                            IF Z <> Atomic_number[K] THEN                            BEGIN								IF (ref_index[K] = -1) THEN 								BEGIN									write(Plain,A^.Sym [Atomic_number[K]], '  ');									writeln(Plain, Siegbahn[K][1], ' not fit in this ROI.');								END								ELSE IF (Fit_Procedure = 'ML') AND (ref_index[K] = 0) THEN								BEGIN									write(Plain,A^.Sym [Atomic_number[K]], '  ');									writeln(Plain, Siegbahn[K][1], ' not fit; no reference for lines in this ROI.');								END;								Sum := MyStr2Num('0.0');                                Z := Atomic_number[K];                            END;	{IF Z <> Atomic_number[K] THEN...}							                              IF (((Fit_Procedure = 'ML') AND (ref_index[K] > 0)) or 							    ((Fit_procedure = 'Sm') and (Ref_Index[k] <> -1))) and								 (Siegbahn[K] <> 'KA2  ') THEN							BEGIN                                  IF (Siegbahn[K] = 'KA1  ') and (Siegbahn[K+1] = 'KA2  ') THEN                                  BEGIN { sum A1 and A2 }                                      PCB := Peak_to_Chosen_Bkg[K] + Peak_to_Chosen_Bkg[K + 1];                                      realtostring(PCB, 5, 3, str1);                                      IF ItsNaN(str1) THEN PCB := 0.0;                                      PLB := Peak_to_Local_Bkg[K] + Peak_to_Local_Bkg[K + 1];                                      realtostring(PLB, 5, 3, str1);                                      IF ItsNaN(str1) THEN PLB := 0.0;                                      write(Plain, A^.Sym[Atomic_number[K]], '  KA1,2  ', (Area[K] + Area[K + 1]): 11: 3, (2 *                                            Err_or_Energy[K] + Err_or_Energy[K + 1]) / 3: 18: 4, PLB: 19: 3, PCB: 14: 3);                                      Sum := Sum + Area[K] + Area[K + 1];                                  END { IF (Siegbahn[K] = 'KA1 '...}                                  ELSE                                    IF NOT ((Siegbahn[K][4] = 'D') AND (Reduced_Output)) THEN                                    BEGIN                                        PCB := Peak_to_Chosen_Bkg[K];                                        realtostring(PCB, 5, 3, str1);                                        IF ItsNaN(str1) THEN PCB := 0.0;                                        PLB := Peak_to_Local_Bkg[K];                                        realtostring(PLB, 5, 3, str1);                                        IF ItsNaN(str1) THEN PLB := 0.0;                                        write(Plain, A^.Sym[Atomic_number[K]], '  ');                                        write(Plain, Siegbahn[K], '  ', Analysis_result^^.Fit_result.Area[K]: 11: 3);                                        write(Plain, Err_or_Energy[K]: 18: 4);                                        write(Plain, PLB: 19: 3);                                        write(Plain, PCB: 14: 3);                                        Sum := Sum + Area[K];                                    END; {IF NOT (( Siegbahn[K][4])...}                                  IF NOT (Conc[K] < -0.99) AND NOT (Siegbahn[K][4] = 'D') THEN                                  BEGIN	                                  if NOT (This_is_a_Standard) then          {%%& 9/15/92 &%%}									    Conc_SUM := Conc_SUM + Conc[K];									  IF Do_hallOutput THEN writeln(Plain, Conc[K] * 1.0E6 / At_Wt^^.Value[Atomic_number[K]]: 19: 6)                                      else writeln(Plain, Conc[K]: 19: 6);                                  END                                  ELSE writeln(Plain, str8);  								                                    IF ((Fit_Procedure = 'Sm') AND 								     ((K = index2) OR (Z <> Atomic_number[K + 1]))) 									 THEN                                    writeln(Plain, 'Sum =        ', Sum: 10: 3);                           END; { IF (Siegbahn[K] <> 'KA2 ')...}                          END; {K loop}                        IF (Bulk_Physics_Boolean) AND (Fit_Procedure = 'Sm') THEN                          BEGIN                            Sum := 0.0;                            FOR K := index1 TO index2 DO { Get the sum of all the areas }                              BEGIN                                effic := f_chi_P^[rinttol(Err_or_Energy[K] * 100)] * Det_Effic_P^[rinttol(Err_or_Energy[K] * 100)];                                Sum := Sum + Area[K] / effic;                              END;                            Alfa_effic := f_chi_P^[rinttol(Err_or_Energy[index1] * 100)] * Det_Effic_P^[rinttol(Err_or_Energy[index1]                                          * 100)];                            writeln(Plain);                            writeln(Plain, 'LINE          GEN. AREA        F(chi)     GEN.(Pk/Alfa)      GEN.(Pk/Sum)');                            FOR K := index1 TO index2 DO                              BEGIN                                effic := f_chi_P^[rinttol(Err_or_Energy[K] * 100)] * Det_Effic_P^[rinttol(Err_or_Energy[K] * 100)];                                IF Siegbahn[K] = 'KA1  ' THEN                                  writeln(Plain, 'KA1,2       ', (Area[K] + Area[K + 1]) / (effic * Faraday_Current * 6.24196E9 *                                          Live_Time * Domega / (4 * PI)), f_chi_P^[rinttol(Err_or_Energy[K] * 100)]: 14: 8, (Area[                                          K] / effic) / (Area[index1] / Alfa_effic): 13: 8, '     ', (Area[K] / effic) / Sum: 13:                                          8)                                ELSE                                  IF Siegbahn[K] <> 'KA2  ' THEN                                    writeln(Plain, Siegbahn[K], '       ', Area[K] / (effic * Faraday_Current * 6.24196E9 *                                            Live_Time * Domega / (4 * PI)), f_chi_P^[rinttol(Err_or_Energy[K] * 100)]: 14: 8, (Area                                            [K] / effic) / (Area[index1] / Alfa_effic): 13: 8, '     ', (Area[K] / effic) / Sum:                                            13: 8);                              END; { K }                          END; { if Bulk_Physics_Boolean then..... }                    END; { if Plain_Boolean then... }						{Continues Spread output on the same line...}				  IF (spread_Boolean) THEN				  BEGIN                    Z := 0;	{...for each ROI, in case 1st line Z in ROI same as last line Z in last ROI}					Sum := 0.0;					sumPbyB := 0.0;               	    FOR K := index1 TO index2 DO					If (Ref_Index[K] <> -1) or					   ((fit_procedure = 'ML') and (Ref_Index[K] <> 0)) then                    BEGIN                     IF Z <> Atomic_number[K] THEN					 begin					 	Sum := 0.0;						sumPbyB := 0.0;						Z := Atomic_number[K];						FirstK := K;					 end;					 IF Do_hallOutput THEN Conc[K] := Conc[K] * 1.0E6 / At_Wt^^.Value[Atomic_number[K]];					 {Conc[K] is either 0.0 or quant value}					 IF (Siegbahn[K] <> 'KA2  ') AND (Siegbahn[K][4] <> 'D') THEN					 BEGIN					   ZZ := Atomic_number[K];					   Get_Energies(ZZ);					   QKF := 1;                       err_or_ener := Err_or_Energy[K];					   IF (Siegbahn[K] = 'KA1  ') and  (Siegbahn[K+1] = 'KA2  ')THEN					   BEGIN					       err_or_ener := (2 * err_or_ener + Err_or_Energy[K + 1]) / 3;						   PArea := Area[K] + Area[K+1];						   PLB := Peak_to_Local_Bkg[K] + Peak_to_Local_Bkg[K+1];						   PCB := Peak_to_Chosen_Bkg[K] + Peak_to_Chosen_Bkg[K+1];					   END	{IF  (Siegbahn[K] = 'KA1  '...}					   ELSE BEGIN	{all other lines}						   PArea := Area[K];						   PLB := Peak_to_Local_Bkg[K];						   PCB := Peak_to_Chosen_Bkg[K];					   END;	{all other lines}					  					  If Conc[K] <> 1.0 then					  begin					  	Sum := Sum + PArea; {...line contributed to quant}						sumPbyB := sumPbyB + PCB;					  end;	{If Conc[K] <> 1.0...}					  							effic := eV_Line[1] / Plt_spec[10]^^.Expt_Info.dE;							if effic < 8191.0 then                            		effic := Det_Effic_P^[rinttol(eV_Line[1] / Plt_spec[10]^^.Expt_Info.dE)]							else effic := 0.0;                            IF Running_Thin_Mode OR Running_Bulk_Mode THEN                            BEGIN                                IF Running_Thin_Mode THEN the_kV := Thin_KV                                ELSE IF Running_Bulk_Mode THEN the_kV := Bulk_KV;                                IF (Siegbahn[K][1] = 'K') THEN QKF := Qk(the_kV, A^.edge[1]) * WK(ZZ) * SAK(ZZ)                                ELSE IF (Siegbahn[K][1] = 'L') THEN QKF := Ql(the_kV, A^.edge[4]) * WL(ZZ) * SAL(ZZ)                                ELSE IF (Siegbahn[K][1] = 'M') THEN QKF := Qm(the_kV, A^.edge[9]) * WM(ZZ) * SAM(ZZ);                            END; {IF Running_Thin_Mode or...}                            QKF := QKF * effic / Atomic_Weight;						IF ((Fit_Procedure = 'Sm') AND 						   ((K = index2) OR (Z <> Atomic_number[K + 1]))) 						THEN BEGIN							IF (NOT Do_hallOutput) THEN write(spread,chr(9),PArea,chr(9),err_or_ener,chr(9),PLB,chr(9),PCB,chr(9),															  Conc[K],chr(9),Sum,chr(9),sumPbyB)							ELSE write(spread,chr(9),Err_or_Energy[FirstK],chr(9),Conc[K],chr(9),Sum,chr(9),sumPbyB); 							{...for Hall only write at end of family: E for 1st line in family, conc and sums}						END						ELSE IF ((Fit_Procedure = 'ML') or (NOT Do_hallOutput))							{...if ML or SIM and not Hall, write each line info...}							THEN write(spread,chr(9),PArea,chr(9),err_or_ener,chr(9),PLB,chr(9),PCB,chr(9),Conc[K]);												IF Thin_Physics_Boolean THEN write(spread, chr(9), effic, chr(9), QKF);                     END; {IF (IF (Siegbahn[K] <> 'KA2  '...}				   END; {FOR K := index1 TO index2 DO  ... }				  END; {IF spread_Boolean THEN BEGIN  ... }                    Sum := 0.0;					sumPbyB := 0.0;                    IF Plain_Boolean THEN writeln(Plain);       		   END; {FOR Index := 1 TO Number_of_PeakRois - 1...}			   IF ( spread_Boolean) THEN write(spread, chr(13));	{end the line}			   			   if (Conc_SUM <> 0) and (not Hall_active) and (not do_HallOutput) then			    begin				   writeln(Plain, '                                                       Concentration SUM =',Conc_SUM: 19: 6);                end;          END; { big WITH...WITH Analysis_result^^, SpectrumStuff...}        ChangeCursor(ArrowC);      END; {of procedure FormatOutput}    BEGIN { WriteFitResults: Called while batch fitting or in Add_a_fit, if		    any file boolean set in D_Results_Options (see_fit = F, do_ascii = F);			also called from See_a_Fit (see_fit = T, do_ascii = F) and			Old_Fit Output (show: see_fit = T, do_ascii = F; write: see_fit = F, do_ascii = T)			¥¥NOT called for displaying just one fit!¥¥ }      	  errCode := getvol(Save_Volume_Name, save_vol);	  	  {simplest place...}	  saveplain := plain_boolean;	  savespread := spread_boolean;	  	  if (See_Fit) then begin {show whole fit file from Old Fit or See_a_fit if results_added}	  	plain_boolean := true;		spread_boolean := false;	{NEVER make a spread if See_fit}	  end;	  {...or there's no point in being here at all}				{¥¥¥do this here for (num_of_fits = 1) in case other procedures		 called between creation and first write to file...}		IF (see_fit) OR (num_of_fits = 1) or do_ascii THEN			{get fit or quant results creation date info...}		BEGIN		 {Get WD information so we can get file info..}		  If Do_CLOutput or Do_Halloutput then	{we have file info}		  begin		     myblock.ioDirID := In_Spec.parID;			 myblock.ioVRefNum := In_Spec.Vrefnum;					 blockmove(@In_Spec.Name,@thename,sizeof(str63));		  end		  else begin			 myblock.ioVRefNum := MCA_Results_VolNum;	{working dir num}			 Get_WDInfo(theVName,myblock.ioDirID,myblock.ioVRefNum); {in Utilities}			 {myblock.ioVRefNum on return is volume ref num}			 thename := '';			 blockmove(@MCA_ResultsName,@thename,sizeof(str63));		  end;		 {Now get file information so we can get creation data...}			 myblock.ioNamePtr := StringPtr(NewPtr(sizeof(str255)));			 {...thename is str255, MCA_ResultsName is str63}			 myblock.ioNamePtr := @thename;	{stringPtr...to str255}			 myblock.ioCompletion := NIL; {always NIL}			 myblock.ioFDirIndex := -1;			 errcode := PBHGetFInfosync(@myblock);{FILES:2-194}		     SecondsToDate(myblock.ioFlCrDat, theDateTime);{a dateTimeRec}		    DisposePtr(Ptr(myblock.ioNamePtr));		     myblock.ioNamePtr := NIL;		 DateAndTimeStr := DTRec2Str;		 IF (theDateTime.hour) >= 12 THEN		 	  DateAndTimeStr := CONCAT('           ',DateAndTimeStr, ' pm')		 ELSE DateAndTimeStr := CONCAT('           ',DateAndTimeStr, ' am');	  END;	{IF (see_fit) or (num_of_fits = 1)...got fit results info for creation date}	  	  {1. We want to SEE a plain file ONLY, but it doesn't exist if	   called for Show Old Fit File, or Sili See_a_Fit when Plain_Options is F.	   So write the whoooooole thing. Spread_Boolean is saved above, set it false	   and restore it below. Plain_boolean is also saved and restored here.	   Plain_options, PlainName and Plain_Vol are saved/restored in calling code.	   Plain_options set F in calling code.	   Plain_boolean must be T; Spread_boolean must be F below...it is saved above.	   	   2. Or we want to WRITE Plain and/or Spread file for Old Fit File, or Hall or	   CL file so write the whoooooole thing. The call to D_Results options	   got the names and booleans for Plain and Spread. And created	   the files. We cannot reset Spread here. In calling routine we MUST	   set See_Fit := T and then false.}	  {if ascii and spread are selected in D_Results_options, they are also created there}	  	  IF (See_Fit) or (do_ascii) THEN	{write the whole text if (See_Fit) or (do_ascii);	  									 write the whole spread if (do_ascii) and spread_boolean}      BEGIN  	{Plain_Options is not affected here}	   errCode := noerr;	   if (Do_HallOutput) or (Do_CLOutput) then refnum := Hold_RefNum	   else errCode := FSOpen(MCA_ResultsName, MCA_Results_VolNum, refnum);if errcode <> noerr thenif answermessage(' FSOpen(MCA_ResultsName, MCA_Results_VolNum...','in Sandia','FAILED','OK = quit')then exit(WriteFitResults);		errCode := setfpos(refnum, fsFromstart, 0);		bytecount := 1;		errCode := FSRead(refnum, bytecount, @Is_Batch);if errcode <> noerr thenif answermessage(' FSRead...refnum for',MCA_ResultsName,'FAILED in Sandia','OK = quit')then exit(WriteFitResults);		bytecount := sizeof(simplex_fit);		errCode := FSRead(refnum, bytecount, @analysis_result^^);	   		If (plain_boolean) and (not Plain_Options) then		Begin	{...must be here from Show Old Fit OR SEE_A_FIT so spread_boolean is false;	   			 Plain_Options can only be set in D_Results_Options}		  Plain_VolNum := MCA_Results_VolNum;	{this is a WD num}          IF (Analysis_result^^.Fit_params.Fit_Procedure = 'ML') THEN            IF (Is_Batch) THEN PlainName := 'MLBatchASCII'            ELSE PlainName := 'MLAddASCII'          ELSE IF (Analysis_result^^.Fit_params.Fit_Procedure = 'Sm') THEN			IF (Is_Batch) THEN PlainName := 'SimpBatchASCII'			ELSE PlainName := 'SimpAddASCII';	   		 {the ascii text file must be created...}		  errCode := setvol(NIL, Plain_VolNum); {either selected vol or MCA vol}		 (* Rewrite(Plain, PlainName);*)		  Open(Plain, PlainName);		  Rewrite(Plain);          temp := IOResult;          numToString(temp, str);          str := CONCAT('Error Number is ', str);          str1 := CONCAT('For File Var: ', 'Plain ', ' and File Name: ', PlainName);		  IF temp <> 0 THEN putmessage('Failure to "ReWrite" the "Plain" TEXT File', str, str1, '')		  else begin			 fndrInfo.fdcreator := 'MSWD';			 fndrInfo.fdtype := 'TEXT';			 fndrInfo.fdFlags := 0;			 errCode := setfinfo(PlainName, Plain_VolNum, fndrInfo);			 numToString(errCode, str);			 IF errCode <> noErr THEN			   putmessage('setFinfo error just occured', 'in trying to set file info for "plain"', 'Error Number', str);			 Close(Plain);		     err := FlushVol(NIL, Plain_VolNum);		  end;	{if IF temp <> 0 ...else...}	    End;	{If (plain_boolean) and (not Plain_Options)...we created the file here;	   		 otherwise if Plain_Options it already existed}		 		 {still in 'IF (See_Fit) or (do_ascii) THEN...'}		 {bytecount := 2147483600;}		 IF plain_Boolean THEN         BEGIN		  errCode := setvol(NIL, plain_VolNum);		  Open(Plain, PlainName);	{random read/write, contents not erased}		  if not eof(Plain) then Seek(Plain,MaxLONGINT);{...find the eof}		  If not eof(plain) then putmessage('uh-oh! no eof for plain','','','');		 END;		 {spread created in d_results_options from Fit output options (write one at a time	  via add_a Fit or Batch fit), or Old Fit output options (write all at once)...}	     IF (do_ascii and spread_Boolean) THEN {do not do Spread for any see fit options}		 BEGIN		   errCode := setvol(NIL, spread_VolNum);		   Open(spread,spreadname);	{random read/write, contents not erased}		   if not eof(spread) then Seek(spread,MaxLONGINT);		   if not eof(spread) then putmessage('uh-oh! no eof in spread','','','');		 END;	    		  {variable Do_HallOutput used for Hall and CL...}		  IF (Do_HallOutput AND NOT binary_choice) THEN writeln(Plain, '           ', Hall_Name)		   ELSE writeln(Plain, '   Results from ', MCA_ResultsName);		   writeln(Plain, DateAndTimeStr);		 		 {already read 1st anal_res above...}		  if is_batch then LABELS_1(1);	{1:the expt info and column labels for Plain AND Spread}		  err := noErr;		  bytecount := sizeof(simplex_fit);		  J := 0; { counts Number of fits }		  WHILE err <> EOFerr DO { the next FSRead is just before END of WHILE}		  BEGIN			 J := J + 1;			 if (not is_batch) then LABELS_1(J); {J>1 means no col labels for Spread}			 FormatOutput; { if plain_boolean and/or spread_boolean the data							 is written to the selected files}			 err := FSRead(refnum, bytecount, (@Analysis_result^^)); { read binary fit file }		  END; {WHILE err <> EOFerr...}			  err := FSClose(refnum);		  err := FlushVol(NIL, MCA_Results_VolNum);	   END	{IF (See_Fit) or (do_ascii)...}	   ELSE BEGIN	{do this for add_a_fit or each write while doing Batch...}		 IF plain_Boolean THEN         BEGIN		  errCode := setvol(NIL, plain_VolNum);		  Open(Plain, PlainName);		  {bytecount := 2147483600;}		  if not eof(Plain) then Seek(Plain,MaxLONGINT);		  If not eof(plain) then putmessage('uh-oh! no eof for plain','','','');		 END;		  {spread created only in d_results_options; always written only one fit at a time...}		 IF (spread_Boolean) THEN		 BEGIN		   errCode := setvol(NIL, spread_VolNum);		   Open(spread,spreadname);			  { bytecount := 2147483600;}		   if not eof(spread) then Seek(spread,MaxLONGINT);		   if not eof(spread) then putmessage('uh_oh! no eof in spread','','','');		 END;		  		  if num_of_fits = 1 then	{num_of_fits is a global}		  Begin		    IF (Do_HallOutput AND NOT binary_choice) THEN writeln(Plain, '           ', Hall_Name)			ELSE writeln(Plain, '   Results from ', MCA_ResultsName);			writeln(Plain, DateAndTimeStr);			J := 1;	{so FormatOutput writes col labels for each line}			LABELS_1(1);	{the expt info AND col labels for Spread}			FormatOutput;		  End		  Else Begin		  {anal_res above is in memeory from fit...}		   J := 2; {for FormatOutput}		   if not is_batch then LABELS_1(J);	{the expt info but not Spread col labels}		 		   FormatOutput; { This will write all the formatted and prettied up stuff into						the just opened temporary file which will be reopened below and 						then put into the text edit record. This is done inside Function						ReadText called below. }		  End;	  	    END;	{IF see_fit or do_ascii...ELSE BEGIN}		    IF Plain_Boolean THEN	    begin          fndrInfo.fdcreator := 'MSWD';          fndrInfo.fdtype := 'TEXT';          fndrInfo.fdFlags := 0;	{set hasBundle bit, clear hasBeenInited bit}          errCode := setfinfo(PlainName, Plain_VolNum, fndrInfo);          numToString(errCode, str);          IF errCode <> noErr THEN            putmessage('setFinfo error just occured', 'in trying to set file info for "plain"', 'Error Number', str);		  close(Plain);          errcode := FlushVol(NIL, Plain_VolNum);      end;	  IF spread_Boolean THEN	  Begin			fndrInfo.fdcreator := spreadcreator;			fndrInfo.fdtype := 'TEXT';			fndrInfo.fdFlags := 0; { set bit 14 to 0 to make icon visible }			errcode := FSPSetfinfo(SpreadSpec, fndrInfo);						IF errcode <> NoErr THEN			  putmessage('setFinfo error just occured', 'in Rewrite(spread, spreadName)', '', '');		    close(Spread);			errcode := FlushVol(NIL, Spread_VolNum);	  End;	  plain_boolean := saveplain;	  spread_boolean := savespread;	  errCode := setvol(Save_Volume_Name, save_vol);    END; {of WriteFitResults}  {$S SANDIA3}   PROCEDURE WriteOneFit;    VAR      temp                          : integer;      fndrInfo                      : FInfo;      errCode                       : OSErr;      str, str1, str2, str3, str4, str5, str6, str8: str255;    PROCEDURE FormatOneOutput;     {  pretty up and format one Curve Fit output and write only the ASCII file for SHOW FIT.}      VAR        DateAndTimeStr                : str255;        Index, K, rn, np, wc          : integer;        index1, index2, ZZ            : integer;        Sum, Conc_SUM                 : real;        effic                         : real;        Alfa_effic, QKF, the_kV       : real;        PArea, PLB, PCB               : real;      BEGIN        WITH Analysis_result^^, SpectrumStuff, Acq_Info, Spectrum_Info, Fit_params, Fit_result, ExptStuff DO          BEGIN            writeln(onePlain, '');            SpinCursor;            DateAndTimeStr := CONCAT('           Fit to the Work Spectrum');            writeln(onePlain, DateAndTimeStr);            writeln(onePlain);            writeln(onePlain, 'Analyst: ', Plt_spec[10]^^.Expt_Info.Analyst);            writeln(onePlain, 'Specimen_ID: ', Plt_spec[10]^^.Expt_Info.Specimen_ID);            writeln(onePlain, 'Experiment Comments: ', Plt_spec[10]^^.Expt_Info.Specimen_Comment_Field);            writeln(onePlain, ' Spectrum from the file: ', MCA_Filename);            writeln(onePlain, ' Beam keV =  ', KV: 6: 3);            writeln(onePlain, ' Take Off Angle =  ', Take_Off_Angle: 6: 3); 		   if Plt_Spec[10]^^.Expt_Info.Detector.spec = EDS then		   writeln(onePlain, ' Mn FWHM (eV) =  ', Si_Resolution: 6: 3);		   if Plt_Spec[10]^^.Expt_Info.Detector.spec = WDS then		   writeln(onePlain, ' WDS Resolution =  ', WDS_Resolution: 6: 3);            IF (Normal_Output) THEN              BEGIN                writeln(onePlain, ' Si(Li) Dead Zone (um) = ', Si_Thickness: 6: 3);                writeln(onePlain, ' Detector Thickness (mm) =  ', Detector_Thickness: 6: 3);                writeln(onePlain, ' Detector Area (sq. mm) =  ', Detector_Area: 6: 3);                writeln(onePlain, ' Detector-Specimen distance (mm) =  ', Spec_Detector_Distance: 6: 3);                IF C_Thickness > 0.0 THEN writeln(onePlain, ' Carbon Window Component =  ', C_Thickness: 6: 3);                IF Ice_Thickness > 0.0 THEN writeln(onePlain, ' Ice (as Oxygen) =  ', Ice_Thickness: 6: 3);                IF Be_Thickness > 0.0 THEN writeln(onePlain, ' Be Thickness =  ', Be_Thickness: 6: 3);                IF Au_Thickness > 0.0 THEN writeln(onePlain, ' Au Thickness =  ', Au_Thickness: 6: 3);                IF Mylar > 0.0 THEN writeln(onePlain, ' Mylar Thickness =  ', Mylar: 6: 3);                IF Moxtek > 0.0 THEN writeln(onePlain, ' Moxtek Thickness =  ', Moxtek: 6: 3);                IF Paralene > 0.0 THEN writeln(onePlain, ' Paralene Thickness =  ', Paralene: 6: 3);                IF BN_Thickness > 0.0 THEN writeln(onePlain, ' BN Thickness =  ', BN_Thickness: 6: 3);                IF SiN_Thickness > 0.0 THEN writeln(onePlain, ' Si3N4 Thickness =  ', SiN_Thickness: 6: 3);                writeln(onePlain, ' Elevation Angle =  ', elevation: 6: 3);                writeln(onePlain, ' Azimuth Angle =  ', azimuth: 6: 3);              END;            IF Fit_Procedure = 'Sm' THEN              BEGIN                writeln(onePlain, ' Exit Tolerence =  ', Toler: 13: 9);                IF constrained THEN                  BEGIN                    writeln(onePlain, ' Starting estimate for resolution(eV): ', FWStart: 5: 2, '; Resolution Constraint(eV) was ',                            DFWHMM: 6: 3);                    writeln(onePlain, '                                              Energy Constraint (eV) was ', DEN: 6: 3);                  END                ELSE writeln(onePlain, ' Starting estimate for resolution(eV): ', FWStart: 5: 2, '; No constraints.');              END;            writeln(onePlain);            Number_of_PeakRois := Number_of_Windows + 1;            FOR Index := 1 TO Number_of_PeakRois - 1 DO              BEGIN                index1 := First_in_Roi[Index]; { number of 1st pk in window }                IF (Index = Number_of_PeakRois - 1) { in the last ROI }                   THEN                  index2 := number_of_peaks                ELSE { before the last ROI }                  index2 := First_in_Roi[Index + 1] - 1;                FOR K := index1 TO index2 DO                  BEGIN                    str := CONCAT(A^.Sym[Atomic_number[K]], Siegbahn[K]);                    IF (Siegbahn[K] = 'K    ') OR (Siegbahn[K] = 'KA1  ') OR (Siegbahn[K] = 'L    ') OR (Siegbahn[K] = 'LA1  ') OR                       (Siegbahn[K] = 'M    ') OR (Siegbahn[K] = 'MA1  ') OR (Siegbahn[K] = 'Stoic') OR (Siegbahn[K] = 'Diff ') OR                       (Siegbahn[K] = 'Fixed') THEN                      IF (str[2] <> 'A') AND (str[3] <> '2') AND (str[6] <> 'D') THEN                        BEGIN                          str1 := CONCAT(str, ': Area');                          str2 := CONCAT(str, ': P/Lcl bg');                          str3 := CONCAT(str, ': P/Chosen bg');                          str4 := CONCAT(str, ': concentration');                          str5 := CONCAT(str, ': Det. Eff.');                          str6 := CONCAT(str, ': Eff*Q¥F¥Omega/A');                        END; { If ((str[2]<>'A') and...}                  END;              END; { FOR Index := 1 TO Number_of_PeakRois - 1}            IF Fit_Procedure = 'ML' THEN              BEGIN                rn := 1;                WHILE (Ref_FileName[rn] <> '') DO                  BEGIN                    str1 := CONCAT(' From Reference file ', Ref_FileName[rn], ': ');                    wc := 0;                    FOR np := 1 TO Analysis_result^^.Fit_params.number_of_peaks DO                      BEGIN                        IF (Siegbahn[np][4] <> 'D') THEN                          BEGIN                            wc := wc + 1; { ref_index is not valued for derivatives }                            IF (ref_index[wc] = rn) THEN str1 := CONCAT(str1, A^.Sym[Atomic_number[np]], Siegbahn[np]);                          END;                      END; {FOR np :=...}                    writeln(onePlain, str1);                    rn := rn + 1;                  END; {WHILE...}              END; {IF Fit_Procedure = 'ML' THEN...}            writeln(onePlain, ' Quant Background Region = ', Chosen_ROI_Lo: 6: 3, ' : ', Chosen_ROI_Hi: 6: 3);            writeln(onePlain);            numToString(Spectrum_Number, str1);            IF Spectrum_Comment_Field = '' THEN str := CONCAT(str1, ':   No Comments')            ELSE str := CONCAT(str1, ':   ', Spectrum_Comment_Field);            IF Spectrum_Class = '' THEN str1 := 'Spectrum class: Unknown.'            ELSE str1 := CONCAT('Spectrum class: ', Spectrum_Class);            IF (Theoretically_Generated) THEN str1 := CONCAT(' Spectrum was generated; Spectrum class: ', Spectrum_Class)            ELSE IF (This_is_a_Standard) THEN str1 := CONCAT(' Spectrum is a standard');            writeln(onePlain, str);            IF (Theoretically_Generated) OR (This_is_a_Standard) THEN writeln(onePlain, str1)            ELSE IF Length(Spectrum_Class) > 0 THEN writeln(onePlain, ' Spectrum class: ', Spectrum_Class);            writeln(onePlain, ' Live and Real Time: ', Live_Time: 6, '   ', Real_Time: 6);            writeln(onePlain, ' Begin and End Faraday Current =  ', Begin_Faraday: 6: 3, '   ', End_Faraday: 6: 3);            Conc_SUM := 0.0;            FOR Index := 1 TO Number_of_PeakRois - 1 DO              BEGIN                index1 := First_in_Roi[Index]; { number of 1st pk in window }                IF (Index = Number_of_PeakRois - 1) { in the last ROI }                   THEN                  index2 := number_of_peaks                ELSE { before the last ROI }                  index2 := First_in_Roi[Index + 1] - 1;                writeln(onePlain, '    Fitting Region = ', Fitting_ROI_Lo[Index]: 6: 3, ' : ', Fitting_ROI_Hi[Index]: 6: 3);                IF Fit_Procedure = 'ML' THEN                  writeln(onePlain, '   Chi Square = ', Response[Index]: 6: 5, '               FWHM Mn = ', FWHM_Mn[Index]: 4: 1,                          '    Iterations=', Iterations[Index]: 4)                ELSE                  writeln(onePlain, '   Chi Square = ', Response[Index]: 6: 5, '    Calculated FWHM Mn = ', FWHM_Mn[Index]: 4: 1,                          '    Iterations=', Iterations[Index]: 4);                IF Fit_Procedure = 'ML' THEN                  writeln(onePlain, 'SYM  LINE         AREA          FITSigma              P/B(10eV)      P/Chsn            CONC  ')                   ;                IF Fit_Procedure = 'Sm' THEN                  writeln(onePlain, 'SYM  LINE         AREA           ENERGY               P/B(10eV)      P/Chsn            CONC ');                 str8 := '              --         ';                Z := 0;                FOR K := index1 TO index2 DO                  BEGIN                    IF Z <> Atomic_number[K] THEN                    BEGIN						IF (ref_index[K] = -1) THEN 						BEGIN							write(onePlain,A^.Sym [Atomic_number[K]], '  ');							writeln(onePlain, Siegbahn[K][1], ' not fit in this ROI.');						END						ELSE IF (Fit_Procedure = 'ML') AND (ref_index[K] = 0) THEN						BEGIN							write(onePlain,A^.Sym [Atomic_number[K]], '  ');							writeln(onePlain, Siegbahn[K][1], ' not fit; no reference for lines in this ROI.');						END;						Sum := MyStr2Num('0.0');						Z := Atomic_number[K];                    END;					IF (((Fit_Procedure = 'ML') AND (ref_index[K] > 0)) or 						((Fit_procedure = 'Sm') and (Ref_Index[k] <> -1))) and						 (Siegbahn[K] <> 'KA2  ') THEN					BEGIN						  IF (Siegbahn[K] = 'KA1  ') THEN						  BEGIN { sum A1 and A2 }							PCB := Peak_to_Chosen_Bkg[K] + Peak_to_Chosen_Bkg[K + 1];							realtostring(PCB, 5, 3, str1);							IF ItsNaN(str1) THEN PCB := 0.0;							PLB := Peak_to_Local_Bkg[K] + Peak_to_Local_Bkg[K + 1];							realtostring(PLB, 5, 3, str1);							IF ItsNaN(str1) THEN PLB := 0.0;							write(onePlain, A^.Sym[Atomic_number[K]], '  KA1,2  ', (Area[K] + Area[K + 1]): 11: 3, (2 *								  Err_or_Energy[K] + Err_or_Energy[K + 1]) / 3: 18: 4, PLB: 19: 3, PCB: 14: 3);							Sum := Sum + Area[K] + Area[K + 1];						  END { IF (Siegbahn[K] = 'KA1 '...}                          ELSE                            IF NOT ((Siegbahn[K][4] = 'D') AND (Reduced_Output)) THEN                              BEGIN                                PCB := Peak_to_Chosen_Bkg[K];                                realtostring(PCB, 5, 3, str1);                                IF ItsNaN(str1) THEN PCB := 0.0;                                PLB := Peak_to_Local_Bkg[K];                                realtostring(PLB, 5, 3, str1);                                IF ItsNaN(str1) THEN PLB := 0.0;                                write(onePlain, A^.Sym[Atomic_number[K]], '  ');                                write(onePlain, Siegbahn[K], '  ', Analysis_result^^.Fit_result.Area[K]: 11: 3);                                write(onePlain, Err_or_Energy[K]: 18: 4);                                write(onePlain, PLB: 19: 3);                                write(onePlain, PCB: 14: 3);                                Sum := Sum + Area[K];                              END; {IF NOT (( Siegbahn[K][4])...}                          IF NOT (Conc[K] < -0.99) AND NOT (Siegbahn[K][4] = 'D') THEN                            BEGIN	                          if NOT (This_is_a_Standard) then          {%%& 9/15/92 &%%}							    Conc_SUM := Conc_SUM + Conc[K];                              writeln(onePlain, Conc[K]: 19: 6);                            END                          ELSE writeln(onePlain, str8);                          IF ((Fit_Procedure = 'Sm') AND ((K = index2) OR (Z <> Atomic_number[K + 1]))) THEN                            writeln(onePlain, 'Sum =        ', Sum: 10: 3);                    END; { IF (((Fit_Procedure = 'ML') AND...(Siegbahn[K] <> 'KA2 ')...}                  END; {K loop}                IF (Bulk_Physics_Boolean) AND (Fit_Procedure = 'Sm') THEN                  BEGIN                    Sum := 0.0;                    FOR K := index1 TO index2 DO { Get the sum of all the areas }                      BEGIN					effic := f_chi_P^[rinttol(Err_or_Energy[K] * 100)] * Det_Effic_P^[rinttol(Err_or_Energy[K] * 100)];                        Sum := Sum + Area[K] / effic;                      END;				Alfa_effic := f_chi_P^[rinttol(Err_or_Energy[index1] * 100)] * Det_Effic_P^[rinttol(Err_or_Energy[index1] * 100)];                    writeln(onePlain);                    writeln(onePlain, 'LINE          GEN. AREA        F(chi)     GEN.(Pk/Alfa)      GEN.(Pk/Sum)');                    FOR K := index1 TO index2 DO                      BEGIN					effic := f_chi_P^[rinttol(Err_or_Energy[K] * 100)] * Det_Effic_P^[rinttol(Err_or_Energy[K] * 100)];                        IF Siegbahn[K] = 'KA1  ' THEN                          writeln(onePlain, 'KA1,2       ', (Area[K] + Area[K + 1]) / (effic * Faraday_Current * 6.24196E9 *							  Live_Time * Domega / (4 * PI)), f_chi_P^[rinttol(Err_or_Energy[K] * 100)]: 14: 8, (Area[K] /                                  effic) / (Area[index1] / Alfa_effic): 13: 8, '     ', (Area[K] / effic) / Sum: 13: 8)                        ELSE                          IF Siegbahn[K] <> 'KA2  ' THEN                            writeln(onePlain, Siegbahn[K], '       ', Area[K] / (effic * Faraday_Current * 6.24196E9 * Live_Time *								Domega / (4 * PI)), f_chi_P^[rinttol(Err_or_Energy[K] * 100)]: 14: 8, (Area[K] / effic) / (Area                                    [index1] / Alfa_effic): 13: 8, '     ', (Area[K] / effic) / Sum: 13: 8);                      END; { K }                  END; { if Bulk_Physics_Boolean then..... }                FOR K := index1 TO index2 DO                  BEGIN                    IF (Siegbahn[K] = 'K    ') OR (Siegbahn[K] = 'KA1  ') OR (Siegbahn[K] = 'L    ') OR (Siegbahn[K] = 'LA1  ') OR                       (Siegbahn[K] = 'M    ') OR (Siegbahn[K] = 'MA1  ') OR (Siegbahn[K] = 'Stoic') OR (Siegbahn[K] = 'Diff ') OR                       (Siegbahn[K] = 'Fixed') THEN                      BEGIN                        ZZ := Atomic_number[K];                        Get_Energies(ZZ);                        QKF := 1;                        PArea := Area[K];                        PLB := Peak_to_Local_Bkg[K];                        PCB := Peak_to_Chosen_Bkg[K];                        IF (Siegbahn[K] = 'KA1  ') THEN                          BEGIN                            PArea := 1.5 * PArea;                            PLB := 1.5 * PLB;                            PCB := 1.5 * PCB;                          END;						  effic := eV_Line[1] / Plt_spec[10]^^.Expt_Info.dE;							if effic < 8191.0 then								effic := Det_Effic_P^[rinttol(eV_Line[1] / Plt_spec[10]^^.Expt_Info.dE)]							else effic := 0.0;                        IF Running_Thin_Mode OR Running_Bulk_Mode THEN                          BEGIN                            IF Running_Thin_Mode THEN the_kV := Thin_KV                            ELSE IF Running_Bulk_Mode THEN the_kV := Bulk_KV;                            IF (Siegbahn[K][1] = 'K') THEN QKF := Qk(the_kV, A^.edge[1]) * WK(ZZ) * SAK(ZZ)                            ELSE                              IF (Siegbahn[K][1] = 'L') THEN QKF := Ql(the_kV, A^.edge[4]) * WL(ZZ) * SAL(ZZ)                              ELSE IF (Siegbahn[K][1] = 'M') THEN QKF := Qm(the_kV, A^.edge[9]) * WM(ZZ) * SAM(ZZ);                          END; {IF Running_Thin_Mode or...}                        QKF := QKF * effic / Atomic_Weight;                      END; {IF (Siegbahn[K] =...}                  END; { For K:=index1 to index2 do }                Sum := 0.0;                writeln(onePlain);              END; { for index :=1... ie window counter}			   if (Conc_SUM <> 0) and (not Hall_active) and (not do_HallOutput) then			    begin				   write(onePlain, '                                                       Concentration SUM =');				   writeln(onePlain, Conc_SUM: 19: 6);                end;				          END; { big WITH......}        ChangeCursor(ArrowC);      END; {of procedure FormatOneOutput for one plain output}    BEGIN { WriteOneFit }      { A file MUST be created to review one fit result}      IF (Analysis_result^^.Fit_params.Fit_Procedure = 'ML') THEN        Filename := 'OneMLFit' {filename is a golbal variable: use in call to ReviewFitResults}      ELSE IF (Analysis_result^^.Fit_params.Fit_Procedure = 'Sm') THEN Filename := 'OneSimplexFit';      errCode := getvol(Save_Volume_Name, save_vol);      errCode := setvol(NIL, MCA_Results_VolNum);      Rewrite(onePlain, Filename);      Rewrite(onePlain);      temp := IOResult;      numToString(temp, str);      str := CONCAT('Error Number is ', str);      str1 := CONCAT('For File Name: ', Filename);      IF temp <> 0 THEN putmessage('Failure to "ReWrite" the  TEXT File', str, str1, '');      fndrInfo.fdcreator := 'MSWD';      fndrInfo.fdtype := 'TEXT';      fndrInfo.fdFlags := 0{100};      errCode := setfinfo(Filename, MCA_Results_VolNum, fndrInfo);      numToString(errCode, str);      IF errCode <> noErr THEN        putmessage('setFinfo error just occured', 'in trying to set file info for one fit result;', ' Error Number', str);     	  FormatOneOutput;	{writes the text}      Close(onePlain); {close the file after writing is finished}      errCode := FlushVol(NIL, MCA_Results_VolNum);      errCode := setvol(Save_Volume_Name, save_vol);    END; {of WriteOneFit}  FUNCTION ReadText(wPtr: WindowPtr; texthndl: TEHandle; Filename: str255; VolNum: integer): boolean;{ Read text file from volNum:fileName.  Function returns TRUE if text  is loaded into memory. }    VAR      Error                         : boolean;      fileNum                       : integer;      len                           : Longint;      hCopy                         : Handle;         { Copy of textEdit rec's hText handle }    BEGIN      Error := true; { Unless all of the following succeeds }      IF FSOpen(Filename, VolNum, fileNum) = noErr THEN      BEGIN          IF GetEOF(fileNum, len) = noErr THEN { Get file length }            IF SetFPos(fileNum, FSFromStart, 0) = noErr THEN { Reset to top }			BEGIN			  hCopy := texthndl^^.htext; { Copy hText handle }			  SetHandleSize(hCopy, len); { Reserve memory to hold text }			  len := GetHandleSize(hCopy); { len=actual bytes reserved }			  IF FSRead(fileNum, len, hCopy^) = noErr THEN				WITH texthndl^^ DO				BEGINif len >= 32766 then beepbeep;beepbeep;beepbeep;								  if len <= 32766 then teLength := len { Save length in TERec }				  else teLength := 32766;				  TECalText(texthndl); { WARNING: might compact heap! }				  Error := false { Tell caller all is okay }				END { with }			END; { if }          IF FSClose(fileNum) <> noErr { Close text file }             THEN            Error := true;          IF NOT Error THEN            BEGIN              BackColor(WhiteColor);              ForeColor(BlackColor);              InvalRect(wPtr^.portRect); { Force display of text in window }            END; { if }        END; { if }      ReadText := NOT Error; { Report function result }    END; { of procedure ReadText }  PROCEDURE ReviewFitResults {(Filename:fnamestr; VolNum:integer)} ;    { purpose: writes a summary of the input data and the computed      output into the Output Window. returns true & real data if      successful, or false & dummy data if canceled.}    VAR      defaultMSG1                   : str255;      activefontinfo                : Fontinfo;    BEGIN      {if Plain_Boolean = False then WriteFitResults; done before this is called}      IF Fit_Invisibly = false THEN        BEGIN          SetPort(MAINPtr); {set main window to current graf port}          SelectWindow(MAINPtr); {and make it active}          {ShowWindow(MAINPtr);}          BackColor(WhiteColor);          ForeColor(BlackColor);          GetFontInfo(activefontinfo);          WITH activefontinfo DO            BEGIN {set single line spacing the active font}              MAINtextHndl^^.lineHeight := ascent + descent + leading;              MAINtextHndl^^.fontAscent := ascent;            END;          WITH MAINPtr^.portRect DO            BEGIN             SetRect(MAINtextHndl^^.viewrect, 0, 0, Right - 0, Bottom - 16);{reset view rectangle}            END;          InvalRect(MAINPtr^.portRect);          TEAutoView(true, MAINtextHndl); {enable auto scrolling}          EraseRect(WindowPeek(MAINPtr)^.port.portRect); {clear the output window} ;          TESetSelect(0, 32766, MAINtextHndl); {select any existing textÉ}          TEDelete(MAINtextHndl); {and delete it}          TEIdle(MAINtextHndl); {re-position the insertion point}          TEUpdate(MAINtextHndl^^.destrect, MAINtextHndl); {re-draw the text in active Window}          ShowWindow(MAINPtr);        END; { if Fit_Invisibly = False }      {read the file into the text edit record for the window, This is done inside Function ReadText}      IF ReadText(MAINPtr, MAINtextHndl, Filename, VolNum) = false THEN        BEGIN          defaultMSG1 := 'No File was found to read into this window.';          TESetText(@defaultMSG1[1], Length(defaultMSG1), MAINtextHndl);        END;      IF Fit_Invisibly = false THEN        BEGIN          WITH MAINPtr^.portRect DO           SetRect(MAINtextHndl^^.viewrect, 0, 0, Right - 0, Bottom - 16);{reset view rectangle}          BackColor(WhiteColor);          ForeColor(BlackColor);          InvalRect(MAINPtr^.portRect); {force an update}          TEAutoView(true, MAINtextHndl); {enable auto scrolling}          BeginUpdate(MAINPtr); {signal start of update}          EraseRect(WindowPeek(MAINPtr)^.port.portRect);          TEUpdate(MAINtextHndl^^.destrect, MAINtextHndl); {re-draw the text in active Window}          SetScrollbarLimits(MAINPtr, MAINtextHndl); {adjust scroll stuff}          ShowControl(MAINVscrollhndl);          DrawGrowIcon(MAINPtr);          DrawControls(MAINPtr);          EndUpdate(MAINPtr);        END; { if Fit_Invisibly = False }    END; {of Review Fit Results}	  FUNCTION ItsMyWindow(wPtr: WindowPtr): boolean;    BEGIN      IF (wPtr = MAINPtr) THEN ItsMyWindow := true      ELSE ItsMyWindow := false;    END; {of function ItsMyWindow}    {----------------------------------------------------------------------------}PROCEDURE CommonAction(control: ControlHandle; VAR amount: INTEGER);{----------------------------------------------------------------------------}VAR	value, max	: INTEGER;	{window		: WindowPtr;}BEGIN	value := GetControlValue(control);	max := GetControlMaximum(control);	amount := value - amount;		IF (amount < 0) THEN BEGIN		amount := 0;	END	ELSE IF (amount > max) THEN BEGIN		amount := max;	END;		SetControlValue(control, amount);	amount := value - amount;END;    {----------------------------------------------------------------------------}PROCEDURE VActionProc(control: ControlHandle; part: INTEGER);{----------------------------------------------------------------------------}VAR	amount	: INTEGER;	window	: WindowPtr;BEGIN	IF (part <> 0) THEN BEGIN		window := control^^.contrlOwner;		WITH  MAINtextHndl^^ DO BEGIN			CASE part OF							kControlUpButtonPart, kControlDownButtonPart: BEGIN					amount := 1;				END;									kControlPageUpPart, kControlPageDownPart: BEGIN					amount := (viewRect.bottom - viewRect.top) DIV lineHeight;				END;							END;						IF ((part = kControlDownButtonPart) | (part = kControlPageDownPart)) THEN BEGIN				amount := -amount;			END;						CommonAction(control, amount);						IF (amount <> 0) THEN BEGIN				TEScroll(0, amount * MAINtextHndl^^.lineHeight, MAINtextHndl);			END;					END;	END;END;{----------------------------------------------------------------------------}PROCEDURE AdjustHV(isVert: BOOLEAN; control: ControlHandle; docTE: TEHandle; canRedraw: BOOLEAN);{----------------------------------------------------------------------------}CONST	kCRChar				= 13;	{kMaxDocWidth		= 576;}VAR	value, lines, max	: INTEGER;	oldValue, oldMax	: INTEGER;	BEGIN	oldValue := GetControlValue(control);	oldMax := GetControlMaximum(control);		IF (isVert) THEN BEGIN		lines := MAINtextHndl^^.nLines;		IF (Ptr(ORD(MAINtextHndl^^.hText^) + MAINtextHndl^^.teLength - 1)^ = kCRChar) THEN BEGIN			lines := lines + 1;		END;		max := lines - ((MAINtextHndl^^.viewRect.bottom - MAINtextHndl^^.viewRect.top) DIV MAINtextHndl^^.lineHeight);	{END	ELSE BEGIN		max := kMaxDocWidth - (MAINtextHndl^^.viewRect.right - MAINtextHndl^^.viewRect.left);}	END;		IF (max < 0) THEN BEGIN		max := 0;	END;		SetControlMaximum(control, max);		IF (isVert) THEN BEGIN		value := (MAINtextHndl^^.viewRect.top - MAINtextHndl^^.destRect.top) DIV MAINtextHndl^^.lineHeight;	{END	ELSE BEGIN		value := MAINtextHndl^^.viewRect.left - MAINtextHndl^^.destRect.left;}	END;		IF (value < 0) THEN BEGIN		value := 0;	END	ELSE IF (value > max) THEN BEGIN		value := max;	END;		SetControlValue(control, value);		IF (canRedraw & ( (max <> oldMax) | (value <> oldValue))) THEN BEGIN		ShowControl(control);	END;	END;    (*¥* replace AsmClikLoop, GetOldClikLoop, & PascalClikLoop with myClikLoop *¥*){----------------------------------------------------------------------------}FUNCTION myClikLoop : BOOLEAN;{----------------------------------------------------------------------------}VAR	window	: WindowPtr;	region	: RgnHandle;	mouse		: Point;	canRedraw	: boolean;BEGIN	window := FrontWindow;	region := NewRgn;	GetClip(region);	ClipRect(window^.portRect);	GetMouse(mouse);		WITH DocumentPeek(window)^ DO BEGIN		IF (mouse.v < MAINtextHndl^^.viewRect.top) THEN BEGIN			VActionProc(MAINVscrollhndl, kControlUpButtonPart);		END		ELSE IF (mouse.v > MAINtextHndl^^.viewRect.bottom) THEN BEGIN			VActionProc(MAINVscrollhndl, kControlDownButtonPart);		END;		(*IF (mouse.h > MAINtextHndl^^.viewRect.right) THEN BEGIN			HActionProc(docHScroll, kControlDownButtonPart);		END		ELSE IF (mouse.h < MAINtextHndl^^.viewRect.left) THEN BEGIN			HActionProc(docHScroll, kControlUpButtonPart);		END;*)	END;		{AdjustScrollValues(window, TRUE);}	AdjustHV(TRUE, MAINVscrollhndl, MAINtextHndl, canRedraw);	SetClip(region);	DisposeRgn(region);	myClikLoop := TRUE;END;   PROCEDURE Initialize_MAIN;    VAR      activefontinfo                : Fontinfo;    BEGIN      SetWindowLimits(ScreenArea, MaxWindowRect, DragArea, GrowArea); {must do once}      OpenMainWindow; {opens a visible main window}      SetPort(MAINPtr); {set main window to current graf port}      SelectWindow(MAINPtr); {and make it active}      BackColor(WhiteColor);      ForeColor(BlackColor); 	(*¥* allocate UPPs required and check for success *¥*)   gVscrollUPP := NewRoutineDescriptor(@VActionProc,uppControlActionProcInfo,GetCurrentISA);  { gHscrollUPP := NewRoutineDescriptor(@HActionProc,uppControlActionProcInfo,GetCurrentISA);}   gClikLoopUPP := NewRoutineDescriptor(@myClikLoop,uppTEClickLoopProcInfo,GetCurrentISA);      ActiveWindow := MAINPtr;      GetFontInfo(activefontinfo);      WITH activefontinfo DO        BEGIN {set single line spacing the active font}          MAINtextHndl^^.lineHeight := ascent + descent + leading;           MAINtextHndl^^.fontAscent := ascent;        END;      SetWTitle(MAINPtr, 'Output');      BackColor(WhiteColor);      ForeColor(BlackColor);      EraseRect(WindowPeek(MAINPtr)^.port.portRect); {clear the output window} ;      TESetSelect(0, 32767, MAINtextHndl); {select any existing textÉ}      TEDelete(MAINtextHndl); {and delete it}      TEIdle(MAINtextHndl); {re-position the insertion point}      TEUpdate(MAINtextHndl^^.destrect, MAINtextHndl);    END; {of proc Initialize}  PROCEDURE HandleClick(VAR wPtr: WindowPtr; MLoc: Point; VAR texthndl: TEHandle);    VAR      whichControl                  : ControlHandle;      part                          : integer;    BEGIN      IF (ItsMyWindow(wPtr) = true) AND {if this is one of my windowsÉ}         (wPtr <> Frontwindow) THEN        SelectWindow(wPtr)      ELSE        IF (ItsMyWindow(wPtr) = true) THEN          BEGIN            WITH wPtr^.portRect DO             SetRect(texthndl^^.viewrect, 0, 0, Right - 16, Bottom - 16);{reset view rectangle}            GlobalToLocal(MLoc); {because these operations need it that way}            SetScrollbarLimits(Frontwindow, texthndl); {adjust the scrollbar stuff}            part := FindControl(MLoc, wPtr, whichControl); {find out where the click happened}            IF whichControl <> NIL THEN {click was in a control}              BEGIN                IF part = kControlIndicatorPart THEN {while in thumb, do things the system's wayÉ}                  BEGIN                    thumbvalue := GetControlValue(MAINVscrollhndl);                    part := TrackControl(whichControl, MLoc, {gVscrollUPP} NIL);                    WITH texthndl^^ DO                      BEGIN						IF (part <> 0) THEN BEGIN						thumbvalue := thumbvalue - GetControlValue(MAINVscrollhndl);						IF (thumbvalue <> 0) THEN BEGIN                        IF whichControl = MAINVscrollhndl THEN                          BEGIN                            TEScroll(0, thumbvalue * lineHeight, texthndl);                           (* TEScroll(0, viewrect.Top - destrect.Top, texthndl);                            TEScroll(0, - (thumbvalue - 1) * lineHeight, texthndl);*)                          END;                          END;                         END;                      END;                  END                ELSE {otherwise, allow repetition while mouse held down}                  BEGIN                    thumbvalue {part} := TrackControl(whichControl, MLoc, gVscrollUPP);                  END;              END;          END;    END; {of proc HandleClick}  PROCEDURE HandleGoAway(wPtr: WindowPtr; MLoc: Point);    VAR      Wpeek                         : WindowPeek;     {for looking at windows}    BEGIN      IF ItsMyWindow(wPtr) = true {if it's one of my windows}         THEN        BEGIN          IF wPtr = Frontwindow THEN {if it's the active window}            BEGIN              IF TrackGoAway(wPtr, MLoc) {if the GoAway box is clicked}                 THEN                BEGIN                  IF ItsMyWindow(wPtr) = true {if it's one of my windows}                     THEN                    BEGIN                      IF wPtr = MAINPtr THEN                        BEGIN                          HideWindow(MAINPtr);                          Mouse_Active_Window;                          Update_Full;                        END;                    END                  ELSE                    BEGIN                      Wpeek := WindowPeek(wPtr);                      CloseDeskAcc(Wpeek^.windowKind); {close DeskAcc, & return to last frontwindow}                    END;                END;            END;        END;    END; {of proc HandleGoAway}  PROCEDURE HandleGrow(wPtr: WindowPtr; MLoc: Point; texthndl: TEHandle);   { purpose, handle mouse click in grow box }    TYPE      GrowRec                       =        RECORD          CASE integer OF            0:              (result                        : Longint);            1:              (Height, Width                 : integer)        END;    VAR      GrowInfo                      : GrowRec;    BEGIN	{this does not properly refresh the rect for the lower scroll bar,			 but neither is the lower scroll bar region defined anywhere!!!???}      IF ItsMyWindow(wPtr) = true {if it's one of my windows}         THEN        BEGIN          WITH GrowInfo DO            BEGIN              result := GrowWindow(wPtr, MLoc, GrowArea); {get amt of growth}			  {GrowArea is a rect which gives the new min and max vertical and horizontal			   measurements for the window's portrect}              {if we 'grow' the window, the area outside the content region but inside			   the frame, ie the region generally used for the lower scroll bar which is			   NOT defined for this window will not be updated unless it is covered			   by the new content region}                             			   SizeWindow(wPtr, Width, Height, true);			   { ...resizes window and accumulates newly created part of content region			     into update region ...accumulates if it gets bigger}              WITH wPtr^.portRect DO {deal with scroll bars}				  setrect(bottomRect,1, Bottom - 15, Right - 16, Bottom - 1);				  InvalRect(bottomRect);				  eraserect(bottomrect);				  Beepbeep;Beepbeep;              			  WITH wPtr^.portRect DO {deal with scroll bars}                BEGIN                  SizeControl(MAINVscrollhndl, 16, Bottom - Top - 13); {re-size rect for Vertical scroll bar}                  MoveControl(MAINVscrollhndl, Right - 15, Top - 1); {re-position rect for Vertical scroll bar}                END;            END;          BackColor(WhiteColor);          ForeColor(BlackColor);                    WITH wPtr^.portRect DO            SetRect(texthndl^^.viewrect, 0, 0, Right - 16, Bottom - 16); {reset view rectangle}		  		  TEUpdate(texthndl^^.destrect, texthndl); {re-draw the text in active Window}          InvalRect(wPtr^.portRect);          DrawGrowIcon(wPtr);          DrawControls(wPtr);	{does the vertical scroll bar only since there is no horizontal		  						 scroll bar control}	{Beepbeep;Beepbeep;Beepbeep;Beepbeep;Beepbeep;}        END;	{ IF ItsMyWindow(wPtr) ...}    END; {of proc HandleGrow}  PROCEDURE DoMouseDown(theEvent: EventRecord; VAR ActivetextHndl: TEHandle);   { purpose identify where mouse was clicked and handle it }    VAR      theWindow                     : WindowPtr;      WLoc                          : integer;    BEGIN      theMouseLocation := theEvent.where; {get mouse position in global co-ordinates}      WLoc := FindWindow(theMouseLocation, theWindow); {get window, location in window}      CASE WLoc OF {handle window locations}        InContent:	{ in scroll bar for example...}          HandleClick(theWindow, theMouseLocation, ActivetextHndl); {inside the window}        InGoAway:		  begin           HandleGoAway(theWindow, theMouseLocation); {in the go away box}		   OffScreen_2_OnScreen;		  end;        InGrow:		  begin			HandleGrow(theWindow, theMouseLocation, ActivetextHndl);			OffScreen_2_OnScreen;{take this away and the spectrum area only does not refresh}		  end;        END    END; {of proc DoMouseDown}  PROCEDURE DoActivate(theEvent: EventRecord; VAR ActivetextHndl: TEHandle);    VAR      AFlag                         : boolean;      theWindow                     : WindowPtr;      activefontinfo                : Fontinfo;    BEGIN      WITH theEvent DO        BEGIN          theWindow := WindowPtr(Message); {get the pointer to the window}          AFlag := Odd(modifiers); {if odd = true, activate theWindow,}          {if odd = false, = deactive}          IF AFlag = true THEN            BEGIN {if it's being activatedÉ}              SetPort(theWindow); {make it the active grafport}              IF theWindow = MAINPtr {next, find the correct Hndl's}                 THEN                BEGIN                  GetFontInfo(activefontinfo);                  WITH activefontinfo DO                    BEGIN {set single line spacing the active font}                      ActivetextHndl^^.lineHeight := ascent + descent + leading;                      ActivetextHndl^^.fontAscent := ascent;                    END;                  WITH theWindow^.portRect DO                    BEGIN                      SetRect(ActivetextHndl^^.viewrect, 0, 0, Right - 16, Bottom - 16);{reset view rectangle}                    END;                  BackColor(WhiteColor);                  ForeColor(BlackColor);				  BeginUpdate(theWindow);				  EraseRect(theWindow^.portRect);                  TEUpdate(ActivetextHndl^^.destrect, ActivetextHndl);                  InvalRect(theWindow^.portRect);                  TEAutoView(true, ActivetextHndl); {enable auto scrolling}                  DrawGrowIcon(MAINPtr);                  DrawControls(MAINPtr);				  EndUpdate(theWindow);                END;            END          ELSE            BEGIN {if it's been deactivatedÉ}              {SetPort(grafPtr(ScreenPort));} { reassign port }            END;        END;    END; {of proc DoActvate}  PROCEDURE DoUpdate(theEvent: EventRecord; texthndl: TEHandle);{    purpose         handles window update event.                    will only update my front window.}    VAR      theWindow                     : WindowPtr;    BEGIN      theWindow := WindowPtr(theEvent.Message); {find which window}      IF ItsMyWindow(theWindow) = true {if it's one of my windows}         THEN        BEGIN(*	beepbeep;beepbeep;*)          GetPort(GrafPtr(SavePort)); {save current grafport}          SetPort(theWindow); {set WPtr as current port}          BeginUpdate(theWindow); {signal start of update}          BackColor(WhiteColor);          ForeColor(BlackColor);         EraseRect(WindowPeek(MAINPtr)^.port.portRect);          IF (theWindow = MAINPtr) THEN            BEGIN              BackColor(WhiteColor);              ForeColor(BlackColor);              TEUpdate(texthndl^^.destrect, texthndl); {re-draw the text in active Window}              SetScrollbarLimits(theWindow, texthndl); {adjust scroll stuff}              DrawGrowIcon(theWindow);              DrawControls(theWindow);            END;          {now, back to our programÉ}          EndUpdate(theWindow); {signal end of update}(*beepbeep;beepbeep;beepbeep;beepbeep;*)		  SetPort(GrafPtr(SavePort)); {restore original grafport}        END;    END; {of proc DoUpdate}  PROCEDURE HandleMAINEvent {(theEvent : EventRecord;var ActivetextHndl : TEHandle)} ;    BEGIN      CASE theEvent.What OF        mouseDown:          DoMouseDown(theEvent, MAINtextHndl); {mouse button pushed}        updateEvt:          DoUpdate(theEvent, MAINtextHndl); {window need updating}        activateEvt:          DoActivate(theEvent, MAINtextHndl); {window made act/inact}        END    END; {of proc HandleEvent}END. { of UNIT SANDIA }