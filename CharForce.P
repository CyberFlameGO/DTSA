unit CharForce;interface	uses		QuickDraw, QuickdrawText, Types, OSUtils, ToolUtils, Timer, Errors, Menus, Files, Lists, Memory, Dialogs,   		Packages, Printing, StandardFile, PasLibIntf, Retrace, SegLoad, fenv, fp {SANE, StrLib}, Controls, 		TextUtils, Windows, Events, CITZAFCode, CITZAFCode1, {Transfer,} CitInitialize,		Spectrum_Structures, Declarations, INITIALIZE, Global_Functions, utilities, 		codes, CitPhysics, Sandia, ZAF ; 	 	function  MyFilter (theDialog: DialogPtr; var theEvent: EventRecord; var itemHit: integer): boolean;    procedure Spectrum_Handler;	procedure Spectrum_Handler_1;	procedure D_Input_Data_Codes;    procedure CIT_Per_Tab_Buttons;    procedure D_Printout_Conditions;	procedure D_Correction_Procedure;	procedure D_Mix_and_Match;    procedure D_Element_Dialog;    procedure D_Edit_File_Elements;    procedure D_Standard_Choice;    procedure Choose_Specimen_Type;    procedure Choose_Standards_Type;	implementation{$S CharForce}VAR		MyPt: Point;   				     {Current list selection point}		(*Rect_I_List1: Rect; *) 			{Rectangle for my list}		List_I_List1: ListHandle;    	{Handle for my list}        str1,str2,str3,str4,str5,str6,str7,str8   : str255;	procedure D_Particle_Geometry;	const		I_Accept = 1;		I_Cancel = 2;		I_Help = 3;		I_Thin_Film__Thick_poli = 4;		I_Rectangular_Prism_Par = 5;		I_Tetragonal_Prism_Part = 6;		I_Triangular_Prism_Part = 7;		I_Square_Pyramid_Partic = 8;		I_Side_Scattered_Correc = 9;		I_Checkboxx10 = 10;		I_Checkboxx11 = 11;		I_Checkboxx12 = 12;		I_Checkboxx13 = 13;		I_Checkboxx14 = 14;		I_Checkboxx15 = 15;		I_Checkboxx16 = 16;		I_Checkboxx17 = 17;		I_Checkboxx18 = 18;		I_Checkboxx19 = 19;		I_Checkboxx20 = 20;		I_Checkboxx21 = 21;		I_x = 22; 		I_xDensity = 26;		I_x31 = 27;		I_x33 = 28;		I_x35 = 29;		I_x37 = 30;		I_x39 = 31;		I_x41 = 32;		I_x43 = 33;		I_x45 = 34;		I_x47 = 35;		I_x49 = 36;		I_x51 = 37;		I_x53 = 38;		I_x55 = 39;		I_xThickness_Diam = 41;		var 		    ExitDialog : boolean;    			GetSelection : DialogPtr;			tempRect : Rect;			DType : Integer;			DItem : Handle;			CItem	 : controlhandle;			sTemp,str : Str255;			itemHit : Integer;			temp,nn : Integer;			abort_xcit   : Boolean;   	         	{This is an update routine for non-controls in the dialog} 	{This is executed after the dialog is uncovered by an alert} 	procedure Refresh_Dialog; 	 		begin 			SetPort(GetSelection);			GetDialogItem(GetSelection,I_Accept,DType,DItem,tempRect);			PenSize(3, 3);			InsetRect(tempRect, -4, -4);			FrameRoundRect(tempRect, 16, 16); 			PenSize(1, 1); 				end; 	 	 	begin			GetSelection := GetNewDialog(7050, nil,  Pointer(-1) );			ShowWindow(GetSelection);			SelectWindow(GetSelection);			SetPort(GetSelection);			 			 			{Setup initial conditions}			GetDialogItem(GetSelection,I_xDensity,DType,DItem,tempRect);			RealtoString(PtcRho,5,2,str);			SetDialogItemText(DItem,str);						GetDialogItem(GetSelection,I_x31,DType,DItem,tempRect);			RealtoString(PtcX1,6,5,str);						SetDialogItemText(DItem,str);						for nn := I_x33 to I_x55 do			begin			   GetDialogItem(GetSelection,nn,DType,DItem,tempRect);			   RealtoString(Dia1[nn-I_x33+1],5,2,str);			   SetDialogItemText(DItem,str);			end;			GetDialogItem(GetSelection,I_xThickness_Diam,DType,DItem,tempRect);			RealtoString(PtcJ9,5,2,str);			SetDialogItemText(DItem,str);			            for nn := 0 to 11 do {ее7/11/97 change nn := 1 to nn := 0ее}			begin			  GetDialogItem(GetSelection, I_Checkboxx10+nn, DType, DItem, tempRect);			  if  (IDIA1[nn+1] = 1) then			     begin				   SetControlValue(controlhandle(DItem), 1);                 end				 else				 begin				   SetControlValue(controlhandle(DItem), 0);				 end;            end;            for nn := 0 to 5 do 			begin			  GetDialogItem(GetSelection, I_Thin_Film__Thick_poli+nn, DType, DItem, tempRect);			  if  (IMD1[nn+1] = 1) then			     begin				   SetControlValue(controlhandle(DItem), 1);                 end				 else				 begin				   SetControlValue(controlhandle(DItem), 0);				 end;            end;			Refresh_Dialog; 			 			ExitDialog := FALSE;			Abort_xcit := FALSE;											repeat				ModalDialog(nil, itemHit);				GetDialogItem(GetSelection, itemHit, DType, DItem, tempRect);				CItem := controlhandle(DItem);				 				if (ItemHit =I_Accept) then				begin					ExitDialog:=TRUE;				end;								if (ItemHit =I_Cancel) then				begin				 abort_xcit := TRUE;	 				end;								if (ItemHit =I_Help) then				begin					 				end;								  if (ItemHit >= 4) and (ItemHit <= 9)then				  begin					  temp := GetControlValue(CItem);					  SetControlValue(CItem, (temp + 1) mod 2);				  end;								  if (ItemHit >= I_Checkboxx10) and (ItemHit <= I_Checkboxx21)then				  begin					  temp := GetControlValue(CItem);					  SetControlValue(CItem, (temp + 1) mod 2);				  end;				 			until ExitDialog;			            if abort_xcit then 			begin			 DisposeDialog(GetSelection);			 exit(D_Particle_Geometry);			end;						GetDialogItem(GetSelection,I_xThickness_Diam,DType,DItem,tempRect);			GetDialogItemText(DItem, sTemp);			PtcJ9 := MyStr2Num(sTemp);			GetDialogItem(GetSelection,I_xDensity,DType,DItem,tempRect);			GetDialogItemText(DItem, sTemp);			PtcRho :=  MyStr2Num(sTemp);						GetDialogItem(GetSelection,27,DType,DItem,tempRect);			GetDialogItemText(DItem, sTemp);			PtcX1 := MyStr2Num(sTemp);			             for nn := 0 to 5 do 			begin			   GetDialogItem(GetSelection, I_Thin_Film__Thick_poli+nn, DType, DItem, tempRect);			   IMD1[nn+1]:= GetControlValue(controlhandle(DItem));             end;			             for nn := 0 to 11 do 			begin			   GetDialogItem(GetSelection, I_Checkboxx10+nn, DType, DItem, tempRect);			   IDIA1[nn+1] := GetControlValue(controlhandle(DItem));			   			   GetDialogItem(GetSelection,I_x33+nn,DType,DItem,tempRect);			   GetDialogItemText(DItem, sTemp);			   Dia1[nn+1] := MyStr2Num(sTemp);             end;			  IN9 := 13;			  IMOD := 0;			  for nn := 1 to 6 do			   if IMD1[nn]=1 then 			  begin				IMOD := IMOD + 1;				IMD[IMOD] := nn;			  end;				Main_Handler1;							IN9 := 14;			IDIAM := 0;			For nn := 1 to 12 do			if IDIA1[nn] = 1 then			begin			 IDIAM := IDIAM + 1;			 DIA[IDIAM] := DIA1[nn];			end;			Main_Handler1;						IN9 := 15;			pRHO := PtcRho;			Main_Handler1;					   IN9 := 16;			J9 := PtcJ9;			Main_Handler1;				   IN9 := 17;			X1 := PtcX1;			Main_Handler1;						DisposeDialog(GetSelection);					end;				procedure Choose_Standards_Type;         CONST		   I_OK          = 1;		   I_Bulk        = 2;		   I_Part_Thin   = 3;		   		 VAR			GetSelection: DialogPtr;			tempRect: Rect;			DType: Integer;			Index: Integer;			temp: Integer;			DItem: Handle;			CItem	: controlhandle;			itemHit: Integer;             ExitDialog : boolean;		begin		   GetSelection := GetNewDialog(5040, nil, Pointer(-1));		   ShowWindow(GetSelection);		   SelectWindow(GetSelection);		   SetPort(GetSelection);		   		   GetDialogItem(GetSelection, I_Bulk, DType, DItem, tempRect);		   SetControlValue(controlhandle(DItem), 1);		   		   GetDialogItem(GetSelection, I_Part_Thin, DType, DItem, tempRect);		   SetControlValue(controlhandle(DItem), 0);   	       ExitDialog := FALSE;		repeat			ModalDialog(nil, itemHit);			GetDialogItem(GetSelection, itemHit, DType, DItem, tempRect);			CItem := controlhandle(DItem); 			if (itemHit = I_OK) then				begin					ExitDialog := TRUE;				end;			if (itemHit >= I_Bulk) and (itemHit <= I_Part_Thin) then				begin					for Index := I_Bulk to I_Part_Thin do						begin							GetDialogItem(GetSelection, Index, DType, DItem, tempRect);							SetControlValue(controlhandle(DItem), 0);						end;					    SetControlValue(CItem, 1);				end;		until ExitDialog;		  index := I_Bulk;	      REPEAT	        GetDialogItem(GetSelection, index, DType, DItem, tempRect);	        temp := GetControlValue(ControlHandle(DItem));	        index := index + 1;	      UNTIL (temp <> 0) OR (index > I_Part_Thin);	      temp := index - I_Part_Thin +1;			if temp = 1 then						  begin						   IDIAM   := 1;						   IMOD    := 1;						   PtcRho  := 1;						   PtcJ9   := 1;						   IPtcD   := 1;						   IPtcM   := 1;						   IMD[1]  := 1;						   DIA[1]  := 10000;						   PtcX1   := 0.00001;						  end;						  						if temp = 2 then						  begin						   D_Particle_Geometry;						  end;        DisposeDialog(GetSelection);		end;				procedure Choose_Specimen_Type;         CONST		   I_OK          = 1;		   I_Bulk        = 2;		   I_Part_Thin   = 3;		   		 VAR			GetSelection: DialogPtr;			tempRect: Rect;			DType: Integer;			Index: Integer;			temp: Integer;			DItem: Handle;			CItem	: controlhandle;			itemHit: Integer;             ExitDialog : boolean;		begin		   GetSelection := GetNewDialog(5041, nil, Pointer(-1));		   ShowWindow(GetSelection);		   SelectWindow(GetSelection);		   SetPort(GetSelection);		   		   GetDialogItem(GetSelection, I_Bulk, DType, DItem, tempRect);		   SetControlValue(controlhandle(DItem), 1);		   		   GetDialogItem(GetSelection, I_Part_Thin, DType, DItem, tempRect);		   SetControlValue(controlhandle(DItem), 0);   	       ExitDialog := FALSE;		repeat			ModalDialog(nil, itemHit);			GetDialogItem(GetSelection, itemHit, DType, DItem, tempRect);			CItem := controlhandle(DItem); 			if (itemHit = I_OK) then				begin					ExitDialog := TRUE;				end;			if (itemHit >= I_Bulk) and (itemHit <= I_Part_Thin) then				begin					for Index := I_Bulk to I_Part_Thin do						begin							GetDialogItem(GetSelection, Index, DType, DItem, tempRect);							SetControlValue(controlhandle(DItem), 0);						end;					SetControlValue(CItem, 1);				end;			  		until ExitDialog;		  index := I_Bulk;	      REPEAT	        GetDialogItem(GetSelection, index, DType, DItem, tempRect);	        temp := GetControlValue(ControlHandle(DItem));	        index := index + 1;	      UNTIL (temp <> 0) OR (index > I_Part_Thin);	      temp := index - I_Part_Thin +1;			if temp = 1 then			  begin			   IPtc    := 0;			   IDIAM   := 1;			   IMOD    := 1;			   PtcRho  := 1;			   PtcJ9   := 1;			   IPtcD   := 1;			   IPtcM   := 1;			   IMD[1]  := 1;			   DIA[1]  := 10000;			   PtcX1   := 0.00001;			  end;			  			if temp = 2 then			  begin			   IPtc := 1;			  end;		        DisposeDialog(GetSelection);		end;			procedure D_Pick_a_Standard;	const		I_Accept = 1;		I_Input_Composition = 2;		I_Standard_1 = 3;		I_Standard_2 = 4;		I_Standard_3 = 5;		I_Standard_4 = 6;		I_Standard_5 = 7;		I_Standard_6 = 8;		I_Standard_7 = 9;		I_Standard_8 = 10;		I_Standard_9 = 11;		I_Standard_10 = 12;		I_Standard_11 = 13; 		var			GetSelection: DialogPtr;			tempRect: Rect;			DType: Integer;			Index: Integer;			DItem: Handle;			CItem	: controlhandle;			itemHit: Integer;			temp: Integer; 			ExitDialog: boolean;        {This is executed after the dialog is uncovered by an alert}		procedure Refresh_Dialog;			var				rTempRect: Rect;		begin			SetPort(GetSelection);			rTempRect := tempRect;			GetDialogItem(GetSelection, I_Accept, DType, DItem, tempRect);			PenSize(3, 3);			InsetRect(tempRect, -4, -4);			FrameRoundRect(tempRect, 16, 16);			PenSize(1, 1); 			PenSize(4, 4);			MoveTo(144, 19);			LineTo(325, 19);			PenSize(1, 1);			tempRect := rTempRect;		end;	begin		GetSelection := GetNewDialog(446, nil, Pointer(-1));		ShowWindow(GetSelection);		SelectWindow(GetSelection);		SetPort(GetSelection);  		GetDialogItem(GetSelection, I_Standard_1, DType, DItem, tempRect);		SetControlValue(controlhandle(DItem), 1);		Refresh_Dialog;		ExitDialog := FALSE;		repeat			ModalDialog(nil, itemHit);			GetDialogItem(GetSelection, itemHit, DType, DItem, tempRect);			CItem := controlhandle(DItem); 			if (itemHit = I_Accept) then				begin					ExitDialog := TRUE;					Refresh_Dialog;				end;			if (itemHit = I_Input_Composition) then				begin					Refresh_Dialog;				end;			if (itemHit >= I_Standard_1) and (itemHit <= I_Standard_11) then				begin					for Index := I_Standard_1 to I_Standard_11 do						begin							GetDialogItem(GetSelection, Index, DType, DItem, tempRect);							SetControlValue(controlhandle(DItem), 0);						end;					SetControlValue(CItem, 1);				end;		until ExitDialog; 		Index := I_Standard_1;		repeat			GetDialogItem(GetSelection, Index, DType, DItem, tempRect);			temp := GetControlValue(controlhandle(DItem));			Index := Index + 1;		until (temp <> 0) or (Index > I_Standard_11);		temp := Index - I_Standard_1 + 1;        { I_Standard_1 TO I_Standard_11}		DisposeDialog(GetSelection);	end;                                            {End of procedure}	procedure D_Standard_Choice;		const		    I_Accept  = 1;			I_First_El = 63;			I_Reset_to_Defaults = 5;			I_Read_From_File = 3;			I_Help = 4;			I_Cancel = 2;		var			ExitDialog: boolean;			GetSelection: DialogPtr;			tempRect: Rect;			DType: Integer;			Index: Integer;			DItem: Handle;			CItem	: controlhandle;			itemHit: Integer;			temp: Integer; 			ROW: Integer;			COLUMN: Integer;			MM: Integer;					procedure Refresh_Dialog;			var				rTempRect: Rect;		begin			SetPort(GetSelection);			rTempRect := tempRect;			GetDialogItem(GetSelection, I_Accept, DType, DItem, tempRect);			PenSize(3, 3);			InsetRect(tempRect, -4, -4);			FrameRoundRect(tempRect, 16, 16);			PenSize(1, 1);			GetDialogItem(GetSelection, I_Read_From_File, DType, DItem, tempRect);			HiliteControl(controlhandle(DItem), 255);			PenSize(4, 4);			MoveTo(250, 60);			LineTo(250, 279);			PenSize(1, 1);			MoveTo(10, 137);			LineTo(490, 137);			tempRect := rTempRect;		end;	begin		GetSelection := GetNewDialog(501, nil, Pointer(-1));		ShowWindow(GetSelection);		SelectWindow(GetSelection);		SetPort(GetSelection);         {еееееееееееееееееSetup initial conditionsееееееееееееееееееее}		GetDialogItem(GetSelection, I_Reset_to_Defaults, DType, DItem, tempRect);		HiliteControl(controlhandle(DItem), 255);		GetDialogItem(GetSelection, I_Read_From_File, DType, DItem, tempRect);		HiliteControl(controlhandle(DItem), 255);		for Index := 1 to 16 do			begin				if A^.IZ[Index] > 0 then					begin						GetDialogItem(GetSelection, Index + I_First_El - 1, DType, DItem, tempRect);						SetDialogItemText(DItem, A^.Sym[A^.IZ[Index]])					end				else					begin						GetDialogItem(GetSelection, Index + I_First_El - 1, DType, DItem, tempRect);						SetDialogItemText(DItem, '');					end;			end;		for ROW := 1 to 16 do			begin				if (A^.IZ[ROW] = 0) or (G^^.IT[ROW] = 1) or (G4^^.IL[ROW] > 3) or (G4^^.IL[ROW] < 1) then					begin						for COLUMN := 1 to 3 do							begin								Index := ROW * 3 + COLUMN + 2;								GetDialogItem(GetSelection, Index, DType, DItem, tempRect);								HiliteControl(controlhandle(DItem), 255);							end;					end				else					begin						MM := 0;						if (G^^.Name_of_Standard[ROW] = 'Pure Element') and 						   (G^^.Standard_Comp_Code[ROW] = 9) and 						   (CoS_H^^.v[ROW, ROW] = 1) then							begin								MM := 1;								Index := ROW * 3 + 3;								GetDialogItem(GetSelection, Index, DType, DItem, tempRect);								SetControlValue(controlhandle(DItem), 1);							end;						temp := 0;						if MM = 0 then							begin								for Index := 1 to I_N do									if CoS_H^^.v[ROW, Index] > 0 then										temp := 1;								if temp = 1 then									begin										Index := ROW * 3 + 5;										GetDialogItem(GetSelection, Index, DType, DItem, tempRect);										SetControlValue(controlhandle(DItem), 1);									end;							end;					end;			end;  		Refresh_Dialog;		ExitDialog := FALSE;		repeat			ModalDialog(nil, itemHit);			GetDialogItem(GetSelection, itemHit, DType, DItem, tempRect);			CItem := controlhandle(DItem);			if (itemHit = I_Accept) then				begin					ExitDialog := TRUE;					Refresh_Dialog;				end;			if (itemHit = I_Reset_to_Defaults) then				begin					Refresh_Dialog;				end;			if (itemHit = I_Read_From_File) then				begin					Refresh_Dialog;				end;			if (itemHit = I_Help) then				begin					putmessage('Sooooon', '', '', '');					Refresh_Dialog;				end;			if (itemHit = I_Cancel) then				begin					(*DisposeDialog(GetSelection);					exit(D_Standard_Choice);*)					ExitDialog := TRUE;				end;			for ROW := 1 to 16 do  { This is a place where some protection is required. Put in a "are}{                                    you sure???" yes-no pair of buttons in THIS dialog}				begin					if (itemHit >= ROW * 3 + 3) and (itemHit <= ROW * 3 + 5) then						begin							for Index := ROW * 3 + 3 to ROW * 3 + 5 do								begin									GetDialogItem(GetSelection, Index, DType, DItem, tempRect);									SetControlValue(controlhandle(DItem), 0);								end;							temp := itemHit - (ROW * 3 + 2);							SetControlValue(CItem, 1);							IN8 := ROW;							case temp of								1: 									begin										G^^.Name_of_Standard[ROW] := 'Pure Element';										G^^.Standard_Comp_Code[ROW] := 9;										for MM := 1 to 20 do											CoS_H^^.v[ROW, MM] := 0;										CoS_H^^.v[ROW, ROW] := 1;									end;								2: 									begin										putmessage('The following dialog is not active yet', 'Please ignore it and use one of the other 2 options', '', '');										D_Pick_a_Standard;										Refresh_Dialog;									end;								3: 									begin										Run_Data_Now := FALSE;										D_Code_8;										Refresh_Dialog;									end;							end;                            { case }						end;				end;                                    {For COLUMN := 1 to 3 do... }		until ExitDialog;		for index := 1 to I_N do			begin				if (A^.IZ[index] > 0) and (G^^.IT[index] = 0) and (G4^^.IL[index] > 0) and (G4^^.IL[index] < 4) then					begin						IN8 := index;						IN9 := G^^.Standard_Comp_Code[index];						ELEMSTD := G^^.Name_of_Standard[index];						for MM := 1 to 20 do							begin								G4^^.K[MM] := CoS_H^^.v[index, MM];							end;						MAIN_Handler1;					end;			end;		DisposeDialog(GetSelection);	end;	procedure D_Edit_File_Elements;		const                          		I_Accept = 1;		I_Help = 2;		I_Z_First = 63;		I_Z_Last = 82;		I_Order_First = 3;		I_Order_Last = 22;		I_Code_First = 23;		I_Code_Last = 42;		I_Label_First = 83;		I_Label_Last = 102;		I_Grav_First = 43;		I_Grav_Last = 62;		I_Cancel = 110;	var		    ExitDialog: boolean; {Flag used to exit the Dialog} 			GetSelection: DialogPtr; {Pointer to this dialog}			tempRect: Rect; {Temporary rectangle}			DType: Integer; {Type of dialog item}			Index: Integer; {For looping}			DItem: Handle; {Handle to the dialog item}			sTemp: Str255; {Get text entered, temp holding}			itemHit: Integer; {Get selection} 			J_N, J_El, J_Max: integer;			J_Z, J_IL: array[1..20] of integer;			J_Gr: array[1..20] of real;			Scratch_Longint: Longint;			 		label			100;	begin                        		GetSelection := GetNewDialog(430, nil, Pointer(-1));  		ShowWindow(GetSelection);  		SelectWindow(GetSelection);  		SetPort(GetSelection);       		for Index := 0 to 19 do			begin				GetDialogItem(GetSelection, Index + I_Z_First, DType, DItem, tempRect);				SetDialogItemText(DItem, '');				GetDialogItem(GetSelection, Index + I_Order_First, DType, DItem, tempRect);				NumToString(Index + 1, str);				SetDialogItemText(DItem, str);				GetDialogItem(GetSelection, Index + I_Code_First, DType, DItem, tempRect);				SetDialogItemText(DItem, '0');				GetDialogItem(GetSelection, Index + I_Grav_First, DType, DItem, tempRect);				SetDialogItemText(DItem, '0');				GetDialogItem(GetSelection, Index + I_Label_First, DType, DItem, tempRect);				SetDialogItemText(DItem, '');			end;		if I_N > 20 then			I_N := 20;		for Index := 1 to I_N do			begin				if A^.IZ[Index] > 0 then					begin						GetDialogItem(GetSelection, Index + I_Z_First - 1, DType, DItem, tempRect);						SetDialogItemText(DItem, A^.Sym[A^.IZ[Index]]);						GetDialogItem(GetSelection, Index + I_Code_First - 1, DType, DItem, tempRect);						NumToString(G4^^.IL[Index], str);						SetDialogItemText(DItem, str);						GetDialogItem(GetSelection, Index + I_Grav_First - 1, DType, DItem, tempRect);						RealToString(A^.GR[Index], 3, 1, str);						SetDialogItemText(DItem, str);						case G4^^.IL[Index] of							1: 								str1 := 'K-alpha';							2: 								str1 := 'L-alpha';							3: 								str1 := 'M-alpha';							4: 								str1 := 'Difference';							5: 								str1 := 'Fixed Conc.';							6: 								str1 := 'Grav. Lst El';							0: 								str1 := 'Grav. Cation';							-1: 								str1 := 'Std. Only';							-2: 								str1 := 'Std. Only';							-3: 								str1 := 'Std. Only';							otherwise								str1 := '??';						end;						GetDialogItem(GetSelection, Index + I_Label_First - 1, DType, DItem, tempRect);						SetDialogItemText(DItem, str1);					end;			end;100:		ExitDialog := FALSE;		repeat			ModalDialog(nil, itemHit);			GetDialogItem(GetSelection, itemHit, DType, DItem, tempRect);			if (itemHit = I_Accept) then				begin					ExitDialog := TRUE;				end;			if (itemHit = I_Cancel) then				begin					(*DisposeDialog(GetSelection);					Exit(D_Edit_File_Elements);*)					ExitDialog := TRUE;				end;			if (itemHit = I_Help) then				begin					PutMessage('Im breathing hard!!!', '', '', '');				end;		until ExitDialog;        {ееееееееееееGet results after dialogеееееееееееееееееее}		J_Max := 0;		J_N := 0;		for index := 1 to 20 do			begin				J_Z[index] := 0;				J_IL[index] := 0;				J_GR[index] := 0;			end;		for Index := 0 to 19 do			begin				GetDialogItem(GetSelection, I_Z_First + Index, DType, DItem, tempRect);				GetDialogItemText(DItem, sTemp);				J_El := AtSymbol_To_Znum(sTemp);				if J_El > 0 then					begin						GetDialogItem(GetSelection, I_Order_First + Index, DType, DItem, tempRect);						GetDialogItemText(DItem, sTemp);						StringToNum(sTemp, Scratch_Longint);						J_N := integer(Scratch_Longint);						if (J_N < 1) or (J_N > 20) then							begin								PutMessage('Check the ordering of the elements and try again', '', '', '');								goto 100;							end;						if J_N > J_Max then							J_Max := J_N;						J_Z[J_N] := J_El;						GetDialogItem(GetSelection, I_Code_First + Index, DType, DItem, tempRect);						GetDialogItemText(DItem, sTemp);						StringToNum(sTemp, Scratch_Longint);						J_IL[J_N] := integer(Scratch_Longint);						GetDialogItem(GetSelection, I_Grav_First + Index, DType, DItem, tempRect);						GetDialogItemText(DItem, sTemp);						J_GR[J_N] := MyStr2Num(sTemp)					end;			end;		for Index := 1 to J_Max do			begin				if J_Z[Index] = 0 then					begin						PutMessage('Your ordering is missing one or more elements in the sequence.', 'Please try again.', '', '');						goto 100;					end;			end;		J_N := 0;		for Index := 1 to J_Max do			begin				if J_IL[Index] = 4 then					J_N := J_N + 1;				if J_N > 1 then					begin						PutMessage('No more than one element can be calculated by difference.', 'Please try again', '', '');						goto 100;					end;				if (J_IL[Index] = 0) and (Index < J_Max) then					begin						PutMessage('The element calculated by Gravimetry relative to cations', 'must be the last element in the sequence.', 'Sorry, please try again.', '');						goto 100;					end;			end;		for Index := 1 to 20 do			begin				A^.IZ[Index] := J_Z[Index];				G4^^.IL[Index] := J_IL[Index];				A^.GR[Index] := J_GR[Index];			end;		I_N := J_Max;		if G4^^.IL[I_N] = 0 then			IN1 := I_N - 1		else			IN1 := I_N;		DisposeDialog(GetSelection);	end;                        {End of procedure}  	procedure D_Element_Dialog;	const   									I_Accept = 1;		I_If_you_want_pick_a_std = 2;		I_Element_Present_only_in_Std  = 3;		I_Grav_Relative_To_Cations = 4;		I_Grav_relative_to_Last_El = 5;		I_Fixed_Concentration = 6;		I_Difference_From_100 = 7;		I_Ma_Line = 8;		I_La_Line = 9;		I_Ka_Line = 10;		I_Grav_Factor = 16;						    var 		    ExitDialog : boolean;   		 			GetSelection : DialogPtr;			tempRect : Rect;    					DType : Integer;    					Index : Integer;    					DItem : Handle; 						CItem	 : controlhandle;			sTemp : Str255; 						itemHit : Integer;  					temp : Integer; 			 	begin   										GetSelection := GetNewDialog(5006, nil,  Pointer(-1) );			ShowWindow(GetSelection);			SelectWindow(GetSelection);			SetPort(GetSelection);  				  			 			{еееееееееееееSetup initial conditionsеееееееееееееееееее}												GetDialogItem(GetSelection,I_Ka_Line,DType,DItem,tempRect);			SetControlValue(controlhandle(DItem), 1);  							GetDialogItem(GetSelection,I_Grav_Factor,DType,DItem,tempRect);{Get the item handle}						RealToString(A^.GR[I_N], 2, 1, Str1);			SetDialogItemText(DItem,str1);						 			ExitDialog:=FALSE;  						Str1 := A^.Sym[ A^.IZ[I_N] ];			NumToString(A^.IZ[I_N],str);			Str1 := CONCAT(Str1,', Z = ',str);			ParamText(Str1,Str1,Str1,Str1);			 			repeat  									ModalDialog(nil, itemHit);				GetDialogItem(GetSelection, itemHit, DType, DItem, tempRect);				CItem := controlhandle(DItem);				 				if (ItemHit =I_Accept) then{Handle the Button being pressed}				begin					ExitDialog:=TRUE;{Exit the dialog when this selection is made}				end;    												if (ItemHit =I_If_you_want_pick_a_std) then				begin				 PutMessage('Not Implemented yet, disregard what follows.','','','');				 D_Pick_a_Standard;				end;    												if (ItemHit >=I_Element_Present_only_in_Std ) and (ItemHit <=I_Ka_Line) then				begin					for Index:=I_Element_Present_only_in_Std   to I_Ka_Line do					begin						GetDialogItem(GetSelection, Index, DType, DItem, tempRect);						SetControlValue(controlhandle(DItem), 0);					end;    								SetControlValue(CItem, 1);				end;    												 			until ExitDialog;   		{Handle dialog items until exit selected}			 			{Get results after dialog}			Index:=I_Element_Present_only_in_Std ;{Start at the first radio in this group}			repeat  					{Look until we have found the radio selected}				GetDialogItem(GetSelection, Index, DType, DItem, tempRect);{Get the radio handle}				temp := GetControlValue(controlhandle(DItem));{Get the radio value}				Index := Index + 1;{Go to next radio}			until (temp<>0) or (Index >I_Ka_Line);{Go till we find it}			temp:= Index -I_Element_Present_only_in_Std  +1;{The indexed radio selection}             CASE temp OF			  2: if A^.IZ[I_N] < 31 then G4^^.IL[I_N]  := -1			     else if A^.IZ[I_N] < 80 then G4^^.IL[I_N]  := -2				 else  G4^^.IL[I_N]  := -3;			  3: G4^^.IL[I_N]  := 0;			  4: G4^^.IL[I_N]  := 6;			  5: G4^^.IL[I_N]  := 5;			  6: G4^^.IL[I_N]  := 4;			  7: G4^^.IL[I_N]  := 3;			  8: G4^^.IL[I_N]  := 2;			  9: G4^^.IL[I_N]  := 1;			 Otherwise G4^^.IL[I_N]  := 1;			end; { Case }           												GetDialogItem(GetSelection,I_Grav_Factor,DType,DItem,tempRect);			GetDialogItemText(DItem, sTemp);			A^.GR[I_N] := MyStr2Num(sTemp);									DisposeDialog(GetSelection);					end;    						{End of procedure}	procedure D_Mix_and_Match;			const   							         I_Accept = 1;		I_Absorption_Correction = 2;		I_Atomic_Number_Correct = 3;		I_Fluorescence_Correcti = 4;		I_Mean_Ionization_Poten = 5;		I_Backscatter_Coefficie = 6;		I_Surface_Ionization_Fu = 7;		I_Ionization_Cross_Sect = 8;		I_Mass_Absorption_Coeff = 9;		I_Continuum_Fluor_Corr = 10;		I_Fluorescence_Yield = 11;		I_Continuum_Cross_Secti = 12;		I_Reset_to_Default_Valu = 13;							var		    ExitDialog: boolean; 			GetSelection: DialogPtr; 			tempRect: Rect;    		 			DType: Integer;    		 			DItem: Handle; 			 			itemHit: Integer;  		{Get selection}  		procedure Refresh_Dialog;   		{Refresh the dialogs non-controls}			var				rTempRect: Rect;     		{Temp rectangle used for drawing}		begin			SetPort(GetSelection);  	{Point to our dialog window}			rTempRect := tempRect;  	{Save the current contents of  tempRect}			GetDialogItem(GetSelection, I_Accept, DType, DItem, tempRect);{Get the item handle}			PenSize(3, 3);  			{Change pen to draw thick default outline}			InsetRect(tempRect, -4, -4);{Draw outside the button by 1 pixel}			FrameRoundRect(tempRect, 16, 16); {Draw the outline}			PenSize(1, 1);  			{Restore the pen size to the default value}			{Draw a line, Drawn line2 }			PenSize(4, 4);   			{Set a wider pen width}			MoveTo(34, 19);  			{Horz,vert, Move to starting position}			LineTo(198, 19); 			{Horz,vert, Draw to the ending position}			PenSize(1, 1);   			{Back to default pen size}			tempRect := rTempRect;		end;	begin   							{Start of dialog handler}		GetSelection := GetNewDialog(409, nil, Pointer(-1));{Bring in the dialog resource}		ShowWindow(GetSelection);{Open a dialog box}		SelectWindow(GetSelection);{Lets see it}		SetPort(GetSelection);  	{Prepare to add conditional text} 			{ееееееееееSetup initial conditionsееееееееееее}		Refresh_Dialog;		ExitDialog := FALSE;		repeat			ModalDialog(nil, itemHit);			GetDialogItem(GetSelection, itemHit, DType, DItem, tempRect);				{Handle it real time}			if (ItemHit = I_Accept) then				begin					ExitDialog := TRUE;					Refresh_Dialog;				end;			if (ItemHit = I_Absorption_Correction) then				begin					D_Absorption_Correctio;					Refresh_Dialog;				end;			if (ItemHit = I_Atomic_Number_Correct) then				begin					D_Atomic_Number_Correc;					Refresh_Dialog;				end;			if (ItemHit = I_Fluorescence_Correcti) then				begin					D_Charactristic_Fluore;					Refresh_Dialog;				end;			if (ItemHit = I_Mean_Ionization_Poten) then				begin					D_Mean_Ionization_Pote;					Refresh_Dialog;				end;			if (ItemHit = I_Backscatter_Coefficie) then				begin					D_Backscatter_Coefficient;					Refresh_Dialog;				end;			if (ItemHit = I_Surface_Ionization_Fu) then				begin					D_Surface_Ionization_F;					Refresh_Dialog;				end;			if (ItemHit = I_Ionization_Cross_Sect) then				begin					D_Ionization_Cross_Sec;					Refresh_Dialog;				end;			if (ItemHit = I_Mass_Absorption_Coeff) then				begin					D_Mass_Absorption_Coef;					Refresh_Dialog;				end;			if (ItemHit = I_Continuum_Fluor_Corr) then				begin					D_Continuum_Fluorescen;					Refresh_Dialog;				end;			if (ItemHit = I_Fluorescence_Yield) then				begin					putmessage('Not hooked up yet', 'Values calculated from CITZAF Equation', '', '');					Refresh_Dialog;				end;			if (ItemHit = I_Continuum_Cross_Secti) then				begin					D_Continuum_Cross_Sect;					Refresh_Dialog;				end;			if (ItemHit = I_Reset_to_Default_Valu) then				begin					IABS := 9;					IZED := 2;					ISTP := 4;					IBKS := 4;					IMIP := 1;					IBSC := 2;					IPHI := 2;					IICS := 0;					IFLU := 1;					IMAC := 1;					ICOR := 1;					IMAC_Input := False;					Refresh_Dialog;				end;		until ExitDialog;   		{Handle dialog items until exit selected}			{Get results after dialog}		DisposeDialog(GetSelection); 	end;    						 	procedure D_Correction_Procedure; 	const		I_Accept = 1;		I_CITZAF = 2;		I_NBS_FRAME = 3;		I_Philibert__Duncumb_Re = 4;		I_Love_Scott = 5;		I_Sewell_et_al = 6;		I_Bastin = 7;		I_Packwood_and_Brown = 8;		I_PAP = 9;		I_NBS_COR_2 = 10;		I_Spare_1 = 11;		I_Spare_2 = 12;		I_Spare_3 = 13;		I_Mix_and_Match = 14;		var			GetSelection: DialogPtr;			tempRect: Rect;			DType: Integer;			Index: Integer;			DItem: Handle;			CItem	: controlhandle;			itemHit: Integer;			temp: Integer; 			BTemp: Longint;            ExitDialog : boolean;					procedure Refresh_Dialog;			var				rTempRect: Rect;		begin			SetPort(GetSelection);			rTempRect := tempRect;			GetDialogItem(GetSelection, I_Accept, DType, DItem, tempRect);			PenSize(3, 3);			InsetRect(tempRect, -4, -4);			FrameRoundRect(tempRect, 16, 16);			PenSize(1, 1);   			tempRect := rTempRect;		end;	begin		GetSelection := GetNewDialog(408, nil, Pointer(-1));		ShowWindow(GetSelection);		SelectWindow(GetSelection);		SetPort(GetSelection);			  if IPtc = 1 then	  begin		 GetDialogItem(GetSelection, I_NBS_FRAME, DType, DItem, tempRect);		 HiliteControl(controlhandle(DItem), 255);   		 GetDialogItem(GetSelection, I_Philibert__Duncumb_Re, DType, DItem, tempRect);		 HiliteControl(controlhandle(DItem), 255);   		 GetDialogItem(GetSelection, I_Love_Scott, DType, DItem, tempRect);		 HiliteControl(controlhandle(DItem), 255);		 		 GetDialogItem(GetSelection, I_Sewell_et_al, DType, DItem, tempRect);		 HiliteControl(controlhandle(DItem), 255);		 GetDialogItem(GetSelection, I_PAP, DType, DItem, tempRect);		 HiliteControl(controlhandle(DItem), 255);		 GetDialogItem(GetSelection, I_NBS_COR_2, DType, DItem, tempRect);		 HiliteControl(controlhandle(DItem), 255);		       end; 			{еееееееееееееSetup initial conditionsеееееееееееее}		case ICOR of			0:  BTemp := 14;			1:  BTemp := 2;			2:  BTemp := 3;			3:  BTemp := 4;			4:  BTemp := 5;			5:  BTemp := 6;			6:  BTemp := 7;			7:  BTemp := 8;			8:  BTemp := 9;			9:  BTemp := 10;			10: BTemp := 11;			11: BTemp := 12;			12: BTemp := 13;			otherwise BTemp := 2;		end; { Case }		GetDialogItem(GetSelection, BTemp, DType, DItem, tempRect);		SetControlValue(controlhandle(DItem), 1);   		GetDialogItem(GetSelection, I_Spare_2, DType, DItem, tempRect);		CItem := controlhandle(DItem);		SetControlValue(CItem, 0);		HiliteControl(CItem, 255); {Dim the radio}		GetDialogItem(GetSelection, I_Spare_3, DType, DItem, tempRect);		CItem := Pointer(DItem);		SetControlValue(CItem, 0);		HiliteControl(CItem, 255); {Dim the radio}		Refresh_Dialog;		ExitDialog := FALSE;		repeat			ModalDialog(nil, itemHit);			GetDialogItem(GetSelection, itemHit, DType, DItem, tempRect);			CItem := controlhandle(DItem);			if (ItemHit = I_Accept) then				begin					ExitDialog := TRUE;					Refresh_Dialog;				end;			if (ItemHit >= I_CITZAF) and (ItemHit <= I_Mix_and_Match) then				begin					for Index := I_CITZAF to I_Mix_and_Match do						begin							GetDialogItem(GetSelection, Index, DType, DItem, tempRect);							SetControlValue(controlhandle(DItem), 0);						end;					SetControlValue(CItem, 1);				end;		until ExitDialog;			{ееееееееееееееGet results after dialogеееееееееееееееее}		Index := I_CITZAF;		repeat			GetDialogItem(GetSelection, Index, DType, DItem, tempRect);			temp := GetControlValue(controlhandle(DItem));			Index := Index + 1;		until (temp <> 0) or (Index > I_Mix_and_Match);{14}		temp := Index - I_CITZAF + 1;		if temp = 2 then			begin				IABS := 9;				ISTP := 4;				IBKS := 4;				IMIP := 1;				IBSC := 2;				IPHI := 2;				IICS := 0;				IERE := 0;				ICOR := 1;			end;		if temp = 3 then			begin				IABS := 2;				ISTP := 1;				IBKS := 1;				IMIP := 1;				IBSC := 0;				IPHI := 0;				IICS := 0;				IERE := 0;				ICOR := 2;			end;		if temp = 4 then			begin				IABS := 1;				ISTP := 1;				IBKS := 1;				IMIP := 2;				IBSC := 0;				IPHI := 0;				IICS := 0;				IERE := 0;				ICOR := 3;			end;		if temp = 5 then			begin				IABS := 4;				ISTP := 4;				IBKS := 4;				IMIP := 1;				IBSC := 2;				IPHI := 2;				IICS := 0;				IERE := 0;				ICOR := 4;			end;		if temp = 6 then			begin				IABS := 6;				ISTP := 4;				IBKS := 4;				IMIP := 7;				IBSC := 2;				IPHI := 2;				IICS := 0;				IERE := 0;				ICOR := 5;			end;		if temp = 7 then			begin				IABS := 10;				ISTP := 6;				IBKS := 0;				IMIP := 3;				IBSC := 2;				IPHI := 2;				IICS := 0;				IERE := 0;				ICOR := 6;			end;		if temp = 8 then			begin				IABS := 15;				ISTP := 5;				IBKS := 7;				IMIP := 3;				IBSC := 3;				IPHI := 4;				IICS := 0;				IERE := 0;				ICOR := 7;			end;		if temp = 9 then			begin				IABS := 12;				ISTP := 5;				IBKS := 7;				IMIP := 3;				IBSC := 3;				IPHI := 4;				IICS := 0;				IERE := 0;				ICOR := 8;			end;		if temp = 10 then			begin				IABS := 13;				ISTP := 5;				IBKS := 7;				IMIP := 3;				IBSC := 3;				IPHI := 4;				IICS := 0;				IERE := 0;				ICOR := 9;			end;		if temp = 11 then			begin				IABS := 7;				ISTP := 6;				IBKS := 0;				IMIP := 1;				IBSC := 1;				IPHI := 1;				IICS := 0;				IERE := 0;				ICOR := 10;			end;		if temp = 12 then			begin			end;		if temp = 13 then			begin			end;		if temp = 14 then			begin				D_Mix_and_Match;			end;		DisposeDialog(GetSelection);	end;    						{End of procedure}{$S CharForce1}	procedure D_Printout_Conditions;	const		I_Accept = 1;		I_Output_mass_absorptio = 2;		I_Output_compositions_o = 3;		I_Output_ZAF_correction = 4;		I_Normalize_to_100 = 5;		I_Atom_proportions = 6;		I_Oxide_weight_percent = 7;		I_Element_weight_percen = 8;		I_k_values = 9;		I_Output_to_Screen = 11;		I_Compressed_Output = 12;		I_Full_Output = 13;	var		    ExitDialog: boolean; 			GetSelection: DialogPtr; 			tempRect: Rect;    		 			DType: Integer;    		 			Index: Integer;    		 			DItem: Handle; 			 			CItem	: controlhandle; 			itemHit: Integer;  		 			temp: Integer; 			  	 		procedure Refresh_Dialog;   		 			var				rTempRect: Rect;     		 		begin			SetPort(GetSelection);  	 			rTempRect := tempRect;  	 			GetDialogItem(GetSelection, I_Accept, DType, DItem, tempRect);			PenSize(3, 3);  			 			InsetRect(tempRect, -4, -4); 			FrameRoundRect(tempRect, 16, 16);  			PenSize(1, 1);  			  			tempRect := rTempRect;  	 		end;	begin   							 		GetSelection := GetNewDialog(429, nil, Pointer(-1)); 		ShowWindow(GetSelection); 		SelectWindow(GetSelection); 		SetPort(GetSelection);  	  			{еееееееееееееSetup initial conditionsееееееееееееееееее}		GetDialogItem(GetSelection, I_Output_compositions_o, DType, DItem, tempRect);		CItem := controlhandle(DItem);		if IB = 1 then			SetControlValue(CItem, 1)		else			SetControlValue(CItem, 0);		GetDialogItem(GetSelection, I_Output_ZAF_correction, DType, DItem, tempRect);		CItem := controlhandle(DItem);		if IZAF = 1 then			SetControlValue(CItem, 1)		else			SetControlValue(CItem, 0);		GetDialogItem(GetSelection, I_Normalize_to_100, DType, DItem, tempRect);		CItem := controlhandle(DItem);		if INORM = 1 then			SetControlValue(CItem, 1)		else			SetControlValue(CItem, 0);		if IPRN = 0 then			HiliteControl(CItem, 255);  {Dim the checkbox}		GetDialogItem(GetSelection, I_Atom_proportions, DType, DItem, tempRect);		CItem := controlhandle(DItem);		if ICAT = 0 then			SetControlValue(CItem, 1)		else			SetControlValue(CItem, 0);		if IPRN = 0 then			HiliteControl(CItem, 255);  {Dim the checkbox}		GetDialogItem(GetSelection, I_Oxide_weight_percent, DType, DItem, tempRect);		CItem := controlhandle(DItem);		if ICOX = 0 then			SetControlValue(CItem, 1)		else			SetControlValue(CItem, 0);		if IPRN = 0 then			HiliteControl(CItem, 255);  {Dim the checkbox}		GetDialogItem(GetSelection, I_Element_weight_percen, DType, DItem, tempRect);		CItem := controlhandle(DItem);		if ICEL = 0 then			SetControlValue(CItem, 1)		else			SetControlValue(CItem, 0);		if IPRN = 0 then			HiliteControl(CItem, 255);  {Dim the checkbox}		GetDialogItem(GetSelection, I_k_values, DType, DItem, tempRect);		CItem := controlhandle(DItem);		if IKEL = 0 then			SetControlValue(CItem, 1)		else			SetControlValue(CItem, 0);		if IPRN = 0 then			HiliteControl(CItem, 255);  {Dim the checkbox}		GetDialogItem(GetSelection, I_Output_mass_absorptio, DType, DItem, tempRect);		CItem := controlhandle(DItem);		if IA = 1 then			SetControlValue(CItem, 1)		else			SetControlValue(CItem, 0);		GetDialogItem(GetSelection, I_Output_to_Screen, DType, DItem, tempRect);		CItem := controlhandle(DItem);		SetControlValue(CItem, 0);  	{Check the checkbox}		HiliteControl(CItem, 255);{Dim the checkbox}		GetDialogItem(GetSelection, I_Full_Output, DType, DItem, tempRect);		CItem := controlhandle(DItem);		if IPRN = 0 then			SetControlValue(CItem, 1)		else			SetControlValue(CItem, 0);		GetDialogItem(GetSelection, I_Compressed_Output, DType, DItem, tempRect);		CItem := controlhandle(DItem);		if IPRN > 0 then			SetControlValue(CItem, 1)		else			SetControlValue(CItem, 0);		Refresh_Dialog;		ExitDialog := FALSE;		repeat  								ModalDialog(nil, itemHit);			GetDialogItem(GetSelection, itemHit, DType, DItem, tempRect);			CItem := controlhandle(DItem);			if (ItemHit = I_Accept) then{Handle the Button being pressed}				begin					ExitDialog := TRUE;{Exit the dialog when this selection is made}					Refresh_Dialog;				end;    				{End for this item selected}			if (ItemHit = I_Output_mass_absorptio) then{Handle the checkbox being pressed}				begin					temp := GetControlValue(CItem);{Get the current Checkbox value}					SetControlValue(CItem, (temp + 1) mod 2);{Toggle the value to the opposite}					if (temp = 0) then{Do all CHECKED linkages}						begin						end     			{End for this item checked}					else    			{Do all UNCHECKED linkages}						begin						end;    			{End for this item unchecked}				end;    				{End for this item selected}			if (ItemHit = I_Output_compositions_o) then{Handle the checkbox being pressed}				begin					temp := GetControlValue(CItem);{Get the current Checkbox value}					SetControlValue(CItem, (temp + 1) mod 2);{Toggle the value to the opposite}					if (temp = 0) then{Do all CHECKED linkages}						begin						end     			{End for this item checked}					else    			{Do all UNCHECKED linkages}						begin						end;    			{End for this item unchecked}				end;    				{End for this item selected}			if (ItemHit = I_Output_ZAF_correction) then{Handle the checkbox being pressed}				begin					temp := GetControlValue(CItem);{Get the current Checkbox value}					SetControlValue(CItem, (temp + 1) mod 2);{Toggle the value to the opposite}					if (temp = 0) then{Do all CHECKED linkages}						begin						end     			{End for this item checked}					else    			{Do all UNCHECKED linkages}						begin						end;    			{End for this item unchecked}				end;    				{End for this item selected}			if (ItemHit = I_Normalize_to_100) then{Handle the checkbox being pressed}				begin					temp := GetControlValue(CItem);{Get the current Checkbox value}					SetControlValue(CItem, (temp + 1) mod 2);{Toggle the value to the opposite}					if IPRN = 0 then						HiliteControl(CItem, 255)					else						HiliteControl(CItem, 0);					if (temp = 0) then{Do all CHECKED linkages}						begin						end     			{End for this item checked}					else    			{Do all UNCHECKED linkages}						begin						end;    			{End for this item unchecked}				end;			if (ItemHit = I_Atom_proportions) then{Handle the checkbox being pressed}				begin					temp := GetControlValue(CItem);{Get the current Checkbox value}					SetControlValue(CItem, (temp + 1) mod 2);{Toggle the value to the opposite}					if IPRN = 0 then						HiliteControl(CItem, 255)					else						HiliteControl(CItem, 0);					if (temp = 0) then{Do all CHECKED linkages}						begin						end     			{End for this item checked}					else    			{Do all UNCHECKED linkages}						begin						end;    			{End for this item unchecked}				end;    				{End for this item selected}			if (ItemHit = I_Oxide_weight_percent) then{Handle the checkbox being pressed}				begin					temp := GetControlValue(CItem);{Get the current Checkbox value}					SetControlValue(CItem, (temp + 1) mod 2);{Toggle the value to the opposite}					if IPRN = 0 then						HiliteControl(CItem, 255)					else						HiliteControl(CItem, 0);					if (temp = 0) then{Do all CHECKED linkages}						begin						end     			{End for this item checked}					else    			{Do all UNCHECKED linkages}						begin						end;    			{End for this item unchecked}				end;    				{End for this item selected}			if (ItemHit = I_Element_weight_percen) then{Handle the checkbox being pressed}				begin					temp := GetControlValue(CItem);{Get the current Checkbox value}					SetControlValue(CItem, (temp + 1) mod 2);{Toggle the value to the opposite}					if IPRN = 0 then						HiliteControl(CItem, 255)					else						HiliteControl(CItem, 0);					if (temp = 0) then{Do all CHECKED linkages}						begin						end     			{End for this item checked}					else    			{Do all UNCHECKED linkages}						begin						end;    			{End for this item unchecked}				end;    				{End for this item selected}			if (ItemHit = I_k_values) then{Handle the checkbox being pressed}				begin					temp := GetControlValue(CItem);{Get the current Checkbox value}					SetControlValue(CItem, (temp + 1) mod 2);{Toggle the value to the opposite}					if IPRN = 0 then						HiliteControl(CItem, 255)					else						HiliteControl(CItem, 0);					if (temp = 0) then{Do all CHECKED linkages}						begin						end     			{End for this item checked}					else    			{Do all UNCHECKED linkages}						begin						end;    			{End for this item unchecked}				end;    				{End for this item selected}			if (ItemHit = I_Output_to_Screen) then{Handle the checkbox being pressed}				begin					temp := GetControlValue(CItem);{Get the current Checkbox value}					SetControlValue(CItem, (temp + 1) mod 2);{Toggle the value to the opposite}					if (temp = 0) then{Do all CHECKED linkages}						begin						end     			{End for this item checked}					else    			{Do all UNCHECKED linkages}						begin						end;    			{End for this item unchecked}				end;			if (ItemHit >= I_Compressed_Output) and (ItemHit <= I_Full_Output) then{Handle the Radio selection}				begin					for Index := I_Compressed_Output to I_Full_Output do						begin							GetDialogItem(GetSelection, Index, DType, DItem, tempRect);							SetControlValue(controlhandle(DItem), 0);{Turn the radio selection OFF}						end;    			{End of clear the radio selections loop}					SetControlValue(CItem, 1);{Turn the one radio selection ON}					if ItemHit = I_Compressed_Output then						IPRN := 1;					if ItemHit = I_Full_Output then						IPRN := 0;					GetDialogItem(GetSelection, I_Normalize_to_100, DType, DItem, tempRect);					CItem := controlhandle(DItem);					if IPRN = 0 then						HiliteControl(CItem, 255)					else						HiliteControl(CItem, 0);					GetDialogItem(GetSelection, I_Atom_proportions, DType, DItem, tempRect);					CItem := controlhandle(DItem);					if IPRN = 0 then						HiliteControl(CItem, 255)					else						HiliteControl(CItem, 0);					GetDialogItem(GetSelection, I_Oxide_weight_percent, DType, DItem, tempRect);					CItem := controlhandle(DItem);					if IPRN = 0 then						HiliteControl(CItem, 255)					else						HiliteControl(CItem, 0);					GetDialogItem(GetSelection, I_Element_weight_percen, DType, DItem, tempRect);					CItem := controlhandle(DItem);					if IPRN = 0 then						HiliteControl(CItem, 255)					else						HiliteControl(CItem, 0);					GetDialogItem(GetSelection, I_k_values, DType, DItem, tempRect);					CItem := controlhandle(DItem);					if IPRN = 0 then						HiliteControl(CItem, 255)					else						HiliteControl(CItem, 0);				end;		until ExitDialog;		GetDialogItem(GetSelection, I_Output_mass_absorptio, DType, DItem, tempRect);		IA := GetControlValue(controlhandle(DItem));		GetDialogItem(GetSelection, I_Output_compositions_o, DType, DItem, tempRect);		IB := GetControlValue(controlhandle(DItem));		GetDialogItem(GetSelection, I_Output_ZAF_correction, DType, DItem, tempRect);		IZAF := GetControlValue(controlhandle(DItem));		GetDialogItem(GetSelection, I_Normalize_to_100, DType, DItem, tempRect);		INORM := GetControlValue(controlhandle(DItem));		GetDialogItem(GetSelection, I_Atom_proportions, DType, DItem, tempRect);		temp := GetControlValue(controlhandle(DItem));		if temp = 1 then			ICAT := 0		else			ICAT := 1;		GetDialogItem(GetSelection, I_Oxide_weight_percent, DType, DItem, tempRect);		temp := GetControlValue(controlhandle(DItem));		if temp = 1 then			ICOX := 0		else			ICOX := 1;		GetDialogItem(GetSelection, I_Element_weight_percen, DType, DItem, tempRect);		temp := GetControlValue(controlhandle(DItem));		if temp = 1 then			ICEL := 0		else			ICEL := 1;		GetDialogItem(GetSelection, I_k_values, DType, DItem, tempRect);		temp := GetControlValue(controlhandle(DItem));		if temp = 1 then			IKEL := 0		else			IKEL := 1;		GetDialogItem(GetSelection, I_Output_to_Screen, DType, DItem, tempRect);		temp := GetControlValue(controlhandle(DItem));			{ Output to Screen? }		Index := I_Compressed_Output;		repeat			GetDialogItem(GetSelection, Index, DType, DItem, tempRect);			temp := GetControlValue(controlhandle(DItem));			Index := Index + 1;		until (temp <> 0) or (Index > I_Full_Output);		temp := Index - I_Compressed_Output + 1;		if temp = 2 then			IPRN := 1		else			IPRN := 0;		DisposeDialog(GetSelection);	end;    						{End of procedure}	procedure CIT_Per_Tab_Buttons;	const   							{These are the item numbers for controls in the Dialog}		I_Accept = 1;		I_H = 2; { the rest of the element button numbers are in between H & Am }		I_Am = 96;		I_Clear_All = 97;		I_Help = 98;		I_Clear_Last = 99;	var		    ExitDialog: boolean;   		    			GetSelection: DialogPtr; 			tempRect: Rect;    		 			DType: Integer;    		 			DItem: Handle; 			 			{CItem, CItem1	: controlhandle;} 			itemHit: Integer;  		  			I: Integer;	begin   							 		GetSelection := GetNewDialog(5004, nil, Pointer(-1)); 		ShowWindow(GetSelection); 		SelectWindow(GetSelection); 		SetPort(GetSelection);  	  			{еееееееееееееSetup initial conditionsеееееееееееее}		if I_N > 0 then			begin				for I := 1 to I_N do					begin						itemHit := A^.IZ[I] + I_H - 1;						GetDialogItem(GetSelection, itemHit, DType, DItem, tempRect);						HiliteControl(controlhandle(DItem), 1);    					end;			end;		ExitDialog := FALSE;		repeat			ModalDialog(nil, itemHit);			GetDialogItem(GetSelection, itemHit, DType, DItem, tempRect);			{CItem := controlhandle(DItem);}			if (itemhit >= I_H) and (itemhit <= I_Am) then				begin					if I_N = 0 then						I_NEW := 0					else						begin							for i := 1 to I_N do								begin									if A^.IZ[I] = itemhit - (I_H - 1) then										I_NEW := 1								end;						end;					I_N := I_N + 1;					A^.IZ[I_N] := itemhit - (I_H - 1);					GetDialogItem(GetSelection, itemhit, DType, DItem, tempRect);					HiliteControl(controlhandle(DItem), 1); {Black out the zone to add some zing}					D_Element_Dialog;					if I_NEW = 1 then						begin							I_NEW := 0;							BeepBeep;							PutMessage('You have clicked the same element more than once.', 'If you did not do that deliberately then ', 'click the "Clear Last" button.', '');						end;				end;			         (* numtostring(i_n,str);}{					  putmessage(str,'','','');	*)			if (ItemHit = I_Clear_Last) and (I_N > 0) then				begin					I := A^.IZ[I_N] + I_H - 1;					GetDialogItem(GetSelection, I, DType, DItem, tempRect);					HiliteControl(controlhandle(DItem), 0);   {White out the zone}					A^.IZ[I_N] := 0;					G4^^.IL[I_N] := 0;					A^.GR[I_N] := 0;					I_N := I_N - 1;				end;			if (ItemHit = I_Help) then				begin					Putmessage('Tough Luck ', '', '', '');				end;			if (ItemHit = I_Clear_All) then				begin					for I := 1 to I_N do						begin						    GetDialogItem(GetSelection, A^.IZ[I] + I_H - 1, DType, DItem, tempRect);						    HiliteControl(controlhandle(DItem), 0);     							A^.IZ[I] := 0;							G4^^.IL[I] := 0;							A^.GR[I] := 0;					    end;						  											I_N := 0; 				end;			if (ItemHit = I_Accept) then				begin					ExitDialog := TRUE;				end;		until ExitDialog;			{ееееееееееGet results after dialogеееееееее}		DisposeDialog(GetSelection);		if I_N > 0 then D_Edit_File_Elements;	end;    						{End of procedure}  PROCEDURE SeeMe;     VAR      tempRect                     : Rect;                  offset                       : integer;	  Left                         : integer;	  Top                          : integer;      n                            : integer;	  i, ii                        : integer;	  G_Help                       : DialogPtr;      itemHit                      : integer;      DType                         : Integer;      DItem                         : Handle;	  ExitDialog                    : Boolean;	  str,str1,str2,str3,str4,str5,str6,str7  : str255;	      CONST      G_Accept                      = 1;	label   5000;  	  BEGIN                                                         			G_Help := GetNewDialog(433, NIL, POINTER( - 1));			ShowWindow(G_Help);			SelectWindow(G_Help);			SetPort(G_Help);			OutlineButton(G_Help, 1, 16); { outline the OK button }			SetFont('Monaco', 9, []);			offset := 12;			Left := 5;			Top := 15;				             n := 0; 			n := n+1;	 			moveto(Left,Top + n*offset); 			str := CONCAT('Sample ID = ',ID_Name);						DrawString(str); 			n := n+2;						moveto(Left,Top + n*offset);			realtostring( E0  ,5,2,str);			str := CONCAT('kV is ',str);						DrawString(str);						n := n+1;			moveto(Left,Top + n*offset);			realtostring( T0 ,5,2,str);			str := CONCAT('X-Ray Emergence Angle is ',str);			            DrawString(str);    	  if IPtc = 1 then 	  begin  			n := n+1;			moveto(Left,Top + n*offset);			{Numtostring( IMN ,str);			str := CONCAT('Int. step Length= ',str);}			ii := 1;			FOR i := 1 to 6 DO			IF (IMD1[i] = 1) then ii := i;			str := CONCAT('Particle Model = ',P_Model[ii]);			            DrawString(str); 			n := n+1;			moveto(Left,Top + n*offset);			Realtostring( {10000*}DIA[IptcD]/PRho,5,2,str);			str := CONCAT('Diameter= ',str);			            DrawString(str);			n := n+1;			moveto(Left,Top + n*offset);			realtostring( DIA[IptcD] ,5,2,str);			str := CONCAT('Thin Film or Thick Polished Specimen  T= ',str);			            DrawString(str);			n := n+1;			moveto(Left,Top + n*offset);			realtostring( PRho ,5,2,str);			str := CONCAT('Density= ',str);			            DrawString(str);end; 			n := n+2;            moveto(Left,Top + n*offset); str := 'Element      K-Value       K-(Std)      El. Wt%       Ox Wt%      Norm El%     Norm Ox%      Atom Propor.';            DrawString(str);			n := n+1;			moveto(Left,Top + n*offset);        SUMOX1 := 0;      FOR i := 1 TO IN1 DO        SUMOX1 := SUMOX1 + G^^.C[i] * G4^^.GR1[i];      IF Num_Oxs > 0 THEN SCAT := 0;      IF Num_Oxs = 0 THEN        BEGIN          FOR i := 1 TO IN1 DO            IF (ICCAT = 0) OR ((G4^^.IL[i] <> 6) AND (G4^^.GR1[i] > 0)) THEN SCAT := SCAT + G^^.C[i] / G4^^.B[i];        END; { IF Num_Oxs = 0 }      FOR i := 1 TO I_N DO        BEGIN          IF G^^.C[i] > 0 THEN            BEGIN              IF (Num_Oxs = 0) THEN CAT := (G^^.C[i] / G4^^.B[i]) * (NCAT / SCAT)              ELSE CAT := G^^.C[i] / G4^^.B[i] / (G^^.C[I_N] / G4^^.B[I_N]) * Num_Oxs;                             IF (G4^^.IL[I_N] = 0) AND (i = I_N) THEN ICHOICE := 2;              IF (G4^^.IL[I_N] = 0) AND (i = I_N) THEN GOTO 5000;              IF i = I_N THEN SUMOX2 := 100 * (G^^.C[i] - SUMOX1)              ELSE SUMOX2 := 100 * (G^^.C[i] * (1 + G4^^.GR1[i]));              IF (IM2 > 0) AND (G^^.C[i] < 0.01) THEN ICHOICE := 1              ELSE ICHOICE := 0;            5000:              CASE ICHOICE OF                0:                  BEGIN { regular analysis format }				     str := A^.Sym[A^.IZ[i]];   { the atomic symbol }                     RealToString(G4^^.K[i],5,4,str1);  					 RealToString(G4^^.KSMP[i],5,4,str2);					 RealToString(100 * G^^.C[i],5,2,str3);					 RealToString(SUMOX2,5,2,str4);					 RealToString(100 * G^^.C[i] / M4,5,2,str5);                      RealToString(SUMOX2 / M4,5,2,str6);					 RealToString(CAT,5,3,str7); 					 str := CONCAT('  ',					               str, '          ',					               str1,'        ',								   str2,'        ',								   str3,'        ',								   str4,'        ',								   str5,'        ',								   str6,'          ',								   str7);                     DrawString(str);			n := n+1;			moveto(Left,Top + n*offset);											                    END;				   				   				   (*                1:                  BEGIN { trace analysis format }                    Write(Out_TxtFile, G4^^.K[i]: 13: 6, G4^^.KSMP[i]: 10: 6, 100 * G^^.C[i]: 10: 4, SUMOX2: 9: 4, 100 *                          G^^.C[i] / M4: 11: 4);                    writeln(Out_TxtFile, SUMOX2 / M4: 12: 4, CAT: 11: 4);                  END;                2:                  BEGIN { oxygen analysis format }                    Write(Out_TxtFile, '       -----     -----    ');                    writeln(Out_TxtFile, 100 * G^^.C[i]: 7: 2, 100 * G^^.C[i] / M4: 20: 2, CAT: 23: 3);                  END; { case 2 }*)                END; { CASE }            END; { IF G^^.C[I] > 0 }									        END; { i loop } 			RealToString(M4*100,5,2,str1);			str1 := CONCAT('                                   SUM = ',str1);			DrawString(str1);     REPEAT  ModalDialog(NIL, itemHit);  GetDialogItem(G_Help, itemHit, DType, DItem, tempRect);  IF (itemHit = G_Accept) THEN	BEGIN	  ExitDialog := True;	END;UNTIL ExitDialog;					DisposeDialog(G_Help);			beginupdate(BackPlane);			DrawAxesFull;			Update_Full;			EndUpdate(BackPlane);		    UpDate_SiLi_Window(SiLiWindow) ;			 END;                                              {End of SeeMe procedure}		 procedure Spectrum_Handler_1;VAR I, Ixx : Integer;peak_label : str_5;index1, index2, k2	: integer;unk_inten           : ARRAY [1..15] OF real {double_t};line_pos_in_structure	: ARRAY [1..15] of integer;Num_Peaks					 : integer;peak_int						: real {double_t};BEGIN   Num_Peaks := analysis_result^^.Fit_params.Number_of_Peaks;   IN9 := 6;   ID_Name := 'sample temp';   for I:= 1 to IN1 do G2^^.F[2,I] := 0;{ set backgrounds to zero }   for I:= 1 to IN1 do G2^^.F[4,I] := 0;{ set sample pk intensities to 0 }   for I:= 1 to IN1 do unk_inten[I] := 0.0;   for I:= 1 to IN1 do   begin    if (G^^.IT[I]=0) and (G4^^.IL[I]<4) then 	  begin	  	unk_inten[I] := 0.0;					  IF (analysis_result^^.Fit_params.Fit_Procedure = 'Sm')						  THEN							BEGIN							  ZAF_Record^^.ZAF_data.Simplex_run := True;									  IF (G4^^.IL[I] = 1)										THEN peak_label := 'KA1  ';									  IF (G4^^.IL[I] = 2)										THEN peak_label := 'LA1  ';									  IF (G4^^.IL[I] = 3)										THEN peak_label := 'MA1  ';							END					  ELSE						IF (analysis_result^^.Fit_params.Fit_Procedure = 'ML')						  THEN							BEGIN							  ZAF_Record^^.ZAF_data.ML_run := True;									  IF (G4^^.IL[I] = 1)										THEN peak_label := 'KA   ';									  IF (G4^^.IL[I] = 2)										THEN peak_label := 'LA   ';									  IF (G4^^.IL[I] = 3)										THEN peak_label := 'MA   ';							END;													k2 := 0;						ZAF_Record^^.Faraday_current := 							   (analysis_result^^.SpectrumStuff.Acq_Info.Begin_Faraday +								analysis_result^^.SpectrumStuff.Acq_Info.End_Faraday) / 2;						IF (ZAF_Record^^.Faraday_current <= 0.0) then							ZAF_Record^^.Faraday_current := 1.0;                      FOR index1 := 1 TO Num_Peaks DO                        BEGIN							spincursor;							  									   						if (ZAF_Record^^.ZAF_data.Simplex_run = TRUE) then							begin							                              IF ((analysis_result^^.Fit_params.Atomic_Number[index1] = A^.IZ[I]) AND							  	 (analysis_result^^.Fit_params.Siegbahn[index1] = peak_label) AND								 (analysis_result^^.Fit_params.Siegbahn[index1][4] <> 'D')) THEN                                BEGIN{This may not be necessary}														  (*for index2 := 1 to ZAF_Record^^.ZAF_data.Num_elements do						  		if (A^.IZ[I] = ZAF_Record^^.ZAF_data.Atomic_Number[index2]) then Ixx := index2;					    	find_peak_in_ROI(Ixx, index1, peak_int);							if (ZAF_Record^^.ZAF_data.Spare1[Ixx] > 0) AND							(peak_int <> 0.0) then						 		 begin									unk_inten[I] := peak_int;*)																		line_pos_in_structure[I] := index1;							  (*  Select peaks here *)							  							  for index2 := 1 TO Num_Peaks DO							    begin																  IF (analysis_result^^.Fit_params.Atomic_Number[index2] = A^.IZ[I]) AND								  	(Analysis_result^^.Fit_result.Err_or_Energy[index2]*1000 < ZAF_Record^^.ZAF_data.M_kRatio[I]) AND									(Analysis_result^^.Fit_result.Err_or_Energy[index2]*1000 > ZAF_Record^^.ZAF_data.L_kRatio[I]) then									begin									  k2 := k2 +1;									  unk_inten[I] := unk_inten[I] + analysis_result^^.Fit_Result.Area[index2];									end;							      end;		{for index2 := 1 TO Num_Peaks}								  																	 END;								end		{if ZAF_Record^^.ZAF_data.Simplex_run}													else if (ZAF_Record^^.ZAF_data.ML_run = TRUE) then					  BEGIN					  					(*numtostring(analysis_result^^.Fit_params.Atomic_Number[index1], str1);					str2 := concat(' element found ',str1,' ',analysis_result^^.Fit_params.Siegbahn[index1]);					numtostring(analysis_result^^.Fit_params.Ref_Index[index1], str1);					putmessage('Look for ',str,str2,str1);*)										  IF ((analysis_result^^.Fit_params.Atomic_Number[index1] = A^.IZ[I]) AND 					  (analysis_result^^.Fit_params.Siegbahn[index1][1] = peak_label[1]) AND 					  (analysis_result^^.Fit_params.Ref_Index[index1] > 0) AND					  (analysis_result^^.Fit_params.Siegbahn[index1][4] <> 'D')) THEN						BEGIN						  for index2 := 1 to ZAF_Record^^.ZAF_data.Num_elements do						  		if (A^.IZ[I] = ZAF_Record^^.ZAF_data.Atomic_Number[index2]) then Ixx := index2;					    	find_peak_in_ROI(Ixx, index1, peak_int);												(*numtostring(ZAF_Record^^.ZAF_data.Spare1[Ixx],str);					realtostring(peak_int,8,2,str1);					putmessage('Spare1[Ixx] is ',str,' and peak_int is ',str1);*)											if (ZAF_Record^^.ZAF_data.Spare1[Ixx] > 0) AND							(peak_int <> 0.0) then						  begin							unk_inten[I] := peak_int;							line_pos_in_structure[I] := index1;														(*numtostring(A^.IZ[I], str);							realtostring(unk_inten[I],8,2,str1);							numtostring(line_pos_in_structure[I], str2);							putmessage(' Unk Z, int, pos: ',str,str1,str2);*)													  end;						END;					  END;		{IF (ZAF_Record^^.ZAF_data.ML_run = TRUE)}								                    END;                          { for index1 := 1 to Num_Peaks }										{IF (ZAF_Record^^.ZAF_data.Simplex_run = TRUE) THEN}				  unk_inten[I] := unk_inten[I] / analysis_result^^.SpectrumStuff.Acq_Info.Live_Time /						ZAF_Record^^.Faraday_current;								(*	for I2 := 1 to analysis_result^^.Fit_Params.Number_of_Peaks do			   if ((A^.IZ[I]= analysis_result^^.Fit_Params.Atomic_Number[I2]) and			   (analysis_result^^.Fit_params.Siegbahn[I2] = peak_label)) then	*)			            G2^^.F[4,I] := unk_inten[I];	        {we are not checking to see if a spectrum had two families for same element}	   {Now we are}	  end;   end;   MAIN_Handler1; { еееее runs analysis }   for I := 1 to I_N do   begin    if (G4^^.IL[I] > 0) AND (G4^^.IL[I] < 4) AND (G^^.IT[I] = 0) then	 begin		ZAF_Record^^.ZAF_data.Concentration[I] := G^^.C[I];		analysis_result^^.Fit_Result.conc[line_pos_in_structure[I]] := (G^^.C[I]);	 end;   end;        WITH ZAF_Record^^, ZAF_data DO          BEGIN	if (Unanal_Z_On) then	  begin	    Num_Peaks := analysis_result^^.Fit_Params.Number_of_Peaks;		if ( analysis_result^^.Fit_params.Atomic_Number[Num_Peaks] = A^.IZ[I_N] ) then		  begin			analysis_result^^.Fit_Result.conc[Num_Peaks] := (G^^.C[I_N]);			Concentration[Num_elements] := (G^^.C[I_N]);			if ( Stoic_Diff ) then			  analysis_result^^.Fit_params.Siegbahn[Num_Peaks] := 'Stoic'			else			  analysis_result^^.Fit_params.Siegbahn[Num_Peaks] := 'Diff ';		  end		else		  begin			analysis_result^^.Fit_params.Number_of_Peaks := Num_Peaks + 1;			index1 := analysis_result^^.Fit_params.Number_of_Peaks;			Concentration[Num_elements] := (G^^.C[I_N]);			analysis_result^^.Fit_Result.conc[index1] := (G^^.C[I_N]);			analysis_result^^.Fit_params.Atomic_Number[index1] := A^.IZ[I_N];			Atomic_Number[Num_elements] := A^.IZ[I_N];			if ( Stoic_Diff ) then			 begin			  analysis_result^^.Fit_params.Siegbahn[index1] := 'Stoic';			  Siegbahn[Num_elements] := 'Stoic';			 end			else			 begin			  analysis_result^^.Fit_params.Siegbahn[index1] := 'Diff ';			  Siegbahn[Num_elements] := 'Diff';			 end;		  end;		end;	END;	    if not Fit_Invisibly then SeeMe;     END; { procedure Spectrum_Handler_1; }    procedure Spectrum_Handler;VAR I,I4,I5 : Integer;I1,I2,I3, I_2, I_3 : Integer;I_Gnu, std_found : Boolean;I_Match : Array[1..15] of Integer;Beginif not First_Time then exit(Spectrum_Handler);First_Time := false; if not Manual_Mode then begin E0 := ZAF_Record^^.E0; T0 := ZAF_Record^^.Take_Off_Angle; end;  D_Correction_Procedure; D_Printout_Conditions;                     (*						C_Store_Process: 							begin								Setup_File_Input := False;								MAIN_Handler;							end;						C_Standard_Info: 							begin								Run_Data_Now := False;								D_Standard_Choice;							end;						C_Input_Manually: 							begin								Run_Data_Now := True;								D_Input_Data_Codes;                      *)					  					    I_N := ZAF_Record^^.ZAF_data.Num_elements; I_3:=0; I_2:=0; for I := 1 to I_N do  begin  I_Match[I] := 0;  if (ZAF_Record^^.ZAF_data.Atomic_Number[I]>3) AND (ZAF_Record^^.ZAF_data.Atomic_Number[I]<95) then     begin	    I_2:=I_2+1;		I_3:=I_3+1;        A^.IZ[I_2] := ZAF_Record^^.ZAF_data.Atomic_Number[I];        A^.GR[I_2] := ZAF_Record^^.ZAF_data.Valence[I]/2;        if ZAF_Record^^.ZAF_data.Siegbahn[I][1]='K' then G4^^.IL[I_2] := 1;        if ZAF_Record^^.ZAF_data.Siegbahn[I][1]='L' then G4^^.IL[I_2] := 2;        if ZAF_Record^^.ZAF_data.Siegbahn[I][1]='M' then G4^^.IL[I_2] := 3;          if ZAF_Record^^.ZAF_data.Siegbahn[I][1]='D' then            Begin             G4^^.IL[I_2] := 4;	         A^.GR[I_2]:= 0;           End;	         if ZAF_Record^^.ZAF_data.Siegbahn[I][1]='S' then 		   Begin			 G4^^.IL[I_2] := 0;			 A^.GR[I_2]:= 0;		   End;	 		   if ZAF_Record^^.ZAF_data.Siegbahn[I][1]='F' then 		   Begin			 G4^^.IL[I_2] := 5;			 G4^^.K[I_2] := ZAF_Record^^.ZAF_data.Concentration[I];		   End;	 (* 				numtostring(I_2,str);		numtostring(A^.IZ[I_2],str1);		numtostring(G4^^.IL[I_2],str2);		putmessage('ее1ее  I-2, A^.IZ[I_2], G4^^.IL[I_2]: ',str,str1,str2);	*)	    end;	     end;  I_2:= I_N;  I_N:=I_3;  I1 := 0;  For I := 1 to I_N do   BEGIN     If G4^^.IL[I]=0 then if I1>0 then 	  begin	   putmessage('You can not have more than one element as a valence element','','','');	   exit(Spectrum_Handler);	  end	 else I1 := I;   END;if I1>0 thenBEGIN  A^.IZ[I_N+1]:= A^.IZ[I1];  G4^^.IL[I_N+1]:= G4^^.IL[I1];  A^.GR[I_N+1]:= A^.GR[I1];  For I := I1 to I_N do    begin	 A^.IZ[I]:= A^.IZ[I+1];	 G4^^.IL[I]:= G4^^.IL[I+1];	 A^.GR[I]:= A^.GR[I+1];	end;  A^.IZ[I_N+1]:= 0;  G4^^.IL[I_N+1]:= 0;  A^.GR[I_N+1]:= 0;	END;If G4^^.IL[I_N]=0 then IN1:= I_N-1 else                  IN1:= I_N;For I := 1 to IN1 doif G4^^.IL[I]<4 thenBEGIN for I1 := 1 to {I_2} IN1 {ZAF_Record^^.ZAF_data.Num_elements} do   begin  	{if ZAF_Record^^.ZAF_data.Spare1[I] > 0 then 		begin		I_Match[I]:= I1;}	if (G^^.IT[I]=0) and (G4^^.IL[I]<4) then 	  begin	    for I2 := 1 to ZAF_Record^^.Quant_stds.Num_Std_Elems[I1] do		    begin			 I_Gnu := TRUE;			 for I3 := 1 to I_N do			   begin			     if A^.IZ[I3]=ZAF_Record^^.Quant_stds.Z_of_Std_Elems[I1,I2] then				    I_Gnu := FALSE;			   end;			   if (I_Gnu) AND (ZAF_Record^^.Quant_stds.Z_of_Std_Elems[I1,I2]>3)  AND 			       (ZAF_Record^^.Quant_stds.Z_of_Std_Elems[I1,I2]<95) then 			     begin				   A^.IZ[I_N+1]:= A^.IZ[I_N];				   G4^^.IL[I_N+1]:= G4^^.IL[I_N];				   A^.GR[I_N+1]:= A^.GR[I_N];				   A^.IZ[I_N]:= ZAF_Record^^.Quant_stds.Z_of_Std_Elems[I1,I2];				   G4^^.IL[I_N] := -1 ;				   A^.GR[I_N]:= 0;				   I_N := I_N+1;  				 end;			end;				end; 	  end; END;    Setup_File_Input := False;   MAIN_Handler;   IN9:= 9; { weight fractions, setting up for standards}   std_found := false;   For I1 := 1 to IN1 do	{do I1}   BEGIN    if (G^^.IT[I1]=0) and (G4^^.IL[I1]<4) then 	 begin		IN8 := I1;		for I := 1 to I_N do G4^^.K[I]:=0;		 std_found := false;		 I := 1;		 REPEAT	{UNTIL (I = I_N) OR (std_found = true)}		  		I5 := 1;		REPEAT	{(I5 > ZAF_Record^^.ZAF_data.Num_elements) OR (std_found = true)}		    if (A^.IZ[I1]= ZAF_Record^^.ZAF_data.Atomic_Number[I5]) AND (ZAF_Record^^.ZAF_data.Spare1[I5] > 0) then 		BEGIN			  I2 := 1;			  REPEAT	{UNTIL (I2 > ZAF_Record^^.Quant_stds.Num_Std_Elems[I5]) OR (std_found = true)}								(*if (A^.IZ[I1]= ZAF_Record^^.Quant_stds.Z_of_Std_Elems[I5,I2]) then begin	{do if}*)					FOR I4 := 1 to I_N do begin						for I3 := 1 to ZAF_Record^^.Quant_stds.Num_Std_Elems[I5] do begin						  if (A^.IZ[I4]= ZAF_Record^^.Quant_stds.Z_of_Std_Elems[I5,I3]) {and								(G4^^.K[I4] = 0.0)} then							G4^^.K[I4]:=ZAF_Record^^.Quant_stds.C_of_Std_Elems[I5,I3];						end;	{do I3}					end;	{do I4}									 ElemStd:= ZAF_Record^^.ZAF_data.Std_Name[I5];				 std_found := true;			   (*end;	{do if}*)			 			 I2 := I2 + 1;			 UNTIL (I2 > ZAF_Record^^.Quant_stds.Num_Std_Elems[I5]) OR (std_found = true);		 END;		 I5 := I5 + 1;		 UNTIL (I5 > ZAF_Record^^.ZAF_data.Num_elements) OR (std_found = true);		 I := I + 1;		 UNTIL (I = I_N) OR (std_found = true); 		 Run_Data_Now := True; 		 MAIN_Handler1; { calculates corr factors for standards }	 	 end; { if IT[I]=0 }   END;	{do I1}   IN9 := 5;   for I:= 1 to IN1 do G2^^.F[1,I] := 0;{ set backgrounds to zero }   for I:= 1 to IN1 do G2^^.F[3,I] := 1;{ set std pk intensities to 1 }   for I:= 1 to IN1 do   begin    if (G^^.IT[I]=0) and (G4^^.IL[I]<4) then 	  begin		for I2 := 1 to ZAF_Record^^.ZAF_data.Num_Elements do			   if A^.IZ[I]= ZAF_Record^^.ZAF_data.Atomic_Number[I2] then begin	{xx}					 G2^^.F[3,I]:=ZAF_Record^^.ZAF_data.RawArea[I2];{we are not checking to see if a spectrum had two families for same element}	(*	numToString(ZAF_Record^^.ZAF_data.Num_Elements, str);		numToString(ZAF_Record^^.ZAF_data.Atomic_Number[I2], str1);		numToString(I, str2);		realtostring(ZAF_Record^^.ZAF_data.RawArea[I2],8,2, str3);		str4 := concat(' No. of ele = ',str,' I = ',str2);		str := concat(' At No = ',str1,' Area = ',str3);		putmessage('Output from CharForce2 ',str4,str,'');*)		end;	{xx}	  end;   end;   MAIN_Handler1; { store the intensities of the standards } end; { procedure Spectrum_Handler; }{$S CharForce3}	procedure D_Input_Data_Codes;	const		I_Input_standard_concen = 1;		I_Input_drift_correctio = 2;		I_Input_standard_compos = 3;		I_Input_number_of_catio = 4;		I_Input_background_Std = 5;		I_Input_background_Smp = 15;		I_Input_peak_counts_for = 6;		I_Input_peak_counts_for7 = 7;		I_end_of_data_in_this_f = 8;		I_end_of_data__exit_pro = 9;		I_Input_Sample_k_ratios = 10; 		I_Input_Change_P_Thin   =  14;			var		    ExitDialog: boolean; 			GetSelection: DialogPtr;			tempRect: Rect;			DType: Integer;			DItem: Handle;			itemHit		: Integer; 		procedure Refresh_Dialog;   		{Refresh the dialogs non-controls}			var				rTempRect: Rect;     		{Temp rectangle used for drawing}		begin			SetPort(GetSelection);  	{Point to our dialog window}			rTempRect := tempRect;  	{Save the current contents of  tempRect}  			tempRect := rTempRect;  	{Restore the current contents of  tempRect}		end;	begin   							{Start of dialog handler}		GetSelection := GetNewDialog(428, nil, Pointer(-1));{Bring in the dialog resource}		ShowWindow(GetSelection);{Open a dialog box}		SelectWindow(GetSelection);{Lets see it}		SetPort(GetSelection);  	{Prepare to add conditional text} 			 		Refresh_Dialog;     		 		ExitDialog := FALSE;  		 		repeat  					 			ModalDialog(nil, itemHit); 			GetDialogItem(GetSelection, itemHit, DType, DItem, tempRect); 				{Handle it real time}			if (ItemHit = I_Input_standard_concen) then				begin					D_Code_1;					Refresh_Dialog;					SeeMe; 				end;			if (ItemHit = I_Input_Change_P_Thin) then				begin                  D_Particle_Geometry; 				end;			if (ItemHit = I_Input_drift_correctio) then				begin					D_Code_2;					Refresh_Dialog;				end;			if (ItemHit = I_Input_standard_compos) then				begin					D_Code_8;					Refresh_Dialog;				end;			if (ItemHit = I_Input_number_of_catio) then				begin					D_Code_7;					Refresh_Dialog;				end;			if (ItemHit = I_Input_background_Std) then				begin					D_Code_4a;					Refresh_Dialog;				end;			if (ItemHit = I_Input_background_Smp) then				begin					D_Code_4b;					Refresh_Dialog;				end;			if (ItemHit = I_Input_peak_counts_for) then				begin					D_Code_5;					Refresh_Dialog; 				end;			if (ItemHit = I_Input_peak_counts_for7) then				begin					D_Code_6;					Refresh_Dialog;					SeeMe;				end;			if (ItemHit = I_end_of_data_in_this_f) then				begin					ExitDialog := TRUE;					Refresh_Dialog;				end;			if (ItemHit = I_end_of_data__exit_pro) then				begin					ExitDialog := TRUE;					Refresh_Dialog;					  sysbeep(10);					  sysbeep(10);					    if not demo_DTSA then Writeln(Out_TxtFile1, ' 12');						if not demo_DTSA then Writeln(Out_TxtFile1, '');												{if not demo_DTSA then PLFlush(Out_TxtFile1); 						if not demo_DTSA then PLFlush ( Out_TxtFile );}												if not demo_DTSA then Close(Out_TxtFile); 						{Close(TxtFile1);} {read only} 						if not demo_DTSA then Close(Out_TxtFile1); 				end;			if (ItemHit = I_Input_Sample_k_ratios) then				begin					D_Code_3;					Refresh_Dialog;					SeeMe;				end;  		until ExitDialog;         		DisposeDialog(GetSelection);	end;    						{End of procedure}	function MyFilter (theDialog: DialogPtr;									var theEvent: EventRecord;									var itemHit: integer): boolean;		var			temp: Longint;			DataLen: Integer;			str_3: string[3];		function Strip_Trailing_Blanks (symbol: str255): str255;			var				nn, count: integer;		begin                                           {main function}			count := LENGTH(symbol);			for nn := count downto 1 do				begin					if symbol[nn] = ' ' then						Delete(symbol, nn, 1)					else						begin							Strip_Trailing_Blanks := symbol;							exit(Strip_Trailing_Blanks);						end;				end;			Strip_Trailing_Blanks := symbol;		end;                                            {of Function Strip_Trailing_Blanks}	begin		MyFilter := FALSE;		if (theEvent.what = MouseDown) then    {Only do on a mouse click}			begin				dummy_Boolean := False;				MyPt := theEvent.where;     {Get the point where the mouse was clicked}				GlobalToLocal(MyPt);				if PtInRect(myPt, Rect_I_List1) then					begin						DoubleClick := LClick(myPt, theEvent.modifiers, List_I_List1);						if DoubleClick then							begin								dataLen := 3;								str_3 := '   ';								LGetCell(Pointer(ord(@str_3) + 1), dataLen, List_I_List1^^.lastClick, List_I_List1);								str_3 := Strip_Trailing_Blanks(str_3);								StringToNum(str_3, temp);								itemHit := integer(temp + 10);								dummy_Boolean := True;								MyFilter := TRUE;							end;					end;    					{End of PtInRect}			end;	end;{===========================================================}(*	procedure D_Standards_Picker;	const   							{These are the item numbers for controls in the Dialog}		I_Accept = 1;		I_Cancel = 2;		I_Clear_Choices = 3;		I_Open_another_Standard = 3;		I_List1 = 5; 		I_Help = 4;		I_Message = 4; 		I_1 = 5;		I_20 = 24; 		I_x45 = 26; 		I_el_1 = 27;		I_el_20 = 46; 		I_tx_1 = 47;		I_tx_20 = 66; 		I_Drawn_line1 = 67;		I_Drawn_line2 = 68;	var		I_Line: Integer;		I_Pick: integer;		MyErr: OSErr;  				     {OS error returned}		cSize: Point;  			          {Pointer to a cell in a list}		RecOffset: array[1..99] of Integer;		JJ: Integer;		Rem_Row_DClicked: Integer;		theCell: Cell;		LineHit: Longint;		bytecount : Longint;			GetSelection: DialogPtr; 			tempRect: Rect;    		 			DType: Integer;    		 			Index: Integer;    		 			DItem: Handle; 			 			CItem, CTempItem: controlhandle; 			sTemp: Str255; 			 			itemHit: Integer;  		 			temp: Integer; 			 			dataBounds: Rect;  		    			I_Num: array[1..20] of Integer;			J, I1: Integer;			ExitDialog: boolean;			err: OSErr;			I_Total: Integer;			I_Last_Z: Integer;			I_Last_Line: Integer;			I_Last_Grav: Real;			Is_Elem_Here: Integer;			I2: Integer;			Last_Std_Name: str255;			Last_Area: Real;			Std_Comp_El: array[1..20, 1..20] of Integer;			Std_Comp_Conc: array[1..20, 1..20] of Real;			Std_Comp_Nel: array[1..20] of Integer;			Std_Name: array[1..20] of Str255;			Std_Name1: array[1..20] of Str255;			Std_Area: array[1..20] of Real;		procedure D_Lister;			var				GetSelection: DialogPtr; 				tempRect: Rect;    		 				DType: Integer;    		 				Index: Integer;    		 				DItem: Handle; 			 				CItem, CTempItem: controlhandle; 				sTemp: Str255; 			 				itemHit: Integer;  		 				temp: Integer; 			  				theRow: integer;   		    				DateAndTimeStr: str255;				K, J: integer;				index1, index2, ZZ: integer;				Area_K, Area_Km1: Real;				err: OSErr;				ExitDialog: boolean;				Is_Line_Here: integer;				Is_Line_Here_also: integer;				Temp_Time: Real;				Temp_Current: real; 			procedure Refresh_Dialog;   		 				var					rTempRect: Rect;     		 			begin				SetPort(GetSelection);  	 				GetDialogItem(GetSelection, I_Accept, DType, DItem, tempRect); 				PenSize(3, 3);  			 				InsetRect(tempRect, -4, -4); 				FrameRoundRect(tempRect, 16, 16);  				PenSize(1, 1);  			 				LUpdate(GetSelection^.visRgn, List_I_List1); 				rTempRect := Rect_I_List1; 				InsetRect(rTempRect, -1, -1); 				FrameRect(rTempRect);   	 			end;	{This is a routine used to add strings to an existing list}			procedure Add_List_String (theString: Str255;											theList: ListHandle);				var					theRow: integer; 			 			begin				if (theList <> nil) then					begin						cSize.h := 0;   		{Point to the correct column}						theRow := LAddRow(1, 200, theList);{Add another row at the end of the list}						cSize.v := theRow;  	{Point to the row just added}						sTemp := theString;  	{Get the string to add}						LSetCell(Pointer(ord(@sTemp) + 1), length(sTemp), cSize, theList);{Place string in row just created}						LDraw(cSize, theList);{Draw the new string}					end;			end;		begin   							 			GetSelection := GetNewDialog(2345, nil, Pointer(-1));  			ShowWindow(GetSelection); 			SelectWindow(GetSelection); 			SetPort(GetSelection);  	  			SetRect(Rect_I_List1, 20, 140, 540, 340);{left,top,right,bottom}			tempRect := Rect_I_List1;{Start with full size}			tempRect.Right := tempRect.Right - 15;{Make room for the scroll bar on the right}			if (tempRect.Right <= (tempRect.Left + 15)) then{Safety check}				tempRect.Right := tempRect.Left + 15;{Safety check}			InsetRect(tempRect, -1, -1);{Set for framing}			FrameRect(tempRect);    	{Frame it}			InsetRect(tempRect, 1, 1);{Restore}			SetRect(dataBounds, 0, 0, 1, 0);{Set list up}			cSize.h := tempRect.Right - tempRect.Left;{Width of the list}			cSize.v := 0;   			{Height of a cell, let List Manager determine the size}			List_I_List1 := LNew(tempRect, dataBounds, cSize, 0, GetSelection, TRUE, FALSE, FALSE, TRUE);{Make the list}			List_I_List1^^.selFlags := lOnlyOne + lNoNilHilite;{Set the attributes}			LdoDraw(TRUE, List_I_List1); {Draw the list}			errCode := FSOpen(MCA_ResultsName, MCA_Results_VolNum, refnum);			errCode := setfpos(refnum, fsFromstart, 0);			if errCode <> 0 then				putmessage('A setfpos(...) error in procedure Open_OldFit_File just happened', '', '', '');			bytecount := 1;			errCode := FSRead(refnum, bytecount, @Is_Batch);			if errCode <> 0 then				putmessage('An FSRead(...) error in procedure Open_OldFit_File at 1 just happened', '', '', '');			J := 0;	{ counts Number of fits }			JJ := 0;			bytecount := Sizeof(Simplex_Fit);			err := FSRead(refnum, bytecount, (@Analysis_result^^));			while err <> EOFerr do	{ the next FSRead is just before END of WHILE}				begin					JJ := JJ + 1; { Count the number of records read }					Is_Line_Here := 0;					Is_Line_Here_Also := 0;					if (Analysis_result^^.SpectrumStuff.Spectrum_Info.This_is_a_Standard) and 					   (Analysis_Result^^.ExptStuff.KV = E0) and 					   (Analysis_Result^^.SpectrumStuff.Spectrum_Info.Take_Off_Angle = T0) then						begin							for index := 1 to Analysis_result^^.SpectrumStuff.Spectrum_Info.Number_of_Elements do								begin									if (Analysis_Result^^.SpectrumStuff.Spectrum_Info.Element_Info[index].Atomic_Number = A^.IZ[I_Pick]) and (Analysis_Result^^.SpectrumStuff.Spectrum_Info.Element_Info[index].Weight_Fraction > 0) then										Is_Line_Here := index;								end;							if Is_Line_Here > 0 then								begin									for index := 1 to MaxNumPks do										begin											I_Line := 0;											if Analysis_Result^^.Fit_params.Atomic_Number[index] = A^.IZ[I_Pick] then												begin													if (Analysis_Result^^.Fit_params.Siegbahn[index] = 'KA1  ') or (Analysis_Result^^.Fit_params.Siegbahn[index] = 'K    ') then														begin															I_Line := 1;														end;													if (Analysis_Result^^.Fit_params.Siegbahn[index] = 'LA1  ') or (Analysis_Result^^.Fit_params.Siegbahn[index] = 'L    ') then														begin															I_Line := 2;														end;													if (Analysis_Result^^.Fit_params.Siegbahn[index] = 'MA1  ') or (Analysis_Result^^.Fit_params.Siegbahn[index] = 'M    ') then														begin															I_Line := 3;														end;													if I_Line = G4^^.IL[I_Pick] then														begin															Is_Line_Here_Also := index;															leave;														end;												end;										end;								end;						end;					if (Is_Line_Here > 0) and (Is_Line_Here_Also > 0) then						begin							J := J + 1;							RecOffset[JJ] := Is_Line_Here_Also;							with Analysis_Result^^.SpectrumStuff.Spectrum_Info do								begin									numToString(jj, str1);									Str := CONCAT(str1, '  :   ', Spectrum_Comment_Field);									Add_List_String(Str, List_I_List1); {Add in the new string}								end;						end;					err := FSRead(refnum, bytecount, (@Analysis_result^^));        { read binary }				end; {WHILE err <> EOFerr...}			cSize.v := 0;   			{  Select first item }			LSetSelect(TRUE, cSize, List_I_List1);			LineHit := 0;			Refresh_Dialog;			ExitDialog := FALSE;			dummy_Boolean := False;			repeat				ModalDialog(@MyFilter, itemHit);				GetDialogItem(GetSelection, itemHit, DType, DItem, tempRect);				CItem := Pointer(DItem);{if not dummy_Boolean then}{putmessage ( 'WARNING!!!  You did not double click on a standard choice' , '' , '' , '' );}				if (ItemHit = I_Accept) then					begin						ExitDialog := TRUE;						Refresh_Dialog;					end;				if (ItemHit = I_Cancel) then					begin						Refresh_Dialog;					end;				if (ItemHit = I_Open_another_Standard) then					begin						Open_OldFit_File;						WriteFitResults;						Refresh_Dialog;					end;				if (ItemHit > 10) and (ItemHit < 109) then					begin						bytecount := Sizeof(Simplex_Fit);						errCode := setfpos(refnum, fsFromstart, (ItemHit - 11) * bytecount + 1);						err := FSRead(refnum, bytecount, (@Analysis_result^^));						Std_Name[I_Pick] := CONCAT(MCA_ResultsName, ': ', Analysis_Result^^.SpectrumStuff.Spectrum_Info.Spectrum_Comment_Field);						Std_Name1[I_Pick] := CONCAT(': ', Analysis_Result^^.SpectrumStuff.Spectrum_Info.Spectrum_Comment_Field);						Std_Area[I_Pick] := Analysis_Result^^.Fit_Result.Area[RecOffset[itemHit - 10]];						Temp_Time := analysis_result^^.SpectrumStuff.Acq_Info.Live_Time;						if Temp_Time <= 0 then							Temp_Time := 1;						Temp_Current := analysis_result^^.SpectrumStuff.Acq_Info.Begin_Faraday;						if Analysis_Result^^.SpectrumStuff.Acq_Info.End_Faraday > 0 then							Temp_Current := (Temp_Current + Analysis_Result^^.SpectrumStuff.Acq_Info.End_Faraday) / 2;						if Temp_Current <= 0 then							Temp_Current := 1;						Std_Area[I_Pick] := Std_Area[I_Pick] / (Temp_Current * Temp_Time);						GetDialogItem(GetSelection, I_Message, DType, DItem, tempRect);						str1 := '';						Std_Comp_Nel[I_Pick] := Analysis_result^^.SpectrumStuff.Spectrum_Info.Number_of_Elements;						for index1 := 1 to Analysis_result^^.SpectrumStuff.Spectrum_Info.Number_of_Elements do							begin								str1 := CONCAT(str1, '  ', A^.Sym[Analysis_Result^^.SpectrumStuff.Spectrum_Info.Element_Info[index1].Atomic_Number]);								realToString(Analysis_Result^^.SpectrumStuff.Spectrum_Info.Element_Info[index1].Weight_Fraction, 7, 4, str2);								str1 := CONCAT(str1, ': ', str2);								Std_Comp_El[I_Pick, Index1] := Analysis_Result^^.SpectrumStuff.Spectrum_Info.Element_Info[index1].Atomic_Number;								Std_Comp_Conc[I_Pick, Index1] := Analysis_Result^^.SpectrumStuff.Spectrum_Info.Element_Info[index1].Weight_Fraction;							end;						SetDialogItemText(DItem, str1);					end;			until ExitDialog;			DisposeDialog(GetSelection);			errcode := FSClose(refnum);			errcode := FlushVol(nil, MCA_Results_VolNum);		end;    						{End of procedure}		procedure Refresh_Dialog;   		 			var				rTempRect: Rect;     		 				index: integer;		begin			SetPort(GetSelection);  	 			rTempRect := tempRect;  	 			GetDialogItem(GetSelection, I_Accept, DType, DItem, tempRect); 			PenSize(3, 3);  			 			InsetRect(tempRect, -4, -4); 			FrameRoundRect(tempRect, 16, 16);  			PenSize(1, 1);  			  			PenSize(4, 4);   			 			MoveTo(104, 23); 			 			LineTo(420, 23); 			 			PenSize(1, 1);   			  			MoveTo(293, 101);    		 			LineTo(293, 322);    		 			for index := I_tx_1 to I_tx_1 + I1 - 1 do				begin					GetDialogItem(GetSelection, index, DType, DItem, tempRect);					SetDialogItemText(DItem, Std_Name1[index - I_tx_1 + 1]);				end;			tempRect := rTempRect;  	  		end;	begin   							 		GetSelection := GetNewDialog(1234, nil, Pointer(-1));  		ShowWindow(GetSelection); 		SelectWindow(GetSelection); 		SetPort(GetSelection);  	   		Refresh_Dialog;		for index := I_el_1 to I_tx_20 do			begin				GetDialogItem(GetSelection, index, DType, DItem, tempRect);				SetDialogItemText(DItem, '');			end;		I1 := 0;		for index := 1 to I_N do			begin				if (G4^^.IL[index] > 0) and (G4^^.IL[index] < 4) then					begin						I1 := I1 + 1;						GetDialogItem(GetSelection, I_el_1 + I1 - 1, DType, DItem, tempRect);						SetDialogItemText(DItem, A^.Sym[A^.IZ[index]]);						I_Num[I1] := index;					end;			end;		for index := I_tx_1 to I_tx_1 + I1 - 1 do			begin				GetDialogItem(GetSelection, index, DType, DItem, tempRect);				Std_Name1[index - I_tx_1 + 1] := ': Not yet chosen';				SetDialogItemText(DItem, Std_Name1[index - I_tx_1 + 1]);			end;		if I1 < 20 then			begin				for index := 5 + I1 to 24 do					begin						GetDialogItem(GetSelection, index, DType, DItem, tempRect);						CItem := Pointer(DItem);						HiLiteControl(CItem, 255);					end;			end;		ExitDialog := FALSE; 		repeat  								ModalDialog(nil, itemHit);			GetDialogItem(GetSelection, itemHit, DType, DItem, tempRect);			CItem := Pointer(DItem);				{Handle it real time}			if (ItemHit = I_Accept) then				begin					ExitDialog := TRUE;					Refresh_Dialog;				end;			if (ItemHit = I_Cancel) then				begin					Refresh_Dialog;				end;			if (ItemHit = I_Clear_Choices) then				begin					Refresh_Dialog;				end;			if (ItemHit = I_Help) then				begin					Refresh_Dialog;				end;			for index := I_1 to I_20 do				begin					if (ItemHit = index) then						begin							temp := GetControlValue(CItem);							SetControlValue(CItem, (temp + 1) mod 2);							if (temp = 0) then{Do all CHECKED linkages}								begin									I_Pick := I_Num[index - I_1 + 1];									D_Lister;									Refresh_Dialog;								end     			{End for this item checked}							else    			{Do all UNCHECKED linkages}								begin								end;    			{End for this item unchecked}						end;    				{End for this item selected}				end; { index loop }		until ExitDialog;   		{Handle dialog items until exit selected}		for index := I_1 to I_20 do			begin				GetDialogItem(GetSelection, index, DType, DItem, tempRect);{Get the Checkbox handle}				CItem := Pointer(DItem);{Change dialog handle to control handle}				temp := GetControlValue(CItem);{Get the checkbox value}			end;		I_Total := I_N - 1;		I_Last_Z := A^.IZ[I_N];		I_Last_Line := G4^^.IL[I_N];		I_Last_Grav := A^.GR[I_N];		if (I_Last_Line > 0) and (I_Last_Line < 4) then			begin				Last_Std_Name := STD_Name[I_N];				Last_Area := Std_Area[I_N];			end		else			begin				Last_Std_Name := '';				Last_Area := 1.0;			end;		if I_Total > 0 then			for index := 1 to I_Total do				begin					if (G4^^.IL[index] > 0) and (G4^^.IL[index] < 4) then						begin							for I1 := 1 to Std_Comp_Nel[index] do								begin									Is_Elem_Here := 0;									for I2 := 1 to I_Total do										begin											if A^.IZ[I2] = Std_Comp_El[index, I1] then												begin													Is_Elem_Here := 1;													leave;												end;										end;									if I_Last_Z = Std_Comp_El[index, I1] then										Is_Elem_Here := 1;									if Is_Elem_Here = 0 then										begin											I_Total := I_Total + 1;											A^.IZ[I_Total] := Std_Comp_El[index, I1];											G4^^.IL[I_Total] := -1;											A^.GR[I_Total] := 0;										end;								end;						end;				end;		if (I_Last_Line > 0) and (I_Last_Line < 4) then			begin				for I1 := 1 to Std_Comp_Nel[I_N] do					begin						Is_Elem_Here := 0;						for I2 := 1 to I_Total do							begin								if A^.IZ[I2] = Std_Comp_El[I_N, I1] then									begin										Is_Elem_Here := 1;										leave;									end;							end;						if I_Last_Z = Std_Comp_El[I_N, I1] then							Is_Elem_Here := 1;						if Is_Elem_Here = 0 then							begin								I_Total := I_Total + 1;								A^.IZ[I_Total] := Std_Comp_El[I_N, I1];								G4^^.IL[I_Total] := -1;								A^.GR[I_Total] := 0;							end;					end;			end;		I_N := I_Total + 1;		A^.IZ[I_N] := I_Last_Z;		G4^^.IL[I_N] := I_Last_Line;		A^.GR[I_N] := I_Last_Grav;		Std_Name[I_N] := Last_Std_Name;		Std_Area[I_N] := Last_Area;		Main_Handler;		IN9 := 9;              { Calculates k-values for standards }		for index := 1 to IN1 do			begin				if (G^^.IT[index] = 0) and (G4^^.IL[index] < 4) then					begin						IN8 := index;						ELEMSTD := Std_Name[index];						for I1 := 1 to I_N do							G4^^.K[I1] := 0.0;						for I1 := 1 to STD_Comp_Nel[index] do							begin								for I2 := 1 to I_N do									if A^.IZ[I2] = STD_Comp_el[index, I1] then										G4^^.K[I2] := STD_Comp_Conc[index, I1];							end;						Main_Handler1;					end;			end;		IN9 := 5; { Inserts peak intensities for the standards }		for index := 1 to IN1 do			if (G^^.IT[index] = 0) and (G4^^.IL[index] < 4) then				G2^^.F[3, index] := Std_Area[index];		Main_Handler1;		errcode := FSClose(refnum);		errcode := FlushVol(nil, MCA_Results_VolNum);		DisposeDialog(GetSelection);	end;    						{End of procedure}*)end.    							{End of unit}